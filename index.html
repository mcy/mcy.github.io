<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/styles.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/boxicons@2.0.7/css/boxicons.min.css"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script src="https://mcyoung.xyz/public/js/nsfw.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item " href="https://mcyoung.xyz/art">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> • <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/feed"> <img style="height: 0.8em; transform: translate(0.07em, 0.15em);" src="https://mcyoung.xyz/public/images/rss.svg"></a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile">&copy; 2025 Miguel Young de la Sota <br> <div style="font-size: 95%;"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> </div></span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-10-21 • 5756 words • 63 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#optimization">#optimization</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2025/10/21/ssa-1/"> Why SSA? </a></h1> </div> <div class="post"> <p>If you’ve read anything about compilers in the last two decades or so, you have almost certainly heard of <em>SSA compilers</em>, a popular architecture featured in many optimizing compilers, including ahead-of-time compilers such as LLVM, GCC, Go, CUDA (and various shader compilers), Swift<sup id="fnref:swift" role="doc-noteref"><a href="#fn:swift" class="footnote" rel="footnote">1</a></sup>, and MSVC<sup id="fnref:msvc" role="doc-noteref"><a href="#fn:msvc" class="footnote" rel="footnote">2</a></sup>, and just-in-time compilers such as HotSpot C2<sup id="fnref:hotspot" role="doc-noteref"><a href="#fn:hotspot" class="footnote" rel="footnote">3</a></sup>, V8<sup id="fnref:v8" role="doc-noteref"><a href="#fn:v8" class="footnote" rel="footnote">4</a></sup>, SpiderMonkey<sup id="fnref:spidermonkey" role="doc-noteref"><a href="#fn:spidermonkey" class="footnote" rel="footnote">5</a></sup>, LuaJIT, and the Android Runtime<sup id="fnref:art" role="doc-noteref"><a href="#fn:art" class="footnote" rel="footnote">6</a></sup>.</p> <p>SSA is hugely popular, to the point that most compiler projects no longer bother with other IRs for optimization<sup id="fnref:ghc" role="doc-noteref"><a href="#fn:ghc" class="footnote" rel="footnote">7</a></sup>. This is because SSA is incredibly nimble at the types of program analysis and transformation that compiler optimizations want to do on your code. But <em>why</em>? Many of my friends who don’t do compilers often say that compilers seem like opaque magical black boxes, and SSA, as it often appears in the literature, is impenetrably complex.</p> <p>But it’s not! SSA is actually very simple once you forget everything you think your programs are actually doing. We will develop the concept of SSA form, a simple SSA IR, prove facts about it, and design some optimizations on it.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I have <a href="https://mcyoung.xyz/2023/08/01/llvm-ir">previously written</a> about the granddaddy of all modern SSA compilers, LLVM. This article is about SSA in general, and won’t really have anything to do with LLVM. However, it may be helpful to read that article to make some of the things in this article feel more concrete.</p> </blockquote> <h2 id="what-is-ssa"><a href="#what-is-ssa">What Is SSA?</a></h2> <p>SSA is a property of <em>intermediate representations</em> (IRs), primarily used by compilers for optimizing imperative code that target a <em>register machine</em>. Register machines are computers that feature a fixed set of <em>registers</em> that can be used as the operands for instructions: this includes virtually all physical processors, including CPUs, GPUs, and weird tings like DSPs.</p> <p>SSA is most frequently found in compiler <em>middle-ends</em>, the optimizing component between the <em>frontend</em> (which deals with the <em>surface language</em> programmers write, and lowers it into the middle-end’s IR), and the <em>backend</em> (which takes the optimized IR and lowers it into the target platform’s assembly).</p> <p>SSA IRs, however, often have little resemblance to the surface language they lower out of, or the assembly language they target. This is because neither of these representations make it easy for a compiler to intuit optimization opportunities.</p> <h3 id="imperative-code-is-hard"><a href="#imperative-code-is-hard">Imperative Code Is Hard</a></h3> <p>Imperative code consists of a sequence of operations that mutate the executing machine’s state to produce a desired result. For example, consider the following C program:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">-=</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">C</a></div></div> <p>This program returns <code class="language-plaintext highlighter-rouge">0</code> no matter what its input is, so we can optimize it down to this:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">C</a></div></div> <p>But, how would you write a general algorithm to detect that all of the operations cancel out? You’re forced to keep in mind <em>program order</em> to perform the necessary dataflow analysis, following mutations of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> through the program. But this isn’t very general, and traversing all of those paths makes the search space for large functions very big. Instead, you would like to rewrite the program such that <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> gradually get replaced with the expression that calculates the most recent value, like this:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a3</span> <span class="o">=</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">b2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">a3</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">C</a></div></div> <p>Then we can replace each occurrence of a variable with its right-hand side recursively…</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a3</span> <span class="o">=</span> <span class="p">(</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">C</a></div></div> <p>Then fold the constants together…</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a3</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">-</span> <span class="n">argc</span>
  <span class="k">return</span> <span class="n">argc</span> <span class="o">-</span> <span class="n">argc</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">C</a></div></div> <p>And finally, we see that we’re returning <code class="language-plaintext highlighter-rouge">argc - argc</code>, and can replace it with <code class="language-plaintext highlighter-rouge">0</code>. All the other variables are now unused, so we can delete them.</p> <p>The reason this works so well is because we took a function with mutation, and converted it into a <em>combinatorial circuit</em>, a type of digital logic circuit that has no state, and which is very easy to analyze. The dependencies between <em>nodes</em> in the circuit (corresponding to primitive operations such as addition or multiplication) are obvious from its structure. For example, consider the following circuit diagram for a one-bit multiplier:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/multiplier.png" style="filter:invert(100%);"/></p> <figcaption>A binary multiplier (Wikipedia)</figcaption> </figure> <p>This graph representation of an operation program has two huge benefits:</p> <ol> <li> <p>The powerful tools of graph theory can be used to algorithmically analyze the program and discover useful properties, such as operations that are independent of each other or whose results are never used.</p> </li> <li> <p>The operations are not ordered with respect to each other except when there is a dependency; this is useful for reordering operations, something compilers really like to do.</p> </li> </ol> <p>The reason combinatorial circuits are the best circuits is because they are <em>directed acyclic graphs</em> (DAGs) which admit really nice algorithms. For example, longest path in a graph is <a href="https://en.wikipedia.org/wiki/NP-hardness">NP-hard</a> (and because <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo mathvariant="normal">≠</mo><mi>N</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">P \neq NP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">NP</span></span></span></span></span><sup id="fnref:p-np" role="doc-noteref"><a href="#fn:p-np" class="footnote" rel="footnote">8</a></sup>, has complexity <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>). However, if the graph is a DAG, it admits an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> solution!</p> <p>To understand this benefit, consider another program:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">*=</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">y</span> <span class="o">*=</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">C</a></div></div> <p>Suppose we wanted to replace each variable with its definition like we did before. We can’t <em>just</em> replace each constant variable with the expression that defines it though, because we would wind up with a different program!</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">*=</span> <span class="n">y</span><span class="p">;</span>
  <span class="c1">// const int z = y; // Replace z with its definition.</span>
  <span class="n">y</span> <span class="o">*=</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">C</a></div></div> <p>Now, we pick up an extra <code class="language-plaintext highlighter-rouge">y</code> term because the squaring operation is no longer unused! We can put this into circuit form, but it requires inserting new variables for every mutation.</p> <p>But we can’t do this when complex control flow is involved! So all of our algorithms need to carefully account for mutations and program order, meaning that we don’t get to use the nice graph algorithms without careful modification.</p> <h2 id="the-ssa-invariant"><a href="#the-ssa-invariant">The SSA Invariant</a></h2> <p>SSA stands for “static single assignment”, and was developed in the 80s as a way to enhance the existing three-argument code (where every statement is in the form <code class="language-plaintext highlighter-rouge">x = y op z</code>) so that every program was circuit-like, using a very similar procedure to the one described above.</p> <p>The SSA invariant states that every variable in the program is assigned to by precisely one operation. If every operation in the program is visited once, they form a combinatorial circuit. Transformations are required to respect this invariant. In circuit form, a program is a graph where operations are nodes, and “registers” (which is what variables are usually called in SSA) are edges (specifically, each output of an operation corresponds to a register).</p> <p>But, again, control flow. We can’t hope to circuitize a loop, right? The key observation of SSA is that <em>most</em> parts of a program are circuit-like. A <em>basic block</em> is a maximal circuital component of a program. Simply put, it is a sequence of non-control flow operations, and a final <em>terminator</em> operation that transfers control to another basic block.</p> <p>The basic blocks themselves form a graph, the <em>control flow graph</em>, or CFG. This formulation of SSA is sometimes called SSA-CFG<sup id="fnref:non-cfg" role="doc-noteref"><a href="#fn:non-cfg" class="footnote" rel="footnote">9</a></sup>. This graph is <em>not</em> a DAG in general; however, separating the program into basic blocks conveniently factors out the “non-DAG” parts of the program, allowing for simpler analysis within basic blocks.</p> <p>There are two equivalent formalisms for SSA-CFG. The traditional one uses special “phi” operations (often called <em>phi nodes</em>, which is what I will call them here) to link registers across basic blocks. This is the formalism LLVM uses. A more modern approach, used by MLIR, is <em>block arguments</em>: each basic block specifies parameters, like a function, and blocks transferring control flow to it must pass arguments of those types to it.</p> <h3 id="my-first-ir"><a href="#my-first-ir">My First IR</a></h3> <p>Let’s look at some code. First, consider the following C function which calculates Fibonacci numbers using a loop.</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">C</a></div></div> <p>How might we express this in an SSA-CFG IR? Let’s start inventing our SSA IR! It will look a <em>little bit</em> like LLVM IR, since that’s what I’m used to looking at.</p> <div class="codeblock" id="code:fib-ir"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// Globals (including functions) start with $, registers with %.</span>
<span class="c">// Each function declares a signature.</span>
<span class="k">func</span> <span class="n">fib</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// The first block has no label and can't be "jumped to".</span>
    <span class="c">//</span>
    <span class="c">// Single-argument goto jumps directly into a block with</span>
    <span class="c">// the given arguments.</span>
    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>

  <span class="c">// Block labels start with a `!`, can contain dots, and</span>
  <span class="c">// define parameters. Register names are scoped to a block.</span>
  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// Integer comparison: %n &gt; 0.</span>
    <span class="o">%</span><span class="n">cont</span> <span class="o">=</span> <span class="n">cmp</span><span class="o">.</span><span class="n">gt</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span>

    <span class="c">// Multi-argument goto is a switch statement. The compiler</span>
    <span class="c">// may assume that `%cont` is among the cases listed in the</span>
    <span class="c">// goto.</span>
    <span class="k">goto</span> <span class="o">%</span><span class="n">cont</span> <span class="p">{</span>
      <span class="m">0</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">ret</span><span class="p">(</span><span class="o">%</span><span class="n">a</span><span class="p">),</span> <span class="c">// Goto can jump to the function exit.</span>
      <span class="m">1</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">),</span>
    <span class="p">}</span>

  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// Addition and subtraction.</span>
    <span class="o">%</span><span class="n">c</span>    <span class="o">=</span> <span class="n">add</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
    <span class="o">%</span><span class="n">n</span><span class="m">.2</span>  <span class="o">=</span> <span class="n">sub</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">1</span>

    <span class="c">// Note the assignments in @loop.start:</span>
    <span class="c">// %n = %n.2, %a = %b, %b = %c.</span>
    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="m">.2</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:fib-ir">SSA-CFG</a></div></div> <p>Every block ends in a <code class="language-plaintext highlighter-rouge">goto</code>, which transfers control to one of several possible blocks. In the process, it calls that block with the given arguments. One can think of a basic block as a tiny function which <em>tails</em><sup id="fnref:tail-call" role="doc-noteref"><a href="#fn:tail-call" class="footnote" rel="footnote">10</a></sup> into other basic blocks in the same function.</p> <blockquote id="aside:phi-nodes" class="aside"> <p><a href="#aside:phi-nodes"><span class="chip">aside</span><span class="title">Phi Nodes</span></a></p> <p>LLVM IR is… older, so it uses the older formalism of phi nodes. “Phi” comes from “phony”, because it is an operation that doesn’t do anything; it just links registers from predecessors.</p> <p>A <code class="language-plaintext highlighter-rouge">phi</code> operation is essentially a switch-case on the predecessors, each case selecting a register from that predecessor (or an immediate). For example, <code class="language-plaintext highlighter-rouge">@loop.start</code> has two predecessors, the implicit entry block <code class="language-plaintext highlighter-rouge">@entry</code>, and <code class="language-plaintext highlighter-rouge">@loop.body</code>. In a phi node IR, instead of taking a block argument for <code class="language-plaintext highlighter-rouge">%n</code>, it would specify</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="o">&gt;</span>   <span class="o">%</span><span class="n">n</span> <span class="o">=</span> <span class="n">phi</span> <span class="p">{</span> <span class="err">@</span><span class="n">entry</span> <span class="o">-&gt;</span> <span class="m">0</span><span class="p">,</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span> <span class="o">-&gt;</span> <span class="o">%</span><span class="n">n</span><span class="m">.2</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">SSA-CFG</a></div></div> <p>The value of the <code class="language-plaintext highlighter-rouge">phi</code> operation is the value from whichever block jumped to this one.</p> <p>This can be awkward to type out by hand and read, but is a more convenient representation for describing algorithms (just “add a phi node” instead of “add a parameter and a corresponding argument”) and for the in-memory representation, but is otherwise completely equivalent.</p> </blockquote> <p>It’s a bit easier to understand the transformation from C to our IR if we first rewrite the C to use goto instead of a for loop:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="nl">start:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">goto</span> <span class="n">start</span>

<span class="nl">ret:</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">C</a></div></div> <p>However, we still have mutation in the picture, so this isn’t SSA. To get into SSA, we need to replace every assignment with a new register, and somehow insert block arguments…</p> <h3 id="entering-ssa-form"><a href="#entering-ssa-form">Entering SSA Form</a></h3> <p>The <a href="#code:fib-ir">above IR code</a> is already partially optimized; the named variables in the C program have been <em>lifted</em> out of memory and into registers. If we represent each named variable in our C program with a pointer, we can avoid needing to put the program into SSA form immediately. This technique is used by frontends that lower into LLVM, like Clang.</p> <p>We’ll enhance our IR by adding a <code class="language-plaintext highlighter-rouge">stack</code> declaration for functions, which defines scratch space on the stack for the function to use. Each stack slot produces a pointer that we can <code class="language-plaintext highlighter-rouge">load</code> from and <code class="language-plaintext highlighter-rouge">store</code> to.</p> <p>Our Fibonacci function would now look like so:</p> <div class="codeblock" id="code:fib-memory"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="o">&amp;</span><span class="n">fib</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Declare stack slots.</span>
    <span class="o">%</span><span class="n">np</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>
    <span class="o">%</span><span class="n">ap</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>
    <span class="o">%</span><span class="n">bp</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>

    <span class="c">// Load initial values into them.</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="m">0</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="m">1</span>

    <span class="c">// Start the loop.</span>
    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">)</span>

  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="o">:</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span>
    <span class="o">%</span><span class="n">n</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">np</span>
    <span class="o">%</span><span class="n">cont</span> <span class="o">=</span> <span class="n">cmp</span><span class="o">.</span><span class="n">gt</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span>

    <span class="k">goto</span> <span class="o">%</span><span class="n">cont</span> <span class="p">{</span>
      <span class="m">0</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">exit</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="p">)</span>
      <span class="m">1</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">),</span>
    <span class="p">}</span>

  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="o">:</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">ap</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">bp</span>
    <span class="o">%</span><span class="n">c</span> <span class="o">=</span> <span class="n">add</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span>

    <span class="o">%</span><span class="n">n</span>   <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">np</span>
    <span class="o">%</span><span class="n">n</span><span class="m">.2</span> <span class="o">=</span> <span class="n">sub</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">1</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="m">.2</span>

    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">)</span>

  <span class="err">@</span><span class="n">exit</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="o">:</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">ap</span>
    <span class="k">goto</span> <span class="err">@</span><span class="n">ret</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:fib-memory">SSA-CFG</a></div></div> <p>Any time we reference a named variable, we load from its stack slot, and any time we assign it, we store to that slot. This is very easy to get into from C, but the code sucks because it’s doing lots of unnecessary pointer operations. How do we get from this to the register-only function I showed earlier?</p> <blockquote id="aside:program-order" class="aside"> <p><a href="#aside:program-order"><span class="chip">aside</span><span class="title">Program Order</span></a></p> <p>We want program order to not matter for the purposes of reordering, but as we’ve written code here, program order <em>does</em> matter: loads depend on prior stores but stores don’t produce a value that can be used to link the two operations.</p> <p>We can restore not having program order by introducing operands representing an “address space”; loads and stores take an address space as an argument, and stores return a new address space. An address space, or <code class="language-plaintext highlighter-rouge">mem</code>, represents the state of some region of memory. Loads and stores are independent when they are not connected by a <code class="language-plaintext highlighter-rouge">mem</code> argument.</p> <p>This type of enhancement is used by Go’s SSA IR, for example. However, it adds a layer of complexity to the examples, so instead I will hand-wave this away.</p> </blockquote> <h2 id="the-dominance-relation"><a href="#the-dominance-relation">The Dominance Relation</a></h2> <p>Now we need to prove some properties about CFGs that are important for the definition and correctness of our optimization passes.</p> <p>First, some definitions.</p> <blockquote id="def:1" class="def"> <p><a href="#def:1"><span class="chip">definition</span></a></p> <p>The <strong>predecessors</strong> (or “preds”) of a basic block is the set of blocks with an outgoing edge <strong>to</strong> that block. A block may be its own predecessors.</p> </blockquote> <p>Some literature calls the above “direct” or immediate predecessors. For example, the preds of in our <a href="#code:fib-memory">example</a> are <code class="language-plaintext highlighter-rouge">@loop.start</code> are <code class="language-plaintext highlighter-rouge">@entry</code> (the special name for the function entry-point) <code class="language-plaintext highlighter-rouge">@loop.body</code>.</p> <blockquote id="def:2" class="def"> <p><a href="#def:2"><span class="chip">definition</span></a></p> <p>The <strong>successors</strong> (no, not “succs”) of a basic block is the set of blocks with an outgoing edge <strong>from</strong> that block. A block may be its own successors.</p> </blockquote> <p>The sucessors of <code class="language-plaintext highlighter-rouge">@loop.start</code> are <code class="language-plaintext highlighter-rouge">@exit</code> and <code class="language-plaintext highlighter-rouge">@loop.body</code>. The successors are listed in the loop’s <code class="language-plaintext highlighter-rouge">goto</code>.</p> <p>If a block <code class="language-plaintext highlighter-rouge">@a</code> is a transitive pred of a block <code class="language-plaintext highlighter-rouge">@b</code>, we say that <code class="language-plaintext highlighter-rouge">@a</code> <em>weakly dominates</em> <code class="language-plaintext highlighter-rouge">@b</code>, or that it is a <em>weak dominator</em> of <code class="language-plaintext highlighter-rouge">@b</code>. For example, <code class="language-plaintext highlighter-rouge">@entry</code>, <code class="language-plaintext highlighter-rouge">@loop.start</code> and <code class="language-plaintext highlighter-rouge">@loop.body</code> both weakly dominate <code class="language-plaintext highlighter-rouge">@exit</code>.</p> <p>However, this is not usually an especially useful relationship. Instead, we want to speak of dominators:</p> <blockquote id="def:3" class="def"> <p><a href="#def:3"><span class="chip">definition</span></a></p> <p>A block <code class="language-plaintext highlighter-rouge">@a</code> is a <strong>dominator</strong> (or <strong>dominates</strong>) <code class="language-plaintext highlighter-rouge">@b</code> if every pred of <code class="language-plaintext highlighter-rouge">@b</code> is dominated by <code class="language-plaintext highlighter-rouge">@a</code>, or if <code class="language-plaintext highlighter-rouge">@a</code> is <code class="language-plaintext highlighter-rouge">@b</code> itself.</p> <p>Equivalently, the dominator set of <code class="language-plaintext highlighter-rouge">@b</code> is the intersection of the dominator sets of its preds, plus <code class="language-plaintext highlighter-rouge">@b</code>.</p> </blockquote> <p>The dominance relation has some nice order properties that are necessary for defining the core graph algorithms of SSA.</p> <h3 id="some-graph-theory"><a href="#some-graph-theory">Some Graph Theory</a></h3> <p>We only consider CFGs which are flowgraphs, that is, all blocks are reachable from the root block <code class="language-plaintext highlighter-rouge">@entry</code>, which has no preds. This is necessary to eliminate some pathological graphs from our proofs. Importantly, we can always ask for an acyclic path<sup id="fnref:acyclic" role="doc-noteref"><a href="#fn:acyclic" class="footnote" rel="footnote">11</a></sup> from <code class="language-plaintext highlighter-rouge">@entry</code> to any block <code class="language-plaintext highlighter-rouge">@b</code>.</p> <p>An equivalent way to state the dominance relationship is that from every path from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code> contains all of <code class="language-plaintext highlighter-rouge">@b</code>’s dominators.</p> <blockquote id="prop:1" class="prop"> <p><a href="#prop:1"><span class="chip">proposition</span></a></p> <p><code class="language-plaintext highlighter-rouge">@a</code> dominates <code class="language-plaintext highlighter-rouge">@b</code> iff every path from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code> contains <code class="language-plaintext highlighter-rouge">@a</code>.</p> <blockquote id="proof:1" class="proof"> <p><a href="#proof:1"><span class="chip">proof</span></a></p> <p>First, assume every <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code> path contains <code class="language-plaintext highlighter-rouge">@a</code>. If <code class="language-plaintext highlighter-rouge">@b</code> is <code class="language-plaintext highlighter-rouge">@a</code>, we’re done. Otherwise we need to prove each predecessor of <code class="language-plaintext highlighter-rouge">@b</code> is dominated by <code class="language-plaintext highlighter-rouge">@a</code>; we do this by induction on the length of acyclic paths from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code>. Consider preds <code class="language-plaintext highlighter-rouge">@p</code> of <code class="language-plaintext highlighter-rouge">@b</code> that are not <code class="language-plaintext highlighter-rouge">@a</code>, and consider all acyclic paths <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@p</code>; by appending <code class="language-plaintext highlighter-rouge">@b</code> to them, we have an acyclic path <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code>, which must contain <code class="language-plaintext highlighter-rouge">@a</code>. Because both the last and second-to-last elements of this are not <code class="language-plaintext highlighter-rouge">@a</code>, it must be within the shorter path <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> which is shorter than <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>. Thus, by induction, <code class="language-plaintext highlighter-rouge">@a</code> dominates <code class="language-plaintext highlighter-rouge">@p</code> and therefore <code class="language-plaintext highlighter-rouge">@b</code></p> <p>Going the other way, if <code class="language-plaintext highlighter-rouge">@a</code> dominates <code class="language-plaintext highlighter-rouge">@b</code>, and consider a path <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code>. The second-to-last element of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> is a pred <code class="language-plaintext highlighter-rouge">@p</code> of <code class="language-plaintext highlighter-rouge">@b</code>; if it is <code class="language-plaintext highlighter-rouge">@a</code> we are done. Otherwise, we can consider the path <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> made by deleting <code class="language-plaintext highlighter-rouge">@b</code> at the end. <code class="language-plaintext highlighter-rouge">@p</code> is dominated by <code class="language-plaintext highlighter-rouge">@a</code>, and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> is shorter than <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span>, so we can proceed by induction as above.</p> </blockquote> </blockquote> <p>Onto those nice properties. Dominance allows us to take an arbitrarily complicated CFG and extract from it a DAG, composed of blocks ordered by dominance.</p> <blockquote id="thm:1" class="thm"> <p><a href="#thm:1"><span class="chip">theorem</span></a></p> <p>The dominance relation is a partial order.</p> <blockquote id="proof:2" class="proof"> <p><a href="#proof:2"><span class="chip">proof</span></a></p> <p>Dominance is reflexive and transitive by definition, so we only need to show blocks can’t dominate each other.</p> <p>Suppose distinct <code class="language-plaintext highlighter-rouge">@a</code> and <code class="language-plaintext highlighter-rouge">@b</code> dominate each other.Pick an acyclic path<span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@a</code>. Because <code class="language-plaintext highlighter-rouge">@b</code> dominates <code class="language-plaintext highlighter-rouge">@a</code>, there is a prefix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> of this path ending in <code class="language-plaintext highlighter-rouge">@b</code>. But because <code class="language-plaintext highlighter-rouge">@a</code> dominates <code class="language-plaintext highlighter-rouge">@b</code>, some prefix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">p&#x27;&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span></span></span></span></span> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> ends in <code class="language-plaintext highlighter-rouge">@a</code>. But now <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> must contain <code class="language-plaintext highlighter-rouge">@a</code> twice, contradicting that it is acyclic.</p> </blockquote> </blockquote> <p>This allows us to write <code class="language-plaintext highlighter-rouge">@a &lt; @b</code> when <code class="language-plaintext highlighter-rouge">@a</code> dominates <code class="language-plaintext highlighter-rouge">@b</code>. There is an even more refined graph structure that we can build out of dominators, which follows immediately from the partial order theorem.</p> <blockquote id="cor:1" class="cor"> <p><a href="#cor:1"><span class="chip">corollary</span></a></p> <p>The dominators of a basic block are totally ordered by the dominance relation.</p> <blockquote id="proof:3" class="proof"> <p><a href="#proof:3"><span class="chip">proof</span></a></p> <p>Suppose <code class="language-plaintext highlighter-rouge">@a1 &lt; @b</code> and <code class="language-plaintext highlighter-rouge">@a2 &lt; @b</code>, but neither dominates the other. Then, there must exist acyclic paths from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code> which contain both, but in different orders. Take the subpaths of those paths which follow <code class="language-plaintext highlighter-rouge">@entry ... @a1</code>, and <code class="language-plaintext highlighter-rouge">@a1 ... @b</code>, neither of which contains <code class="language-plaintext highlighter-rouge">@a2</code>. Concatenating these paths yields a path from <code class="language-plaintext highlighter-rouge">@entry</code> to <code class="language-plaintext highlighter-rouge">@b</code> that does not contain <code class="language-plaintext highlighter-rouge">@a2</code>, a contradiction.</p> </blockquote> </blockquote> <p>This tells us that the DAG we get from the dominance relation is actually a tree, rooted at <code class="language-plaintext highlighter-rouge">@entry</code>. The parent of a node in this tree is called its <em>immediate dominator</em>.</p> <p>Computing dominators can be done iteratively: the dominator set of a block <code class="language-plaintext highlighter-rouge">@b</code> is the intersection the dominator sets of its preds, plus <code class="language-plaintext highlighter-rouge">@b</code>. This algorithm runs in quadratic time.</p> <p>A better algorithm is the Lengauer-Tarjan algorithm[^lta]. It is relatively simple, but explaining how to implement it is a bit out of scope for this article. I found a nice treatment of it <a href="https://www.cs.utexas.edu/~misra/Lengauer+Tarjan.pdf">here</a>.</p> <p>What’s important is we can compute the dominator tree without breaking the bank, and given any node, we can ask for its immediate dominator. Using immediate dominators, we can introduce the final, important property of dominators.</p> <blockquote id="def:4" class="def"> <p><a href="#def:4"><span class="chip">definition</span></a></p> <p>The <em>dominance frontier</em> of a block <code class="language-plaintext highlighter-rouge">@a</code> is the set of all blocks not dominated by <code class="language-plaintext highlighter-rouge">@a</code> with at least one pred which <code class="language-plaintext highlighter-rouge">@a</code> dominates.</p> </blockquote> <p>These are points where control flow merges from <em>distinct</em> paths: one containing <code class="language-plaintext highlighter-rouge">@a</code> and one not. The dominance frontier of <code class="language-plaintext highlighter-rouge">@loop.body</code> is <code class="language-plaintext highlighter-rouge">@loop.start</code>, whose preds are <code class="language-plaintext highlighter-rouge">@entry</code> and <code class="language-plaintext highlighter-rouge">@loop.body</code>.</p> <p>There are many ways to calculate dominance frontiers, but with a dominance tree in hand, we can do it like this:</p> <blockquote id="alg:dominance-frontiers" class="alg"> <p><a href="#alg:dominance-frontiers"><span class="chip">algorithm</span><span class="title">Dominance Frontiers.</span></a></p> <p>For each block <code class="language-plaintext highlighter-rouge">@b</code> with more than one pred, for each of its preds, let <code class="language-plaintext highlighter-rouge">@p</code> be that pred. Add <code class="language-plaintext highlighter-rouge">@b</code> to the dominance frontier of <code class="language-plaintext highlighter-rouge">@p</code> and all of its dominators, stopping when encountering <code class="language-plaintext highlighter-rouge">@b</code>’ immediate dominator.</p> <blockquote id="proof:4" class="proof"> <p><a href="#proof:4"><span class="chip">proof</span></a></p> <p>We need to prove that every block examined by the algorithm winds up in the correct frontiers.</p> <p>First, we check that every examined block <code class="language-plaintext highlighter-rouge">@b</code> is added to the correct frontier. If <code class="language-plaintext highlighter-rouge">@a &lt; @p</code>, where <code class="language-plaintext highlighter-rouge">@p</code> is a pred of <code class="language-plaintext highlighter-rouge">@b</code>, and a <code class="language-plaintext highlighter-rouge">@d</code> is <code class="language-plaintext highlighter-rouge">@b</code>’s immediate dominator, then if <code class="language-plaintext highlighter-rouge">@a &lt; @d</code>, <code class="language-plaintext highlighter-rouge">@b</code> is not in its frontier, because <code class="language-plaintext highlighter-rouge">@a</code> must dominate <code class="language-plaintext highlighter-rouge">@b</code>. Otherwise, <code class="language-plaintext highlighter-rouge">@b</code> must be in <code class="language-plaintext highlighter-rouge">@a</code>’s frontier, because <code class="language-plaintext highlighter-rouge">@a</code> dominates a pred but it cannot dominate <code class="language-plaintext highlighter-rouge">@b</code>, because then it would be dominated by <code class="language-plaintext highlighter-rouge">@i</code>, a contradiction.</p> <p>Second, we check that every frontier is complete. Consider a block <code class="language-plaintext highlighter-rouge">@a</code>. If an examined block <code class="language-plaintext highlighter-rouge">@b</code> is in its frontier, then <code class="language-plaintext highlighter-rouge">@a</code> must be among the dominators of some pred <code class="language-plaintext highlighter-rouge">@p</code>, and it must be dominated by <code class="language-plaintext highlighter-rouge">@b</code>’s immediate dominator; otherwise, <code class="language-plaintext highlighter-rouge">@a</code> would dominate <code class="language-plaintext highlighter-rouge">@b</code> (and thus <code class="language-plaintext highlighter-rouge">@b</code> would not be in its frontier). Thus, <code class="language-plaintext highlighter-rouge">@b</code> gets added to <code class="language-plaintext highlighter-rouge">@a</code>’s dominator.</p> </blockquote> </blockquote> <p>You might notice that all of these algorithms are quadratic. This is actually a very good time complexity for a compilers-related graph algorithm. Cubic and quartic algorithms are not especially uncommon, and yes, your optimizing compiler’s time complexity is probably cubic or quartic in the size of the program!</p> <h2 id="lifting-memory"><a href="#lifting-memory">Lifting Memory</a></h2> <p>Ok. Let’s construct an optimization. We want to figure out if we can replace a load from a pointer with the most recent store to that pointer. This will allow us to fully lift values out of memory by cancelling out store/load pairs.</p> <p>This will make use of yet another implicit graph data structure.</p> <blockquote id="def:5" class="def"> <p><a href="#def:5"><span class="chip">definition</span></a></p> <p>The <strong>dataflow graph</strong> is the directed graph made up of the internal circuit graphs of each each basic block, connected along block arguments.</p> <p>To <strong>follow a use-def chain</strong> is to walk this graph forward from an operation to discover operations that potentially depend on it, or backwards to find operations it potentially depends on.</p> </blockquote> <p>It’s important to remember that the dataflow graph, like the CFG, does <em>not</em> have a well defined “up” direction. Navigating it and the CFG requires the dominator tree.</p> <p>One other important thing to remember here is that every instruction in a basic block always executes if the block executes. In much of this analysis, we need to appeal to “program order” to select the last load in a block, but we are always able to do so. This is an important property of basic blocks that makes them essential for constructing optimizations.</p> <h3 id="forward-dataflow"><a href="#forward-dataflow">Forward Dataflow</a></h3> <p>For a given <code class="language-plaintext highlighter-rouge">store %p, %v</code>, we want to identify all loads that depend on it. We can follow the use-def chain of <code class="language-plaintext highlighter-rouge">%p</code> to find which blocks contain loads that potentially depend on the store (call it <code class="language-plaintext highlighter-rouge">%s</code>).</p> <p>First, we can eliminate loads within the same basic block (call it <code class="language-plaintext highlighter-rouge">@a</code>). Replace all <code class="language-plaintext highlighter-rouge">load %p</code> instructions after <code class="language-plaintext highlighter-rouge">s</code> (but before any other <code class="language-plaintext highlighter-rouge">store %p, _</code>s, in program order) with <code class="language-plaintext highlighter-rouge">%v</code>’s def. If <code class="language-plaintext highlighter-rouge">s</code> is not the last store in this block, we’re done.</p> <p>Otherwise, follow the use-def chain of <code class="language-plaintext highlighter-rouge">%p</code> to successors which use <code class="language-plaintext highlighter-rouge">%p</code>, i.e., successors whose <code class="language-plaintext highlighter-rouge">goto</code> case has <code class="language-plaintext highlighter-rouge">%p</code> as at least one argument. Recurse into those successors, and now replacing the pointer <code class="language-plaintext highlighter-rouge">%p</code> of interest with the parameters of the successor which were set to <code class="language-plaintext highlighter-rouge">%p</code> (more than one argument may be <code class="language-plaintext highlighter-rouge">%p</code>).</p> <p>If successor <code class="language-plaintext highlighter-rouge">@b</code> loads from one of the registers holding <code class="language-plaintext highlighter-rouge">%p</code>, replace all such loads before a store to <code class="language-plaintext highlighter-rouge">%p</code>. We also now need to send <code class="language-plaintext highlighter-rouge">%v</code> into <code class="language-plaintext highlighter-rouge">@b</code> somehow.</p> <p>This is where we run into something of a wrinkle. If <code class="language-plaintext highlighter-rouge">@b</code> has exactly one predecessor, we need to add a new block argument to pass whichever register is holding <code class="language-plaintext highlighter-rouge">%v</code> (which exists by induction). If <code class="language-plaintext highlighter-rouge">%v</code> is already passed into <code class="language-plaintext highlighter-rouge">@b</code> by another argument, we can use that one.</p> <p>However, if <code class="language-plaintext highlighter-rouge">@b</code> has multiple predecessors, we need to make sure that every path from <code class="language-plaintext highlighter-rouge">@a</code> to <code class="language-plaintext highlighter-rouge">@b</code> sends <code class="language-plaintext highlighter-rouge">%v</code>, and canonicalizing those will be tricky. Worse still, if <code class="language-plaintext highlighter-rouge">@b</code> is in <code class="language-plaintext highlighter-rouge">@a</code>’s domination frontier, a <em>different</em> store could be contributing to that load! For this reason, dataflow from stores to loads is not a great strategy.</p> <p>Instead, we’ll look at dataflow from loads backwards to stores (in general, dataflow from uses to defs tends to be more useful), which we can use to augment the above forward dataflow analysis to remove the complex issues around domination frontiers.</p> <h3 id="dependency-analysis"><a href="#dependency-analysis">Dependency Analysis</a></h3> <p>Let’s analyze loads instead. For each <code class="language-plaintext highlighter-rouge">load %p</code> in <code class="language-plaintext highlighter-rouge">@a</code>, we want to determine all stores that could potentially contribute to its value. We can find those stores as follows:</p> <p>We want to be able to determine which register in a given block corresponds to the value of <code class="language-plaintext highlighter-rouge">%p</code>, and then find its last store in that block.</p> <p>To do this, we’ll flood-fill the CFG backwards in BFS order. This means that we’ll follow preds (through the use-def chain) recursively, visiting each pred before visiting their preds, and never revisiting a basic block (except we may need to come back to <code class="language-plaintext highlighter-rouge">@a</code> at the end).</p> <p>Determining the “equivalent”<sup id="fnref:equiv-reg" role="doc-noteref"><a href="#fn:equiv-reg" class="footnote" rel="footnote">12</a></sup> of <code class="language-plaintext highlighter-rouge">%p</code> in <code class="language-plaintext highlighter-rouge">@b</code> (we’ll call it <code class="language-plaintext highlighter-rouge">%p.b</code>) can be done recursively: while examining <code class="language-plaintext highlighter-rouge">@b</code>, follow the def of <code class="language-plaintext highlighter-rouge">%p.b</code>. If <code class="language-plaintext highlighter-rouge">%p.b</code> is a block parameter, for each pred <code class="language-plaintext highlighter-rouge">@c</code>, set <code class="language-plaintext highlighter-rouge">%p.c</code> to the corresponding argument in the <code class="language-plaintext highlighter-rouge">@b(...)</code> case in <code class="language-plaintext highlighter-rouge">@c</code>’s <code class="language-plaintext highlighter-rouge">goto</code>.</p> <p>Using this information, we can collect all stores that the load potentially depends on. If a predecessor <code class="language-plaintext highlighter-rouge">@b</code> stores to <code class="language-plaintext highlighter-rouge">%p.b</code>, we add the last such store in <code class="language-plaintext highlighter-rouge">@b</code> (in program order) to our set of stores, and do not recurse to <code class="language-plaintext highlighter-rouge">@b</code>’s preds (because this store overwrites all past stores). Note that we <em>may</em> revisit <code class="language-plaintext highlighter-rouge">@a</code> in this process, and collect a store to <code class="language-plaintext highlighter-rouge">%p</code> from it occurs in the block. This is necessary in the case of loops.</p> <p>The result is a set <code class="language-plaintext highlighter-rouge">stores</code> of <code class="language-plaintext highlighter-rouge">(store %p.s %v.s, @s)</code> pairs. In the process, we also collected a set of all blocks visited, <code class="language-plaintext highlighter-rouge">subgraph</code>, which are dominators of <code class="language-plaintext highlighter-rouge">@a</code> which we need to plumb a <code class="language-plaintext highlighter-rouge">%v.b</code> through. This process is called <em>memory dependency analysis</em>, and is a key component of many optimizations.</p> <blockquote id="note:2" class="note"> <p><a href="#note:2"><span class="chip">note</span></a></p> <p>Not all contributing operations are stores. Some may be references to globals (which we’re disregarding), or function arguments or the results of a function call (which means we probably can’t lift this load). For example <code class="language-plaintext highlighter-rouge">%p</code> gets traced all the way back to a function argument, there is a code path which loads from a pointer whose stores we can’t see.</p> </blockquote> <p>It may also trace back to a stack slot that is potentially not stored to. This means there is a code path that can potentially load uninitialized memory. Like LLVM, we can assume this is not observable behavior, so we can discount such dependencies. If all of the dependencies are uninitialized loads, we can potentially delete not just the load, but operations which depend on it (reverse dataflow analysis is the origin of so-called “time-traveling” UB).</p> <h3 id="lifting-loads"><a href="#lifting-loads">Lifting Loads</a></h3> <p>Now that we have the full set of dependency information, we can start lifting loads. Loads can be safely lifted when all of their dependencies are stores in the current function, or dependencies we can disregard thanks to UB in the surface language (such as <code class="language-plaintext highlighter-rouge">null</code> loads or uninitialized loads).</p> <blockquote id="note:3" class="note"> <p><a href="#note:3"><span class="chip">note</span></a></p> <p>There is a lot of fuss in this algorithm about plumbing values through block arguments. A lot of IRs make a simplifying change, where every block implicitly receives the registers from its dominators as block arguments.</p> <p>I am keeping the fuss because it makes it clearer what’s going on, but in practice, most of this plumbing, except at dominance frontiers, would be happening in the background.</p> </blockquote> <p>Suppose we can safely lift some load. Now we need to plumb the stored values down to the load. For each block <code class="language-plaintext highlighter-rouge">@b</code> in <code class="language-plaintext highlighter-rouge">subgraph</code> (all other blocks will now be in <code class="language-plaintext highlighter-rouge">subgraph</code> unless stated otherwise). We will be building two mappings: one <code class="language-plaintext highlighter-rouge">(@s, @b) -&gt; %v.s.b</code>, which is the register equivalent to <code class="language-plaintext highlighter-rouge">%v.s</code> in that block. We will also be building a map <code class="language-plaintext highlighter-rouge">@b -&gt; %v.b</code>, which is the value that <code class="language-plaintext highlighter-rouge">%p</code> must have in that block.</p> <ol> <li> <p>Prepare a work queue, with each <code class="language-plaintext highlighter-rouge">@s</code> in it initially.</p> </li> <li> <p>Pop a block <code class="language-plaintext highlighter-rouge">@a</code> form the queue. For each successor <code class="language-plaintext highlighter-rouge">@b</code> (in <code class="language-plaintext highlighter-rouge">subgraph</code>):</p> <ol> <li> <p>If <code class="language-plaintext highlighter-rouge">%v.b</code> isn’t already defined, add it as a block argument. Have <code class="language-plaintext highlighter-rouge">@a</code> pass <code class="language-plaintext highlighter-rouge">%v.a</code> to that argument.</p> </li> <li> <p>If <code class="language-plaintext highlighter-rouge">@b</code> hasn’t been visited yet, and isn’t the block containing the load we’re deleting, add it to the queue.</p> </li> </ol> </li> </ol> <p>Once we’re done, if <code class="language-plaintext highlighter-rouge">@a</code> is the block that contains the load, we can now replace all loads to <code class="language-plaintext highlighter-rouge">%p</code> before any stores to <code class="language-plaintext highlighter-rouge">%p</code> with <code class="language-plaintext highlighter-rouge">%v.a</code>.</p> <blockquote id="tip:1" class="tip"> <p><a href="#tip:1"><span class="chip">tip</span></a></p> <p>There are cases where this whole process can be skipped, by applying a “peephole” optimization. For example, stores followed by loads within the same basic block can be optimized away locally, leaving the heavy-weight analysis for cross-block store/load pairs.</p> </blockquote> <h3 id="worked-example"><a href="#worked-example">Worked Example</a></h3> <p>Here’s the result of doing dependency analysis on our Fibonacci function. Each load is annotated with the blocks and stores in <code class="language-plaintext highlighter-rouge">stores</code>.</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="o">&amp;</span><span class="n">fib</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">%</span><span class="n">np</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>
    <span class="o">%</span><span class="n">ap</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>
    <span class="o">%</span><span class="n">bp</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>

    <span class="n">store</span> <span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span>  <span class="c">// S1</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="m">0</span>   <span class="c">// S2</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="m">1</span>   <span class="c">// S3</span>

    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">)</span>

  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="o">:</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// @entry: S1</span>
    <span class="c">// @loop.body: S6</span>
    <span class="o">%</span><span class="n">n</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">np</span>  <span class="c">// L1</span>
    <span class="o">%</span><span class="n">cont</span> <span class="o">=</span> <span class="n">cmp</span><span class="o">.</span><span class="n">gt</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span>

    <span class="k">goto</span> <span class="o">%</span><span class="n">cont</span> <span class="p">{</span>
      <span class="m">0</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">exit</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="p">)</span>
      <span class="m">1</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">),</span>
    <span class="p">}</span>

  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="o">:</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// @entry: S1</span>
    <span class="c">// @loop.body: S4</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">ap</span>  <span class="c">// L2</span>
    <span class="c">// @entry: S2</span>
    <span class="c">// @loop.body: S5</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">bp</span>  <span class="c">// L3</span>
    <span class="o">%</span><span class="n">c</span> <span class="o">=</span> <span class="n">add</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="c">// S4</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="c">// S5</span>

    <span class="c">// @entry: S1</span>
    <span class="c">// @loop.body: S6</span>
    <span class="o">%</span><span class="n">n</span>   <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">np</span>  <span class="c">// L3</span>
    <span class="o">%</span><span class="n">n</span><span class="m">.2</span> <span class="o">=</span> <span class="n">sub</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">1</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="m">.2</span>  <span class="c">// S6</span>

    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">)</span>

  <span class="err">@</span><span class="n">exit</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="o">:</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// @entry: S2</span>
    <span class="c">// @loop.body: S5</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">load</span> <span class="o">%</span><span class="n">ap</span>  <span class="c">// L4</span>
    <span class="k">goto</span> <span class="err">@</span><span class="n">ret</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">SSA-CFG</a></div></div> <p>Let’s look at <code class="language-plaintext highlighter-rouge">L1</code>. Is contributing loads are in <code class="language-plaintext highlighter-rouge">@entry</code> and <code class="language-plaintext highlighter-rouge">@loop.body</code>. So we add a new parameter <code class="language-plaintext highlighter-rouge">%n</code>: in <code class="language-plaintext highlighter-rouge">@entry</code>, we call that parameter with <code class="language-plaintext highlighter-rouge">%n</code> (since that’s stored to it in <code class="language-plaintext highlighter-rouge">@entry</code>), while in <code class="language-plaintext highlighter-rouge">@loop.body</code>, we pass <code class="language-plaintext highlighter-rouge">%n.2</code>.</p> <p>What about L4? The contributing loads are also in <code class="language-plaintext highlighter-rouge">@entry</code> and <code class="language-plaintext highlighter-rouge">@loop.body</code>, but one of those isn’t a pred of <code class="language-plaintext highlighter-rouge">@exit</code>. <code class="language-plaintext highlighter-rouge">@loop.start</code> is also in the subgraph for this load, though. So, starting from <code class="language-plaintext highlighter-rouge">@entry</code>, we add a new parameter <code class="language-plaintext highlighter-rouge">%a</code> to <code class="language-plaintext highlighter-rouge">@loop.body</code> and feed <code class="language-plaintext highlighter-rouge">0</code> (the stored value, an immediate this time) through it. Now looking at <code class="language-plaintext highlighter-rouge">@loop.body</code>, we see there is already a parameter for this load (<code class="language-plaintext highlighter-rouge">%a</code>), so we just pass <code class="language-plaintext highlighter-rouge">%b</code> as that argument. Now we process <code class="language-plaintext highlighter-rouge">@loop.start</code>, which <code class="language-plaintext highlighter-rouge">@entry</code> pushed onto the queue. <code class="language-plaintext highlighter-rouge">@exit</code> gets a new parameter <code class="language-plaintext highlighter-rouge">%a</code>, which is fed <code class="language-plaintext highlighter-rouge">@loop.start</code>’s own <code class="language-plaintext highlighter-rouge">%a</code>. We do not re-process <code class="language-plaintext highlighter-rouge">@loop.body</code>, even though it also appears in <code class="language-plaintext highlighter-rouge">@loop.start</code>’s gotos, because we already visited it.</p> <p>After doing this for the other two loads, we get this:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="o">&amp;</span><span class="n">fib</span><span class="p">(</span><span class="o">%</span><span class="n">n</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">%</span><span class="n">np</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>
    <span class="o">%</span><span class="n">ap</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>
    <span class="o">%</span><span class="n">bp</span> <span class="o">=</span> <span class="n">stack</span> <span class="n">i32</span>

    <span class="n">store</span> <span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span>  <span class="c">// S1</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="m">0</span>   <span class="c">// S2</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="m">1</span>   <span class="c">// S3</span>

    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>

  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="o">:</span> <span class="n">ptr</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// @entry: S1</span>
    <span class="c">// @loop.body: S6</span>
    <span class="c">// %n = load %np  // L1</span>
    <span class="o">%</span><span class="n">cont</span> <span class="o">=</span> <span class="n">cmp</span><span class="o">.</span><span class="n">gt</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span>

    <span class="k">goto</span> <span class="o">%</span><span class="n">cont</span> <span class="p">{</span>
      <span class="m">0</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">exit</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
      <span class="m">1</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">),</span>
    <span class="p">}</span>

  <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">body</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="o">:</span> <span class="n">ptr</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// @entry: S1</span>
    <span class="c">// @loop.body: S4</span>
    <span class="c">// %a = load %ap  // L2</span>
    <span class="c">// @entry: S2</span>
    <span class="c">// @loop.body: S5</span>
    <span class="c">// %b = load %bp  // L3</span>
    <span class="o">%</span><span class="n">c</span> <span class="o">=</span> <span class="n">add</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="c">// S4</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="c">// S5</span>

    <span class="c">// @entry: S1</span>
    <span class="c">// @loop.body: S6</span>
    <span class="c">// %n   = load %np  // L3</span>
    <span class="o">%</span><span class="n">n</span><span class="m">.2</span> <span class="o">=</span> <span class="n">sub</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span> <span class="m">1</span>
    <span class="n">store</span> <span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="m">.2</span>  <span class="c">// S6</span>

    <span class="k">goto</span> <span class="err">@</span><span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">%</span><span class="n">np</span><span class="p">,</span> <span class="o">%</span><span class="n">ap</span><span class="p">,</span> <span class="o">%</span><span class="n">bp</span><span class="p">,</span> <span class="o">%</span><span class="n">n</span><span class="m">.2</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>

  <span class="err">@</span><span class="n">exit</span><span class="p">(</span><span class="o">%</span><span class="n">ap</span><span class="o">:</span> <span class="n">ptr</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span><span class="o">:</span>
    <span class="c">// @entry: S2</span>
    <span class="c">// @loop.body: S5</span>
    <span class="c">// %a = load %ap  // L4</span>
    <span class="k">goto</span> <span class="err">@</span><span class="n">ret</span><span class="p">(</span><span class="o">%</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">SSA-CFG</a></div></div> <p>After lifting, if we know that a stack slot’s pointer does not escape (i.e., none of its uses wind up going into a function call<sup id="fnref:calls-only" role="doc-noteref"><a href="#fn:calls-only" class="footnote" rel="footnote">13</a></sup>) or a write to a global (or a pointer that escapes), we can delete every store to that pointer. If we delete every store to a stack slot, we can delete the stack slot altogether (there should be no loads left for that stack slot at this point).</p> <h3 id="complications"><a href="#complications">Complications</a></h3> <p>This analysis is simple, because it assumes pointers do not alias in general. Alias analysis is necessary for more accurate dependency analysis. This is necessary, for example, for lifting loads of fields of structs through subobject pointers, and dealing with pointer arithmetic in general.</p> <p>However, our dependency analysis <em>is</em> robust to passing different pointers as arguments to the same block from different predecessors. This is the case that is specifically handled by all of the fussing about with dominance frontiers. This robustness ultimately comes from SSA’s circuital nature.</p> <p>Similarly, this analysis needs to be tweaked to deal with something like <code class="language-plaintext highlighter-rouge">select %cond, %a, %b</code> (a ternary, essentially). <code class="language-plaintext highlighter-rouge">select</code>s of pointers need to be replaced with <code class="language-plaintext highlighter-rouge">select</code>s of the loaded values, which means we need to do the lifting transformation “all at once”: lifting some liftable loads will leave the IR in an inconsistent state, until all of them have been lifted.</p> <h2 id="cleanup-passes"><a href="#cleanup-passes">Cleanup Passes</a></h2> <p>Many optimizations will make a mess of the CFG, so it’s useful to have simple passes that “clean up” the mess left by transformations. Here’s some easy examples.</p> <h3 id="unused-result-elimination"><a href="#unused-result-elimination">Unused Result Elimination</a></h3> <p>If an operation’s result has zero uses, and the operation has no side-effects, it can be deleted. This allows us to then delete operations that it depended on that now have no side effects. Doing this is very simple, due to the circuital nature of SSA: collect all instructions whose outputs have zero uses, and delete them. Then, examine the defs of their operands; if those operations now have no uses, delete them, and recurse.</p> <p>This bubbles up all the way to block arguments. Deleting block arguments is a bit trickier, but we can use a work queue to do it. Put all of the blocks into a work queue.</p> <ol> <li> <p>Pop a block from the queue.</p> </li> <li> <p>Run unused result elimination on its operations.</p> </li> <li> <p>If it now has parameters with no uses, remove those parameters.</p> </li> <li> <p>For each pred, delete the corresponding arguments to this block. Then, Place those preds into the work queue (since some of their operations may have lost their last use).</p> </li> <li> <p>If there is still work left, go to 1.</p> </li> </ol> <h3 id="simplifying-the-cfg"><a href="#simplifying-the-cfg">Simplifying the CFG</a></h3> <p>There are many CFG configurations that are redundant and can be simplified to reduce the number of basic blocks.</p> <p>For example, unreachable code can help delete blocks. Other optimizations may cause the <code class="language-plaintext highlighter-rouge">goto</code> at the end of a function to be empty (because all of its successors were optimized away). We treat an empty <code class="language-plaintext highlighter-rouge">goto</code> as being unreachable (since it has no cases!), so we can delete every operation in the block up to the last non-pure operation. If we delete every instruction in the block, we can delete the block entirely, and delete it from its preds’ <code class="language-plaintext highlighter-rouge">goto</code>s. This is a form of <em>dead code elimination</em>, or DCE, which combines with the previous optimization to aggressively delete redundant code.</p> <p>Some jumps are redundant. For example, if a block has exactly one pred and one successor, the pred’s <code class="language-plaintext highlighter-rouge">goto</code> case for that block can be wired directly to the successor. Similarly, if two blocks are each other’s unique predecessor/successor, they can be <em>fused</em>, creating a single block by connecting the input blocks’ circuits directly, instead of through a <code class="language-plaintext highlighter-rouge">goto</code>.</p> <p>If we have a ternary <code class="language-plaintext highlighter-rouge">select</code> operation, we can do more sophisticated fusion. If a block has two successors, both of which the same unique successor, and those successors consist only of gotos, we can fuse all four blocks, replacing the CFG diamond with a <code class="language-plaintext highlighter-rouge">select</code>. In terms of C, this is this transformation:</p> <div class="code-multicol"> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Before.</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">C</a></div></div> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// After.</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">C</a></div></div> </div> <p>LLVM’s CFG simplification pass is very sophisticated and can eliminate complex forms of control flow.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>I am hoping to write more about SSA optimization passes. This is a very rich subject, and viewing optimizations in isolation is a great way to understand how a sophisticated optimization pipeline is built out of simple, dumb components.</p> <p>It’s also a practical application of graph theory that shows just how powerful it can be, and (at least in my opinion), is an intuitive setting for understanding graph theory, which can feel very abstract otherwise.</p> <p>In the future, I’d like to cover CSE/GVN, loop optimizations, and, if I’m feeling brave, getting out of SSA into a finite-register machine (backends are not my strong suit!).</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:swift" role="doc-endnote"> <p>Specifically the Swift frontend before lowering into LLVM IR. <a href="#fnref:swift" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:msvc" role="doc-endnote"> <p>Microsoft Visual C++, a non-conforming C++ compiler sold by Microsoft <a href="#fnref:msvc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:hotspot" role="doc-endnote"> <p>HotSpot is the JVM implementation provided by OpenJDK; C2 is the “second compiler”, which has the best performance among HotSpot’s Java execution engines. <a href="#fnref:hotspot" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:v8" role="doc-endnote"> <p>V8 is Chromium’s JavaScript runtime. <a href="#fnref:v8" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:spidermonkey" role="doc-endnote"> <p>SpiderMonkey is Firefox’s JavaScript runtime. <a href="#fnref:spidermonkey" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:art" role="doc-endnote"> <p>The Android Runtime (ART) is the “JVM” (scare quotes) on the Android platform. <a href="#fnref:art" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ghc" role="doc-endnote"> <p>The Glasgow Haskell Compiler (GHC), does <em>not</em> use SSA; it (like some other pure-functional languages) uses a continuation-oriented IR (compare to Scheme’s <code class="language-plaintext highlighter-rouge">call/cc</code>). <a href="#fnref:ghc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:p-np" role="doc-endnote"> <p>Every compiler person firmly believes that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo mathvariant="normal">≠</mo><mi>N</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">P \neq NP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">NP</span></span></span></span></span>, because program optimization is full of NP-hard problems and we would have definitely found polynomial ideal register allocation by now if it existed. <a href="#fnref:p-np" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:non-cfg" role="doc-endnote"> <p>Some more recent IRs use a different version of SSA called “structured control flow”, or SCF. Wasm is a notable example of an SCF IR. SSA-SCF is equivalent to SSA-CFG, and polynomial time algorithms exist for losslessly converting between them (LLVM compiling Wasm, for example, converts its CFG into SCF using a “relooping algorithm”).</p> <p>In SCF, operations like switch statements and loops are represented as macro operations that <em>contain</em> basic blocks. For example, a <code class="language-plaintext highlighter-rouge">switch</code> operation might take a value as input, select a basic block to execute based on that, and return the value that basic block evaluates to as its output.</p> <p><a href="https://arxiv.org/abs/1912.05036">RVSDG</a> is a notable innovation in this space, because it allows circuit analysis of entire imperative programs.</p> <p>I am convering SSA-CFG instead of SSA-SCF simply because it’s more common, and because it’s what LLVM IR is.</p> <p>See also this <a href="https://llvm.org/devmtg/2024-04/slides/TechnicalTalks/Bock-LiftingCFGs.pdf">MLIR presentation</a> for converting between the two. <a href="#fnref:non-cfg" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:tail-call" role="doc-endnote"> <p>Tail calling is when a function call is the last operation in a function; this allows the caller to jump directly to the callee, recycling its own stack frame for it instead of requiring it to allocate its own. <a href="#fnref:tail-call" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:acyclic" role="doc-endnote"> <p>Given any path from <code class="language-plaintext highlighter-rouge">@a</code> to <code class="language-plaintext highlighter-rouge">@b</code>, we can make it acyclic by replacing each subpath from <code class="language-plaintext highlighter-rouge">@c</code> to <code class="language-plaintext highlighter-rouge">@c</code> with a single <code class="language-plaintext highlighter-rouge">@c</code> node. <a href="#fnref:acyclic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:equiv-reg" role="doc-endnote"> <p>When moving from a basic block to a pred, a register in that block which is defined as a block parameter corresponds to some register (or immediate) in each predecessor. That is the “equivalent” of <code class="language-plaintext highlighter-rouge">%p</code>.</p> <p>One possible option for the “equivalent” is an immediate: for example, <code class="language-plaintext highlighter-rouge">null</code> or the address of a global. In the case of a global <code class="language-plaintext highlighter-rouge">&amp;g</code>, assuming no data races, we would instead need alias information to tell if stores to this global within the current function (a) exist and (b) are liftable at all.</p> <p>If the equivalent is <code class="language-plaintext highlighter-rouge">null</code>, we can proceed in one of two ways depending on optimization level. If we want loads of <code class="language-plaintext highlighter-rouge">null</code> to trap (as in Go), we need to mark this load as not being liftable, because it may trap. If we want loads of <code class="language-plaintext highlighter-rouge">null</code> to be UB, we simply ignore that pred, because we can assume (for our analysis) that if the pointer is <code class="language-plaintext highlighter-rouge">null</code>, it is never loaded from. <a href="#fnref:equiv-reg" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:calls-only" role="doc-endnote"> <p>Returned stack pointers do <em>not</em> escape: stack slots’ lifetimes end at function exit, so we return a dangling pointer, which we assume are never loaded. So stores to that pointer before returning it can be discarded. <a href="#fnref:calls-only" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-08-25 • 2194 words • 24 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#go">#go</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/2025/08/25/go-default-methods/"> Default Methods in Go </a></h1> </div> <div class="post"> <p>Go’s interfaces are very funny. Rather than being explicitly implemented, like in Java or Rust, they are simply a collection of methods (a “method set”) that the concrete type must <em>happen</em> to have. This is called structural typing, which is the opposite of nominal typing.</p> <p>Go interfaces are very cute, but this conceptual simplicity leads to a lot of implementation problems (a theme with Go, honestly). It removes a lot of intentionality from implementing interfaces, and there is no canonical way to document that <code class="language-plaintext highlighter-rouge">A</code> satisfies<sup id="fnref:satisfy-implement" role="doc-noteref"><a href="#fn:satisfy-implement" class="footnote" rel="footnote">1</a></sup> <code class="language-plaintext highlighter-rouge">B</code>, nor can you <em>avoid</em> conforming to interfaces, especially if one forces a particular method on you.</p> <p>It also has very quirky results for the language runtime. To cast an interface value to another interface type (via the type assertion syntax <code class="language-plaintext highlighter-rouge">a.(B)</code>), the runtime essentially has to use reflection to go through the method set of the concrete type of <code class="language-plaintext highlighter-rouge">a</code>. I go into detail on how this is implemented <a href="https://mcyoung.xyz/2024/12/12/go-abi#codegen-for-interface-operations">here</a>.</p> <p>Because of their structural nature, this <em>also</em> means that you can’t add new methods to an interface without breaking existing code, because there is no way to attach default implementations to interface methods. This results in very silly APIs because someone screwed up an interface.</p> <h2 id="flagvalue-is-a-mess"><a href="#flagvalue-is-a-mess">flag.Value is a Mess</a></h2> <p>For example, in the standard library’s package <code class="language-plaintext highlighter-rouge">flag</code>, the interface <code class="language-plaintext highlighter-rouge">flag.Value</code> represents a value which can be parsed as a CLI flag. It looks like this:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Value</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="c">// Get a string representation of the value.</span>
  <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>

  <span class="c">// Parse a value from a string, possibly returning an error.</span>
  <span class="n">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Go</a></div></div> <p><code class="language-plaintext highlighter-rouge">flag.Value</code> also has an optional method, which is only specified in the documentation. If the concrete type happens to provide <code class="language-plaintext highlighter-rouge">IsBoolFlag() bool</code>, it will be queries for determining if the flag should have bool-like behavior. Essentially, this means that something like this exists in the flag library:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">isBool</span> <span class="kt">bool</span>
<span class="k">if</span> <span class="n">b</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="k">interface</span><span class="p">{</span> <span class="n">IsBoolFlag</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">});</span> <span class="n">ok</span> <span class="p">{</span>
  <span class="n">isBool</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">IsBoolFlag</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Go</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">flag</code> package already uses reflection, but you can see how it might be a problem if this interface-to-interface cast happens regularly, even taking into account Go’s caching of cast results.</p> <p>There is also <code class="language-plaintext highlighter-rouge">flag.Getter</code>, which exists because they messed up and didn’t provide a way for a <code class="language-plaintext highlighter-rouge">flag.Value</code> to unwrap into the value it contains. For example, if a flag is defined with <code class="language-plaintext highlighter-rouge">flag.Int</code>, and then that flag is looked up with <code class="language-plaintext highlighter-rouge">flag.Lookup</code>, there’s no straightforward way to get the int out of the returned <code class="language-plaintext highlighter-rouge">flag.Value</code>.</p> <p>Instead, you have to side-cast to <code class="language-plaintext highlighter-rouge">flag.Getter</code>:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Getter</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Value</span>

  <span class="c">// Returns the value of the flag.</span>
  <span class="n">Get</span><span class="p">()</span> <span class="n">any</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Go</a></div></div> <p>As a result, <code class="language-plaintext highlighter-rouge">flag.Lookup("...").(flag.Getter)</code> needs to do a lot more work than if <code class="language-plaintext highlighter-rouge">flag.Value</code> had just added <code class="language-plaintext highlighter-rouge">Get() any</code>, with a default return value of <code class="language-plaintext highlighter-rouge">nil</code>.</p> <p>It turns out that there is a rather elegant workaround for this.</p> <h2 id="struct-embeddings"><a href="#struct-embeddings">Struct Embeddings</a></h2> <p>Go has this quirky feature called <em>embedding</em>, where a a field in a struct is declared without a name:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="p">(</span>
  <span class="n">A</span> <span class="kt">int</span>
  <span class="n">B</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">A</span>
    <span class="n">Foo</span> <span class="kt">int</span>
  <span class="p">}</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Go</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">A</code>-typed embedded field behaves as if we had declared the field <code class="language-plaintext highlighter-rouge">A A</code>, but selectors on <code class="language-plaintext highlighter-rouge">var b B</code> will search in <code class="language-plaintext highlighter-rouge">A</code> if they do not match something on the <code class="language-plaintext highlighter-rouge">B</code> level. For example, if <code class="language-plaintext highlighter-rouge">A</code> has a method <code class="language-plaintext highlighter-rouge">Bar</code>, and <code class="language-plaintext highlighter-rouge">B</code> does not, <code class="language-plaintext highlighter-rouge">b.Bar()</code> will resolve to <code class="language-plaintext highlighter-rouge">b.A.Bar()</code>. However, if <code class="language-plaintext highlighter-rouge">A</code> has a method <code class="language-plaintext highlighter-rouge">Foo</code>, <code class="language-plaintext highlighter-rouge">b.Foo</code> resolves to <code class="language-plaintext highlighter-rouge">b.Foo</code>, not <code class="language-plaintext highlighter-rouge">b.A.Foo</code>, because <code class="language-plaintext highlighter-rouge">b</code> has a field <code class="language-plaintext highlighter-rouge">Foo</code>.</p> <p>Importantly, any methods from <code class="language-plaintext highlighter-rouge">A</code> which <code class="language-plaintext highlighter-rouge">B</code> does not already have will be added to <code class="language-plaintext highlighter-rouge">B</code>’s method set. So this works:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="p">(</span>
  <span class="n">A</span> <span class="kt">int</span>
  <span class="n">B</span> <span class="k">struct</span><span class="p">{</span> <span class="n">A</span> <span class="p">}</span>
  <span class="n">C</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="p">()</span>
    <span class="n">Bar</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">)</span>

<span class="k">func</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="n">Foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="n">Bar</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">var</span> <span class="n">_</span> <span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="p">{}</span>  <span class="c">// B satisfies C.</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Go</a></div></div> <p>Now, suppose that we were trying to add <code class="language-plaintext highlighter-rouge">Get() any</code> to <code class="language-plaintext highlighter-rouge">flag.Value</code>. Let’s suppose that we had also defined <code class="language-plaintext highlighter-rouge">flag.ValueDefaults</code>, a type that all satisfiers of <code class="language-plaintext highlighter-rouge">flag.Value</code> must embed. Then, we can write the following:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Value</span> <span class="k">interface</span><span class="p">{</span>
  <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="n">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

  <span class="n">Get</span><span class="p">()</span> <span class="n">any</span>  <span class="c">// New method.</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ValueDefaults</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ValueDefaults</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Go</a></div></div> <p>Then, no code change is required for all clients to pick up the new implementation of <code class="language-plaintext highlighter-rouge">Get()</code>.</p> <h3 id="required-embeds"><a href="#required-embeds">Required Embeds</a></h3> <p>Now, this only works if we had required in the first place that anyone satisfying <code class="language-plaintext highlighter-rouge">flag.Value</code> embeds <code class="language-plaintext highlighter-rouge">flag.ValueDefaults</code>. How can we force that?</p> <p>A little-known Go feature is that interfaces can have unexported methods. The way these work, for the purposes of interface conformance, is that exported methods are matched just by their name, but unexported methods must match both name and package.</p> <p>So, if we have an interface like <code class="language-plaintext highlighter-rouge">interface { foo() }</code>, then <code class="language-plaintext highlighter-rouge">foo</code> will only match methods defined in the same package that this interface expression appears. This is useful for preventing satisfaction of interfaces.</p> <p>However, there is a loophole: embedding inherits the <em>entire</em> method set, including unexported methods. Therefore, we can enhance <code class="language-plaintext highlighter-rouge">Value</code> to account for this:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Value</span> <span class="k">interface</span><span class="p">{</span>
  <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="n">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

  <span class="n">Get</span><span class="p">()</span> <span class="n">any</span>  <span class="c">// New method.</span>

  <span class="n">value</span><span class="p">()</span> <span class="c">// Unexported!</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ValueDefaults</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ValueDefaults</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">ValueDefaults</span><span class="p">)</span> <span class="n">value</span><span class="p">()</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Go</a></div></div> <p>Now, it’s impossible for any type defined outside of this package to satisfy <code class="language-plaintext highlighter-rouge">flag.Value</code>, without embedding <code class="language-plaintext highlighter-rouge">flag.ValueDefaults</code> (either directly or through another embedded <code class="language-plaintext highlighter-rouge">flag.Value</code>).</p> <h3 id="exported-struct-fields"><a href="#exported-struct-fields">Exported Struct Fields</a></h3> <p>Now, another problem is that you can’t control the name of embedded fields. If the embedded type is <code class="language-plaintext highlighter-rouge">Foo</code>, the field’s name is <code class="language-plaintext highlighter-rouge">Foo</code>. Except, it’s not based on the name of the type itself; it will pick up the name of a type alias. So, if you want to unexport the defaults struct, you can simply write:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">MyValue</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">valueDefaults</span>

  <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">valueDefaults</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">ValueDefaults</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Go</a></div></div> <p>This also has the side-effect of hiding all of <code class="language-plaintext highlighter-rouge">ValueDefaults</code>’ methods from <code class="language-plaintext highlighter-rouge">MyValue</code>’s documentation, despite the fact that exported and fields methods are still selectable and callable by other packages (including via interfaces). As far as I can tell, this is simply a bug in <code class="language-plaintext highlighter-rouge">godoc</code>, since this behavior is not documented.</p> <h3 id="what-about-same-name-methods"><a href="#what-about-same-name-methods">What About Same-Name Methods?</a></h3> <p>There is still a failure mode: if a user type satisfying <code class="language-plaintext highlighter-rouge">flag.Value</code> happened to define a <code class="language-plaintext highlighter-rouge">Get</code> method with a different interface. In this case, that <code class="language-plaintext highlighter-rouge">Get</code> takes precedence, and changes to <code class="language-plaintext highlighter-rouge">flag.Value</code> will break users.</p> <p>There are two workarounds:</p> <ol> <li> <p>Tell people not to define methods on their satisfying type, and if they do, they’re screwed. Because satisfying <code class="language-plaintext highlighter-rouge">flag.Value</code> is now explicit, this is not too difficult to ask for.</p> </li> <li> <p>Pick a name for new methods that is unlikely to collide with anything.</p> </li> </ol> <p>Unfortunately, this runs into a big issue with structural typing, which is that it is very difficult to avoid making mistakes when making changes, due to the lack of intent involved. A similar problem occurs with C++ templates, where the interfaces defined by concepts are implicit, and can result in violating contract expectations.</p> <p>Go has historically be relatively cavalier about this kind of issue, so I think that breaking people based on this is fine.</p> <p>And of course, you cannot retrofit a default struct into a interface; you have to define it from day one.</p> <h2 id="using-defaults"><a href="#using-defaults">Using Defaults</a></h2> <p>Now that we have defaults, we can also enhance <code class="language-plaintext highlighter-rouge">flag.Value</code> with bool flag detection:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Value</span> <span class="k">interface</span><span class="p">{</span>
  <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="n">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

  <span class="n">Get</span><span class="p">()</span> <span class="n">any</span>
  <span class="n">IsBoolFlag</span><span class="p">()</span> <span class="kt">bool</span>

  <span class="n">value</span><span class="p">()</span> <span class="c">// Unexported!</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ValueDefaults</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ValueDefaults</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">ValueDefaults</span><span class="p">)</span> <span class="n">IsBoolFlag</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="no">false</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">ValueDefaults</span><span class="p">)</span> <span class="n">value</span><span class="p">()</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Go</a></div></div> <p>Now <code class="language-plaintext highlighter-rouge">IsBoolFlag</code> is more than just a random throw-away comment on a type.</p> <p>We can also use defaults to speed up side casts. Many functions around the <code class="language-plaintext highlighter-rouge">io</code> package will cast an <code class="language-plaintext highlighter-rouge">io.Reader</code> into an <code class="language-plaintext highlighter-rouge">io.Seeker</code> or <code class="language-plaintext highlighter-rouge">io.ReadAt</code> to perform more efficient I/O.</p> <p>In a hypothetical world where we had defaults structs for all the <code class="language-plaintext highlighter-rouge">io</code> interfaces, we can enhance <code class="language-plaintext highlighter-rouge">io.Reader</code> with a <code class="language-plaintext highlighter-rouge">ReadAt</code> default method that by default returns an error.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Read</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="n">ReadAt</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

  <span class="n">reader</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReaderDefaults</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ReaderDefaults</span><span class="p">)</span> <span class="n">ReadAt</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">ErrUnsupported</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">ReaderDefaults</span><span class="p">)</span> <span class="n">reader</span><span class="p">()</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Go</a></div></div> <p>We can do something similar for <code class="language-plaintext highlighter-rouge">io.Seeker</code>, but because it’s a rather general interface, it’s better to keep <code class="language-plaintext highlighter-rouge">io.Seeker</code> as-is. So, we can add a conversion method:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Seeker</span><span class="p">()</span> <span class="n">io</span><span class="o">.</span><span class="n">Seeker</span>

  <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReaderDefaults</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ReaderDefaults</span><span class="p">)</span> <span class="n">Seeker</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">int64</span><span class="p">)</span> <span class="n">io</span><span class="o">.</span><span class="n">Seeker</span> <span class="p">{</span>
  <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Go</a></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">Reader.Seeker()</code> converts to an <code class="language-plaintext highlighter-rouge">io.Seeker</code>, returning <code class="language-plaintext highlighter-rouge">nil</code> if that’s not possible. How is this faster than <code class="language-plaintext highlighter-rouge">r.(io.Seeker)</code>? Well, consider what this would look like in user code:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">MyIO</span> <span class="k">struct</span><span class="p">{</span>
  <span class="n">io</span><span class="o">.</span><span class="n">ReaderDefaults</span>
  <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">MyIO</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">MyIO</span><span class="p">)</span> <span class="n">Seek</span><span class="p">(</span><span class="n">offset</span> <span class="kt">int64</span><span class="p">,</span> <span class="n">whence</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">MyIO</span><span class="p">)</span> <span class="n">Seeker</span><span class="p">()</span> <span class="n">io</span><span class="o">.</span><span class="n">Seeker</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Go</a></div></div> <p>Calling <code class="language-plaintext highlighter-rouge">r.Seeker()</code>, if <code class="language-plaintext highlighter-rouge">r</code> is an <code class="language-plaintext highlighter-rouge">io.Reader</code> containing a <code class="language-plaintext highlighter-rouge">MyIO</code>, lowers to the following machine code:</p> <ol> <li>Load the function pointer for <code class="language-plaintext highlighter-rouge">Seeker</code> out of <code class="language-plaintext highlighter-rouge">r</code>’s itab.</li> <li>Perform an indirect jump on that function pointer.</li> <li>Inside of <code class="language-plaintext highlighter-rouge">(*MyIO).Seeker</code>, load a pointer to the itab symbol <code class="language-plaintext highlighter-rouge">go:itab.*MyIO,io.Seeker</code> and <code class="language-plaintext highlighter-rouge">m</code> into the return slots.</li> <li>Return.</li> </ol> <p>The main cost of this conversion is the indirect jump, compared to, at minimum, hitting a hashmap lookup loop for the cache for <code class="language-plaintext highlighter-rouge">r.(io.Seeker)</code>.</p> <p>Does this performance matter? Not for I/O interfaces, probably, but it <em>can</em> matter for some uses!</p> <h2 id="shouldnt-this-be-a-language-feature"><a href="#shouldnt-this-be-a-language-feature">Shouldn’t This Be a Language Feature?</a></h2> <p>Yes, it should, but here we are. Although making it a language feature has a few rather unfortunate quirks that we need to keep in mind.</p> <p>Suppose we can define defaults on interface methods somehow, like this:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Foo</span> <span class="k">interface</span><span class="p">{</span>
  <span class="n">Bar</span><span class="p">()</span>
  <span class="n">Baz</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">Foo</span><span class="p">)</span> <span class="n">Baz</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Go</a></div></div> <p>Then, any type which provides <code class="language-plaintext highlighter-rouge">Bar()</code> automatically satisfies <code class="language-plaintext highlighter-rouge">Foo</code>. Suppose <code class="language-plaintext highlighter-rouge">MyFoo</code> satisfies <code class="language-plaintext highlighter-rouge">Foo</code>, but does not provide <code class="language-plaintext highlighter-rouge">Baz</code>. Then we have a problem:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">x</span> <span class="n">MyFoo</span>
<span class="n">x</span><span class="o">.</span><span class="n">Baz</span><span class="p">()</span>       <span class="c">// Error!</span>
<span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">Baz</span><span class="p">()</span>  <span class="c">// Ok!</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Go</a></div></div> <p>Now, we might consider looking past that, but it becomes a big problem with reflection. If we passed <code class="language-plaintext highlighter-rouge">Foo(x)</code> into <code class="language-plaintext highlighter-rouge">reflect.ValueOf</code>, the resulting <code class="language-plaintext highlighter-rouge">any</code> conversion would discard the defaulted method, meaning that it would not be findable by <code class="language-plaintext highlighter-rouge">reflect.Value.MethodByName()</code>. Oops.</p> <p>So we need to somehow add <code class="language-plaintext highlighter-rouge">Baz</code> to <code class="language-plaintext highlighter-rouge">MyFoo</code>’s method set. Maybe we say that if <code class="language-plaintext highlighter-rouge">MyFoo</code> is ever converted into <code class="language-plaintext highlighter-rouge">Foo</code>, it gets the method. But this doesn’t work, because the compiler might not be able to see through something like <code class="language-plaintext highlighter-rouge">any(MyFoo{...}).(Foo)</code>. This means that <code class="language-plaintext highlighter-rouge">Baz</code> must be applied unconditionally. But, now we have the problem that if we have another interface <code class="language-plaintext highlighter-rouge">interface { Bar(); Baz(int) }</code>, <code class="language-plaintext highlighter-rouge">MyFoo</code> would need to receive incompatible signatures for <code class="language-plaintext highlighter-rouge">Baz</code>.</p> <p>Again, we’re screwed by the non-intentionality of structural typing.</p> <h3 id="missing-methods"><a href="#missing-methods">Missing Methods</a></h3> <p>Ok, let’s forget about default method implementations, that doesn’t seem to be workable. What if we make some methods optional, like <code class="language-plaintext highlighter-rouge">IsBoolFlag()</code> earlier? Let’s invent some syntax for it.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Foo</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Bar</span><span class="p">()</span>
  <span class="err">?</span><span class="n">Baz</span><span class="p">()</span> <span class="c">// Optional method.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Go</a></div></div> <p>Then, suppose that <code class="language-plaintext highlighter-rouge">MyFoo</code> provides <code class="language-plaintext highlighter-rouge">Bar</code> but not <code class="language-plaintext highlighter-rouge">Baz</code> (or <code class="language-plaintext highlighter-rouge">Baz</code> with the wrong signature). Then, the entry in the itab for <code class="language-plaintext highlighter-rouge">Baz</code> would contain a nil function pointer, such that <code class="language-plaintext highlighter-rouge">x.Baz()</code> panics! To determine if <code class="language-plaintext highlighter-rouge">Baz</code> is safe to call, we would use the following idiom:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">Baz</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
  <span class="n">x</span><span class="o">.</span><span class="n">Baz</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Go</a></div></div> <p>The compiler is already smart enough to elide construction of funcvals for cases like this, although it does mean that <code class="language-plaintext highlighter-rouge">x.Func</code> in general, for an interface value <code class="language-plaintext highlighter-rouge">x</code>, requires an extra <code class="language-plaintext highlighter-rouge">cmov</code> or similar to make sure that <code class="language-plaintext highlighter-rouge">x.Func</code> is nil when it’s a missing method.</p> <p>All of the use cases described above would work Just Fine using this construction, though! However, we run into the same issue that <code class="language-plaintext highlighter-rouge">Foo(x)</code> appears to have a larger method set than <code class="language-plaintext highlighter-rouge">x</code>. It is not clear if <code class="language-plaintext highlighter-rouge">Foo(x)</code> should conform to <code class="language-plaintext highlighter-rouge">interface { Bar(); Baz() }</code>, where <code class="language-plaintext highlighter-rouge">Baz</code> is required. My intuition would be no: <code class="language-plaintext highlighter-rouge">Foo</code> is a strictly weaker interface. Perhaps it might be necessary to avoid the method access syntax for optional methods, but that’s a question of aesthetics.</p> <p>This idea of having nulls in place of function pointers in a vtable is not new, but to my knowledge is not used especially widely. It would be very useful in C++, for example, to be able to determine if no implementation was provided for a non-pure virtual function. However, the nominal nature of C++’s virtual functions does not make this <em>as big</em> of a need.</p> <h3 id="related-interfaces"><a href="#related-interfaces">Related Interfaces</a></h3> <p>Another alternative is to store a related interfaces’ itabs on in an itab. For example, suppose that we invent the syntax <code class="language-plaintext highlighter-rouge">A&lt;-</code> within an <code class="language-plaintext highlighter-rouge">interface{}</code> to indicate that that interface will likely get cast to <code class="language-plaintext highlighter-rouge">A</code>. For example:</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="p">(</span>
  <span class="n">A</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Foo</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="n">B</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Bar</span><span class="p">()</span>

    <span class="n">A</span><span class="o">&lt;-</span>
  <span class="p">}</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Go</a></div></div> <p>Satisfying <code class="language-plaintext highlighter-rouge">B</code> does not require satisfying <code class="language-plaintext highlighter-rouge">A</code>. However, the <code class="language-plaintext highlighter-rouge">A&lt;-</code> must be part of public API, because a <code class="language-plaintext highlighter-rouge">interface{ Bar() }</code> cannot be used in place of an <code class="language-plaintext highlighter-rouge">interface{ A&lt;- }</code></p> <p>Within <code class="language-plaintext highlighter-rouge">B</code>’s itab, after all of the methods, there is a pointer to an itab for <code class="language-plaintext highlighter-rouge">A</code>, if the concrete type for this itab also happens to satisfy <code class="language-plaintext highlighter-rouge">A</code>. Then, a cast from <code class="language-plaintext highlighter-rouge">B</code> to <code class="language-plaintext highlighter-rouge">A</code> is just loading a pointer from the itab. If the cast would fail, the loaded pointer will be <code class="language-plaintext highlighter-rouge">nil</code>.</p> <p>I had always assumed that Go did an optimization like this for embedding interfaces, but no! <em>Any</em> inter-interface conversion, including upcasts, goes through the whole type assertion machinery! Of course, Go cannot hope to generate an itab for every possible subset of the method set of an interface (exponential blow-up), but it’s surprising that they don’t do this for embedded interfaces, which are Go’s equivalent of superinterfaces (present in basically every language with interfaces).</p> <p>Using this feature, we can update <code class="language-plaintext highlighter-rouge">flag.Value</code> to look like this:</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Value</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="n">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

  <span class="n">BoolValue</span><span class="o">&lt;-</span>
  <span class="n">Getter</span><span class="o">&lt;-</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">BoolValue</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Value</span>
  <span class="n">IsBoolFlag</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Getter</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Value</span>
  <span class="n">Get</span><span class="p">()</span> <span class="n">any</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Go</a></div></div> <p>Unfortunately, because <code class="language-plaintext highlighter-rouge">A&lt;-</code> changes the ABI of an interface, it does not seem possible to actually add this to existing interfaces, because the following code is valid:</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">A</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Foo</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">var</span> <span class="p">(</span>
  <span class="n">a</span> <span class="n">A</span>
  <span class="n">b</span> <span class="k">interface</span><span class="p">{</span> <span class="n">Foo</span><span class="p">()</span> <span class="p">}</span>
<span class="p">)</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Go</a></div></div> <p>Even though this fix seems really clean, it doesn’t work! The only way it could work is if PGO determines that a particular interface conversion <code class="language-plaintext highlighter-rouge">A</code> to <code class="language-plaintext highlighter-rouge">B</code> happens a lot, and updates the ABI of all interfaces with the method set of <code class="language-plaintext highlighter-rouge">A</code>, program-globally, to contain a pointer to a <code class="language-plaintext highlighter-rouge">B</code> itab if available.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Go’s interfaces are pretty bad; in my opinion, a feature that looks good on a slide, but which results in a lot of mess due to its granular and intention-less nature. We can sort of patch over it with embeds, but there’s still problems.</p> <p>Due to how method sets work in Go, it’s very hard to “add” methods through an interface, and honestly at this point, any interface mechanism that makes it impossible (or expensive) to add new functions is going to be a huge problem.</p> <p>Missing methods seems like the best way out of this problem, but for now, we can stick to the janky embedded structs.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:satisfy-implement" role="doc-endnote"> <p>Go uses the term “implements” to say that a type satisfies an interface. I am instead intentionally using the term “satisfies”, because it makes the structural, passive nature of implementing an interface clearer. This is also more in-line with interfaces’ use as generic constraints.</p> <p>Swift uses the term “conform” instead, which I am avoiding for this reason. <a href="#fnref:satisfy-implement" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-07-16 • 4119 words • 45 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> • <a href="https://mcyoung.xyz/tags.html#protobuf">#protobuf</a> </span> <h1><a href="/2025/07/16/hyperpb/"> Parsing Protobuf Like Never Before </a></h1> </div> <div class="post"> <p>Historically I have worked on many projects related to high-performance Protobuf, be that on the C++ runtime, on the Rust runtime, or on integrating <a href="https://github.com/protocolbuffers/protobuf/tree/main/upb">UPB</a>, the fastest Protobuf runtime, written by my colleague <a href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html">Josh Haberman</a>. I <em>generally</em> don’t post directly about my current job, but my most recent toy-turned-product is something I’m very excited to write about: <a href="https://github.com/bufbuild/hyperpb-go"><code class="language-plaintext highlighter-rouge">hyperpb</code></a>.</p> <p>Here’s how we measure up against other Go Protobuf parsers. This is a subset of my benchmarks, since the benchmark suite contains many dozens of specimens. This was recorded on an AMD Zen 4 machine.</p> <figure style="max-width: 95%;"> <p><img src="https://mcyoung.xyz/public/images/hyperpb/benches.svg" alt=""/></p> <figcaption> <p>Throughput for various configurations of <code class="language-plaintext highlighter-rouge">hyperpb</code> (colored bars) vs. competing parsers (grey bars). Each successive <code class="language-plaintext highlighter-rouge">hyperpb</code> includes all previous optimizations, corresponding to <a href="#zerocopy-strings">zerocopy mode</a>, <a href="#arena-reuse">arena reuse</a>, and <a href="#tdptype">profile-guided optimization</a>. Bigger is better.</p> </figcaption> </figure> <p>Traditionally, Protobuf backends would generate parsers by generating source code specialized to each type. Naively, this would give the best performance, because everything would be “right-sized” to a particular message type. Unfortunately, now that we know better, there are a bunch of drawbacks:</p> <ol> <li>Every type you care about must be compiled ahead-of-time. Tricky for when you want to build something generic over schemas your users provide you.</li> <li>Every type contributes to a cost on the instruction cache, meaning that if your program parses a lot of different types, it will essentially flush your instruction cache any time you enter a parser. Worse still, if a parse involves enough types, the parser itself will hit instruction decoding throughput issues.</li> </ol> <p>These effects are not directly visible in normal workloads, but other side-effects are visible: for example, giant switches on field numbers can turn into chains of branch instructions, meaning that higher-numbered fields will be quite slow. Even binary-searching on field numbers isn’t exactly ideal. However, we know that every Protobuf codec ever emits fields in index order (i.e., declaration order in the <code class="language-plaintext highlighter-rouge">.proto</code> file), which is a data conditioning fact we don’t take advantage of with a switch.</p> <p>UPB solves this problem. It is a small C kernel for parsing Protobuf messages, which is completely dynamic: a UPB “parser” is actually a collection of data tables that are evaluated by a <em>table-driven parser</em>. In other words, a UPB parser is actually configuration for an interpreter VM, which executes Protobuf messages as its bytecode. UPB also contains many arena optimizations to improve allocation throughput when parsing complex messages.</p> <p><code class="language-plaintext highlighter-rouge">hyperpb</code> is a brand new library, written in the most cursed Go imaginable, which brings many of the optimizations of UPB to Go, and many new ones, while being tuned to Go’s own weird needs. The result leaves the competition in the dust in virtually every benchmark, while being completely runtime-dynamic. This means it’s faster than Protobuf Go’s own generated code, <em>and</em> <a href="https://github.com/planetscale/vtprotobuf"><code class="language-plaintext highlighter-rouge">vtprotobuf</code></a> (a popular but non-conforming<sup id="fnref:vtproto" role="doc-noteref"><a href="#fn:vtproto" class="footnote" rel="footnote">1</a></sup> parser generator for Go).</p> <p>This post is about some of the internals of <code class="language-plaintext highlighter-rouge">hyperpb</code>. I have also prepared a more sales-ey writeup, which you can read on <a href="https://buf.build/blog/introducing-hyperpb">the Buf blog</a>.</p> <h2 id="why-reinvent-upb"><a href="#why-reinvent-upb">Why Reinvent UPB?</a></h2> <p>UPB is awesome. It can slot easily into any language that has C FFI, which is basically every language ever.</p> <p>Unfortunately, Go’s C FFI is really, really bad. It’s hard to overstate how bad cgo is. There isn’t a good way to cooperate with C on memory allocation (C can’t really handle Go memory without a lot of problems, due to the GC). Having C memory get cleaned up by the GC requires finalizers, which are very slow. Calling into C is very slow, because Go pessimistically assumes that C requires a large stack, and also calling into C does nasty things to the scheduler.</p> <p>All of these things can be worked around, of course. For a while I considered compiling UPB to assembly, and rewriting that assembly into Go’s awful assembly syntax<sup id="fnref:go-asm" role="doc-noteref"><a href="#fn:go-asm" class="footnote" rel="footnote">2</a></sup>, and then having Go assemble UPB out of that. This presents a few issues though, particularly because Go’s assembly calling convention is still in the stone age<sup id="fnref:abi0" role="doc-noteref"><a href="#fn:abi0" class="footnote" rel="footnote">3</a></sup> (arguments are passed on the stack), and because we would still need to do a lot of work to get UPB to match the <code class="language-plaintext highlighter-rouge">protoreflect</code> API.</p> <p>Go also has a few… unique qualities that make writing a Protobuf interpreter an interesting challenge with <em>exciting</em> optimization opportunities.</p> <p>First, of course, is the register ABI, which on <code class="language-plaintext highlighter-rouge">x86_64</code> gives us a whopping <em>nine</em> argument and return registers, meaning that we can simply pass the entire parser state in registers all the time.</p> <p>Second is that Go does not have much UB to speak of, so we can get away with a lot of very evil pointer crimes that we could not in C++ or Rust.</p> <p>Third is that Protobuf Go has a robust reflection system that we can target if we design specifically for it.</p> <p>Also, the Go ecosystem seems much more tolerant of less-than-ideal startup times (because the language <em>loves</em> life-before-main due to <code class="language-plaintext highlighter-rouge">init()</code> functions), so unlike UPB, we can require that the interpreter’s program be generated at runtime, meaning that we can design for online PGO. In other words, we have the perfect storm to create the first-ever Protobuf JIT compiler (which we also refer to as “online PGO” or “real-time PGO”).</p> <h2 id="hyperpbs-api"><a href="#hyperpbs-api">hyperpb’s API</a></h2> <p>Right now, <code class="language-plaintext highlighter-rouge">hyperpb</code>’s API is very simple. There are <code class="language-plaintext highlighter-rouge">hyperpb.Compile*</code> functions that accept some representation of a message descriptor, and return a <code class="language-plaintext highlighter-rouge">*hyperpb.MessageType</code>, which implements the <code class="language-plaintext highlighter-rouge">protoreflect</code> type APIs. This can be used to allocate a new <code class="language-plaintext highlighter-rouge">*hyperpb.Message</code> , which you can shove into <code class="language-plaintext highlighter-rouge">proto.Unmarshal</code> and do reflection on the result. However, you can’t mutate <code class="language-plaintext highlighter-rouge">*hyperpb.Message</code>s currently, because the main use-cases I am optimizing for are read-only. All mutations panic instead.</p> <p>The hero use-case, using Buf’s <code class="language-plaintext highlighter-rouge">protovalidate</code> library, uses reflection to execute validation predicates. It looks like this:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// Compile a new message type, deserializing an encoded FileDescriptorSet.</span>
<span class="n">msgType</span> <span class="o">:=</span> <span class="n">hyperpb</span><span class="o">.</span><span class="n">CompileForBytes</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="s">"my.api.v1.Request"</span><span class="p">)</span>

<span class="c">// Allocate a new message of that type.</span>
<span class="n">msg</span> <span class="o">:=</span> <span class="n">hyperpb</span><span class="o">.</span><span class="n">NewMessage</span><span class="p">(</span><span class="n">msgType</span><span class="p">)</span>

<span class="c">// Unmarshal like you would any other message, using proto.Unmarshal.</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">proto</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="c">// Handle parse failure.</span>
<span class="p">}</span>

<span class="c">// Validate the message. Protovalidate uses reflection, so this Just Works.</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">protovalidate</span><span class="o">.</span><span class="n">Validate</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="c">// Handle validation failure.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Go</a></div></div> <p>We tell users to make sure to cache the compilation step because compilation can be arbitrarily slow: it’s an optimizing compiler! This is not unlike the same warning on <code class="language-plaintext highlighter-rouge">regexp.Compile</code>, which makes it easy to teach users how to use this API correctly.</p> <p>In addition to the main API, there’s a bunch of performance tuning knobs for the compiler, for unmarshaling, and for recording profiles. Types can be recompiled using a recorded profile to be more optimized for the kinds of messages that actually come on the wire. <code class="language-plaintext highlighter-rouge">hyperpb</code> PGO<sup id="fnref:go-pgo" role="doc-noteref"><a href="#fn:go-pgo" class="footnote" rel="footnote">4</a></sup> affects a number of things that we’ll get into as I dive into the implementation details.</p> <h2 id="the-guts"><a href="#the-guts">The Guts</a></h2> <p>Most of the core implementation lives under <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/tdp"><code class="language-plaintext highlighter-rouge">internal/tdp</code></a>. The main components are as follows:</p> <ol> <li><code class="language-plaintext highlighter-rouge">tdp</code>, which defines the “object code format” for the interpreter. This includes definitions for describing types and fields to the parser.</li> <li><code class="language-plaintext highlighter-rouge">tdp/compiler</code>, which contains all of the code for converting a <code class="language-plaintext highlighter-rouge">protoreflect.MessageDescriptor</code> into a <code class="language-plaintext highlighter-rouge">tdp.Library</code>, which contains all of the types relevant to a particular parsing operation.</li> <li><code class="language-plaintext highlighter-rouge">tdp/dynamic</code> defines what dynamic message types look like. The compiler does a bunch of layout work that gets stored in <code class="language-plaintext highlighter-rouge">tdp.Type</code> values, which a <code class="language-plaintext highlighter-rouge">dynamic.Message</code> interprets to find the offsets of fields within itself.</li> <li><code class="language-plaintext highlighter-rouge">tdp/vm</code> contains the core interpreter implementation, including the VM state that is passed in registers everywhere. It also includes hand-optimized routines for parsing varints and validating UTF-8.</li> <li><code class="language-plaintext highlighter-rouge">tdp/thunks</code> defines <em>archetypes</em>, which are classes of fields that all use the same layout and parsers. This corresponds roughly to a <code class="language-plaintext highlighter-rouge">(presence, kind)</code> pair, but not exactly. There are around 200 different archetypes.</li> </ol> <p>This article won’t be a deep-dive into everything in the parser, and even this excludes large portions of <code class="language-plaintext highlighter-rouge">hyperpb</code>. For example, the <a href="https://mcyoung.xyz/2025/04/21/go-arenas/"><code class="language-plaintext highlighter-rouge">internal/arena</code></a> package is already described in a different blogpost of mine. I recommend taking a look at that to learn about how we implement a GC-friendly arena for <code class="language-plaintext highlighter-rouge">hyperpb</code> .</p> <p>Instead, I will give a brief overview of how the object code is organized and how the parser interprets it. I will also go over a few of the more interesting optimizations we have.</p> <h3 id="tdptype"><a href="#tdptype">tdp.Type</a></h3> <p>Every <code class="language-plaintext highlighter-rouge">MessageDescriptor</code> that is reachable from the root message (either as a field or as an extension) becomes a <code class="language-plaintext highlighter-rouge">tdp.Type</code> . This contains the dynamic size of the corresponding message type, a pointer to the type’s default parser (there can be more than one parser for a type) and a variable number of <code class="language-plaintext highlighter-rouge">tdp.Field</code> values. These specify the offset of each field and provide accessor thunks, for actually extracting the value of the field.</p> <p>A <code class="language-plaintext highlighter-rouge">tdp.TypeParser</code> is what the parser VM interprets alongside encoded Protobuf data. It contains all of the information needed for decoding a message in compact form, including <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code>s for each of its fields (and extensions), as well as a hashtable for looking up a field by tag, which is used by the VM as a fallback.</p> <p>The <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code>s each contain:</p> <ol> <li>The same offset information as a <code class="language-plaintext highlighter-rouge">tdp.Field</code>.</li> <li>The field’s tag, in a special format.</li> <li>A function pointer that gets called to parse the field.</li> <li>The next field(s) to try parsing after this one is parsed.</li> </ol> <p>Each <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code> actually corresponds to a possible tag on a record for this message. Some fields have multiple different tags: for example, a <code class="language-plaintext highlighter-rouge">repeated int32</code> can have a <code class="language-plaintext highlighter-rouge">VARINT</code>-type tag for the repeated representation, and a <code class="language-plaintext highlighter-rouge">LEN</code>-type tag for the packed representation.</p> <p>Each field specifies which fields to try next. This allows the compiler to perform <em>field scheduling</em>, by carefully deciding which order to try fields in based both on their declaration order and a rough estimation of their “hotness”, much like branch scheduling happens in a program compiler. This avoids almost all of the work of looking up the next field in the common case, because we have already pre-loaded the correct guess.</p> <p>I haven’t managed to nail down a good algorithm for this yet, but I am working on a system for implementing a type of “branch prediction” for PGO, that tries to provide better predictions for the next fields to try based on what has been seen before.</p> <p>The offset information for a field is more than just a memory offset. A <code class="language-plaintext highlighter-rouge">tdp.Offset</code> includes a bit offset, for fields which request allocation of individual bits in the message’s bitfields. These are used to implement the hasbits of <code class="language-plaintext highlighter-rouge">optional</code> fields (and the values of <code class="language-plaintext highlighter-rouge">bool</code> fields). It also includes a byte offset for larger storage. However, this byte offset can be negative, in which case it’s actually an offset into the <em>cold region</em>.</p> <p>In many messages, most fields won’t be set, particularly extensions. But we would like to avoid having to allocate memory for the very rare (i.e., “cold”) fields. For this, a special “cold region” exists in a separate allocation from the main message, which is referenced via a compressed pointer. If a message happens to need a cold field set, it takes a slow path to allocate a cold region only if needed. Whether a field is cold is a dynamic property that can be affected by PGO.</p> <h3 id="the-parser-vm"><a href="#the-parser-vm">The Parser VM</a></h3> <p>The parser is designed to make maximal use of Go’s generous ABI without spilling anything to the stack that isn’t absolutely necessary. The parser state consists of eight 64-bit integers, split across two types: <code class="language-plaintext highlighter-rouge">vm.P1</code> and <code class="language-plaintext highlighter-rouge">vm.P2</code>. Unfortunately, these can’t be merged due to a <a href="https://github.com/golang/go/issues/72897">compiler bug</a>, as documented in <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/tdp/vm/vm.go#L50"><code class="language-plaintext highlighter-rouge">vm/vm.go</code></a>.</p> <p>Every parser function takes these two structs as its first two arguments, and returns them as its first two results. This ensures that register allocation tries its darnedest to keep those eight integers in the first eight argument registers, even across calls. This leads to the common idiom of</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">n</span> <span class="kt">int</span>
<span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Go</a></div></div> <p>Overwriting the parser state like this ensures that future uses of p1 and p2 use the values that <code class="language-plaintext highlighter-rouge">DoSomething</code> places in registers for us.</p> <p>I spent a lot of time and a lot of profiling catching all of the places where Go would incorrectly spill parser state to the stack, which would result in stalls. I found quite a few codegen bugs in the process. Particularly notable (and shocking!) is <a href="https://github.com/golang/go/issues/73589">#73589</a>. Go has somehow made it a decade without a very basic pointer-to-SSA lifting pass (for comparison, this is a heavy-lifting cleanup pass (<code class="language-plaintext highlighter-rouge">mem2reg</code>) in LLVM).</p> <p>The core loop of the VM goes something like this:</p> <ol> <li>Are we out of bytes to parse? If so, pop a parser stack frame<sup id="fnref:stack" role="doc-noteref"><a href="#fn:stack" class="footnote" rel="footnote">5</a></sup>. If we popped the last stack frame, parsing is done; return success.</li> <li>Parse a tag. This does not fully decode the tag, because <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code>s contain a carefully-formatted, partially-decoded tag to reduce decoding work.</li> <li>Check if the next field we would parse matches the tag. <ol> <li>If yes, call the function pointer <code class="language-plaintext highlighter-rouge">tdp.Field.Parser</code>; update the current field to <code class="language-plaintext highlighter-rouge">tdp.Field.NextOk</code>; goto 1.</li> <li>If no, update the current field to <code class="language-plaintext highlighter-rouge">tdp.Field.NextErr</code>; goto 3.</li> <li>If no “enough times”, fall through.</li> </ol> </li> <li>Slow path: hit <code class="language-plaintext highlighter-rouge">tdp.Field.Tags</code> to find the matching field for that tag. <ol> <li>If matched, go to 3a.</li> <li>If not, this is an unknown field; put it into the unknown field set; parse a tag and goto 4.</li> </ol> </li> </ol> <p>Naturally, this is implemented as a single function whose control flow consists exclusively of <code class="language-plaintext highlighter-rouge">if</code>s and <code class="language-plaintext highlighter-rouge">goto</code>s, because getting Go to generate good control flow otherwise proved too hard.</p> <p>Now, you might be wondering why the hot loop for the parser includes <strong>calling a virtual function</strong>. Conventional wisdom holds that virtual calls are slow. After all, the actual virtual call instruction is quite slow, because it’s an indirect branch, meaning that it can easily stall the CPU. However, it’s actually <em>much faster than the alternatives</em> in this case, due to a few quirks of our workload and how modern CPUs are designed:</p> <ol> <li>Modern CPUs are not <em>great</em> at traversing complex “branch mazes”. This means that selecting one of ~100 alternatives using branches, even if they are well-predicted and you use unrolled binary search, is still likely to result in frequent mispredictions, and is an obstacle to other JIT optimizations in the processor’s backend.</li> <li>Predicting a single indirect branch with dozens of popular targets <em>is</em> something modern CPUs are pretty good at. Chips and Cheese have a <a href="https://chipsandcheese.com/i/138977313/indirect-branch-prediction">great writeup</a> on the indirect prediction characteristics of Zen 4 chips.</li> </ol> <p>In fact, the “optimized” form of a large switch is a jump table, which is essentially an array of function pointers. Rather than doing a large number of comparisons and direct branches, a jump table turns a switch into a load and an indirect branch.</p> <p>This is great news for us, because it means we can make use of a powerful assumption about most messages: most messages only feature a handful of field archetypes. How often is it that you see a message which has more in it than <code class="language-plaintext highlighter-rouge">int32</code>, <code class="language-plaintext highlighter-rouge">int64</code>, <code class="language-plaintext highlighter-rouge">string</code> , and submessages? In effect, this allows us to have a very large “instruction set”, consisting of all of the different field archetypes, but a particular message only pays for what it uses. The fewer archetypes it uses <em>at runtime</em>, the better the CPU can predict this indirect jump.</p> <p>On the other hand, we can just keep adding archetypes over time to specialize for common parse workloads, which PGO can select for. Adding new archetypes that are not used by most messages does not incur a performance penalty.</p> <h2 id="other-optimizations"><a href="#other-optimizations">Other Optimizations</a></h2> <p>We’ve already discussed the hot/cold split, and briefly touched on the message bitfields used for <code class="language-plaintext highlighter-rouge">bool</code>s and hasbits. I’d like to mention a few other cool optimizations that help cover all our bases, as far as high-performance parsing does.</p> <h3 id="zerocopy-strings"><a href="#zerocopy-strings">Zerocopy Strings</a></h3> <p>The fastest <code class="language-plaintext highlighter-rouge">memcpy</code> implementation is the one you don’t call. For this reason, we try to, whenever possible, avoid copying anything out of the input buffer. <code class="language-plaintext highlighter-rouge">string</code>s and <code class="language-plaintext highlighter-rouge">bytes</code> are represented as <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/zc/zc.go"><code class="language-plaintext highlighter-rouge">zc.Range</code>s</a>, which are a packed pair of offset+length in a <code class="language-plaintext highlighter-rouge">uint64</code>. Protobuf is not able to handle lengths greater than 2GB properly, so we can assume that this covers all the data we could ever care about. This means that a <code class="language-plaintext highlighter-rouge">bytes</code> field is 8 bytes, rather than 24, in our representation.</p> <p>Zerocopy is also used for packed fields. For example, a <code class="language-plaintext highlighter-rouge">repeated double</code> will typically be encoded as a <code class="language-plaintext highlighter-rouge">LEN</code> record. The number of <code class="language-plaintext highlighter-rouge">float64</code>s in this record is equal to its length divided by 8, and the <code class="language-plaintext highlighter-rouge">float64</code>s are already encoded in IEEE754 format for us. So we can just retain the whole repeated fields as a <code class="language-plaintext highlighter-rouge">zc.Range</code> . Of course, we need to be able to handle cases where there are multiple disjoint records, so the backing <a href="https://github.com/bufbuild/hyperpb-go/blob/main/internal/tdp/repeated/scalars.go"><code class="language-plaintext highlighter-rouge">repeated.Scalars</code></a> can also function as a 24-byte arena slice. Being able to switch between these modes gracefully is a delicate and carefully-tested part of the repeated field thunks.</p> <p>Surprisingly, we also use zerocopy for varint fields, such as <code class="language-plaintext highlighter-rouge">repeated int32</code>. Varints are variable-length, so we can’t just index directly into the packed buffer to get the <code class="language-plaintext highlighter-rouge">n</code> th element… unless all of the elements happen to be the same size. In the case that every varint is one byte (so, between 0 and 127), we can zerocopy the packed field. This is a relatively common scenario, too, so it results in big savings<sup id="fnref:rep-benches" role="doc-noteref"><a href="#fn:rep-benches" class="footnote" rel="footnote">6</a></sup>. We <em>already</em> count the number of varints in the packed field in order to preallocate space for it, so this doesn’t add extra cost. This counting is very efficient because I have manually vectorized the loop.</p> <h3 id="repeated-preloads"><a href="#repeated-preloads">Repeated Preloads</a></h3> <p>PGO records the median size of each repeated/map field, and that is used to calculate a “preload” for each repeated field. Whenever the field is first allocated, it is pre-allocated using the preload to try to right-size the field with minimal waste.</p> <p>Using the median ensures that large outliers don’t result in huge memory waste; instead, this guarantees that at least 50% of repeated fields will only need to allocate from the arena once. Packed fields don’t use the preload, since in the common case only one record appears for packed fields. This mostly benefits string- and message-typed repeated fields, which can’t be packed.</p> <h3 id="map-optimizations"><a href="#map-optimizations">Map Optimizations</a></h3> <p>We don’t use Go’s built-in map, because it has significant overhead in some cases: in particular, it has to support Go’s mutation-during-iteration semantics, as well as deletion. Although both are Swisstables<sup id="fnref:map-benches" role="doc-noteref"><a href="#fn:map-benches" class="footnote" rel="footnote">7</a></sup> under the hood, my implementation can afford to take a few shortcuts. It also allows our implementation to use arena-managed memory. <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/swiss/table.go"><code class="language-plaintext highlighter-rouge">swiss.Table</code>s</a> are used both for the backing store of <code class="language-plaintext highlighter-rouge">map</code> fields, and for maps inside of <code class="language-plaintext highlighter-rouge">tdp.Type</code>s.</p> <p>Currently, the hash used is the variant of <a href="https://github.com/rust-lang/rustc-hash">fxhash used by the Rust compiler</a>. This greatly out-performs Go’s <a href="https://pkg.go.dev/hash/maphash">maphash</a> for integers, but maphash is better for larger strings. I hope to maybe switch to maphash at some point for large strings, but it hasn’t been a priority.</p> <h3 id="arena-reuse"><a href="#arena-reuse">Arena Reuse</a></h3> <p>Hitting the Go allocator is always going to be a little slow, because it’s a general-case allocator. Ideally, we should learn the estimated memory requirements for a particular workload, and then allocate a single block of that size for the arena to portion out.</p> <p>The best way to do this is via <em>arena reuse</em> In the context of a service, each request has a bounded lifetime on the message that it parses. Once that lifetime is over (the request is complete), the message is discarded. This gives the programmer an opportunity to <em>reset</em> the backing arena, so that it keeps its largest memory block for re-allocation.</p> <p>You can show that over time, this will cause the arena to never hit the Go allocator. If the largest block is too small for a message, a block twice as large will wind up getting allocated. Messages that use the same amount of memory will keep doubling the largest block, until the largest block is large enough to fit the whole message. Memory usage will be at worst 2x the size of this message. Note that, thanks to extensive use of zero-copy optimizations, we can often avoid allocating memory for large portions of the message.</p> <p>Of course, arena re-use poses a memory safety danger, if the previously allocated message is kept around after the arena is reset. For this reason, it’s not the default behavior. Using arena resets is a double-digit percentage improvement, however.</p> <h3 id="oneof-unions"><a href="#oneof-unions">Oneof Unions</a></h3> <p>Go does not properly support unions, because the GC does not keep the necessary book-keeping to distinguish a memory location that may be an integer <em>or</em> a pointer at runtime. Instead, this gets worked around using interfaces, which is always a pointer to some memory. Go’s GC can handle untyped pointers just fine, so this just works.</p> <p>The generated API for Protobuf Go uses interface values for <code class="language-plaintext highlighter-rouge">oneof</code>s. This API is… pretty messy to use, unfortunately, and triggers unnecessary allocations, (much like <code class="language-plaintext highlighter-rouge">optional</code> fields do in the open API).</p> <p>However, my arena design (<a href="https://mcyoung.xyz/2025/04/21/go-arenas/">read about it here</a>) makes it possible to store arena pointers on the arena as if they are integers, since the GC does not need to scan through arena memory. Thus, our <code class="language-plaintext highlighter-rouge">oneof</code>s are true unions, like in C++.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p><code class="language-plaintext highlighter-rouge">hyperpb</code> is really exciting because its growing JIT capabilities offer an improvement in the state of the art over UPB. It’s also been a really fun challenge working around Go compiler bugs to get the best assembly possible. The code is already so well-optimized that re-building the benchmarks with the Go compiler’s own PGO mode (based on a profile collected from the benchmarks) didn’t really seem to move the needle!</p> <p>I’m always working on making <code class="language-plaintext highlighter-rouge">hyperpb</code> better (I get paid for it!) and I’m always excited to try new optimizations. If you think of something, file an issue! I have meticulously commented most things within <code class="language-plaintext highlighter-rouge">hyperpb</code> , so it should be pretty easy to get an idea of where things are if you want to contribute.</p> <p>I would like to write more posts diving into some of the weeds of the implementation. I can’t promise anything, but there’s lots to talk about. For now… have fun source-diving!</p> <p>There’s a lot of other things we could be doing: for example, we could be using SIMD to parse varints, we could have smarter parser scheduling, we could be allocating small submessages inline to improve locality… there’s still so much we can do!</p> <p>And most importantly, I hope you’ve learned something new about performance optimization!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:vtproto" role="doc-endnote"> <p>vtprotobuf gets <em>a lot</em> of things wrong that make it beat us in like two benchmarks, because it’s <em>so</em> sloppy. For example, vtprotobuf believes that it’s ok to not validate UTF-8 strings. This is <em>non-conforming</em> behavior. It also believes that map entries’ fields are always in order and always populated, meaning that valid Protobuf messages containing maps can be parsed <em>incorrectly</em>. This sloppiness is unacceptable, which is why <code class="language-plaintext highlighter-rouge">hyperpb</code> goes to great lengths to implement all of Protobuf correctly. <a href="#fnref:vtproto" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:go-asm" role="doc-endnote"> <p>Never gonna let Rob live that one down. Of all of Rob’s careless design decisions, the assembler is definitely one of the least forgivable ones. <a href="#fnref:go-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:abi0" role="doc-endnote"> <p>There are only really two pieces of code in <code class="language-plaintext highlighter-rouge">hyperpb</code> that could benefit from hand-written assembly: varint decoding and UTF-8 validation. Both of these vectorize well, however, <code class="language-plaintext highlighter-rouge">ABI0</code> is so inefficient that no hand-written implementation will be faster.</p> <p>If I do wind up doing this, it will require a build tag like <code class="language-plaintext highlighter-rouge">hyperasm</code>, along with something like <code class="language-plaintext highlighter-rouge">-gcflags=buf.build/go/hyperpb/internal/asm/...=-+</code> to treat the assembly implementations as part of the Go runtime, allowing the use of <code class="language-plaintext highlighter-rouge">ABIInternal</code>. But even then, this only speeds up parsing of large (&gt;2 byte) varints. <a href="#fnref:abi0" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:go-pgo" role="doc-endnote"> <p>This is PGO performed by <code class="language-plaintext highlighter-rouge">hyperpb</code> itself; this is unrelated to <code class="language-plaintext highlighter-rouge">gc</code>’s own PGO mode, which seems to not actually make <code class="language-plaintext highlighter-rouge">hyperpb</code> faster. <a href="#fnref:go-pgo" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stack" role="doc-endnote"> <p>Yes, the parser manages its own stack separate from the goroutine stack. This ensures that nothing in the parser has to be reentrant. The only time the stack is pushed to is when we “recurse” into a submessage. <a href="#fnref:stack" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rep-benches" role="doc-endnote"> <p>Large packed repeated fields are where the biggest wins are for us. Being able to zero-copy large packed <code class="language-plaintext highlighter-rouge">int32</code> fields full of small values allows us to eliminate all of the overhead that the other runtimes are paying for; we also choose different parsing strategies depending on the byte-to-varint ratio of the record.</p> <figure style="max-width: 95%;"> <p><img src="https://mcyoung.xyz/public/images/hyperpb/repeated.svg" alt=""/></p> <figcaption> <p>Throughput for various repeated field benchmarks. This excludes the <code class="language-plaintext highlighter-rouge">repeated fixed32</code> benchmarks, since those achieve such high throughputs (~20 Gbps) that they make the chart unreadable.</p> </figcaption> </figure> <p>These optimizations account for the performance difference between <code class="language-plaintext highlighter-rouge">descriptor/#00</code> and <code class="language-plaintext highlighter-rouge">descriptor/#01</code> in the first benchmark chart. The latter is a <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> containing <code class="language-plaintext highlighter-rouge">SourceCodeInfo</code>, Protobuf’s janky debuginfo format. It is dominated by <code class="language-plaintext highlighter-rouge">repeated int32</code> fields.</p> <p>NB: This chart is currently missing the Y-axis, I need to have it re-made. <a href="#fnref:rep-benches" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:map-benches" role="doc-endnote"> <p>Map parsing performance has been a bit of a puzzle. <code class="language-plaintext highlighter-rouge">vtprotobuf</code> cheats by rejecting some valid map entry encodings, such as (in Protoscope) <code class="language-plaintext highlighter-rouge">{1: {"key"}}</code> (value is implied to be <code class="language-plaintext highlighter-rouge">""</code>), while mis-parsing others, such as <code class="language-plaintext highlighter-rouge">{2: {"value"} 1: {"key"}}</code> (fields can go in any order), since they don’t actually validate the field numbers like <code class="language-plaintext highlighter-rouge">hyperpb</code> does.</p> <p>Here’s where the benchmarks currently stand for maps:</p> <figure style="max-width: 95%;"> <p><img src="https://mcyoung.xyz/public/images/hyperpb/maps.svg" alt=""/></p> <figcaption> <p>Throughput for various map parsing benchmarks.</p> </figcaption> </figure> <p>Maps, I’m told, are not very popular in Protobuf, so they’re not something I have tried to optimize as hard as packed repeated fields. <a href="#fnref:map-benches" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-07-14 • 4003 words • 44 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <h1><a href="/2025/07/14/best/"> The Best C++ Library </a></h1> </div> <div class="post"> <p>It’s no secret that my taste in programming languages is very weird for a programming language <del>enthusiast</del> professional. Several of my <a href="https://mcyoung.xyz/2025/07/07/nosplit/">last</a> <a href="https://mcyoung.xyz/2025/04/21/go-arenas/">few</a> <a href="https://mcyoung.xyz/2024/12/16/rangefuncs/">posts</a> are about Go, broadly regarded as the programming language equivalent of eating plain oatmeal for breakfast.</p> <p>To make up for that, I’m going to write about the programming language equivalent of diluting your morning coffee with <a href="https://en.wikipedia.org/wiki/Everclear">Everclear</a>. I am, of course, talking about C++.</p> <p>If you’ve ever had the misfortune of doing C++ professionally, you’ll know that the C++ standard library is really bad. Where to begin?</p> <p>Well, the associative containers are terrible. Due to bone-headed API decisions, <a href="https://en.cppreference.com/w/cpp/container/unordered_map.html"><code class="language-plaintext highlighter-rouge">std::unordered_map</code></a> MUST be a closed-addressing, array-of-linked-lists map, not a Swisstable, despite closed-addressing being an outdated technology. <a href="https://www.cppreference.com/w/cpp/container/map.html"><code class="language-plaintext highlighter-rouge">std::map</code></a>, which is not what you usually want, <em>must</em> be a red-black tree. It can’t be a b-tree, like every sensible language provides for the ordered map.</p> <p><a href="https://en.cppreference.com/w/cpp/utility/optional.html"><code class="language-plaintext highlighter-rouge">std::optional</code></a> is a massive pain in the ass to use, and is full of footguns, like <code class="language-plaintext highlighter-rouge">operator*</code>. <code class="language-plaintext highlighter-rouge">std::variant</code> is also really annoying to use. <a href="https://en.cppreference.com/w/cpp/filesystem.html"><code class="language-plaintext highlighter-rouge">std::filesystem</code></a> is full of sharp edges. And where are the APIs for signals?</p> <p>Everything is extremely wordy. <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size.html"><code class="language-plaintext highlighter-rouge">std::hardware_destructive_interference_size</code></a> could have been called <code class="language-plaintext highlighter-rouge">std::cache_line</code>. <a href="https://en.cppreference.com/w/cpp/container/span/subspan"><code class="language-plaintext highlighter-rouge">std::span::subspan</code></a> could have used <code class="language-plaintext highlighter-rouge">opeartor[]</code>. The standard algorithms are super wordy, because they deal with iterator pairs. Oh my god, iterator pairs. They added <a href="https://en.cppreference.com/w/cpp/ranges.html"><code class="language-plaintext highlighter-rouge">std::ranges</code></a>, which do not measure up to Rust’s <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code class="language-plaintext highlighter-rouge">Iterator</code></a> at all!</p> <p>I’m so mad about all this! The people in charge of C++ clearly, actively hate their users!<sup id="fnref:terrible-people" role="doc-noteref"><a href="#fn:terrible-people" class="footnote" rel="footnote">1</a></sup> They want C++ to be as hard and unpleasant as possible to use. Many brilliant people that I am lucky to consider friends and colleagues, including Titus Winters, JeanHeyd Meneide, Matt Fowles-Kulukundis, and Andy Soffer, have tried and mostly failed<sup id="fnref:jh" role="doc-noteref"><a href="#fn:jh" class="footnote" rel="footnote">2</a></sup> to improve the language.</p> <p>This is much to say that I believe C++ in its current form is unfixable. But that’s only due to the small-mindedness of a small cabal based out of Redmond. What if we could do whatever we wanted? What if we used C++’s incredible library-building language features to build a brand-new language?</p> <p>For the last year-or-so I’ve been playing with a wild idea: what would C++ look like if we did it over again? Starting from an empty C++20 file with no access to the standard library, what can we build in its place?</p> <h2 id="starting-over"><a href="#starting-over">Starting Over</a></h2> <p>Titus started Abseil while at Google, whose namespace, <code class="language-plaintext highlighter-rouge">absl</code>, is sometimes said to stand for “a better standard library”<sup id="fnref:abcl" role="doc-noteref"><a href="#fn:abcl" class="footnote" rel="footnote">3</a></sup>. To me, Abseil is important because it was an attempt to work with the existing standard library and make it better, while retaining a high level of implementation quality that a C++ shop’s home-grown utility library won’t have, and a uniformity of vision that <a href="https://www.boost.org/">Boost</a> is too all-over-the-place to achieve.</p> <p>Rather than trying to coexist with the standard library, I want to surpass it. As a form of performance art, I want to discover what the standard library would look like if we designed it <em>today</em>, in 2025.</p> <p>In this sense, I want to build something that isn’t just <em>better</em>. It should be the C++ standard library from the best possible world. It is the best possible library. This is why my library’s namespace is <code class="language-plaintext highlighter-rouge">best</code>.</p> <p>In general, I am trying not to directly copy either what C++, or Abseil, or Rust, or Go did. However, each of them has really interesting ideas, and the best library probably lies in some middle-ground somewhere.</p> <p>The rest of this post will be about what I have achieved with <code class="language-plaintext highlighter-rouge">best</code> so far, and where I want to take it. You can look at the code <a href="https://github.com/mcy/best">here</a>.</p> <h3 id="building-a-foundation"><a href="#building-a-foundation">Building a Foundation</a></h3> <p>We’re throwing out everything, and that includes <code class="language-plaintext highlighter-rouge">&lt;type_traits&gt;</code>. This is a header which shows its age: alias templates were’t added until C++14, and variable templates were added in C++17. As a result, many things that really aught to be concepts have names like <code class="language-plaintext highlighter-rouge">best::is_same_v</code>. All of these now have concept equivalents in <code class="language-plaintext highlighter-rouge">&lt;concepts&gt;</code>.</p> <p>I have opted to try to classify type traits into separate headers to make them easier to find. They all live under <code class="language-plaintext highlighter-rouge">//best/meta/traits</code>, and they form the leaves of the dependency graph.</p> <p>For example, <code class="language-plaintext highlighter-rouge">arrays.h</code> contains all of the array traits, such as <code class="language-plaintext highlighter-rouge">best::is_array</code>, <code class="language-plaintext highlighter-rouge">best::un_array</code> (to remove an array extent), and <code class="language-plaintext highlighter-rouge">best::as_array</code>, which applies an extent to a type T, such that <code class="language-plaintext highlighter-rouge">best::as_array&lt;T, 0&gt;</code> is not an error.</p> <p><code class="language-plaintext highlighter-rouge">types.h</code> contains very low-level metaprogramming helpers, such as:</p> <ul> <li><code class="language-plaintext highlighter-rouge">best::id</code> and <code class="language-plaintext highlighter-rouge">best::val</code>, the identity traits for type- and value-kinded traits.</li> <li><code class="language-plaintext highlighter-rouge">best::same&lt;...&gt;</code>, which returns whether an entire <em>pack</em> of types is all equal.</li> <li><code class="language-plaintext highlighter-rouge">best::lie</code>, our version of <code class="language-plaintext highlighter-rouge">std::declval</code>.</li> <li><code class="language-plaintext highlighter-rouge">best::select</code>, our <code class="language-plaintext highlighter-rouge">std::conditional_t</code>.</li> <li><code class="language-plaintext highlighter-rouge">best::abridge</code>, a “symbol compression” mechanism for shortening the names of otherwise huge symbols.</li> </ul> <p><code class="language-plaintext highlighter-rouge">funcs.h</code> provides <code class="language-plaintext highlighter-rouge">best::tame</code>, which removes the qualifiers from an <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html">abominable function type</a>. <code class="language-plaintext highlighter-rouge">quals.h</code> provides <code class="language-plaintext highlighter-rouge">best::qualifies_to</code>, necessary for determining if a type is “more const” than another. <code class="language-plaintext highlighter-rouge">empty.h</code> provides a standard empty type that interoperates cleanly with <code class="language-plaintext highlighter-rouge">void</code>.</p> <p>On top of the type traits is the metaprogramming library <code class="language-plaintext highlighter-rouge">//best/meta</code>, which includes generalized constructibility traits in <code class="language-plaintext highlighter-rouge">init.h</code> (e.g., to check that you can, in fact, initialize a <code class="language-plaintext highlighter-rouge">T&amp;</code> from a <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>, for example). <code class="language-plaintext highlighter-rouge">tlist.h</code> provides a very general type-level heterogenous list abstraction; a parameter pack as-a-type.</p> <p>The other part of “the foundation” is <code class="language-plaintext highlighter-rouge">//best/base</code>, which mostly provides access to intrinsics, portability helpers, macros, and “tag types” such as our versions of <code class="language-plaintext highlighter-rouge">std::in_place</code>. For example, <code class="language-plaintext highlighter-rouge">macro.h</code> provides <code class="language-plaintext highlighter-rouge">BEST_STRINGIFY()</code>, <code class="language-plaintext highlighter-rouge">port.h</code> provides <code class="language-plaintext highlighter-rouge">BEST_HAS_INCLUDE()</code>, and <code class="language-plaintext highlighter-rouge">hint.h</code> provides <code class="language-plaintext highlighter-rouge">best::unreachable()</code>.</p> <p><code class="language-plaintext highlighter-rouge">guard.h</code> provides our version of the Rust <code class="language-plaintext highlighter-rouge">?</code> operator, which is not an expression because statement expressions are broken in Clang.</p> <p>Finally, within <code class="language-plaintext highlighter-rouge">//best/container</code> we find <code class="language-plaintext highlighter-rouge">best::object</code>, a special type for turning any C++ type into an object (i.e., a type that you can form a reference to). This is useful for manipulating any type generically, without tripping over the assign-through semantics of references. For example, <code class="language-plaintext highlighter-rouge">best::object&lt;T&amp;&gt;</code> is essentially a pointer.</p> <h3 id="adt-containers"><a href="#adt-containers">“ADT” Containers</a></h3> <p>On top of this foundation we build the basic algebraic data types of <code class="language-plaintext highlighter-rouge">best</code>: <code class="language-plaintext highlighter-rouge">best::row</code> and <code class="language-plaintext highlighter-rouge">best::choice</code>, which replace <code class="language-plaintext highlighter-rouge">std::tuple</code> and <code class="language-plaintext highlighter-rouge">std::variant</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::row&lt;A, B, C&gt;</code> is a heterogenous collection of values, stored inside of <code class="language-plaintext highlighter-rouge">best::object</code>s. This means that <code class="language-plaintext highlighter-rouge">best::row&lt;int&amp;&gt;</code> has natural rebinding, rather than assign-through, semantics.</p> <p>Accessing elements is done with <code class="language-plaintext highlighter-rouge">at()</code>: <code class="language-plaintext highlighter-rouge">my_row.at&lt;0&gt;()</code> returns a reference to the first element. Getting the first element is so common that you can also use <code class="language-plaintext highlighter-rouge">my_row.first()</code>. Using <code class="language-plaintext highlighter-rouge">my_row.object&lt;0&gt;()</code> will return a reference to a <code class="language-plaintext highlighter-rouge">best::object</code> instead, which can be used for rebinding references. For example:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">best</span><span class="o">::</span><span class="n">row</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="n">a</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>     <span class="c1">// Writes to x.</span>
<span class="n">a</span><span class="p">.</span><span class="n">object</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// Rebinds a.0 to y.</span>
<span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>    <span class="c1">// Writes to y.</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">C++</a></div></div> <p>There is also <code class="language-plaintext highlighter-rouge">second()</code> and <code class="language-plaintext highlighter-rouge">last()</code>, for the other two most common elements to access.</p> <p><code class="language-plaintext highlighter-rouge">best::row</code> is named so in reference to database rows: it provides many operations for slicing and dicing that <code class="language-plaintext highlighter-rouge">std::tuple</code> does not.</p> <p>For example, in addition to extracting single elements, it’s also possible to access contiguous subsequences, using <code class="language-plaintext highlighter-rouge">best::bounds</code>: <code class="language-plaintext highlighter-rouge">a.at&lt;best::bounds{.start = 1, .end = 10}&gt;()</code>! There are also a plethora of mutation operations:</p> <ul> <li><code class="language-plaintext highlighter-rouge">a + b</code> concatenates tuples, copying or moving as appropriate (<code class="language-plaintext highlighter-rouge">a + BEST_MOVE(b)</code> will move out of the elements of <code class="language-plaintext highlighter-rouge">b</code>, for example).</li> <li><code class="language-plaintext highlighter-rouge">a.push(x)</code> returns a copy of <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">x</code> appended, while <code class="language-plaintext highlighter-rouge">a.insert&lt;n&gt;(x)</code> does the same at an arbitrary index.</li> <li><code class="language-plaintext highlighter-rouge">a.update&lt;n&gt;(x)</code> <em>replaces</em> the <code class="language-plaintext highlighter-rouge">n</code>th element with <code class="language-plaintext highlighter-rouge">x</code>, potentially of a different type.</li> <li><code class="language-plaintext highlighter-rouge">a.remove&lt;n&gt;()</code> deletes the <code class="language-plaintext highlighter-rouge">n</code>th element, while <code class="language-plaintext highlighter-rouge">a.erase&lt;...&gt;()</code> deletes a contiguous range.</li> <li><code class="language-plaintext highlighter-rouge">a.splice&lt;best::bounds{...}&gt;(...)</code> splices a row into another row, offering a general replace/delete operation that all of the above operations are implemented in terms of.</li> <li><code class="language-plaintext highlighter-rouge">gather()</code> and <code class="language-plaintext highlighter-rouge">scatter()</code> are even more general, allowing for non-contiguous indexing.</li> </ul> <p>Meanwhile, <code class="language-plaintext highlighter-rouge">std::apply</code> is a method now: <code class="language-plaintext highlighter-rouge">a.apply(f)</code> calls <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">a</code>’s elements as its arguments. <code class="language-plaintext highlighter-rouge">a.each(f)</code> is similar, but instead expands to <code class="language-plaintext highlighter-rouge">n</code> unary calls of <code class="language-plaintext highlighter-rouge">f</code>, one with each element.</p> <p>And <em>of course</em>, <code class="language-plaintext highlighter-rouge">best::row</code> supports structured bindings.</p> <p>Meanwhile, <code class="language-plaintext highlighter-rouge">best::choice&lt;A, B, C&gt;</code> contains precisely one value from various types. There is an underlying <code class="language-plaintext highlighter-rouge">best::pun&lt;A, B, C&gt;</code> type that implements a variadic untagged union that works around many of C++’s bugs relating to unions with members of non-trivial type.</p> <p>The most common way to operate on a choice is to <code class="language-plaintext highlighter-rouge">match</code> on it:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">choice</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="o">*</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">match</span><span class="p">(</span>
  <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">C++</a></div></div> <p>Which case gets called here is chosen by overload resolution, allowing us to write a default case as <code class="language-plaintext highlighter-rouge">[](auto&amp;&amp;) { ... }</code>.</p> <p>Which variant is currently selected can be checked with <code class="language-plaintext highlighter-rouge">z.which()</code>, while specific variants can be accessed with <code class="language-plaintext highlighter-rouge">z.at()</code>, just like a <code class="language-plaintext highlighter-rouge">best::row</code>, except that it returns a <code class="language-plaintext highlighter-rouge">best::option&lt;T&amp;&gt;</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::choice</code> is what all of the other sum types, like <code class="language-plaintext highlighter-rouge">best::option</code> and <code class="language-plaintext highlighter-rouge">best::result</code>, are built out of. All of the clever layout optimizations live here.</p> <p>Speaking of <code class="language-plaintext highlighter-rouge">best::option&lt;T&gt;</code>, that’s our option type. It’s close in spirit to what <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code></a> is in Rust. <code class="language-plaintext highlighter-rouge">best</code> has a generic niche mechanism that user types can opt into, allowing <code class="language-plaintext highlighter-rouge">best::option&lt;T&amp;&gt;</code> to be the same size as a pointer, using <code class="language-plaintext highlighter-rouge">nullptr</code> for the <code class="language-plaintext highlighter-rouge">best::none</code> variant.</p> <p><code class="language-plaintext highlighter-rouge">best::option</code> provides the usual transformation operations: <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">filter</code>. Emptiness can be checked with <code class="language-plaintext highlighter-rouge">is_empty()</code> or <code class="language-plaintext highlighter-rouge">has_value()</code>. You can even pass a predicate to <code class="language-plaintext highlighter-rouge">has_value()</code> to check the value with, if it’s present: <code class="language-plaintext highlighter-rouge">x.has_value([](auto&amp; x) { return x == 42; })</code>.</p> <p>The value can be accessed using <code class="language-plaintext highlighter-rouge">operator*</code> and <code class="language-plaintext highlighter-rouge">operator-&gt;</code>, like <code class="language-plaintext highlighter-rouge">std::optional</code>; however, this operation is checked, instead of causing UB if the option is empty. <code class="language-plaintext highlighter-rouge">value_or()</code> can be used to unwrap with a default; the default can be any number of arguments, which are used to construct the default, or even a callback. For example:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">option</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>

<span class="c1">// Pass arguments to the constructor.</span>
<span class="n">do_something</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value_or</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">));</span>

<span class="c1">// Execute arbitrary logic if the value is missing.</span>
<span class="n">do_something</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value_or</span><span class="p">([]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Foo</span><span class="p">(...);</span>
<span class="p">}))</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">best::option&lt;void&gt;</code> also Just Works (in fact, <code class="language-plaintext highlighter-rouge">best::option&lt;T&gt;</code> is a <code class="language-plaintext highlighter-rouge">best::choice&lt;void, T&gt;</code> internally), allowing for truly generic manipulation of optional results.</p> <p><code class="language-plaintext highlighter-rouge">best::result&lt;T, E&gt;</code> is, unsurprisingly, the analogue of Rust’s <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code></a>. Because it’s a <code class="language-plaintext highlighter-rouge">best::choice</code> internally, <code class="language-plaintext highlighter-rouge">best::result&lt;void, E&gt;</code> works as you might expect, and is a common return value for I/O operations.</p> <p>It’s very similar to <code class="language-plaintext highlighter-rouge">best::option</code>, including offering <code class="language-plaintext highlighter-rouge">operator-&gt;</code> for accessing the “ok” variant. This enables succinct idioms:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fallible</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">r</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">best</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">err</span><span class="p">());</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">r.ok()</code> and <code class="language-plaintext highlighter-rouge">r.err()</code> return <code class="language-plaintext highlighter-rouge">best::option</code>s containing references to the ok and error variants, depending on which is actually present; meanwhile, a <code class="language-plaintext highlighter-rouge">best::option</code> can be converted into a <code class="language-plaintext highlighter-rouge">best::result</code> using <code class="language-plaintext highlighter-rouge">ok_or()</code> or <code class="language-plaintext highlighter-rouge">err_or()</code>, just like in Rust.</p> <p><code class="language-plaintext highlighter-rouge">best::result</code>s are constructed using <code class="language-plaintext highlighter-rouge">best::ok</code> and <code class="language-plaintext highlighter-rouge">best::err</code>. For example:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">C++</a></div></div> <p>These internally use <code class="language-plaintext highlighter-rouge">best::args</code>, a wrapper over <code class="language-plaintext highlighter-rouge">best::row</code> that represents a “delayed initialization” that can be stored in a value. It will implicitly convert into any type that can be constructed from its elements. For example:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span>  <span class="c1">// Calls Foo::Foo(args, to, foo).</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">C++</a></div></div> <p>Also, every one of the above types is a structural type, meaning it can be used for non-type template parameters!</p> <h3 id="memory-and-pointers"><a href="#memory-and-pointers">Memory and Pointers</a></h3> <p>Of course, all of these ADTs need to be built on top of pointer operations, which is where <code class="language-plaintext highlighter-rouge">//best/memory</code> comes in. <code class="language-plaintext highlighter-rouge">best::ptr&lt;T&gt;</code> is a generalized pointer type that provides many of the same operations as Rust’s raw pointers, including offsetting, copying, and indexing. Like Rust pointers, <code class="language-plaintext highlighter-rouge">best::ptr&lt;T&gt;</code> can be a fat pointer, i.e., it can carry additional metadata on top of the pointer. For example, <code class="language-plaintext highlighter-rouge">best::ptr&lt;int[]&gt;</code> remembers the size of the array.</p> <p>Providing metadata for a <code class="language-plaintext highlighter-rouge">best::ptr</code> is done through a member alias called <code class="language-plaintext highlighter-rouge">BestPtrMetadata</code>. This alias should be private, which <code class="language-plaintext highlighter-rouge">best</code> is given access to by befriending <code class="language-plaintext highlighter-rouge">best::access</code>. Types with custom metadata will usually not be directly constructible (because they are of variable size), and must be manipulated exclusively through types like <code class="language-plaintext highlighter-rouge">best::ptr</code>.</p> <p>Specifying custom metadata allows specifying what the pointer dereferences to. For example, <code class="language-plaintext highlighter-rouge">best::ptr&lt;int[]&gt;</code> dereferences to a <code class="language-plaintext highlighter-rouge">best::span&lt;int&gt;</code>, meaning that all the span operations are accessible through <code class="language-plaintext highlighter-rouge">operator-&gt;</code>: for example, <code class="language-plaintext highlighter-rouge">my_array_ptr-&gt;first()</code>.</p> <p>Most of this may seem a bit over-complicated, since ordinary C++ raw pointers and references are fine for most uses. However, <code class="language-plaintext highlighter-rouge">best::ptr</code> is the foundation upon which <code class="language-plaintext highlighter-rouge">best::box&lt;T&gt;</code> is built on. <code class="language-plaintext highlighter-rouge">best::box&lt;T&gt;</code> is a replacement for <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr.html"><code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code></a> that fixes its const correctness and adds Rust <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code class="language-plaintext highlighter-rouge">Box</code></a>-like helpers. <code class="language-plaintext highlighter-rouge">best::box&lt;T[]&gt;</code> also works, but unlike <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T[]&gt;</code>, it remembers its size, just like <code class="language-plaintext highlighter-rouge">best::ptr&lt;T[]&gt;</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::box</code> is parameterized by its allocator, which must satisfy <code class="language-plaintext highlighter-rouge">best::allocator</code>, a much less insane API than what <a href="https://en.cppreference.com/w/cpp/memory/allocator.html"><code class="language-plaintext highlighter-rouge">std::allocator</code></a> offers. <code class="language-plaintext highlighter-rouge">best::malloc</code> is a singleton allocator representing the system allocator.</p> <p><code class="language-plaintext highlighter-rouge">best::span&lt;T&gt;</code>, mentioned before, is the contiguous memory abstraction, replacing <a href="https://en.cppreference.com/w/cpp/container/span.html"><code class="language-plaintext highlighter-rouge">std::span</code></a>. Like <code class="language-plaintext highlighter-rouge">std::span</code>, <code class="language-plaintext highlighter-rouge">best::span&lt;T, n&gt;</code> is a fixed-length span of <code class="language-plaintext highlighter-rouge">n</code> elements. Unlike <code class="language-plaintext highlighter-rouge">std::span</code>, the second parameter is a <code class="language-plaintext highlighter-rouge">best::option&lt;size_t&gt;</code>, not a <code class="language-plaintext highlighter-rouge">size_t</code> that uses <code class="language-plaintext highlighter-rouge">-1</code> as a sentinel.</p> <p><code class="language-plaintext highlighter-rouge">best::span&lt;T&gt;</code> tries to approximate the API of <a href="https://doc.rust-lang.org/std/primitive.slice.html">Rust slices</a>, providing indexing, slicing, splicing, search, sort, and more. Naturally, it’s also iterable, both forwards and backwards, and provides splitting iterators, just like Rust.</p> <p>Slicing and indexing is always bounds-checked. Indexing can be done with <code class="language-plaintext highlighter-rouge">size_t</code> values, while slicing uses a <code class="language-plaintext highlighter-rouge">best::bounds</code>:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[{.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="mi">6</span><span class="p">}];</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">best::bounds</code> is a generic mechanism for specifying slicing bounds, similar to Rust’s <a href="https://doc.rust-lang.org/std/ops/struct.Range.html">range types</a>. You can specify the start and end (exclusive), like <code class="language-plaintext highlighter-rouge">x..y</code> in Rust. You can also specify an inclusive end using <code class="language-plaintext highlighter-rouge">.inclusive_end = 5</code>, equivalent to Rust’s <code class="language-plaintext highlighter-rouge">x..=y</code>. And you can specify a count, like C++’s slicing operations prefer: <code class="language-plaintext highlighter-rouge">{.start = 1, .count = 5}</code>. <code class="language-plaintext highlighter-rouge">best::bounds</code> itself provides all of the necessary helpers for performing bounds checks and crashing with a nice error message. <code class="language-plaintext highlighter-rouge">best::bounds</code> is also iterable, as we’ll see shortly.</p> <p><code class="language-plaintext highlighter-rouge">best::layout</code> is a copy of Rust’s <a href="https://doc.rust-lang.org/std/alloc/struct.Layout.html"><code class="language-plaintext highlighter-rouge">Layout</code></a> type, providing similar helpers for performing C++-specific size and address calculations.</p> <h3 id="iterators"><a href="#iterators">Iterators</a></h3> <p>C++ iterator pairs suck. C++ ranges suck. <code class="language-plaintext highlighter-rouge">best</code> provides a new paradigm for iteration that is essentially just Rust <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code class="language-plaintext highlighter-rouge">Iterator</code>s</a> hammered into a C++ shape. This library lives in <code class="language-plaintext highlighter-rouge">//best/iter</code>.</p> <p>To define an iterator, you define an <em>iterator implementation type</em>, which must define a member function named <code class="language-plaintext highlighter-rouge">next()</code> that returns a <code class="language-plaintext highlighter-rouge">best::option</code>:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">my_iter_impl</span> <span class="k">final</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">best</span><span class="o">::</span><span class="n">option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">C++</a></div></div> <p>This type is an implementation detail; the actual iterator type is <code class="language-plaintext highlighter-rouge">best::iter&lt;my_iter_impl&gt;</code>. <code class="language-plaintext highlighter-rouge">best::iter</code> provides all kinds of helpers, just like <code class="language-plaintext highlighter-rouge">Iterator</code>, for adapting the iterator or consuming items out of it.</p> <p>Iterators can override the behavior of some of these adaptors to be more efficient, such as for making <code class="language-plaintext highlighter-rouge">count()</code> constant-time rather than linear. Iterators can also offer extra methods if they define the member alias <code class="language-plaintext highlighter-rouge">BestIterArrow</code>; for example, the iterators for <code class="language-plaintext highlighter-rouge">best::span</code> have a <code class="language-plaintext highlighter-rouge">-&gt;rest()</code> method for returning the part of the slice that has not been yielded by <code class="language-plaintext highlighter-rouge">next()</code> yet.</p> <p>One of the most important extension points is <code class="language-plaintext highlighter-rouge">size_hint()</code>, analogous to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint"><code class="language-plaintext highlighter-rouge">Iterator::size_hint()</code></a>, for right-sizing containers that the iterator is converted to, such as a <code class="language-plaintext highlighter-rouge">best::vec</code>.</p> <p>And of course, <code class="language-plaintext highlighter-rouge">best::iter</code> provides <code class="language-plaintext highlighter-rouge">begin/end</code> so that it can be used in a C++ range-for loop, just like C++20 ranges do. <code class="language-plaintext highlighter-rouge">best::int_range&lt;I&gt;</code><sup id="fnref:interval" role="doc-noteref"><a href="#fn:interval" class="footnote" rel="footnote">4</a></sup>, which <code class="language-plaintext highlighter-rouge">best::bounds</code> is an instantiation of, is also an iterator, and can be used much like Rust ranges would:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">best</span><span class="o">::</span><span class="n">int_range</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">200</span><span class="p">})</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">best::int_range</code> will carefully handle all of the awkward corner cases around overflow, such as <code class="language-plaintext highlighter-rouge">best::int_range&lt;uint8_t&gt;{.end_inclusive = 255}</code>.</p> <h3 id="heap-containers"><a href="#heap-containers">Heap Containers</a></h3> <p>Iterators brings us to the most complex container type that’s checked in right now, <code class="language-plaintext highlighter-rouge">best::vec</code>. Not only can you customize its allocator type, but you can customize its small vector optimization type.</p> <p>In <code class="language-plaintext highlighter-rouge">libc++</code>, <code class="language-plaintext highlighter-rouge">std::string</code>s of at most 23 bytes are stored <em>inline</em>, meaning that the strings’s own storage, rather than heap storage, is used to hold them. <code class="language-plaintext highlighter-rouge">best::vec</code> generalizes this, by allowing any trivially copyable type to be inlined. Thus, a <code class="language-plaintext highlighter-rouge">best::vec&lt;int&gt;</code> will hold at most five <code class="language-plaintext highlighter-rouge">int</code>s inline, on 64-bit targets.</p> <p><code class="language-plaintext highlighter-rouge">best::vec</code> mostly copies the APIs of <code class="language-plaintext highlighter-rouge">std::vector</code> and Rust’s <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code class="language-plaintext highlighter-rouge">Vec</code></a>. Indexing and slicing works the same as with <code class="language-plaintext highlighter-rouge">best::span</code>, and all of the <code class="language-plaintext highlighter-rouge">best::span</code> operations can be accessed through <code class="language-plaintext highlighter-rouge">-&gt;</code>, allowing for things like <code class="language-plaintext highlighter-rouge">my_vec-&gt;sort(...)</code>.</p> <p>I have an active (failing) PR which adds <code class="language-plaintext highlighter-rouge">best::table&lt;K, V&gt;</code>, a general hash table implementation that can be used as either a map or a set. Internally it’s backed by a Swisstable<sup id="fnref:swisstable" role="doc-noteref"><a href="#fn:swisstable" class="footnote" rel="footnote">5</a></sup> implementation. Its API resembles neither <code class="language-plaintext highlighter-rouge">std::unordered_map</code>, <code class="language-plaintext highlighter-rouge">absl::flat_hash_map</code>, or Rust’s <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code class="language-plaintext highlighter-rouge">HashMap</code></a>. Instead, everything is done through a general entry API, similar to that of Rust, but optimized for clarity and minimizing hash lookups. I want to get it merged soonish.</p> <p>Beyond <code class="language-plaintext highlighter-rouge">best::table</code>, I plan to add <em>at least</em> the following containers:</p> <ul> <li><code class="language-plaintext highlighter-rouge">best::tree</code>, a btree map/set with a similar API.</li> <li><code class="language-plaintext highlighter-rouge">best::heap</code>, a simple min-heap implementation.</li> <li><code class="language-plaintext highlighter-rouge">best::lru</code>, a <code class="language-plaintext highlighter-rouge">best::table</code> with a linked list running through it for in-order iteration and oldest-member eviction.</li> <li><code class="language-plaintext highlighter-rouge">best::ring</code>, a ring buffer like <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code class="language-plaintext highlighter-rouge">VecDeque</code></a>.</li> <li><code class="language-plaintext highlighter-rouge">best::trie</code>, a port of my <a href="https://docs.rs/twie/latest/twie/"><code class="language-plaintext highlighter-rouge">twie</code> crate</a>.</li> </ul> <p>Possible other ideas: <a href="https://research.swtch.com/sparse">Russ’s sparse array</a>, splay trees, something like Java’s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html"><code class="language-plaintext highlighter-rouge">EnumMap</code></a>, bitset types, and so on.</p> <h3 id="text-handling"><a href="#text-handling">Text Handling</a></h3> <p><code class="language-plaintext highlighter-rouge">best</code>’s string handling is intended to resemble Rust’s as much as possible; it lives within <code class="language-plaintext highlighter-rouge">//best/text</code>. <code class="language-plaintext highlighter-rouge">best::rune</code> is the Unicode scalar type, which is such that it is <em>always</em> within the valid range for a Unicode scalar, but including the unpaired surrogates. It offers a number of relatively simple character operations, but I plan to extend it to all kinds of character classes in the future.</p> <p><code class="language-plaintext highlighter-rouge">best::str</code> is our replacement for <a href="https://en.cppreference.com/w/cpp/string/basic_string_view.html"><code class="language-plaintext highlighter-rouge">best::string_view</code></a>, close to Rust’s <a href="https://doc.rust-lang.org/std/primitive.str.html"><code class="language-plaintext highlighter-rouge">str</code></a>: a sequence of valid UTF-8 bytes, with all kinds of string manipulation operations, such as rune search, splitting, indexing, and so on.</p> <p><code class="language-plaintext highlighter-rouge">best::rune</code> and <code class="language-plaintext highlighter-rouge">best::str</code> use compiler extensions to ensure that when constructed from literals, they’re constructed from <em>valid</em> literals. This means that the following won’t compile!</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">str</span> <span class="n">invalid</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xFF</span><span class="s">"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">best::str</code> is a <code class="language-plaintext highlighter-rouge">best::span</code> under the hood, which can be accessed and manipulated the same way as the underlying <code class="language-plaintext highlighter-rouge">&amp;[u8]</code> to <code class="language-plaintext highlighter-rouge">&amp;str</code> is.</p> <p><code class="language-plaintext highlighter-rouge">best::strbuf</code> is our <a href="https://en.cppreference.com/w/cpp/string/basic_string.html"><code class="language-plaintext highlighter-rouge">std::string</code></a> equivalent. There isn’t very much to say about it, because it works just like you’d expect, and provides a Rust <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code class="language-plaintext highlighter-rouge">String</code></a>-like API.</p> <p>Where this library really shines is that everything is parametrized over encodings. <code class="language-plaintext highlighter-rouge">best::str</code> is actually a <code class="language-plaintext highlighter-rouge">best::text&lt;best::utf8&gt;</code>; <code class="language-plaintext highlighter-rouge">best::str16</code> is then <code class="language-plaintext highlighter-rouge">best::text&lt;best::utf16&gt;</code>. You can write your own text encodings, too, so long as they are relatively tame and you provide rune encode/decode for them. <code class="language-plaintext highlighter-rouge">best::encoding</code> is the concept</p> <p><code class="language-plaintext highlighter-rouge">best::text</code> is always validly encoded; however, sometimes, that’s not possible. For this reason we have <code class="language-plaintext highlighter-rouge">best::pretext</code>, which is “presumed validly encoded”; its operations can fail or produce replacement characters if invalid code units are found. There is no <code class="language-plaintext highlighter-rouge">best::pretextbuf</code>; instead, you would generally use something like a <code class="language-plaintext highlighter-rouge">best::vec&lt;uint8_t&gt;</code> instead.</p> <p>Unlike C++, the fact that a <code class="language-plaintext highlighter-rouge">best::textbuf</code> is a <code class="language-plaintext highlighter-rouge">best::vec</code> under the hood is part of the public interface, allowing for cheap conversions and, of course, we get <code class="language-plaintext highlighter-rouge">best::vec</code>’s small vector optimization for free.</p> <p><code class="language-plaintext highlighter-rouge">best</code> provides the following encodings out of the box: <code class="language-plaintext highlighter-rouge">best::utf8</code>, <code class="language-plaintext highlighter-rouge">best::utf16</code>, <code class="language-plaintext highlighter-rouge">best::utf32</code>, <code class="language-plaintext highlighter-rouge">best::wtf8</code>, <code class="language-plaintext highlighter-rouge">best::ascii</code>, and <code class="language-plaintext highlighter-rouge">best::latin1</code>.</p> <h3 id="formatting"><a href="#formatting">Formatting</a></h3> <p><code class="language-plaintext highlighter-rouge">//best/text:format</code> provides a Rust <code class="language-plaintext highlighter-rouge">format!()</code>-style text formatting library. It’s as easy as:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"my number: 0x{:08x}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">C++</a></div></div> <p>Through the power of compiler extensions and <code class="language-plaintext highlighter-rouge">constexpr</code>, the format is actually checked at compile time!</p> <p>The available formats are the same as Rust’s, including the <code class="language-plaintext highlighter-rouge">{}</code> vs <code class="language-plaintext highlighter-rouge">{:?}</code> distinction. But it’s actually way more flexible. You can use any ASCII letter, and types can provide multiple custom formatting schemes using letters. By convention, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">X</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">o</code> all mean numeric bases. <code class="language-plaintext highlighter-rouge">q</code> will quote strings, runes, and other text objects; <code class="language-plaintext highlighter-rouge">p</code> will print pointer addresses.</p> <p>The special format <code class="language-plaintext highlighter-rouge">{:!}</code> “forwards from above”; when used in a formatting implementation, it uses the format specifier the caller used. This is useful for causing formats to be “passed through”, such as when printing lists or <code class="language-plaintext highlighter-rouge">best::option</code>.</p> <p>Any type can be made formattable by providing a friend template ADL extension (FTADLE) called <code class="language-plaintext highlighter-rouge">BestFmt</code>. This is analogous to implementing a trait like <code class="language-plaintext highlighter-rouge">fmt::Debug</code> in Rust, however, all formatting operations use the same function; this is similar to <a href="https://pkg.go.dev/fmt#Formatter"><code class="language-plaintext highlighter-rouge">fmt.Formatter</code></a> in Go.</p> <p>The <code class="language-plaintext highlighter-rouge">best::formatter</code> type, which gets passed into <code class="language-plaintext highlighter-rouge">BestFmt</code>, is similar to Rust’s <a href="https://doc.rust-lang.org/std/fmt/struct.Formatter.html"><code class="language-plaintext highlighter-rouge">Formatter</code></a>. Beyond being a sink, it also exposes information on the specifier for the formatting operation via <code class="language-plaintext highlighter-rouge">current_spec()</code>, and helpers for printing indented lists and blocks.</p> <p><code class="language-plaintext highlighter-rouge">BestFmtQuery</code> is a related FTADLE that is called to determine what the valid format specifiers for this type are. This allows the format validator to reject formats that a type does not support, such as formatting a <code class="language-plaintext highlighter-rouge">best::str</code> with <code class="language-plaintext highlighter-rouge">{:x}</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::format</code> returns (or appends to) a <code class="language-plaintext highlighter-rouge">best::strbuf</code>; <code class="language-plaintext highlighter-rouge">best::println</code> and <code class="language-plaintext highlighter-rouge">best::eprintln</code> can be used to write to stdout and stderr.</p> <h3 id="reflection"><a href="#reflection">Reflection</a></h3> <p>Within the metaprogramming library, <code class="language-plaintext highlighter-rouge">//best/meta:reflect</code> offers a basic form of reflection. It’s not C++26 reflection, because that’s wholely overkill. Instead, it provides a method for introspecting the members of structs and enums.</p> <p>For example, suppose that we want to have a default way of formatting arbitrary <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization.html">aggregate</a> structs. The code for doing this is actually devilishly simple:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">BestFmt</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">best</span><span class="o">::</span><span class="n">is_reflected_struct</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Reflect the type of the struct.</span>
  <span class="k">auto</span> <span class="n">refl</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">reflect</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// Start formatting a "record" (key-value pairs).</span>
  <span class="k">auto</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">.</span><span class="n">record</span><span class="p">(</span><span class="n">refl</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

  <span class="c1">// For each field in the struct...</span>
  <span class="n">refl</span><span class="p">.</span><span class="n">each</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">field</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Add a field to the formatting record...</span>
    <span class="n">rec</span><span class="p">.</span><span class="n">field</span><span class="p">(</span>
      <span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span>   <span class="c1">// ...whose name is the field...</span>
      <span class="n">value</span><span class="o">-&gt;*</span><span class="n">field</span><span class="p">,</span>  <span class="c1">// ...and with the appropriate value.</span>
    <span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">best::reflect</code> provides access to the fields (or enum variants) of a user-defined type that opts itself in by providing the <code class="language-plaintext highlighter-rouge">BestReflect</code> FTADLE, which tells the reflection framework what the fields are. The simplest version of this FTADLE looks like this:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">friend</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">BestReflect</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">mirror</span><span class="p">,</span> <span class="n">MyStruct</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">mirror</span><span class="p">.</span><span class="n">infer</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">best::mirror</code> is essentially a “reflection builder” that offers fine-grained control over what reflection actually shows of a struct. This allows for hiding fields, or attaching <em>tags</em> to specific fields, which generic functions can then introspect using <code class="language-plaintext highlighter-rouge">best::reflected_field::tags()</code>.</p> <p>The functions on <code class="language-plaintext highlighter-rouge">best::reflected_type</code> allow iterating over and searching for specific fields (or enum variants); these <code class="language-plaintext highlighter-rouge">best::reflected_field</code>s provide metadata about a field (such as its name) and allow accessing it, with the same syntax as a pointer-to-member: <code class="language-plaintext highlighter-rouge">value-&gt;*field</code>.</p> <p>Explaining the full breadth (and implementation tricks) of <code class="language-plaintext highlighter-rouge">best::reflect</code> would be a post of its own, so I’ll leave it at that.</p> <h3 id="unit-tests-and-apps"><a href="#unit-tests-and-apps">Unit Tests and Apps</a></h3> <p><code class="language-plaintext highlighter-rouge">best</code> provides a unit testing framework under <code class="language-plaintext highlighter-rouge">//best/test</code>, like any good standard library should. To define a test, you define a special kind of global variable:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">test</span> <span class="n">MyTest</span> <span class="o">=</span> <span class="p">[](</span><span class="n">best</span><span class="o">::</span><span class="n">test</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Test code.</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">C++</a></div></div> <p>This is very similar to a Go unit test, which defines a function that starts with <code class="language-plaintext highlighter-rouge">Test</code> and takes a <code class="language-plaintext highlighter-rouge">*testing.T</code> as its argument. The <code class="language-plaintext highlighter-rouge">best::test&amp;</code> value offers test assertions and test failures. Through the power of looking at debuginfo, we can extract the name <code class="language-plaintext highlighter-rouge">MyTest</code> from the binary, and use that as the name of the test directly.</p> <p>That’s right, this is a C++ test framework with <em>no macros at all</em>!</p> <p>Meanwhile, at <code class="language-plaintext highlighter-rouge">//best/cli</code> we can find a robust CLI parsing library, in the spirit of <a href="https://docs.rs/clap/latest/clap/_derive/index.html"><code class="language-plaintext highlighter-rouge">#[derive(clap::Parser)]</code></a> and other similar Rust libraries. The way it works is you first define a reflectable struct, whose fields correspond to CLI flags. A very basic example of this can be found in <code class="language-plaintext highlighter-rouge">test.h</code>, since test binaries define their own flags:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">test</span><span class="o">::</span><span class="n">flags</span> <span class="k">final</span> <span class="p">{</span>
  <span class="n">best</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">best</span><span class="o">::</span><span class="n">strbuf</span><span class="o">&gt;</span> <span class="n">skip</span><span class="p">;</span>
  <span class="n">best</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">best</span><span class="o">::</span><span class="n">strbuf</span><span class="o">&gt;</span> <span class="n">filters</span><span class="p">;</span>

  <span class="k">constexpr</span> <span class="k">friend</span> <span class="k">auto</span> <span class="n">BestReflect</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">flags</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">infer</span><span class="p">()</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">app</span><span class="p">{.</span><span class="n">about</span> <span class="o">=</span> <span class="s">"a best unit test binary"</span><span class="p">})</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="o">::</span><span class="n">skip</span><span class="p">,</span>
            <span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">flag</span><span class="p">{</span>
              <span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="s">"FILTER"</span><span class="p">,</span>
              <span class="p">.</span><span class="n">help</span> <span class="o">=</span> <span class="s">"Skip tests whose names contain FILTER"</span><span class="p">,</span>
            <span class="p">})</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="o">::</span><span class="n">filters</span><span class="p">,</span>
            <span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">positional</span><span class="p">{</span>
              <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FILTERS"</span><span class="p">,</span>
              <span class="p">.</span><span class="n">help</span> <span class="o">=</span> <span class="s">"Include only tests whose names contain FILTER"</span><span class="p">,</span>
            <span class="p">});</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">C++</a></div></div> <p>Using <code class="language-plaintext highlighter-rouge">best::mirror::with</code>, we can apply tags to the individual fields that describe how they should be parsed and displayed as CLI flags. A more complicated, full-featured example can be found at <a href="https://github.com/mcy/best/blob/main/best/cli/toy_flags.h"><code class="language-plaintext highlighter-rouge">toy_flags.h</code></a>, which exercises most of the CLI parser’s features.</p> <p><code class="language-plaintext highlighter-rouge">best::parse_flags&lt;MyFlags&gt;(...)</code> can be used to parse a particular flag struct from program inputs, independent of the actual <code class="language-plaintext highlighter-rouge">argv</code> of the program. A <code class="language-plaintext highlighter-rouge">best::cli</code> contains the actual parser metadata, but this is not generally user-accessible; it is constructed automatically using reflection.</p> <p>Streamlining top-level app execution can be done using <code class="language-plaintext highlighter-rouge">best::app</code>, which fully replaces the <code class="language-plaintext highlighter-rouge">main()</code> function. Defining an app is very similar to defining a test:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">app</span> <span class="n">MyApp</span> <span class="o">=</span> <span class="p">[](</span><span class="n">MyFlags</span><span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do something cool!</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">C++</a></div></div> <p>This will automatically record the program inputs, run the flag parser for <code class="language-plaintext highlighter-rouge">MyFlags</code> (printing <code class="language-plaintext highlighter-rouge">--help</code> and existing, when requested), and then call the body of the lambda.</p> <p>The lambda can either return <code class="language-plaintext highlighter-rouge">void</code>, an <code class="language-plaintext highlighter-rouge">int</code> (as an exit code) or even a <code class="language-plaintext highlighter-rouge">best::result</code>, like Rust. <code class="language-plaintext highlighter-rouge">best::app</code> is also where the <code class="language-plaintext highlighter-rouge">argv</code> of the program can be requested by other parts of the program.</p> <h2 id="whats-next"><a href="#whats-next">What’s Next?</a></h2> <p>There’s still a lot of stuff I want to add to <code class="language-plaintext highlighter-rouge">best</code>. There’s no synchronization primitives, neither atomics nor locks or channels. There’s no I/O; I have a work-in-progress PR to add <code class="language-plaintext highlighter-rouge">best::path</code> and <code class="language-plaintext highlighter-rouge">best::file</code>. I’d like to write my own math library, <code class="language-plaintext highlighter-rouge">best::rc</code> (reference-counting), and portable SIMD. There’s also some other OS APIs I want to build, such as signals and subprocesses. I want to add a robust PRNG, time APIs, networking, and stack symbolization.</p> <p>Building the best C++ library is a lot of work, not the least because C++ is a very tricky language and writing exhaustive tests is tedious. But it manages to make C++ fun for me again!</p> <p>I would love to see contributions some day. I don’t expect anyone to actually use this, but to me, it proves C++ could be so much better.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:terrible-people" role="doc-endnote"> <p>They are also <a href="https://patricia.no/2022/03/08/cppcon.html">terrible people</a>. <a href="#fnref:terrible-people" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:jh" role="doc-endnote"> <p>I will grant that JeanHeyd has made significant process where many people believed was impossible. He appears to have the indomitable willpower of a shōnen protagonist. <a href="#fnref:jh" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:abcl" role="doc-endnote"> <p>I have heard an apocryphal story that the namespace was going to be <code class="language-plaintext highlighter-rouge">abc</code> or <code class="language-plaintext highlighter-rouge">abcl</code>, because it was “Alphabet’s library”. This name was ultimately shot down by the office of the CEO, or so the legend goes. <a href="#fnref:abcl" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:interval" role="doc-endnote"> <p>This may get renamed to <code class="language-plaintext highlighter-rouge">best::interval</code> or even <code class="language-plaintext highlighter-rouge">best::range</code> We’ll see! <a href="#fnref:interval" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:swisstable" role="doc-endnote"> <p>The fourth time I’ve written one in my career, lmao. I also wrote a <a href="https://github.com/google/cwisstable">C implementation</a> at one point. My friend Matt has an <a href="https://www.youtube.com/watch?v=ncHmEUmJZf4">excellent introduction</a> to the Swisstable data structure. <a href="#fnref:swisstable" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-07-07 • 1881 words • 20 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2025/07/07/nosplit/"> What's //go:nosplit for? </a></h1> </div> <div class="post"> <p>Most people don’t know that Go has special syntax for directives. Unfortunately, it’s not real syntax, it’s just a comment. For example, <code class="language-plaintext highlighter-rouge">//go:noinline</code> causes the next function declaration to never get inlined, which is useful for changing the inlining cost of functions that call it.</p> <p>There are three types of directives:</p> <ol> <li> <p>The ones documented in <a href="https://pkg.go.dev/cmd/compile#hdr-Function_Directives"><code class="language-plaintext highlighter-rouge">gc</code>’s doc comment</a>. This includes <code class="language-plaintext highlighter-rouge">//go:noinline</code> and <code class="language-plaintext highlighter-rouge">//line</code>.</p> </li> <li> <p>The ones documented elsewhere, such as <code class="language-plaintext highlighter-rouge">//go:build</code> and <code class="language-plaintext highlighter-rouge">//go:generate</code>.</p> </li> <li> <p>The ones documented in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.24.4:src/runtime/HACKING.md">runtime/HACKING.md</a>, which can only be used if the <code class="language-plaintext highlighter-rouge">-+</code> flag is passed to <code class="language-plaintext highlighter-rouge">gc</code>. This includes <code class="language-plaintext highlighter-rouge">//go:nowritebarrier</code>.</p> </li> <li> <p>The ones not documented at all, whose existence can be discovered by searching the compiler’s tests. These include <code class="language-plaintext highlighter-rouge">//go:nocheckptr</code>, <code class="language-plaintext highlighter-rouge">//go:nointerface</code>, and <code class="language-plaintext highlighter-rouge">//go:debug</code>.</p> </li> </ol> <p>We are most interested in a directive of the first type, <code class="language-plaintext highlighter-rouge">//go:nosplit</code>. According to the documentation:</p> <blockquote id="ref:1" class="ref"> <p><a href="#ref:1"><span class="chip">reference</span></a></p> <p>The <code class="language-plaintext highlighter-rouge">//go:nosplit</code> directive must be followed by a function declaration. It specifies that the function must omit its usual stack overflow check. This is most commonly used by low-level runtime code invoked at times when it is unsafe for the calling goroutine to be preempted.</p> </blockquote> <p>What does this even mean? Normal program code can use this annotation, but its behavior is poorly specified. Let’s dig in.</p> <h2 id="go-stack-growth"><a href="#go-stack-growth">Go Stack Growth</a></h2> <p>Go allocates very small stacks for new goroutines, which grow their stack dynamically. This allows a program to spawn a large number of short-lived goroutines without spending a lot of memory on their stacks.</p> <p>This means that it’s very easy to overflow the stack. Every function knows how large its stack is, and <code class="language-plaintext highlighter-rouge">runtime.g</code>, the goroutine struct, contains the end position of the stack; if the stack pointer is less than it (the stack grows up) control passes to <code class="language-plaintext highlighter-rouge">runtime.morestack</code>, which effectively preempts the goroutine while its stack is resized.</p> <p>In effect, every Go function has the following code around it:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span>    <span class="p">.</span><span class="err">f</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="m">24-16</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JLS</span>     <span class="err">grow</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">//</span> <span class="err">Function</span> <span class="err">body</span><span class="p">...</span>
  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span>
<span class="nl">grow:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">MOVQ</span>    <span class="m">16</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">JMP</span>     <span class="p">.</span><span class="err">f</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">x86 Assembly (Go Syntax)</a></div></div> <p>Note that <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the current <code class="language-plaintext highlighter-rouge">runtime.g</code>, and the stack limit is the third word-sized field (<code class="language-plaintext highlighter-rouge">runtime.g.stackguard0</code>) in that struct, hence the offset of 16. If the stack is about to be exhausted, it jumps to a special block at the end of the function that spills all of the argument registers, traps into the runtime, and, once that’s done, unspills the arguments and re-starts the function.</p> <p>Note that arguments are spilled <em>before</em> adjusting <code class="language-plaintext highlighter-rouge">rsp</code>, which means that the arguments are written to the <em>caller’s</em> stack frame. This is part of Go’s ABI; callers must allocate space at the top of their stack frames for any function that they call to spill all of its registers for preemption<sup id="fnref:unused-spill" role="doc-noteref"><a href="#fn:unused-spill" class="footnote" rel="footnote">1</a></sup>.</p> <p>Preemption is not reentrant, which means that functions that are running in the context of a preempted G or with no G at all must not be preempted by this check.</p> <h2 id="nosplit-functions"><a href="#nosplit-functions">Nosplit Functions</a></h2> <p>The <code class="language-plaintext highlighter-rouge">//go:nosplit</code> directive marks a function as “nosplit”, or a “non-splitting function”. “Splitting” has nothing to do with what this directive does.</p> <blockquote id="aside:segmented-stacks" class="aside"> <p><a href="#aside:segmented-stacks"><span class="chip">aside</span><span class="title">Segmented Stacks</span></a></p> <p>In the bad old days, Go’s stacks were <em>split</em> up into <em>segments</em>, where each segment ended with a pointer to the next, effectively replacing the stack’s single array with a linked list of such arrays.</p> <p>Segmented stacks were terrible. Instead of triggering a resize, these prologues were responsible for updating <code class="language-plaintext highlighter-rouge">rsp</code> to the next (or previous) block by following this pointer, whenever the current segment bottomed out. This meant that if a function call happened to be on a segment boundary, it would be <em>extremely slow</em> in comparison to other function calls, due to the significant work required to update <code class="language-plaintext highlighter-rouge">rsp</code> correctly.</p> <p>This meant that unlucky sizing of stack frames meant sudden performance cliffs. Fun!</p> <p>Go has since figured out that segmented stacks are a terrible idea. In the process of implementing a correct GC stack scanning algorithm (which it did not have for many stable releases), it also gained the ability to copy the contents of a stack from one location to another, updating pointers in such a way that user code wouldn’t notice.</p> <p>This stack splitting code is where the name “nosplit” comes from.</p> </blockquote> <p>A nosplit function does not load and branch on <code class="language-plaintext highlighter-rouge">runtime.g.stackguard0</code>, and simply assumes it has enough stack. This means that nosplit functions will not preempt themselves, and, as a result, are noticeably faster to call in a hot loop. Don’t believe me?</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">//go:noinline</span>
<span class="k">func</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">nosplit</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">yessplit</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkCall</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"nosplit"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span> <span class="n">nosplit</span><span class="p">(</span><span class="m">42</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">})</span>
  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"yessplit"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span> <span class="n">yessplit</span><span class="p">(</span><span class="m">42</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Go</a></div></div> <p>If we profile this and pull up the timings for each function, here’s what we get:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="m">390</span><span class="err">ms</span>      <span class="m">390</span><span class="err">ms</span>           <span class="err">func</span> <span class="err">nosplit</span><span class="p">(x</span> <span class="err">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">noinline</span><span class="p">(x)</span> <span class="p">}</span>
 <span class="m">60</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd80:</span>     <span class="err">PUSHQ</span> <span class="err">BP</span>
 <span class="m">10</span><span class="err">ms</span>       <span class="m">10</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd81:</span>     <span class="err">MOVQ</span> <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fd84:</span>     <span class="err">SUBQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
 <span class="m">60</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd88:</span>     <span class="err">CALL</span> <span class="p">.</span><span class="k">noinline</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
<span class="m">190</span><span class="err">ms</span>      <span class="m">190</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd8d:</span>     <span class="err">ADDQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fd91:</span>     <span class="err">POPQ</span> <span class="err">BP</span>
 <span class="m">70</span><span class="err">ms</span>       <span class="m">70</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd92:</span>     <span class="err">RET</span>

<span class="m">440</span><span class="err">ms</span>      <span class="m">490</span><span class="err">ms</span>           <span class="err">func</span> <span class="err">yessplit</span><span class="p">(x</span> <span class="err">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">noinline</span><span class="p">(x)</span> <span class="p">}</span>
 <span class="m">50</span><span class="err">ms</span>       <span class="m">50</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda0:</span>     <span class="err">CMPQ</span> <span class="err">SP</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
 <span class="m">20</span><span class="err">ms</span>       <span class="m">20</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda4:</span>     <span class="err">JBE</span> <span class="m">0x51fdb9</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fda6:</span>     <span class="err">PUSHQ</span> <span class="err">BP</span>
 <span class="m">20</span><span class="err">ms</span>       <span class="m">20</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda7:</span>     <span class="err">MOVQ</span> <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdaa:</span>     <span class="err">SUBQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
 <span class="m">10</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdae:</span>     <span class="err">CALL</span> <span class="p">.</span><span class="k">noinline</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
<span class="m">200</span><span class="err">ms</span>      <span class="m">200</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdb3:</span>     <span class="err">ADDQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdb7:</span>     <span class="err">POPQ</span> <span class="err">BP</span>
<span class="m">140</span><span class="err">ms</span>      <span class="m">140</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdb8:</span>     <span class="err">RET</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdb9:</span>     <span class="err">MOVQ</span> <span class="err">AX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdbe:</span>     <span class="err">NOPW</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdc0:</span>     <span class="err">CALL</span> <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">.</span><span class="err">abi0</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdc5:</span>     <span class="err">MOVQ</span> <span class="m">0x8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdca:</span>     <span class="err">JMP</span> <span class="p">.</span><span class="err">yessplit</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">x86 Assembly (Go Syntax)</a></div></div> <p>The time spent at each instruction (for the whole benchmark, where I made sure equal time was spent on each test case with <code class="language-plaintext highlighter-rouge">-benchtime Nx</code>) is comparable for all of the instructions these functions share, but an additional ~2% cost is incurred for the stack check.</p> <p>This is a very artificial setup, because the <code class="language-plaintext highlighter-rouge">g</code> struct is always in L1 in the <code class="language-plaintext highlighter-rouge">yessplit</code> benchmark due to the fact that no other memory operations occur in the loop. However, for very hot code that needs to saturate the cache, this can have an outsized effect due to cache misses. We can enhance this benchmark by adding an assembly function that executes <code class="language-plaintext highlighter-rouge">clflush [r14]</code>, which causes the <code class="language-plaintext highlighter-rouge">g</code> struct to be ejected from all caches.</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">.</span><span class="err">clflush</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CLFLUSH</span> <span class="p">(</span><span class="err">R14</span><span class="p">)</span>  <span class="err">//</span> <span class="err">Eject</span> <span class="err">the</span> <span class="err">pointee</span> <span class="err">of</span> <span class="err">r14</span> <span class="k">from</span> <span class="err">all</span> <span class="err">caches</span><span class="p">.</span>
  <span class="err">RET</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">x86 Assembly (Go Syntax)</a></div></div> <p>If we add a call to this function to both benchmark loops, we see the staggering cost of a cold fetch from RAM show up in every function call: 120.1 nanosecods for <code class="language-plaintext highlighter-rouge">BenchmarkCall/nosplit</code>, versus 332.1 nanoseconds for <code class="language-plaintext highlighter-rouge">BenchmarkCall/yessplit</code>. The 200 nanosecond difference is a fetch from main memory. An L1 miss is about 15 times less expensive, so if the <code class="language-plaintext highlighter-rouge">g</code> struct manages to get kicked out of L1, you’re paying about 15 or so nanoseconds, or about two map lookups!</p> <p>Despite the language resisting adding an inlining heuristic, which programmers would place everywhere without knowing what it does, they <em>did</em> provide something worse that makes code noticeably faster: nosplit.</p> <h2 id="but-its-harmless"><a href="#but-its-harmless">But It’s Harmless…?</a></h2> <p>Consider the following program<sup id="fnref:consider" role="doc-noteref"><a href="#fn:consider" class="footnote" rel="footnote">2</a></sup>:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Go</a></div></div> <p>Naturally, this will instantly overflow the stack. Instead, we get a really scary linker error:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">x.x: nosplit stack over 792 byte limit
</span><span class="gp">x.x&lt;1&gt;</span><span class="w">
</span><span class="gp">    grows 24 bytes, calls x.x&lt;1&gt;</span><span class="w">
</span><span class="go">    infinite cycle</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Console</a></div></div> <p>The Go linker contains a check to verify that any chain of nosplit functions which call nosplit functions do not overflow a small window of extra stack, which is where the stack frames of nosplit functions live if they go past <code class="language-plaintext highlighter-rouge">stackguard0</code>.</p> <p>Every stack frame contributes some stack use (for the return address, at minimum), so the number of functions you can call before you get this error is limited. And because every function needs to allocate space for all of its callees to spill their arguments if necessary, you can hit this limit every fast if every one of these functions uses every available argument register (ask me how I know).</p> <p>Also, turning on fuzzing instruments the code by inserting nosplit calls into the fuzzer runtime around branches, meaning that turning on fuzzing can <em>previously fine code to no longer link</em>. Stack usage also varies slightly by architecture, meaning that code which builds in one architecture fails to link in others (most visible when going from 32-bit to 64-bit).</p> <p>There is no easy way to control directives using build tags (two poorly-designed features collide), so you cannot just “turn off” performance-sensitive nosplits for debugging, either.</p> <p>For this reason, you must be <em>very very careful</em> about using nosplit for performance.</p> <h3 id="virtual-nosplit-functions"><a href="#virtual-nosplit-functions">Virtual Nosplit Functions</a></h3> <p>Excitingly, nosplit functions whose addresses are taken do not have special codegen, allowing us to defeat the linker stack check by using virtual function calls.</p> <p>Consider the following program:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">var</span> <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">x</span>
  <span class="n">f</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Go</a></div></div> <p>This will quickly exhaust the main G’s tiny stack and segfault in the most violent way imaginable, preventing the runtime from printing a debug trace. All this program outputs is <code class="language-plaintext highlighter-rouge">signal: segmentation fault</code>.</p> <p>This is <a href="https://github.com/golang/go/issues/74478">probably a bug</a>.</p> <h2 id="other-side-effects"><a href="#other-side-effects">Other Side Effects</a></h2> <p>It turns out that nosplit has various other fun side-effects that are not documented anywhere. The main thing it does is it contributes to whether a function is considered “unsafe” by the runtime.</p> <p>Consider the following program:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"os"</span>
  <span class="s">"runtime"</span>
  <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="k">range</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">{}</span>
    <span class="p">}()</span>
  <span class="p">}</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Wait for all the other Gs to start.</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Go</a></div></div> <p>This program will make sure that every P becomes bound to a G that loops forever, meaning they will never trap into the runtime. Thus, this program will hang forever, never printing its result and exiting. But that’s not what happens.</p> <p>Thanks to asynchronous preemption, the scheduler will detect Gs that have been running for too long, and preempt its M by sending a signal to it (<a href="https://cs.opensource.google/go/go/+/master:src/runtime/signal_unix.go;l=43">due to happenstance</a>, this is <code class="language-plaintext highlighter-rouge">SIGURG</code> of all things.)</p> <p>However, asynchronous preemption is only possible when the M stops due to the signal at a safe point, as determined by <code class="language-plaintext highlighter-rouge">runtime.isAsyncSafePoint</code>. It includes the following block of code:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-go" data-lang="go">	<span class="n">up</span><span class="p">,</span> <span class="n">startpc</span> <span class="o">:=</span> <span class="n">pcdatavalue2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">abi</span><span class="o">.</span><span class="n">PCDATA_UnsafePoint</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">up</span> <span class="o">==</span> <span class="n">abi</span><span class="o">.</span><span class="n">UnsafePointUnsafe</span> <span class="p">{</span>
		<span class="c">// Unsafe-point marked by compiler. This includes</span>
		<span class="c">// atomic sequences (e.g., write barrier) and nosplit</span>
		<span class="c">// functions (except at calls).</span>
		<span class="k">return</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span>
	<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Go</a></div></div> <p>If we chase down where this value is set, we’ll find that it is set explicitly for write barrier sequences, for any function that is “part of the runtime” (as defined by being built with the <code class="language-plaintext highlighter-rouge">-+</code> flag) and <em>for any nosplit function</em>.</p> <p>With a small modification of hoisting the <code class="language-plaintext highlighter-rouge">go</code> body into a nosplit function, the following program will run forever: it will never wake up from <code class="language-plaintext highlighter-rouge">time.Sleep</code>.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"os"</span>
  <span class="s">"runtime"</span>
  <span class="s">"time"</span>
<span class="p">)</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">forever</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="k">range</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="n">forever</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Wait for all the other Gs to start.</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Go</a></div></div> <p>Even though there is work to do, every P is bound to a G that will never reach a safe point, so there will never be a P available to run the main goroutine.</p> <p>This represents another potential danger of using nosplit functions: those that do not call preemptable functions must terminate promptly, or risk livelocking the whole runtime.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>I use nosplit <em>a lot</em>, because I write high-performance, low-latency Go. This is a very insane thing to do, which has caused me to slowly generate bug reports whenever I hit strange corner cases.</p> <p>For example, there are many cases where spill regions are allocated for functions that never use them, for example, functions which only call nosplit functions allocate space for them to spill their arguments, which they don’t do.<sup id="fnref:spill-area" role="doc-noteref"><a href="#fn:spill-area" class="footnote" rel="footnote">3</a></sup></p> <p>This is a documented Go language feature which:</p> <ol> <li>Isn’t very well-documented (the async preemption behavior certainly isn’t)!</li> <li>Has very scary optimization-dependent build failures.</li> <li>Can cause livelock and mysterious segfaults.</li> <li>Can be used in user programs that don’t <code class="language-plaintext highlighter-rouge">import "unsafe"</code>!</li> <li>And it makes code faster!</li> </ol> <p>I’m surprised such a massive footgun exists at all, buuuut it’s a measureable benchmark improvement for me, so it’s impossible to tell if it’s bad or not.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:unused-spill" role="doc-endnote"> <p>The astute reader will observe that because preemption is not reentrant, only one of these spill regions will be in use at at time in a G. This is a known bug in the ABI, and is essentially a bodge to enable easy adoption of passing arguments by register, without needing all of the parts of the runtime that expect arguments to be spilled to the stack, as was the case in the slow old days when Go’s ABI on every platform was “<code class="language-plaintext highlighter-rouge">i386-unknown-linux</code> but worse”, i.e., arguments went on the stack and made the CPU’s store queue sad.</p> <p>I recently filed <a href="https://github.com/golang/go/issues/74413">a bug about this</a> that boils down to “add a field to <code class="language-plaintext highlighter-rouge">runtime.g</code> to use a spill space”, which seems to me to be simpler than the alternatives described in the <code class="language-plaintext highlighter-rouge">ABIInternal</code> spec. <a href="#fnref:unused-spill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:consider" role="doc-endnote"> <p>Basically every bug report I write starts with these four words and it means you’re about to see the worst program ever written. <a href="#fnref:consider" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:spill-area" role="doc-endnote"> <p>The spill area is also used for spilling arguments across calls, but in this case, it is not necessary for the caller to allocate it for a nosplit function. <a href="#fnref:spill-area" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-06-03 • 875 words • 9 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/06/03/protobuf-tip-7/"> Protobuf Tip #7: Scoping It Out </a></h1> </div> <div class="post"> <p><em>You’d need a very specialized electron microscope to get down to the level to actually see a single strand of DNA. – Craig Venter</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">buf convert</code> is a powerful tool for examining wire format dumps, by converting them to JSON and using existing JSON analysis tooling. <code class="language-plaintext highlighter-rouge">protoscope</code> can be used for lower-level analysis, such debugging messages that have been corrupted.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-7-scoping-it-out">buf.build blog</a>.</p> </blockquote> <h2 id="json-from-protobuf"><a href="#json-from-protobuf">JSON from Protobuf?</a></h2> <p>JSON’s human-readable syntax is a big reason why it’s so popular, possibly second only to built-in support in browsers and many languages. It’s easy to examine any JSON document using tools like online prettifiers and the inimitable <code class="language-plaintext highlighter-rouge">jq</code>.</p> <p>But Protobuf is a binary format! This means that you can’t easily use <code class="language-plaintext highlighter-rouge">jq</code> -like tools with it…or can you?</p> <h2 id="transcoding-with-buf-convert"><a href="#transcoding-with-buf-convert">Transcoding with <code class="language-plaintext highlighter-rouge">buf convert</code></a></h2> <p>The Buf CLI offers a utility for transcoding messages between the three Protobuf encoding formats: the wire format, JSON, and textproto; it also supports YAML. This is <code class="language-plaintext highlighter-rouge">buf convert</code>, and it’s very powerful.</p> <p>To perform a conversion, we need four inputs:</p> <ol> <li>A Protobuf source to get types out of. This can be a local <code class="language-plaintext highlighter-rouge">.proto</code> file, an encoded <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> , or a remote BSR module. <ul> <li>If not provided, but run in a directory that is within a local Buf module, that module will be used as the Protobuf type source.</li> </ul> </li> <li>The name of the top-level type for the message we want to transcode, via the <code class="language-plaintext highlighter-rouge">--type</code> flag.</li> <li>The input message, via the <code class="language-plaintext highlighter-rouge">--from</code> flag.</li> <li>A location to output to, via the <code class="language-plaintext highlighter-rouge">--to</code> flag.</li> </ol> <p><code class="language-plaintext highlighter-rouge">buf convert</code> supports input and output redirection, making it usable as part of a shell pipeline. For example, consider the following Protobuf code in our local Buf module:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// my_api.proto</span>
<span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>
<span class="kn">package</span> <span class="nn">my</span><span class="o">.</span><span class="n">api.v1</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Cart</span> <span class="p">{</span>
  <span class="kt">int32</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">repeated</span> <span class="n">Order</span> <span class="na">orders</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Order</span> <span class="p">{</span>
  <span class="kt">fixed64</span> <span class="na">sku</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">sku_name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int64</span> <span class="na">count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Protobuf</a></div></div> <p>Then, let’s say we’ve dumped a message of type <code class="language-plaintext highlighter-rouge">my.api.v1.Cart</code> from a service to debug it. And let’s say…well—you can’t just <code class="language-plaintext highlighter-rouge">cat</code> it.</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>dump.pb | xxd <span class="nt">-ps</span>
<span class="go">08a946121b097ac8e80400000000120e76616375756d20636c65616e6572
18011220096709b519000000001213686570612066696c7465722c203220
7061636b1806122c093aa8188900000000121f69736f70726f70796c2061
6c636f686f6c203730252c20312067616c6c6f6e1802</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Console</a></div></div> <p>However, we can use <code class="language-plaintext highlighter-rouge">buf convert</code> to turn it into some nice JSON. We can then pipe it into <code class="language-plaintext highlighter-rouge">jq</code> to format it.</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf convert <span class="nt">--type</span> my.api.v1.Cart <span class="nt">--from</span> dump.pb <span class="nt">--to</span> -#format<span class="o">=</span>json | jq
<span class="go">{
  "userId": 9001,
  "orders": [
    {
      "sku": "82364538",
      "skuName": "vacuum cleaner",
      "count": "1"
    },
    {
      "sku": "431294823",
      "skuName": "hepa filter, 2 pack",
      "count": "6"
    },
    {
	    "sku": "2300094522",
      "skuName": "isopropyl alcohol 70%, 1 gallon",
      "count": "2"
    }
  ]
}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Console</a></div></div> <p>Now you have the full expressivity of <code class="language-plaintext highlighter-rouge">jq</code> at your disposal. For example, we could pull out the user ID for the cart:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="k">function </span>buf-jq<span class="o">()</span> <span class="o">{</span> buf convert <span class="nt">--type</span> <span class="nv">$1</span> <span class="nt">--from</span> <span class="nv">$2</span> <span class="nt">--to</span> -#format<span class="o">=</span>json | jq <span class="nv">$3</span> <span class="o">}</span>
<span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'.userId'</span>
<span class="go">9001</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Console</a></div></div> <p>Or we can extract all of the SKUs that appear in the cart:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].sku]'</span>
<span class="go">[
  "82364538",
  "431294823",
  "2300094522"
]</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Console</a></div></div> <p>Or we could try calculating how many items are in the cart, total:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count] | add'</span>
<span class="go">"162"</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Console</a></div></div> <p>Wait. That’s wrong. The answer should be <code class="language-plaintext highlighter-rouge">9</code>. This illustrates one pitfall to keep in mind when using <code class="language-plaintext highlighter-rouge">jq</code> with Protobuf. Protobuf will <em>sometimes</em> serialize numbers as quoted strings (the C++ reference implementation only does this when they’re integers outside of the IEEE754 representable range, but Go is somewhat lazier, and does it for all 64-bit values).</p> <blockquote> <p>You can test if an <code class="language-plaintext highlighter-rouge">x int64</code> is in the representable float range with this very simple check: <code class="language-plaintext highlighter-rouge">int64(float64(x)) == x)</code>. See <a href="https://go.dev/play/p/T81SbbFg3br">https://go.dev/play/p/T81SbbFg3br</a>. The <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/json/internal/unparser.cc#L96">equivalent version in C++</a> is much more complicated.</p> </blockquote> <p>This means we need to use the <code class="language-plaintext highlighter-rouge">tonumber</code> conversion function:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count | tonumber] | add'</span>
<span class="go">9</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Console</a></div></div> <p><code class="language-plaintext highlighter-rouge">jq</code> ’s whole deal is JSON, so it brings with it all of JSON’s pitfalls. This is notable for Protobuf when trying to do arithmetic on 64-bit values. As we saw above, Protobuf serializes integers outside of the 64-bit float representable range (and in some runtimes, some integers inside it).</p> <p>For example, if you have a <code class="language-plaintext highlighter-rouge">repeated int64</code> that you want to sum over, it may produce incorrect answers due to floating-point rounding. For notes on conversions in <code class="language-plaintext highlighter-rouge">jq</code>, see <a href="https://jqlang.org/manual/#identity">https://jqlang.org/manual/#identity</a>.</p> <h2 id="disassembling-with-protoscope"><a href="#disassembling-with-protoscope">Disassembling with <code class="language-plaintext highlighter-rouge">protoscope</code></a></h2> <p><a href="https://github.com/protocolbuffers/protoscope"><code class="language-plaintext highlighter-rouge">protoscope</code></a> is a tool provided by the Protobuf team (which I originally wrote!) for decoding arbitrary data as if it were encoded in the Protobuf wire format. This process is called <em>disassembly</em>. It’s designed to work without a schema available, although it doesn’t produce especially clean output.</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>go <span class="nb">install </span>github.com/protocolbuffers/protoscope/cmd/protoscope...@latest
<span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {
  1: 82364538i64
  2: {"vacuum cleaner"}
  3: 1
}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Console</a></div></div> <p>The field names are gone; only field numbers are shown. This example also reveals an especially glaring limitation of <code class="language-plaintext highlighter-rouge">protoscope</code>, which is that it can’t tell the difference between string and message fields, so it guesses according to some heuristics. For the first and third elements it was able to grok them as strings, but for <code class="language-plaintext highlighter-rouge">orders[1].sku_name</code>, it incorrectly guessed it was a message and produced garbage.</p> <p>The tradeoff is that not only does <code class="language-plaintext highlighter-rouge">protoscope</code> not need a schema, it also tolerates almost any error, making it possible to analyze messages that have been partly corrupted. If we flip a random bit somewhere in <code class="language-plaintext highlighter-rouge">orders[0]</code>, disassembling the message still succeeds:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {`0f7ac8e80400000000120e76616375756d20636c65616e65721801`}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Console</a></div></div> <p>Although <code class="language-plaintext highlighter-rouge">protoscope</code> did give up on disassembling the corrupted submessage, it still made it through the rest of the dump.</p> <p>Like <code class="language-plaintext highlighter-rouge">buf convert</code>, we can give <code class="language-plaintext highlighter-rouge">protoscope</code> a <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> to make its heuristic a little smarter.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope <span class="se">\</span>
<span class="go">  --descriptor-set &lt;(buf build -o -) \
  --message-type my.api.v1.Cart \
  --print-field-names \
  dump.pb
</span><span class="gp">1: 9001                   #</span><span class="w"> </span>user_id
<span class="gp">2: {                      #</span><span class="w"> </span>orders
<span class="gp">  1: 82364538i64          #</span><span class="w"> </span>sku
<span class="gp">  2: {"vacuum cleaner"}   #</span><span class="w"> </span>sku_name
<span class="gp">  3: 1                    #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                          #</span><span class="w"> </span>orders
<span class="gp">  1: 431294823i64             #</span><span class="w"> </span>sku
<span class="gp">  2: {"hepa filter, 2 pack"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 6                        #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                                      #</span><span class="w"> </span>orders
<span class="gp">  1: 2300094522i64                        #</span><span class="w"> </span>sku
<span class="gp">  2: {"isopropyl alcohol 70%, 1 gallon"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 2                                    #</span><span class="w"> </span>count
<span class="go">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Console</a></div></div> <p>Not only is the second order decoded correctly now, but <code class="language-plaintext highlighter-rouge">protoscope</code> shows the name of each field (via <code class="language-plaintext highlighter-rouge">--print-field-names</code> ). In this mode, <code class="language-plaintext highlighter-rouge">protoscope</code> still decodes partially-valid messages.</p> <p><code class="language-plaintext highlighter-rouge">protoscope</code> also provides a number of other flags for customizing its heuristic in the absence of a <code class="language-plaintext highlighter-rouge">FileDescriporSet</code>. This enables it to be used as a forensic tool for debugging messy data corruption bugs.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-05-20 • 551 words • 6 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/05/20/protobuf-tip-6/"> Protobuf Tip #6: The Subtle Dangers of Enum Aliases </a></h1> </div> <div class="post"> <p><em>I’ve been very fortunate to dodge a nickname throughout my entire career. I’ve never had one. – Jimmie Johnson</em></p> <p>TL;DR: Enum values can have aliases. This feature is poorly designed and shouldn’t be used. The <a href="https://buf.build/docs/lint/rules/#enum_no_allow_alias"><code class="language-plaintext highlighter-rouge">ENUM_NO_ALLOW_ALIAS</code></a> Buf lint rule prevents you from using them by default.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-5-avoid-import-public-weak">buf.build blog</a>.</p> </blockquote> <h2 id="confusion-and-breakage"><a href="#confusion-and-breakage">Confusion and Breakage</a></h2> <p>Protobuf permits multiple enum values to have the same number. Such enum values are said to be <em>aliases</em> of each other. Protobuf used to allow this by default, but now you have to set a special option, <code class="language-plaintext highlighter-rouge">allow_alias</code>, for the compiler to not reject it.</p> <p>This can be used to effectively rename values without breaking existing code:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">MyEnum</span> <span class="p">{</span>
  <span class="k">option</span> <span class="na">allow_alias</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="na">MY_ENUM_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">MY_ENUM_BAD</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[</span><span class="na">deprecated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">];</span>
  <span class="na">MY_ENUM_MORE_SPECIFIC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Protobuf</a></div></div> <p>This works perfectly fine, and is fully wire-compatible! And unlike renaming a field (see <a href="https://mcyoung.xyz//2025/05/08/protobuf-tip-1">TotW #1</a>), it won’t result in source code breakages.</p> <p>But if you use either reflection or JSON, or a runtime like Java that doesn’t cleanly allow enums with multiple names, you’ll be in for a nasty surprise.</p> <p>For example, if you request an enum value from an enum using reflection, such as with <code class="language-plaintext highlighter-rouge">protoreflect.EnumValueDescriptors.ByNumber()</code>, the value you’ll get is the one that appears in the file lexically. In fact, both <code class="language-plaintext highlighter-rouge">myapipb.MyEnum_MY_ENUM_BAD.String()</code> and <code class="language-plaintext highlighter-rouge">myapipb.MyEnum_MY_ENUM_MORE_SPECIFIC.String()</code> return the same value, leading to potential confusion, as the old “bad” value will be used in printed output like logs.</p> <p>You might think, “oh, I’ll switch the order of the aliases”. But that would be an <em>actual</em> wire format break. Not for the binary format, but for JSON. That’s because JSON preferentially stringifies enum values by using their declared name (if the value is in range). So, reordering the values means that what once serialized as <code class="language-plaintext highlighter-rouge">{"my_field": "MY_ENUM_BAD"}</code> now serializes as <code class="language-plaintext highlighter-rouge">{"my_field": "MY_ENUM_MORE_SPECIFIC"}</code> .</p> <p>If an old binary that hasn’t had the new enum value added sees this JSON document, it won’t parse correctly, and you’ll be in for a bad time.</p> <p>You can argue that this is a language bug, and it kind of is. Protobuf should include an equivalent of <code class="language-plaintext highlighter-rouge">json_name</code> for enum values, or mandate that JSON should serialize enum values with multiple names as a number, rather than an arbitrarily chosen enum name. The feature is intended to allow renaming of enum values, but unfortunately Protobuf hobbled it enough that it’s pretty dangerous.</p> <h1 id="what-to-do"><a href="#what-to-do">What To Do</a></h1> <p>Instead, if you <em>really</em> need to rename an enum value for usability or compliance reasons (ideally, not just aesthetics) you’re better off making a new enum type in a new version of your API. As long as the enum value numbers are the same, it’ll be binary-compatible, but it will <em>somewhat</em> reduce the risk of the above JSON confusion.</p> <p>Buf provides a lint rule against this feature, <a href="https://buf.build/docs/lint/rules/#enum_no_allow_alias"><code class="language-plaintext highlighter-rouge">ENUM_NO_ALLOW_ALIAS</code></a> , and Protobuf requires that you specify a magic option to enable this behavior, so in practice you don’t need to worry about this. But remember, the consequences of enum aliases go much further than JSON—they affect anything that uses reflection. So even if you don’t use JSON, you can still get burned.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-05-13 • 852 words • 9 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/05/13/protobuf-tip-5/"> Protobuf Tip #5: Avoid import public/weak </a></h1> </div> <div class="post"> <p><em>My dad had a guitar but it was acoustic, so I smashed a mirror and glued broken glass to it to make it look more metal. It looked ridiculous! –Max Cavalera</em></p> <p>TL;DR: Avoid <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf lint rules <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> and <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> enforce this for you by default.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-5-avoid-import-public-weak">buf.build blog</a>.</p> </blockquote> <p>Protobuf <code class="language-plaintext highlighter-rouge">import</code>s allow you to specify two special modes: <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf CLI lints against these by default, but you might be tempted to try using them anyway, especially because <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19">some GCP APIs use <code class="language-plaintext highlighter-rouge">import public</code></a>. What are these modes, and why do they exist?</p> <h2 id="import-visibility"><a href="#import-visibility">Import Visibility</a></h2> <p>Protobuf imports are by file path, a fact that is very strongly baked into the language and its reflection model.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">"my/other/api.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Protobuf</a></div></div> <p>Importing a file dumps all of its symbols into the current file. For the purposes of name resolution, it’s as if all if the declarations in that file have been pasted into the current file. However, this isn’t transitive. If:</p> <ul> <li><code class="language-plaintext highlighter-rouge">a.proto</code> imports <code class="language-plaintext highlighter-rouge">b.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">b.proto</code> imports <code class="language-plaintext highlighter-rouge">c.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">c.proto</code> defines <code class="language-plaintext highlighter-rouge">foo.Bar</code>…</li> <li>then, <code class="language-plaintext highlighter-rouge">a.proto</code> must import <code class="language-plaintext highlighter-rouge">c.proto</code> to refer to <code class="language-plaintext highlighter-rouge">foo.Bar</code>, even though <code class="language-plaintext highlighter-rouge">b.proto</code> imports it.</li> </ul> <p>This is similar to how importing a package as <code class="language-plaintext highlighter-rouge">.</code> works in Go. When you write <code class="language-plaintext highlighter-rouge">import . "strings"</code>, it dumps all of the declarations from the <code class="language-plaintext highlighter-rouge">strings</code> package into the current file, but not those of any files that <code class="language-plaintext highlighter-rouge">"strings"</code> imports.</p> <p>Now, what’s nice about Go is that packages can be broken up into files in a way that is transparent to users; users of a package import <em>the package</em>, not the files of that package. Unfortunately, Protobuf is not like that, so the file structure of a package leaks to its callers.</p> <p><code class="language-plaintext highlighter-rouge">import public</code> was intended as a mechanism for allowing API writers to break up files that were getting out of control. You can define a new file <code class="language-plaintext highlighter-rouge">new.proto</code> for some of the definitions in <code class="language-plaintext highlighter-rouge">big.proto</code>, move them to the new file, and then add <code class="language-plaintext highlighter-rouge">import public "new.proto";</code> to <code class="language-plaintext highlighter-rouge">big.proto</code>. Existing imports of <code class="language-plaintext highlighter-rouge">big.proto</code> won’t be broken, hooray!</p> <p>Except this feature was designed for C++. In C++, each <code class="language-plaintext highlighter-rouge">.proto</code> file maps to a <code class="language-plaintext highlighter-rouge">.proto.h</code> header, which you <code class="language-plaintext highlighter-rouge">#include</code> in your application code. In C++, <code class="language-plaintext highlighter-rouge">#include</code> behaves like <code class="language-plaintext highlighter-rouge">import public</code>, so marking an import as <code class="language-plaintext highlighter-rouge">public</code> only changes name resolution in Protobuf—the C++ backend doesn’t have to do anything to maintain source compatibility when an import is changed to <code class="language-plaintext highlighter-rouge">public</code>.</p> <p>But other backends, like Go, do not work this way: <code class="language-plaintext highlighter-rouge">import</code> in Go <em>doesn’t</em> pull in symbols transitively, so Go would need to explicitly add aliases for all of the symbols that come in through a public import. That is, if you had:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// foo.proto</span>
<span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// bar.proto</span>
<span class="kn">package</span> <span class="nn">myotherapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="k">import</span> <span class="n">public</span> <span class="s">"foo.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Protobuf</a></div></div> <p>Then the Go backend has to generate a <code class="language-plaintext highlighter-rouge">type Foo = foopb.Foo</code> in <code class="language-plaintext highlighter-rouge">bar.pb.go</code> to emulate this behavior (in fact, I was surprised to learn Go Protobuf implements this at all). Go <em>happens</em> to implement public imports correctly, but not all backends are as careful, because this feature is obscure.</p> <p>The <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19"><code class="language-plaintext highlighter-rouge">spanner.proto</code></a> example of an <code class="language-plaintext highlighter-rouge">import public</code> isn’t even used for breaking up an existing file; instead, it’s used to not make a huge file bigger and avoid making callers have to add an additional import. This is a <em>bad use</em> of a <em>bad feature!</em></p> <p>Using <code class="language-plaintext highlighter-rouge">import public</code> to effectively “hide” imports makes it harder to understand what a <code class="language-plaintext highlighter-rouge">.proto</code> file is pulling in. If Protobuf imports were at the package/symbol level, like Go or Java, this feature would not need to exist. Unfortunately, Protobuf is closely tailored for C++, and this is one of the consequences.</p> <p>Instead of using <code class="language-plaintext highlighter-rouge">import public</code> to break up a file, simply plan to break up the file in the next version of the API.</p> <p>The <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> Buf lint rule enforces that no one uses this feature by default. It’s tempting, but the footguns aren’t worth it.</p> <h2 id="weak-imports"><a href="#weak-imports">Weak Imports</a></h2> <p>Public imports have a good, if flawed, reason to exist. Their implementation details are the main thing that kneecaps them.</p> <p>Weak imports, however, simply should not exist. They were added to the language to make it easier for some of Google’s enormous binaries to avoid running out of linker memory, by making it so that message types could be dropped if they weren’t accessed. This means that weak imports are “optional”—if the corresponding descriptors are missing at runtime, the C++ runtime can handle it gracefully.</p> <p>This leads to all kinds of implementation complexity and subtle behavior differences across runtimes. Most runtimes implement (or implemented, in the case of those that removed support) <code class="language-plaintext highlighter-rouge">import weak</code> in a buggy or inconsistent way. It’s unlikely the feature will ever be truly removed, even though Google has tried.</p> <p>Don’t use <code class="language-plaintext highlighter-rouge">import weak</code>. It should be treated as completely non-functional. The <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> Buf lint rule takes care of this for you.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-29 • 837 words • 9 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/29/protobuf-tip-4/"> Protobuf Tip #4: Accepting Mistakes We Can't Fix </a></h1> </div> <div class="post"> <p><em>Bad humor is an evasion of reality; good humor is an acceptance of it. –Malcolm Muggeridge</em></p> <p>TL;DR: Protobuf’s distributed nature introduces evolution risks that make it hard to fix some types of mistakes. Sometimes the best thing to do is to just let it be.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-4-accepting-mistakes">buf.build blog</a>.</p> </blockquote> <h2 id="a-different-mindset"><a href="#a-different-mindset">A Different Mindset</a></h2> <p>Often, you’ll design and implement a feature for the software you work on, and despite your best efforts to test it, something terrible happens in production. We have a playbook for this, though: fix the bug in your program and ship or deploy the new, fixed version to your users. It might mean working late for big emergencies, but turnaround for most organizations is a day to a week.</p> <p>Most bugs aren’t emergencies, though. Sometimes a function has a confusing name, or an integer type is just a bit too small for real-world data, or an API conflates “zero” and “null”. You fix the API, refactor all usages in your API in one commit, merge, and the fix rolls out gradually.</p> <p>Unless, of course, it’s a bug in a communication API, like a serialization format: your Protobuf types, or your JSON schema, or the not-too-pretty code that parses fields out of dict built from a YAML file. Here, you can’t <em>just</em> atomically fix the world. Fixing bugs in your APIs (from here on, “APIs” means “Protobuf definitions”) requires a different mindset than fixing bugs in ordinary code.</p> <h2 id="what-are-the-risks"><a href="#what-are-the-risks">What Are the Risks?</a></h2> <p>Protobuf’s wire format is designed so that you can safely add new fields to a type, or values to an enum, without needing to perform an atomic upgrade. But other changes, like renaming fields or changing their type, are very dangerous.</p> <p>This is because Protobuf types exist on a temporal axis: different versions of the same type exist simultaneously among programs in the field that are actively talking to each other. This means that <em>writers from the future</em> (that is, new serialization code) must be careful to not confuse the many <em>readers from the past</em> (old versions of the deserialization code). Conversely, future readers must tolerate anything past writers produce.</p> <p>In a modern distributed deployment, the number of versions that exist at once can be quite large. This is true even in self-hosted clusters, but becomes much more fraught whenever user-upgradable software is involved. This can include mobile applications that talk to your servers, or appliance software managed by a third-party administrator, or even just browser-service communication.</p> <p>The most important principle: you can’t easily control when old versions of a type or service are no longer relevant. As soon as a type escapes out of the scope of even a single team, upgrading types becomes a departmental effort.</p> <h2 id="learning-to-love-the-bomb"><a href="#learning-to-love-the-bomb">Learning to Love the Bomb</a></h2> <p>There are many places where Protobuf could have made schema evolution easier, but didn’t. For example, changing <code class="language-plaintext highlighter-rouge">int32 foo = 1;</code> to <code class="language-plaintext highlighter-rouge">sfixed32 foo = 1;</code> is a breakage, even though at the wire format level, it is <em>possible</em> for a parser to distinguish and accept both forms of <code class="language-plaintext highlighter-rouge">foo</code> correctly. There too many other examples to list, but it’s important to understand that the language is not always working in our favor.</p> <p>For example, if we notice a <code class="language-plaintext highlighter-rouge">int32</code> value is too small, and should have been 64-bit, you can’t upgrade it without readers from the past potentially truncating it. But we really have to upgrade it! What are our options?</p> <ol> <li>Issue a new version of the message and all of its dependencies. This is the main reason why sticking a version number in the package name, as enforced by Buf’s <a href="https://buf.build/docs/lint/rules/#package_version_suffix"><code class="language-plaintext highlighter-rouge">PACKAGE_VERSION_SUFFIX</code></a> lint rule, is so important.</li> <li>Do the upgrade anyway and hope nothing breaks. This <em>can</em> work for certain kinds of upgrades, if the underlying format is compatible, but it can have <strong>disastrous consequences</strong> if you don’t know what you’re doing, especially if it’s a type that’s not completely internal to a team’s project. <a href="https://buf.build/docs/breaking/overview/">Buf breaking change detection</a> helps you avoid changes with potential for breakage.</li> </ol> <p>Of course, there is a third option, which is to accept that some things aren’t worth fixing. When the cost of a fix is so high, fixes just aren’t worth it, especially when the language is working against us.</p> <p>This means that even in Buf’s own APIs, we sometimes do things in a way that isn’t quite ideal, or is inconsistent with our own best practices. Sometimes, the ecosystem changes in a way that changes best practice, but we can’t upgrade to it without breaking our users. In the same way, you shouldn’t rush to use new, better language features if they would cause protocol breaks: sometimes, the right thing is to do nothing, because not breaking your users is more important. <br/></p> <p> </p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-22 • 726 words • 8 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/22/protobuf-tip-3/"> Protobuf Tip #3: Enum Names Need Prefixes </a></h1> </div> <div class="post"> <p><em>Smart people learn from their mistakes. But the real sharp ones learn from the mistakes of others. –Brandon Mull</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">enum</code>s inherit some unfortunate behaviors from C++. Use the Buf lint rules <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a> and <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a>  to avoid this problem (they’re part of the <code class="language-plaintext highlighter-rouge">DEFAULT</code> category).</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-3-enum-names-need-prefixes">buf.build blog</a>.</p> </blockquote> <h2 id="c-style-enums"><a href="#c-style-enums">C++-Style Enums</a></h2> <p>Protobuf’s <code class="language-plaintext highlighter-rouge">enum</code>s define data types that represent a small set of valid values. For example, <code class="language-plaintext highlighter-rouge">google.rpc.Code</code> lists status codes used by various RPC frameworks, such as GRPC. Under the hood, every <code class="language-plaintext highlighter-rouge">enum</code> is just an <code class="language-plaintext highlighter-rouge">int32</code>  on the wire, although codegen backends will generate custom types and constants for the enum to make it easier to use.</p> <p>Unfortunately, <code class="language-plaintext highlighter-rouge">enum</code>s were originally designed to match C++ enums exactly, and they inadvertently replicate many of those behaviors.</p> <p>If you look at the source for <code class="language-plaintext highlighter-rouge">google.rpc.Code</code>, and compare it to, say, <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.Type</code>, you will notice a subtle difference:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="k">rpc</span><span class="p">;</span>
<span class="kd">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="na">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">UNKNOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="n">protobuf</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">FieldDescriptorProto</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// 0 is reserved for errors.</span>
    <span class="na">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">TYPE_INT64</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Protobuf</a></div></div> <p><code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> has values starting with <code class="language-plaintext highlighter-rouge">TYPE_</code>, but <code class="language-plaintext highlighter-rouge">Code</code> ‘s values don’t have a <code class="language-plaintext highlighter-rouge">CODE_</code> prefix.  This is because the fully-qualified names (FQN) of an enum value <em>don’t include the name of the enum.</em> That is, <code class="language-plaintext highlighter-rouge">TYPE_DOUBLE</code> actually refers to <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.TYPE_DOUBLE</code>. Thus, <code class="language-plaintext highlighter-rouge">OK</code> is not <code class="language-plaintext highlighter-rouge">google.rpc.Code.OK</code>, but <code class="language-plaintext highlighter-rouge">google.rpc.OK</code>.</p> <p>This is because it matches the behavior of unscoped C++ enums. C++ is the “reference” implementation, so the language often bends for the sake of the C++ backend.</p> <p>When generating code, <code class="language-plaintext highlighter-rouge">protoc</code>’s C++ backend emits the above as follows:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">rpc</span> <span class="p">{</span>
<span class="k">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">FieldDescriptorProto</span> <span class="k">final</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">enum</span> <span class="n">Type</span> <span class="p">{</span>
   <span class="n">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// ...</span>
  <span class="p">};</span>
<span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">C++</a></div></div> <p>And in C++, <code class="language-plaintext highlighter-rouge">enum</code>s don’t scope their enumerators: you write <code class="language-plaintext highlighter-rouge">google::rpc::OK</code>, NOT <code class="language-plaintext highlighter-rouge">google::rpc::Code::OK</code>.</p> <p>If you know C++, you might be thinking, “why didn’t they use <code class="language-plaintext highlighter-rouge">enum class</code>?!”? Enums were added in <code class="language-plaintext highlighter-rouge">proto2</code>, which was developed around 2007-2008, but Google didn’t start using C++11, which introduced <code class="language-plaintext highlighter-rouge">enum class</code> , until much, much later.</p> <p>Now, if you’re a Go or Java programmer, you’re probably wondering why you even care about C++. Both Go and Java do scope enum values to the enum type (although Go does it in a somewhat grody way: <code class="language-plaintext highlighter-rouge">rpcpb.Code_OK</code>).</p> <p>Unfortunately, this affects name collision detection in Protobuf. You can’t write the following code:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Protobuf</a></div></div> <p>Because the enum name is not part of the FQN for an enum value, both <code class="language-plaintext highlighter-rouge">UNSPECIFIED</code>s here have the FQN <code class="language-plaintext highlighter-rouge">myapi.v1.UNSPECIFIED</code>, so Protobuf complains about duplicate symbols.</p> <p>Thus, the convention we see in <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code>:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">STOPLIGHT_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">STOPLIGHT_RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">STOPLIGHT_YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">STOPLIGHT_GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">SPEED_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SPEED_SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">SPEED_FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Protobuf</a></div></div> <p>Buf provides a lint rule to enforce this convention: <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a>. Even though you might think that an enum name will be unique, because top-level enums bleed their names into the containing package, the problem spreads across packages!</p> <h2 id="zero-values"><a href="#zero-values">Zero Values</a></h2> <p><code class="language-plaintext highlighter-rouge">proto3</code> relies heavily on the concept of “zero values” – all non-message fields that are neither <code class="language-plaintext highlighter-rouge">repeated</code> nor <code class="language-plaintext highlighter-rouge">optional</code> are implicitly zero if they are not present. Thus, <code class="language-plaintext highlighter-rouge">proto3</code> requires that enums specify a value equal to zero.</p> <p>By convention, this value shouldn’t be a specific value of the enum, but rather a value representing that no value is specified. <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a> enforces this, with a default of <code class="language-plaintext highlighter-rouge">_UNSPECIFIED</code>. Of course, there are situations where this might not make sense for you, and a suffix like <code class="language-plaintext highlighter-rouge">_ZERO</code> or <code class="language-plaintext highlighter-rouge">_UNKNOWN</code> might make more sense.</p> <p>It may be tempting to have a specific “good default” value for the zero value. Beware though, because that choice is forever. Picking a generic “unknown” as the default reduces the chance you’ll burn yourself.</p> <h2 id="why-dont-all-of-googles-protobuf-files-do-this"><a href="#why-dont-all-of-googles-protobuf-files-do-this">Why Don’t All of Google’s Protobuf Files Do This?</a></h2> <p>Name prefixes and zero values also teach us an important lesson: because Protobuf names are forever, it’s really hard to fix style mistakes, especially as we collectively get better at using Protobuf.</p> <p><code class="language-plaintext highlighter-rouge">google.rpc.Code</code> is intended to be source-compatible with very old existing C++ code, so it throws caution to the wind. <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> doesn’t have a zero value because in <code class="language-plaintext highlighter-rouge">proto2</code> , which doesn’t have zero value footguns in its wire format, you don’t need to worry about that. The lesson isn’t just to use Buf’s linter to try to avoid some of the known pitfalls, but also to remember that even APIs designed by the authors of the language make unfixable mistakes, so unlike other programming languages, imitating “existing practice” isn’t always the best strategy.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-21 • 4283 words • 47 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> </span> <h1><a href="/2025/04/21/go-arenas/"> Cheating the Reaper in Go </a></h1> </div> <div class="post"> <p>Even though I am a C++ programmer at heart, Go fascinates me for none of the reasons you think. Go has made several interesting design decisions:</p> <ol> <li> <p>It has virtually no Undefined Behavior<sup id="fnref:goub" role="doc-noteref"><a href="#fn:goub" class="footnote" rel="footnote">1</a></sup>.</p> </li> <li> <p>It has very simple GC semantics that they’re mostly stuck with due to design decisions in the surface language.</p> </li> </ol> <p>These things mean that despite Go having a GC, it’s possible to do manual memory management in pure Go and in cooperation with the GC (although without any help from the <code class="language-plaintext highlighter-rouge">runtime</code> package). To demonstrate this, we will be building an untyped, garbage-collected arena abstraction in Go which relies on several GC implementation details.</p> <p>I would never play this kind of game in Rust or C++, because LLVM is extremely intelligent and able to find all kinds of ways to break you over the course of frequent compiler upgrades. On the other hand, although Go does not promise any compatibility across versions for code that imports <code class="language-plaintext highlighter-rouge">unsafe</code>, in practice, two forces work against Go doing this:</p> <ol> <li> <p>Go does not attempt to define what is and isn’t allowed: <code class="language-plaintext highlighter-rouge">unsafe</code> lacks any <a href="https://en.wikipedia.org/wiki/Operational_semantics">operational semantics</a>.</p> </li> <li> <p>Go prioritizes not breaking the ecosystem; this allows to assume that <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a> will protect certain observable behaviors of the runtime, from which we may infer what can or cannot break easily.</p> </li> </ol> <p>This is in contrast to a high-performance native compiler like LLVM, which has a carefully defined boundary around all UB, allowing them to arbitrarily break programs that cross it (mostly) without fear of breaking the ecosystem.</p> <p>So, let’s dive in and cheat death.</p> <h2 id="what-are-we-building"><a href="#what-are-we-building">What Are We Building?</a></h2> <p>Our goal is to build an <em>arena</em>, which is a data structure for efficient allocation of memory that has the same lifetime. This reduces pressure on the general-purpose allocator by only requesting memory in large chunks and then freeing it all at once.</p> <p>For a comparison in Go, consider the following program:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">s</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="m">1000</span> <span class="p">{</span>
    <span class="n">prev</span> <span class="o">:=</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Go</a></div></div> <p>This program will print successive powers of 2: this is because <code class="language-plaintext highlighter-rouge">append</code> is implemented approximately like so:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="nb">append</span><span class="p">[</span><span class="n">S</span> <span class="err">~</span><span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">S</span><span class="p">)</span> <span class="n">S</span> <span class="p">{</span>
  <span class="c">// If needed, grow the allocation.</span>
  <span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Either double the size, or allocate just enough if doubling is</span>
    <span class="c">// too little.</span>
    <span class="n">newCap</span> <span class="o">:=</span> <span class="n">max</span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="c">// Grow a.</span>
    <span class="n">a2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">newCap</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a2</span>
  <span class="p">}</span>

  <span class="c">// Increase the length of a to fit b, then write b into the freshly</span>
  <span class="c">// grown region.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span>
  <span class="nb">copy</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Go</a></div></div> <p>For appending small pieces, <code class="language-plaintext highlighter-rouge">make</code> is only called <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> times, a big improvement over calling it for every call to <code class="language-plaintext highlighter-rouge">append</code>. Virtually every programming language’s dynamic array abstraction makes this optimization.</p> <p>An arena generalizes this concept, but instead of resizing exponentially, it allocates <em>new</em> blocks and vends pointers into them. The interface we want to conform to is as follows:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Allocator</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Go</a></div></div> <p>In go a size and and an alignment, out comes a pointer fresh memory with that layout. Go does not have user-visible uninitialized memory, so we additionally require that the returned region be zeroed. We also require that <code class="language-plaintext highlighter-rouge">align</code> be a power of two.</p> <p>We can give this a type-safe interface by writing a generic <code class="language-plaintext highlighter-rouge">New</code> function:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// New allocates a fresh zero value of type T on the given allocator, and</span>
<span class="c">// returns a pointer to it.</span>
<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="n">Allocator</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Go</a></div></div> <p>This all feels very fine and dandy to anyone used to hurting themselves with <code class="language-plaintext highlighter-rouge">malloc</code> or <code class="language-plaintext highlighter-rouge">operator new</code> in C++, but there is a small problem. What happens when we allocate pointer-typed memory into this allocator?</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// Allocate a pointer in our custom allocator, and then</span>
<span class="c">// initialize it to a pointer on the Go heap.</span>
<span class="n">p</span> <span class="o">:=</span> <span class="n">New</span><span class="p">[</span><span class="o">*</span><span class="kt">int</span><span class="p">](</span><span class="n">myAlloc</span><span class="p">)</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="n">runtime</span><span class="o">.</span><span class="n">GC</span><span class="p">()</span>
<span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="m">42</span>  <span class="c">// Use after free!</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Go</a></div></div> <p><code class="language-plaintext highlighter-rouge">Allocator.Alloc</code> takes a size and an alignment, which is sufficient to describe the <em>layout</em> of any type. For example, on 64-bit systems, <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">*int</code> have the same layout: 8 bytes of size, and 8 bytes of alignment.</p> <p>However, the Go GC (and all garbage collectors, generally) require one additional piece of information, which is somewhere between the layout of a value (how it is placed in memory) and the type of a value (rich information on its structure). To understand this, we need a brief overview on what a GC does.</p> <h2 id="mark-and-sweep"><a href="#mark-and-sweep">Mark and Sweep</a></h2> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>For a complete overview on how to build a simple GC, take a look at a toy GC I designed some time ago: <a href="https://mcyoung.xyz/2022/06/07/alkyne-gc/">The Alkyne GC</a>.</p> </blockquote> <p>A garbage collector’s responsibility is to maintain a memory allocator and an accounting of:</p> <ol> <li>What memory has been allocated.</li> <li>Whether that memory is still in use.</li> </ol> <p>Memory that is not in use can be reclaimed and marked as unallocated, for re-use.</p> <p>The most popular way to accomplish this is via a “mark and sweep” architecture. The GC will periodically walk the entire object graph of the program from certain pre-determined <em>roots</em>; anything it finds is “marked” as alive. After a mark is complete, all other memory is “swept”, which means to mark it is unallocated for future re-use, or to return it to the OS, in the case of significant surplus.</p> <p>The roots are typically entities that are actively being manipulated by the program. In the case of Go, this is anything currently on the stack of some G<sup id="fnref:g" role="doc-noteref"><a href="#fn:g" class="footnote" rel="footnote">2</a></sup>, or anything in a global (of which there is a compile-time-known set).</p> <p>The marking phase begins with <em>stack scanning</em>, which looks at the stack of each G and locates any pointers contained therein. The Go compiler generates metadata for each function that specifies which stack slots in a function’s frame contain pointers. All of these pointers are live by definition.</p> <p>These pointers are placed into a queue, and each pointer is traced to its allocation on the heap. If the GC does not know anything about a particular address, it is discarded as foreign memory that does not need to be marked. If it does, each pointer in that allocation is pushed onto the queue if it has not already been marked as alive. The process continues until the queue is empty.</p> <p>The critical step here is to take the address of some allocation, and convert it into all of the pointer values within. Go has precise garbage collection, which means that it only treats things declared as pointers in the surface language as pointers: an integer that happens to look like an address will not result in sweeping. This results in more efficient memory usage, but trades off some more complexity in the GC.</p> <p>For example, the types <code class="language-plaintext highlighter-rouge">*int</code>, <code class="language-plaintext highlighter-rouge">map[int]byte</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">struct {A int; B *int}</code> all contain at least one pointer, while <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">[1000]byte</code>, <code class="language-plaintext highlighter-rouge">struct {X bool; F uintptr}</code> do not. The latter are called <em>pointer-free</em> types.</p> <p>Go enhances the layout of a type into a <em>shape</em> by adding a bitset that specifies which pointer-aligned, pointer-sized words of the type’s memory region contain a pointer. These are called the <em>pointer bits</em>. For example, here are the shapes of a few Go types on a 64-bit system.</p> <table> <thead> <tr> <th>Type</th> <th>Size/Align</th> <th>Pointer Bits<sup id="fnref:ptr-bits-endian" role="doc-noteref"><a href="#fn:ptr-bits-endian" class="footnote" rel="footnote">3</a></sup></th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">byte</code></td> <td>1/1</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">rune</code></td> <td>4/4</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">*int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">unsafe.Pointer</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">string</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">10</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[]int</code></td> <td>24/8</td> <td><code class="language-plaintext highlighter-rouge">100</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[3]string</code></td> <td>48/8</td> <td><code class="language-plaintext highlighter-rouge">101010</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">map[int]byte</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">map[int]string</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">any</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">01</code><sup id="fnref:itab" role="doc-noteref"><a href="#fn:itab" class="footnote" rel="footnote">4</a></sup></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">error</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">01</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">func(int) int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">runtime.hchan</code><sup id="fnref:hchan" role="doc-noteref"><a href="#fn:hchan" class="footnote" rel="footnote">5</a></sup></td> <td>104/8</td> <td><code class="language-plaintext highlighter-rouge">0010110011110</code></td> </tr> </tbody> </table> <p>In the Go GC, each allocation is tagged with its shape (this is done in a variety of ways in the GC, either through an explicit header on the allocation, itself (a “malloc header”), a runtime type stored in the allocation’s <code class="language-plaintext highlighter-rouge">runtime.mspan</code>, or another mechanism). When scanning a value, it uses this information to determine where the pointers to scan through are.</p> <p>The most obvious problem with our <code class="language-plaintext highlighter-rouge">Allocator.Alloc</code> type is that it does not discriminate shapes, so it cannot allocate memory that contains pointers: the GC will not be able to find the pointers, and will free them prematurely!</p> <p>In our example where we allocated an <code class="language-plaintext highlighter-rouge">*int</code> in our custom allocator, we wind up with a <code class="language-plaintext highlighter-rouge">**int</code> on the stack. You would think that Go would simply trace through the first <code class="language-plaintext highlighter-rouge">*</code> to find an <code class="language-plaintext highlighter-rouge">*int</code> and mark it as being alive, but that is not what happens! Go instead finds a pointer into some chunk that the custom allocator grabbed from the heap, which is missing the pointer bits of its shape!</p> <p>Why does go not look at the type of the pointer it steps through? Two reasons.</p> <ol> <li> <p>All pointers in Go are untyped from the runtime’s perspective; every <code class="language-plaintext highlighter-rouge">*T</code> gets erased into an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>. This allows much of the Go runtime to be “generic” without using actual generics.</p> </li> <li> <p>Pointee metadata can be aggregated, so that each pointer to an object does not have to remember its type at runtime.</p> </li> </ol> <p>The end result for us is that we can’t put pointers on the arena. This makes our <code class="language-plaintext highlighter-rouge">New</code> API unsafe, especially since Go does not provide a standard constraint for marking generic parameters as pointer-free: unsurprisingly, the don’t expect most users to care about such a detail.</p> <p>It <em>is</em> possible to deduce the pointer bits of a type using reflection, but that’s very slow, and the whole point of using arenas is to go fast. As we design our arena, though, it will become clear that there is a safe way to have pointers on it.</p> <h2 id="designing-the-arena"><a href="#designing-the-arena">Designing The Arena</a></h2> <p>Now that we have a pretty good understanding about what the Go GC is doing, we can go about designing a fast arena structure.</p> <p>The ideal case is that a call to <code class="language-plaintext highlighter-rouge">Alloc</code> is very fast: just offsetting a pointer in the common case. One assumption we can make off the bat is that all memory can be forced to have maximum alignment: most objects are a pointer or larger, and Go does have a maximum alignment for ordinary user types, so we can just ignore the <code class="language-plaintext highlighter-rouge">align</code> parameter and always align to say, 8 bytes. This means that the pointer to the next unallocated chunk will always be well-aligned. Thus, we might come up with a structure like this one:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>
<span class="p">}</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="c">// Power of two size of the minimum allocation granularity.</span>
  <span class="n">wordBytes</span> <span class="o">=</span> <span class="m">8</span>  <span class="c">// Depends on target, this is for 64-bit.</span>
  <span class="n">minWords</span>  <span class="o">=</span> <span class="m">8</span>
<span class="p">)</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// First, round the size up to the alignment of every object in</span>
  <span class="c">// the arena.</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="c">// Then, replace the size with the size in pointer-sized words.</span>
  <span class="c">// This does not result in any loss of size, since size is now</span>
  <span class="c">// a multiple of the uintptr size.</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">wordBytes</span>

  <span class="c">// Next, check if we have enough space left for this chunk. If</span>
  <span class="c">// there isn't, we need to grow.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size,</span>
    <span class="c">// twice the last allocation, or the next power of two</span>
    <span class="c">// after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
  <span class="p">}</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// Beware, offsetting to one-past-the-end is one of the few</span>
    <span class="c">// things explicitly not allowed by Go.</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="c">// nextPow2 returns the smallest power of two greater than n.</span>
<span class="k">func</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="o">.</span><span class="n">Len</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Go</a></div></div> <p>How fast is this really? Here’s a simple benchmark for it.</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">BenchmarkArena</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bench</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">64</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">1024</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">runs</span> <span class="o">=</span> <span class="m">100000</span>

<span class="k">var</span> <span class="n">sink</span> <span class="n">any</span>

<span class="k">func</span> <span class="n">bench</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">z</span> <span class="n">T</span>
  <span class="n">n</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">runs</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
  <span class="n">name</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%v"</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">T</span><span class="p">]())</span>

  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"arena"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">Arena</span><span class="p">)</span>
        <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
          <span class="n">sink</span> <span class="o">=</span> <span class="n">arena</span><span class="o">.</span><span class="n">New</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">a</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})</span>

    <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"new"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
          <span class="n">sink</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Go</a></div></div> <p>The focus of this benchmark is to measure the cost of allocating many objects of the same size. The number of times the <code class="language-plaintext highlighter-rouge">for b.Loop()</code> loop will execute is unknown, and determined by the benchmarking framework to try to reduce statistical anomaly. This means that if we instead just benchmark a single allocation, the result will be <em>very</em> sensitive to the number of runs.</p> <p>We also use <code class="language-plaintext highlighter-rouge">b.SetBytes</code> to get a throughput measurement on the benchmark. This is a bit easier to interpret than the gross <code class="language-plaintext highlighter-rouge">ns/op</code>, the benchmark would otherwise produce. It tells us how much memory each allocator can allocate per unit time.</p> <p>We want to compare against <code class="language-plaintext highlighter-rouge">new</code>, but just writing <code class="language-plaintext highlighter-rouge">_ = new(T)</code> will get optimized out, since the resulting pointer does not escape. Writing it to a global is sufficient to convince Go that it escapes.</p> <p>Here’s the results, abbreviated to show only the bytes per second. All benchmarks were performed on my AMD Ryzen Threadripper 3960X. Larger is better.</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         794.84 MB/s
BenchmarkArena/int/new-48           390.59 MB/s
BenchmarkArena/[2]int/arena-48      1263.58 MB/s
BenchmarkArena/[2]int/new-48        528.06 MB/s
BenchmarkArena/[64]int/arena-48     7370.08 MB/s
BenchmarkArena/[64]int/new-48       2865.24 MB/s
BenchmarkArena/[1024]int/arena-48   9889.20 MB/s
BenchmarkArena/[1024]int/new-48     2875.75 MB/s</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Console</a></div></div> <p>This is quite nice, and certainly worth pursuing! The performance increase seems to scale up with the amount of memory allocated, for a 2x-4x improvement across different cases.</p> <p>Now we need to contend with the fact that our implementation is completely broken if we want to have pointers in it.</p> <h3 id="not-dropping-memory-on-the-ground"><a href="#not-dropping-memory-on-the-ground">Not Dropping Memory on the Ground</a></h3> <p>In <code class="language-plaintext highlighter-rouge">(*Arena).Alloc</code>, when we assign a freshly-allocated chunk, we overwrite <code class="language-plaintext highlighter-rouge">a.next</code>, which means the GC can reclaim it. But this is fine: as long as pointers into that arena chunk are alive, the GC will not free it, independent of the arena. So it seems like we don’t need to worry about it?</p> <p>However, the whole point of an arena is to allocate lots of memory that has the same lifetime. This is common for graph data structures, such as an AST or a compiler IR, which performs a lot of work that allocates a lot and then throws the result away.</p> <p>We are not allowed to put pointers in the arena, because they would disappear from the view of the GC and become freed too soon. But, if a pointer wants to go on an arena, it necessarily outlive the whole arena, since it outlives part of the arena, and the arena is meant to have the same lifetime.</p> <p>In particular, if we could make it so that holding any pointer returned by <code class="language-plaintext highlighter-rouge">Alloc</code> prevents the <em>entire arena</em> from being swept by the GC, the arena can safely contain pointers into itself! Consider this:</p> <ol> <li> <p>We have a pointer <code class="language-plaintext highlighter-rouge">p **int</code>. It is allocated on some arena <code class="language-plaintext highlighter-rouge">a</code>.</p> </li> <li> <p>The GC sees our pointer (as a type-erased <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>) and marks its allocation as live.</p> </li> <li> <p>Somehow, the GC also marks <code class="language-plaintext highlighter-rouge">a</code> as alive as a consequence.</p> </li> <li> <p>Somehow, the GC then marks every chunk <code class="language-plaintext highlighter-rouge">a</code> has allocated as alive.</p> </li> <li> <p>Therefore he chunk that <code class="language-plaintext highlighter-rouge">*p</code> points to is also alive, so <code class="language-plaintext highlighter-rouge">*p</code> does not need to be marked directly, and will not be freed early.</p> </li> </ol> <p>The step (3) is crucial. By forcing the whole arena to be marked, any pointers stored in the arena into itself will be kept alive automatically, without the GC needing to know how to scan for them.</p> <p>So, even though <code class="language-plaintext highlighter-rouge">*New[*int](a) = new(int)</code> is still going to result in a use-after-free, <code class="language-plaintext highlighter-rouge">*New[*int](a) = New[int](a)</code> would not! This small improvement does not make arenas themselves safe, but a data structure with an internal arena can be completely safe, so long as the only pointers that go into the arena are from the arena itself.</p> <p>How can we make this work? The easy part is (4), which we can implement by adding a <code class="language-plaintext highlighter-rouge">[]unsafe.Pointer</code> to the arena, and sticking every pointer we allocate into it.</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>

  <span class="n">chunks</span> <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>  <span class="c">// New field.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip ...</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size,</span>
    <span class="c">// twice the last allocation, or the next power of two</span>
    <span class="c">// after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// ... snip ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Go</a></div></div> <p>The cost of the <code class="language-plaintext highlighter-rouge">append</code> is amortized: to allocate <code class="language-plaintext highlighter-rouge">n</code> bytes, we wind up allocating an additional <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> times. But what does this do to our benchmarks?</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         800.08 MB/s
BenchmarkArena/int/new-48           386.81 MB/s
BenchmarkArena/[2]int/arena-48      1236.00 MB/s
BenchmarkArena/[2]int/new-48        520.84 MB/s
BenchmarkArena/[64]int/arena-48     7999.71 MB/s
BenchmarkArena/[64]int/new-48       2706.68 MB/s
BenchmarkArena/[1024]int/arena-48   9998.00 MB/s
BenchmarkArena/[1024]int/new-48     2816.28 MB/s</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Console</a></div></div> <p>Seems pretty much the same, which is a good sign.</p> <h3 id="back-pointers"><a href="#back-pointers">Back Pointers</a></h3> <p>Now that the arena does not discard any allocated memory, we can focus on condition (3): making it so that if any pointer returned by <code class="language-plaintext highlighter-rouge">Alloc</code> is alive, then so is the whole arena.</p> <p>Here we can make use of an important property of how Go’s GC works: any pointer into an allocation will keep it alive, as well as <em>anything reachable from that pointer</em>. But the chunks we’re allocating are <code class="language-plaintext highlighter-rouge">[]uintptr</code>s, which will not be scanned. If there could <em>somehow</em> be a single pointer in this slice that was scanned, we would be able to stick the pointer <code class="language-plaintext highlighter-rouge">a *Arena</code> there, and so when anything that <code class="language-plaintext highlighter-rouge">Alloc</code> returns is scanned, it would cause <code class="language-plaintext highlighter-rouge">a</code> to be marked as alive.</p> <p>So far, we have been allocating <code class="language-plaintext highlighter-rouge">[N]uintptr</code> using <code class="language-plaintext highlighter-rouge">make([]T)</code>, but we would actually like to allocate <code class="language-plaintext highlighter-rouge">struct { A [N]uintptr; P unsafe.Pointer }</code>, where <code class="language-plaintext highlighter-rouge">N</code> is some dynamic value.</p> <p>In its infintie wisdom, the Go standard library actually gives us a dedicated mechanism to do this: <code class="language-plaintext highlighter-rouge">reflect.StructOf</code>. This can be used to construct arbitrary anonymous <code class="language-plaintext highlighter-rouge">struct</code> types at runtime, which we can then allocate on the heap.</p> <p>So, instead of calling <code class="language-plaintext highlighter-rouge">make</code>, we might call this function:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
    <span class="p">{</span>
      <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
      <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">words</span><span class="p">),</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()},</span>
  <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Go</a></div></div> <p>This appears to have a minor but noticeable effect on performance<sup id="fnref:type-cache" role="doc-noteref"><a href="#fn:type-cache" class="footnote" rel="footnote">6</a></sup>.</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         763.91 MB/s
BenchmarkArena/int/new-48           385.49 MB/s
BenchmarkArena/[2]int/arena-48      1174.00 MB/s
BenchmarkArena/[2]int/new-48        524.32 MB/s
BenchmarkArena/[64]int/arena-48     7563.54 MB/s
BenchmarkArena/[64]int/new-48       2649.63 MB/s
BenchmarkArena/[1024]int/arena-48   8668.02 MB/s
BenchmarkArena/[1024]int/new-48     2648.10 MB/s</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Console</a></div></div> <h2 id="more-optimizations"><a href="#more-optimizations">More Optimizations</a></h2> <p>Looking back at <code class="language-plaintext highlighter-rouge">Arena.Alloc</code>, the end of this function has a branch:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip...</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// Beware, offsetting to one-past-the-end is one of the few</span>
    <span class="c">// things explicitly not allowed by Go.</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Go</a></div></div> <p>This is the absolute hottest part of allocation, since it is executed every time we call this function. The branch is a bit unfortunate, but it’s necessary, as noted by the comment.</p> <p>In C++, if we have an array of <code class="language-plaintext highlighter-rouge">int</code> with <code class="language-plaintext highlighter-rouge">n</code> elements in it, and <code class="language-plaintext highlighter-rouge">int* p</code> is a pointer to the start of the array, <code class="language-plaintext highlighter-rouge">p + n</code> is a valid pointer, even though it can’t be dereferenced; it points “one past the end” of the array. This is a useful construction, since, for example, you can use it to eliminate a loop induction variable:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Naive for loop, has an induction variable i.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// Faster: avoids the extra variable increment in the loop</span>
<span class="c1">// body for doing p[i].</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">C++</a></div></div> <p>Go, however, gets very upset if you do this, because it confuses the garbage collector. The GC can’t tell the difference between a one-past-the-end pointer for allocation A, and for the start of allocation B immediately after it. At best this causes memory to stay alive for longer, and at worst it triggers safety interlocks in the GC. The GC will panic if it happens to scan a pointer for an address that it knows has been freed.</p> <p>But in our code above, every chunk now has an extra element at the very end that is not used for allocation, so we <em>can</em> have a pointer that <em>is</em> one-past-the-end of the <code class="language-plaintext highlighter-rouge">[N]uintptr</code> that we are vending memory from.</p> <p>The updated allocation function would look like this:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip ...</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Go</a></div></div> <p>Notably, we do not replace <code class="language-plaintext highlighter-rouge">a.left</code> with an end pointer, because of the <code class="language-plaintext highlighter-rouge">if a.left &lt; words</code> comparison. We can’t actually avoid the subtraction <code class="language-plaintext highlighter-rouge">a.left -= words</code> because we would have to do it to make this comparison work if we got rid of <code class="language-plaintext highlighter-rouge">a.left</code>.</p> <p>So how much better is this?</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         780.07 MB/s
BenchmarkArena/int/new-48           383.16 MB/s
BenchmarkArena/[2]int/arena-48      1245.73 MB/s
BenchmarkArena/[2]int/new-48        530.39 MB/s
BenchmarkArena/[64]int/arena-48     7684.39 MB/s
BenchmarkArena/[64]int/new-48       2679.94 MB/s
BenchmarkArena/[1024]int/arena-48   8859.99 MB/s
BenchmarkArena/[1024]int/new-48     2611.33 MB/s</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Console</a></div></div> <p>Remarkably, not very! This is an improvement on the order of magnitude of one or two percentage points. This is because the branch we deleted is extremely predictable. Because Go’s codegen is relatively mediocre, the effect of highly predictable branches (assuming Go actually schedules the branches correctly 🙄) is quite minor.</p> <p>Turns out there’s a bigger improvement we can make.</p> <h3 id="write-barriers"><a href="#write-barriers">Write Barriers</a></h3> <p>Here’s the assembly Go generated for this function, heavily abridged, and annotated with the corresponding Go source code.</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">(*</span><span class="err">Arena</span><span class="p">).</span><span class="err">Alloc</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JBE</span>     <span class="err">moreStack</span>  <span class="c1">; Stack growth prologue.</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">0x58</span><span class="p">,</span> <span class="err">SP</span>

  <span class="c1">; size = (size + mask) &amp;^ mask</span>
  <span class="err">LEAQ</span>    <span class="m">0x7</span><span class="p">(</span><span class="err">BX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">ANDQ</span>    <span class="err">$</span><span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">,</span> <span class="err">DX</span>
  <span class="c1">; words := size / wordBytes</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">SI</span>
  <span class="err">SHRQ</span>    <span class="err">$</span><span class="m">0x3</span><span class="p">,</span> <span class="err">DX</span>

  <span class="c1">; if a.left &lt; words</span>
  <span class="err">CMPQ</span>    <span class="m">0x8</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">JAE</span>     <span class="err">alloc</span>

  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">SI</span><span class="p">,</span> <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>

  <span class="c1">; nextPow2(words)</span>
  <span class="err">MOVZX</span>   <span class="err">runtime</span><span class="p">.x</span><span class="m">86</span><span class="err">HasPOPCNT</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">DI</span>
  <span class="err">TESTL</span>   <span class="err">DI</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">XORL</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">POPCNTQ</span> <span class="err">DX</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">JMP</span>     <span class="m">2</span><span class="err">f</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">CALL</span>    <span class="err">math/bits</span><span class="p">.</span><span class="err">OnesCount</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">CMPQ</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">$</span><span class="m">0x1</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">BSRQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">$</span><span class="m">-0</span><span class="p">x</span><span class="m">1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">CMOVE</span>   <span class="err">DI</span><span class="p">,</span> <span class="err">CX</span>
  <span class="err">INCQ</span>    <span class="err">CX</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">SHLQ</span>    <span class="err">CL</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">$</span><span class="m">0x40</span>
  <span class="err">SBBQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">R8</span>
  <span class="err">ANDQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">MOVQ</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">DX</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="m">0x10</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">SHLQ</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">CX</span>

  <span class="c1">; a.cap = max(minWords, a.cap*2, nextPow2(words))</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">$</span><span class="m">0x8</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMOVA</span>   <span class="err">CX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMPQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMOVA</span>   <span class="err">DX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; a.next = a.allocChunk(a.cap)</span>
  <span class="err">CALL</span>    <span class="err">github</span><span class="p">.</span><span class="err">com/mcy/go-arena</span><span class="p">.(*</span><span class="err">Arena</span><span class="p">).</span><span class="err">allocChunk</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JNE</span>     <span class="m">1</span><span class="err">f</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">JMP</span>     <span class="m">2</span><span class="err">f</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>

  <span class="c1">; a.left = a.cap</span>
  <span class="err">MOVQ</span>    <span class="m">0x10</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x28</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="m">0x20</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">INCQ</span>    <span class="err">BX</span>
  <span class="err">MOVQ</span>    <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">JAE</span>     <span class="m">2</span><span class="err">f</span>

  <span class="c1">; a.chunks = append(a.chunks, a.next)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x50</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">LEAQ</span>    <span class="m">0x28f70</span><span class="p">(</span><span class="err">IP</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">growslice</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x28</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="m">0x50</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0x20</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">(</span><span class="err">R8</span><span class="p">)(</span><span class="err">BX</span><span class="p">*</span><span class="m">8</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">(</span><span class="err">R8</span><span class="p">)(</span><span class="err">BX</span><span class="p">*</span><span class="m">8</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">MOVQ</span>    <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">SI</span>

<span class="nl">alloc:</span>
  <span class="c1">; p := a.next</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">CX</span>

  <span class="c1">; a.next = unsafe.Add(a.next, size)</span>
  <span class="err">LEAQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">CX</span><span class="p">)(</span><span class="err">SI</span><span class="p">*</span><span class="m">1</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">MOVQ</span>    <span class="err">SI</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; a.left -= words</span>
  <span class="err">LEAQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">CX</span><span class="p">)(</span><span class="err">SI</span><span class="p">*</span><span class="m">1</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">SUBQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; return p</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">0x58</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">x86 Assembly (Go Syntax)</a></div></div> <p>There’s a lot going on in this function, but most of it is a mix of Go not being great at register allocation, and lots of <em>write barriers</em>.</p> <p>A write barrier is a mechanism for synchronizing ordinary user code with the GC. Go generates code for one any time a non-pointer-free type is stored. For example, writing to a <code class="language-plaintext highlighter-rouge">**int</code>, <code class="language-plaintext highlighter-rouge">*string</code>, or <code class="language-plaintext highlighter-rouge">*[]int</code> requires a write barrier.</p> <p>Write barriers are implemented as follows:</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">runtime.writeBarrier</code> is checked, which determines whether the write barrier is necessary, which is only when the GC is in the mark phase. Otherwise the branch is taken to skip the write barrier.</p> </li> <li> <p>A call to one of the <code class="language-plaintext highlighter-rouge">runtime.gcWriteBarrierN</code> functions happens. <code class="language-plaintext highlighter-rouge">N</code> is the number of pointers that the GC needs to be informed of.</p> </li> <li> <p>This function calls <code class="language-plaintext highlighter-rouge">runtime.gcWriteBarrier</code>, which returns a buffer onto which pointers the GC needs to now trace through should be written to.</p> </li> <li> <p>The actual store happens.</p> </li> </ol> <p>A write barrier is required for a case like the following. Consider the following code.</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">alloc</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Go</a></div></div> <p>This function will call <code class="language-plaintext highlighter-rouge">runtime.newobject</code> to allocate eight bytes of memory. The resulting pointer will be returned in <code class="language-plaintext highlighter-rouge">rax</code>. This function then stores <code class="language-plaintext highlighter-rouge">rax</code> into <code class="language-plaintext highlighter-rouge">n</code> and returns. If we Godbolt this function, we’ll find that it does, in fact, generate a write barrier:</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">x.</span><span class="err">alloc</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JLS</span>     <span class="err">growStack</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>

  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">main</span><span class="p">.</span><span class="err">n+</span><span class="m">32</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>

  <span class="c1">; new(int)</span>
  <span class="err">LEAQ</span>    <span class="nl">type:</span><span class="err">int</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">newobject</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>

  <span class="err">MOVQ</span>    <span class="err">main</span><span class="p">.</span><span class="err">n+</span><span class="m">32</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">TESTB</span>   <span class="err">AL</span><span class="p">,</span> <span class="p">(</span><span class="err">CX</span><span class="p">)</span>

  <span class="c1">; This is the write barrier.</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0</span>
  <span class="err">JEQ</span>     <span class="err">skip</span>
  <span class="err">MOVQ</span>    <span class="p">(</span><span class="err">CX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="nl">skip:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="p">(</span><span class="err">CX</span><span class="p">)</span>  <span class="c1">; The actual store.</span>

  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span>

<span class="nl">growStack:</span>
  <span class="err">NOP</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">JMP</span>     <span class="p">x.</span><span class="err">alloc</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">x86 Assembly (Go Syntax)</a></div></div> <p>Note that two pointers get written: the pointer returned by <code class="language-plaintext highlighter-rouge">new(int)</code>, and the old value of <code class="language-plaintext highlighter-rouge">*n</code>. This ensures that regardless of where in this function the GC happens to be scanning through <code class="language-plaintext highlighter-rouge">*n</code>, it sees both values during the mark phase.</p> <p>Now, this isn’t necessary if the relevant pointers are already reachable in some other way… which is exactly the case in our arena (thanks to the <code class="language-plaintext highlighter-rouge">chunks</code> slice). So the write barrier in the fast path is redundant.</p> <p>But, how do we get rid of it? There is <code class="language-plaintext highlighter-rouge">//go:nowritebarrier</code>, but that’s not allowed outside of a list of packages allowlisted in the compiler. It also doens’t disable write barriers; it simply generates a diagnostic if any are emitted.</p> <p>But remember, write barriers only occur when storing pointer-typed memory… so we can just replace <code class="language-plaintext highlighter-rouge">next unsafe.Pointer</code> with <code class="language-plaintext highlighter-rouge">next uintptr</code>.</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="kt">uintptr</span> <span class="c">// A real pointer!</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>

  <span class="n">chunks</span> <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">wordBytes</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>

    <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">allocChunk</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">+=</span> <span class="n">size</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">Go</a></div></div> <p><code class="language-plaintext highlighter-rouge">go vet</code> hates this, because it doesn’t know that we’re smarter than it is. Does This make the code faster? To make it a little bit more realistic, I’ve written a separate variant of the benchmarks that hammers the GC really hard in a separate G:</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GC</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}()</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">Go</a></div></div> <p>The result indicates that this is a worthwhile optimization for churn-heavy contexts. Performance is much worse overall, but that’s because the GC is pre-empting everyone. The improvement seems to be on the order of 20% for very small allocations.</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">#</span><span class="w"> </span>Before
<span class="go">BenchmarkArena/int/arena-48         169.09 MB/s
BenchmarkArena/int/new-48           84.73 MB/s
BenchmarkArena/[2]int/arena-48      309.40 MB/s
BenchmarkArena/[2]int/new-48        120.23 MB/s
BenchmarkArena/[64]int/arena-48     1954.16 MB/s
BenchmarkArena/[64]int/new-48       950.48 MB/s
BenchmarkArena/[1024]int/arena-48   3341.13 MB/s
BenchmarkArena/[1024]int/new-48     1413.26 MB/s

</span><span class="gp">#</span><span class="w"> </span>After
<span class="go">BenchmarkArena/int/arena-48         195.58 MB/s
BenchmarkArena/int/new-48           83.67 MB/s
BenchmarkArena/[2]int/arena-48      352.49 MB/s
BenchmarkArena/[2]int/new-48        120.13 MB/s
BenchmarkArena/[64]int/arena-48     1987.22 MB/s
BenchmarkArena/[64]int/new-48       903.78 MB/s
BenchmarkArena/[1024]int/arena-48   3342.67 MB/s
BenchmarkArena/[1024]int/new-48     1439.99 MB/s</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">Console</a></div></div> <h3 id="cutting-out-the-heap-entirely"><a href="#cutting-out-the-heap-entirely">Cutting Out The Heap Entirely</a></h3> <p>Another source of slowdown is the fact that any time we allocate from the heap, it’s forced to eagerly clear the huge allocated chunk every time, because it contains pointers. If you profile this code, a ton of time is spent in <code class="language-plaintext highlighter-rouge">runtime.memclrNoHeapPointers</code>. Because the chunks of memory we allocate are always of a specific size, we can use an array of <code class="language-plaintext highlighter-rouge">sync.Pool</code>s to amortize the cost of allocating and clearing chunks.</p> <p>First, we need an entry in this array of pools, one for each size of memory we allocate. Then, we need to set a finalizer on the arena to reclaim its memory once we’re done. Finally, we can change the contract of <code class="language-plaintext highlighter-rouge">Alloc</code> to require the caller to clear the value for us, and change <code class="language-plaintext highlighter-rouge">New</code> take a value as its argument:</p> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="n">Allocator</span><span class="p">,</span> <span class="n">v</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">Go</a></div></div> <p>What’s nice about this is that it avoids having to clear the value if a non-zero value would be allocated to it instead.</p> <p>Putting this all together, it would look like this:</p> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">pools</span> <span class="p">[</span><span class="m">64</span><span class="p">]</span><span class="n">sync</span><span class="o">.</span><span class="n">Pool</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">pools</span> <span class="p">{</span>
    <span class="n">pools</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">New</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="n">any</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
        <span class="p">{</span>
          <span class="n">Name</span><span class="o">:</span> <span class="s">"A"</span><span class="p">,</span>
          <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
        <span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"P"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()},</span>
      <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="c">// If this is the first chunk allocated, set a finalizer.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">SetFinalizer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">Arena</span><span class="p">)</span><span class="o">.</span><span class="n">finalize</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Place the returned chunk at the offset in a.chunks that</span>
  <span class="c">// corresponds to its log, so we can identify its size easily</span>
  <span class="c">// in the loop above.</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">log</span><span class="o">+</span><span class="m">1</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">finalize</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">log</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="n">words</span> <span class="o">:=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">log</span>
    <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// Make sure that we don't leak the arena.</span>

    <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:25">Go</a></div></div> <p>How does this perform?</p> <div class="codeblock" id="code:26"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48        1260.73 MB/s
BenchmarkArena/int/new-48          712.94 MB/s
BenchmarkArena/[2]int/arena-48     2457.27 MB/s
BenchmarkArena/[2]int/new-48       1167.57 MB/s
BenchmarkArena/[64]int/arena-48    4491.49 MB/s
BenchmarkArena/[64]int/new-48      6800.76 MB/s
BenchmarkArena/[1024]int/arena-48  3992.32 MB/s
BenchmarkArena/[1024]int/new-48    4320.65 MB/s</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:26">Console</a></div></div> <p>Well. That’s a surprise. It does much better for small allocations, but it made really big allocations worse! It’s not immediately clear to me why this is, but note that <code class="language-plaintext highlighter-rouge">new</code> also got <em>much</em> faster, which tells me that because the allocations from the arena are longer-lived, the GC behaves somewhat differently, causing some of the cost from allocating really large things with <code class="language-plaintext highlighter-rouge">new</code> to be amortized.</p> <p>Whether this optimization makes sense would require some profiling. An alternative is to manually manage arena re-use, by adding a very unsafe <code class="language-plaintext highlighter-rouge">Reset()</code> function that causes the arena to behave as if it was just constructed, but <em>keeping all of its allocated chunks</em>. This is analogous to reslicing to zero: <code class="language-plaintext highlighter-rouge">x = x[:0]</code>.</p> <p>This is very unsafe because it can lead to the same memory being allocated twice: this is <em>only</em> ok if the memory is not re-used.</p> <p>Implementing this is very simple.</p> <div class="codeblock" id="code:27"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">log</span> <span class="p">{</span>
    <span class="c">// If we've already allocated a chunk of this size in a previous arena</span>
    <span class="c">// generation, return it.</span>
    <span class="c">//</span>
    <span class="c">// This relies on the fact that an arena never tries to allocate the same</span>
    <span class="c">// size of chunk twice between calls to Reset().</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="c">// ... snip ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:27">Go</a></div></div> <p>Then, if we modify our arena benchmark to take advantage of this…</p> <div class="codeblock" id="code:28"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"arena"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">Arena</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>  <span class="c">// Important!</span>
    <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
      <span class="n">sink</span> <span class="o">=</span> <span class="n">arena</span><span class="o">.</span><span class="n">New</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">a</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:28">Go</a></div></div> <p>What does the performance look like now?</p> <div class="codeblock" id="code:29"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         2376.01 MB/s
BenchmarkArena/int/new-48           377.64 MB/s
BenchmarkArena/[2]int/arena-48      4314.98 MB/s
BenchmarkArena/[2]int/new-48        530.62 MB/s
BenchmarkArena/[64]int/arena-48     10496.49 MB/s
BenchmarkArena/[64]int/new-48       3959.85 MB/s
BenchmarkArena/[1024]int/arena-48   9735.19 MB/s
BenchmarkArena/[1024]int/new-48     6160.73 MB/s</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:29">Console</a></div></div> <p>That’s a massive improvement! There’s a couple of reasons this is faster. First, it doesn’t require waiting for the GC to collect old arenas to make their memory get reused. Second, the fast path is <em>very</em> fast with no synchronization.</p> <p>On the flipside, this is very dangerous: arena re-use needs to be carefully managed, because you can wind up with unique pointers that aren’t.</p> <h3 id="realloc"><a href="#realloc">Realloc</a></h3> <p>Go does not offer an easy mechanism to “reallocate” an allocation, as with <code class="language-plaintext highlighter-rouge">realloc()</code> in C. This is because it has no mechanism for freeing pointers explicitly, which is necessary for a reallocation abstraction.</p> <p>But we already don’t care about safety, so we can offer reallocation on our arena. Now, the reallocation we can offer is quite primitive: if a chunk happens to be the most recent one allocated, we can grow it. Otherwise we just allocate a new chunk and don’t free the old one.</p> <p>This makes it possible to implement “arena slices” that can be constructed by appending, which will not trigger reallocation on slice growth as long as nothing else gets put on the arena.</p> <p><code class="language-plaintext highlighter-rouge">Realloc</code> would look something like this:</p> <div class="codeblock" id="code:30"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Realloc</span><span class="p">(</span>
  <span class="n">ptr</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span>
  <span class="n">oldSize</span><span class="p">,</span> <span class="n">newSize</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">,</span>
<span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">oldSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldSize</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="n">newSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">newSize</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>

  <span class="k">if</span> <span class="n">newSize</span> <span class="o">&lt;=</span> <span class="n">oldSize</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ptr</span>
  <span class="p">}</span>

  <span class="c">// Check if this is the most recent allocation. If it is,</span>
  <span class="c">// we can grow in-place.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">-</span> <span class="n">oldSize</span> <span class="o">==</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Check if we have enough space available for the</span>
    <span class="c">// requisite extra space.</span>
    <span class="n">need</span> <span class="o">:=</span> <span class="p">(</span><span class="n">newSize</span> <span class="o">-</span> <span class="n">oldSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">wordBytes</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">need</span> <span class="p">{</span>
      <span class="c">// Grow in-place.</span>
      <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">need</span>
      <span class="k">return</span> <span class="n">ptr</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c">// Can't grow in place, allocate new memory and copy to it.</span>
  <span class="nb">new</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
  <span class="nb">copy</span><span class="p">(</span>
    <span class="n">unsafe</span><span class="o">.</span><span class="n">Slice</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nb">new</span><span class="p">),</span> <span class="n">newSize</span><span class="p">),</span>
    <span class="n">unsafe</span><span class="o">.</span><span class="n">Slice</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">oldSize</span><span class="p">),</span>
  <span class="p">)</span>

  <span class="k">return</span> <span class="nb">new</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:30">Go</a></div></div> <p>Then, whenever we append to our arena slice, we can call <code class="language-plaintext highlighter-rouge">a.Realloc()</code> to grow it. However, this does not work if the slice’s base pointer is not the original address returned by <code class="language-plaintext highlighter-rouge">Alloc</code> or <code class="language-plaintext highlighter-rouge">Realloc</code>. It is an exercise for the reader to:</p> <ol> <li> <p>Implement a <code class="language-plaintext highlighter-rouge">Slice[T]</code> type that uses an arena for allocation.</p> </li> <li> <p>Make this work for any value of <code class="language-plaintext highlighter-rouge">ptr</code> within the most recent allocation, not just the base offset. This requires extra book-keeping.</p> </li> </ol> <h2 id="all-together"><a href="#all-together">All Together</a></h2> <p>Here is the entirety of the code that we have developed, not including the reallocation function above.</p> <div class="codeblock" id="code:31"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">arena</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"math/bits"</span>
  <span class="s">"reflect"</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">,</span> <span class="n">v</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>
  <span class="n">chunks</span>    <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="n">maxAlign</span> <span class="kt">uintptr</span> <span class="o">=</span> <span class="m">8</span> <span class="c">// Depends on target, this is for 64-bit.</span>
  <span class="n">minWords</span> <span class="kt">uintptr</span> <span class="o">=</span> <span class="m">8</span>
<span class="p">)</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// First, round the size up to the alignment of every object in the arena.</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">maxAlign</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="c">// Then, replace the size with the size in pointer-sized words. This does not</span>
  <span class="c">// result in any loss of size, since size is now a multiple of the uintptr</span>
  <span class="c">// size.</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">maxAlign</span>

  <span class="c">// Next, check if we have enough space left for this chunk. If there isn't,</span>
  <span class="c">// we need to grow.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size, twice the last</span>
    <span class="c">// allocation, or the next power of two after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">allocChunk</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>

    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">pools</span> <span class="p">[</span><span class="m">64</span><span class="p">]</span><span class="n">sync</span><span class="o">.</span><span class="n">Pool</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">pools</span> <span class="p">{</span>
    <span class="n">pools</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">New</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="n">any</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
        <span class="p">{</span>
          <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
          <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
        <span class="p">},</span>
        <span class="p">{</span> <span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()</span> <span class="p">},</span>
      <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">log</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="c">// If this is the first chunk allocated, set a finalizer.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">SetFinalizer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">Arena</span><span class="p">)</span><span class="o">.</span><span class="n">finalize</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Place the returned chunk at the offset in a.chunks that</span>
  <span class="c">// corresponds to its log, so we can identify its size easily</span>
  <span class="c">// in the loop above.</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">log</span><span class="o">+</span><span class="m">1</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">finalize</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">log</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="n">words</span> <span class="o">:=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">log</span>
    <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// Make sure that we don't leak the arena.</span>

    <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="o">.</span><span class="n">Len</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:31">Go</a></div></div> <p>There are other optimizations that we could make here that I haven’t discussed. For example, arenas could be re-used; once an arena is done, it could be “reset” and placed into a <code class="language-plaintext highlighter-rouge">sync.Pool</code>. This arena would not need to go into the GC to request new chunks, re-using the ones previously allocated (and potentially saving on the cost of zeroing memory over and over again).</p> <p>I did say that this relies very heavily on Go’s internal implementation details. Whats the odds that they get broken in the future? Well, the requirement that allocations know their shape is forced by the existence of <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>, and the requirement that a pointer into any part of an allocation keeps the whole thing alive essentially comes from slices being both sliceable and mutable; once a slice escapes to the heap (and thus multiple goroutines) coordinating copies for shrinking a slice would require much more complexity than the current write barrier implementation.</p> <p>And in my opinion, it’s pretty safe to say that Hyrum’s Law has us covered here. ;)</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:goub" role="doc-endnote"> <p>Go <em>does</em> have some UB. For example, Go assumes that a G’s stack is never read or written to by any other G, except by the GC across a write barrier.</p> <p>That said, what UB does exist is very, very difficult to trip on purpose. <a href="#fnref:goub" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:g" role="doc-endnote"> <p>I almost exclusively refer to goroutines as Gs here, since it makes it easy to refer to Ps and Ms as needed. See <a href="https://go.dev/src/runtime/HACKING#scheduler-structures">https://go.dev/src/runtime/HACKING#scheduler-structures</a>. <a href="#fnref:g" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptr-bits-endian" role="doc-endnote"> <p>The pointer bits are in big endian order, so the first bit in left-to-right order corresponds to the first word. <a href="#fnref:ptr-bits-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:itab" role="doc-endnote"> <p>The “itab”, or interface table part of an interface value is not managed by the GC; it is allocated in persistent memory, so even though it is a pointer, it is not a pointer the GC needs to care about. <a href="#fnref:itab" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:hchan" role="doc-endnote"> <p>Internal implementation of the <code class="language-plaintext highlighter-rouge">chan T</code> type, which is implemented as a <code class="language-plaintext highlighter-rouge">*runtime.hchan</code>. See <a href="https://cs.opensource.google/go/go/+/master:src/runtime/chan.go;l=34;drc=a204ed53d907c3b325e3c2bdd6f847a8f97e90d9">https://cs.opensource.google/go/go/+/master:src/runtime/chan.go;l=34;drc=a204ed53d907c3b325e3c2bdd6f847a8f97e90d9</a>. <a href="#fnref:hchan" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:type-cache" role="doc-endnote"> <p>This can be made better by caching the <code class="language-plaintext highlighter-rouge">reflect.Type</code>s, but that is only a very slight improvement on the order of 1% speedup. Most of the slowdown is because Go is a bit more eager about zeroing allocations of values that contain pointers.</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">types</span> <span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Pre-allocate the whole array. There aren't that many powers</span>
  <span class="c">// of two. Don't need to go beyond 1&lt;&lt;61, since that's about as</span>
  <span class="c">// large of an allocation as Go will service (trying to create</span>
  <span class="c">// a larger array will panic).</span>
  <span class="n">types</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span> <span class="m">61</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">types</span> <span class="p">{</span>
    <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
      <span class="p">{</span>
        <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
        <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
      <span class="p">},</span>
      <span class="p">{</span> <span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()</span> <span class="p">},</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">log</span><span class="p">])</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Go</a></div></div> <p>However, with this in place, we can be assured that property (3) now holds, so it’s perfectly safe to place arena pointers into arena-allocated memory, so long as it’s across the same arena. <a href="#fnref:type-cache" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-15 • 805 words • 8 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/15/protobuf-tip-2/"> Protobuf Tip #2: Compress Your Protos! </a></h1> </div> <div class="post"> <p><em>As a matter of fact, when compression technology came along, we thought the future in 1996 was about voice. We got it wrong. It is about voice, video, and data, and that is what we have today on these cell phones. –Steve Buyer</em></p> <p>TL;DR: Compression is everywhere: CDNs, HTTP servers, even in RPC frameworks like Connect. This pervasiveness means that wire size tradeoffs matter less than they used to twenty years ago, when Protobuf was designed.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-2-compress-protos">buf.build blog</a>.</p> </blockquote> <h2 id="varints-from-1998"><a href="#varints-from-1998">Varints from 1998</a></h2> <p>Protobuf’s wire format is intended to be relatively small. It makes use of <em>variable-width integers</em> so that smaller values take up less space on the wire. Fixed width integers might be larger on the wire, but often have faster decoding times.</p> <p>But what if I told you that doesn’t matter?</p> <p>See, most internet traffic is compressed. Bandwidth is precious, and CDN operators don’t want to waste time sending big blobs full of zeros. There are many compression algorithms available, but the state of the art for HTTP requests (which dominates much of global internet traffic) is <a href="https://en.wikipedia.org/wiki/Brotli">Brotli</a>, an algorithm developed at Google in 2013 and standardized in IETF <a href="https://datatracker.ietf.org/doc/html/rfc7932">RFC7932</a> in 2016. There is a very good chance that this article was delivered to your web browser as a Brotli-compressed blob.</p> <h2 id="using-compression"><a href="#using-compression">Using Compression</a></h2> <p>How compression is applied in your case will vary, but both Connect RPC and gRPC support native compression. For example, Connect has an API for injecting compression providers: <a href="https://pkg.go.dev/connectrpc.com/connect#WithCompression">https://pkg.go.dev/connectrpc.com/connect#WithCompression</a>.</p> <p>Connect uses <code class="language-plaintext highlighter-rouge">gzip</code> by default, which uses the DEFLATE compression algorithm. Providing your own compression algorithm (such as Brotli) is pretty simple, as shown by <a href="https://github.com/mattrobenolt/connect-brotli/blob/921ee0236bcd2d66827590c6890bb850e56516ad/connect_brotli.go">this third-party package</a>.</p> <p>Other services may compress for you transparently. Any competent CDN will likely use Brotli (or <code class="language-plaintext highlighter-rouge">gzip</code> or <code class="language-plaintext highlighter-rouge">zlib</code>, but probably Brotli) to compress any files it serves for you. (In fact, JavaScript and HTML minimization can often be rendered irrelevant by HTTP compression, too.)</p> <p>It’s important to remember that Protobuf predates pervasive compression: if it didn’t, it would almost certainly not use variable-width integers for anything. It only uses them because they offer a primitive form of compression in exchange for being slower to decode. If that tradeoff was eliminated, Protobuf would almost certainly only use fixed-width integers on the wire.</p> <h2 id="how-good-is-it-really"><a href="#how-good-is-it-really">How Good Is It Really?</a></h2> <p>Let’s do some apples-to-apples comparisons. Consider the following Protobuf type.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
	<span class="k">repeated</span> <span class="kt">int32</span> <span class="na">varints</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">repeated</span> <span class="kt">sfixed32</span> <span class="na">fixeds</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Protobuf</a></div></div> <p>There are two fields that contain essentially the same data, which can be encoded in four different ways: as old-style repeated fields, as packed fields, and the integers can be encoded as varints or fixed32 values.</p> <p>Using <a href="https://github.com/protocolbuffers/protoscope">Protoscope</a>, we can create some data that exercises these four cases:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># a.pb, repeated varint
</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">2</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">3</span>
<span class="c1"># ...
</span>
<span class="c1"># b.pb, packed varint
</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
  <span class="c1"># ...
</span><span class="p">}</span>

<span class="c1"># c.pb, repeated fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="n">i32</span>

<span class="c1"># d.pb, packed fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span><span class="n">i32</span> <span class="mi">2</span><span class="n">i32</span> <span class="mi">3</span><span class="n">i32</span>
  <span class="c1"># ...
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Protoscope</a></div></div> <p>Each blob contains the integers from 1 to 1000 encoded in different ways. I’ll compress each one using gzip, zlib, and Brotli, using their default compression levels, and arrange their sizes, in bytes, in the table below.</p> <table> <thead> <tr> <th>File</th> <th>Uncompressed</th> <th><code class="language-plaintext highlighter-rouge">gzip</code> (DEFLATE)</th> <th><code class="language-plaintext highlighter-rouge">zlib</code></th> <th>Brotli</th> </tr> </thead> <tbody> <tr> <td>a.pb</td> <td>2875</td> <td>1899</td> <td>1878</td> <td>1094</td> </tr> <tr> <td>b.pb</td> <td>1877</td> <td>1534</td> <td>1524</td> <td>885</td> </tr> <tr> <td>c.pb</td> <td>5005</td> <td>1577</td> <td>1567</td> <td>1140</td> </tr> <tr> <td>d.pb</td> <td>4007</td> <td>1440</td> <td>1916</td> <td>1140</td> </tr> </tbody> </table> <p>Compression achieves incredible results: Brotli manages to get all of the files down to around 1.1 kB, except for the packed varints, which it gets about 250 bytes smaller! Of course, that’s only because most of the values in that repeated field are small. If the values range from 100000 to 101000, b.pb and d.pb are 3006 and 4007 bytes respectively (see that d.pb’s size is unchanged!), but when compressed with brotli, the lead for b.pb starts to disappear: 1039 bytes vs. 1163 bytes. Now it’s only 120 bytes smaller.</p> <h2 id="are-varints-still-better"><a href="#are-varints-still-better">Are Varints Still Better?</a></h2> <p>Applying compression can often have similar results to replacing everything with varints, but not exactly: using a varint will likely always be slightly smaller, at least when using state-of-the-art compression like Brotli. But you can pretty much always assume you <em>will</em> be using compression, such as to compress HTTP headers and other ancillary content in your request. Compression is generic and highly optimized—it applies to all data, regardless of schema, and is often far more optimized than application-level codecs like those in a Protobuf library.</p> <p>Not to mention, you should definitely be compressing any large data blobs you’re storing on disk, too!</p> <p>As a result, you can usually disregard many encoded size concerns when making tradeoffs in designing a Protobuf type. Fixed integer types will decode faster, so if decoding speed is important to you, and you’re worried about the size on the wire, don’t. It’s almost certainly already taken care of at a different layer of the stack.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-14 • 4179 words • 46 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> </span> <h1><a href="/2025/04/14/target-triples/"> What the Hell Is a Target Triple? </a></h1> </div> <div class="post"> <p><em>Cross-compiling</em> is taking a computer program and compiling it for a machine that isn’t the one hosting the compilation. Although historically compilers would only compile for the host machine, this is considered an anachronism: all serious native compilers are now cross-compilers.</p> <p>After all, you don’t want to be building your iPhone app on literal iPhone hardware.</p> <p>Many different compilers have different mechanisms for classifying and identifying <em>targets</em>. A target is a platform that the compiler can produce executable code for. However, due to the runaway popularity of LLVM, virtually all compilers now use <em>target triples</em>. You may have already encountered one, such as the venerable <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code>, or the evil <code class="language-plaintext highlighter-rouge">x86_64-pc-windows</code>. This system is convoluted and <em>almost</em> self-consistent.</p> <p>But what is a target triple, and where did they come from?</p> <h2 id="stupid-gcc-conventions"><a href="#stupid-gcc-conventions">Stupid GCC Conventions</a></h2> <p>So if you go poking around the <a href="https://wiki.osdev.org/Target_Triplet">Target Triplet</a> page on OSDev, you will learn both true and false things about target triples, because this page is about GCC, not native compilers in general.</p> <blockquote id="warning:1" class="warning"> <p><a href="#warning:1"><span class="chip">warning</span></a></p> <p>Generally, there is no “ground truth” for what a target triple is. There isn’t some standards body that assigns these names. But as we’ll see, LLVM is the trendsetter.</p> </blockquote> <p>If you run the following command you can learn the target triple for your machine:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>gcc <span class="nt">-dumpmachine</span>
<span class="go">x86_64-linux-gnu</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Console</a></div></div> <p>Now if you’re at all familiar with any system that makes pervasive use of target triples, you will know that this is <em>not a target triple</em>, because this target’s name is <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-gnu</code>, which is what both <code class="language-plaintext highlighter-rouge">clang</code> and <code class="language-plaintext highlighter-rouge">rustc</code> call-</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>clang <span class="nt">-dumpmachine</span>
<span class="go">x86_64-pc-linux-gnu
</span><span class="gp">$</span><span class="w"> </span>rustc <span class="nt">-vV</span> | <span class="nb">grep </span>host
<span class="go">host: x86_64-unknown-linux-gnu</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Console</a></div></div> <p>Oh no.</p> <p>Well, GCC is missing the the <code class="language-plaintext highlighter-rouge">pc</code> or <code class="language-plaintext highlighter-rouge">unknown</code> component, and that’s specifically a GCC thing; it allows omitting parts of the triple in such a way that is unambiguous. And they are a GCC invention, so perhaps it’s best to start by assessing GCC’s beliefs.</p> <p>According to GCC, a target triple is a string of the form <code class="language-plaintext highlighter-rouge">&lt;machine&gt;-&lt;vendor&gt;-&lt;os&gt;</code>. The “machine” part unambiguously identifies the architecture of the system. Practically speaking, this is the assembly language that the compiler will output at the end. The “vendor” part is essentially irrelevant, and mostly is of benefit for sorting related operating systems together. Finally, the “os” part identifies the operating system that this code is being compiled for. The main thing this identifies for a compiler is the executable format: COFF/PE for Windows, Mach-O for Apple’s operating systems, ELF for Linux and friends, and so on (this, however, is an oversimplification).</p> <p>But you may notice that <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-gnu</code> has an extra, fourth entry<sup id="fnref:quad" role="doc-noteref"><a href="#fn:quad" class="footnote" rel="footnote">1</a></sup>, which plays many roles but is most often called the target’s “ABI”. For <code class="language-plaintext highlighter-rouge">linux</code>, it identifies the target’s libc, which has consequences for code generation of some language features, such as thread locals and unwinding. It is optional, since many targets only have one ABI.</p> <h3 id="cross-compiling-with-gcc"><a href="#cross-compiling-with-gcc">Cross Compiling with GCC</a></h3> <p>A critical piece of history here is to understand the really stupid way in which GCC does cross compiling. Traditionally, each GCC binary would be built for <em>one</em> target triple. The full name of a GCC binary would include the triple, so when cross-compiling, you would compile with <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-gcc</code>, link with <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-ld</code>, and so on (here, <code class="language-plaintext highlighter-rouge">gcc</code> is not the fourth ABI component of a triple; it’s just one of the tools in the <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code> toolchain).</p> <p>Nobody with a brain does this<sup id="fnref:toolchain" role="doc-noteref"><a href="#fn:toolchain" class="footnote" rel="footnote">2</a></sup>. LLVM and all cross compilers that follow it instead put all of the backends in one binary, and use a compiler flag like <code class="language-plaintext highlighter-rouge">--target</code> to select the backend.</p> <p>But regardless, this is where target triples come from, and why they look the way they look: they began as prefixes for the names of binaries in <code class="language-plaintext highlighter-rouge">autoconf</code> scripts.</p> <p>But GCC is ancient technology. In the 21st century, LLVM rules all native compilers.</p> <h2 id="names-in-the-ancient-language"><a href="#names-in-the-ancient-language">Names in the Ancient Language</a></h2> <p>LLVM’s target triple list is the one that should be regarded as “most official”, for a few reasons:</p> <ol> <li> <p>Inertia. Everyone and their mother uses LLVM as a middleend and backend, so its naming conventions bubble up into language frontends like <code class="language-plaintext highlighter-rouge">clang</code>, <code class="language-plaintext highlighter-rouge">rustc</code> <code class="language-plaintext highlighter-rouge">swiftc</code>, <code class="language-plaintext highlighter-rouge">icc</code>, and <code class="language-plaintext highlighter-rouge">nvcc</code>.</p> </li> <li> <p>Upstream work by silicon and operating system vendors. LLVM is what people get hired to work on for the most part, not GCC, so its platform-specific conventions often reflect the preferences of vendors.</p> </li> </ol> <p>These are in no small part because Apple, Google, and Nvidia have armies of compiler engineers contributing to LLVM.</p> <p>The sources for “official” target triples are many. Generally, I would describe a target triple as “official” when:</p> <ol> <li> <p>A major compiler (so, <code class="language-plaintext highlighter-rouge">clang</code> or <code class="language-plaintext highlighter-rouge">rustc</code>) uses it. Rust does a way better job than LLVM of documenting their targets, so I prefer to give it deference. You can find Rust’s official triples <a href="https://doc.rust-lang.org/rustc/platform-support.html">here</a>.</p> </li> <li> <p>A platform developer (e.g., a hardware manufacturer, OS vendor) distributes a toolchain with a target triple in the <code class="language-plaintext highlighter-rouge">arch-vendor-os</code> format.</p> </li> </ol> <p>So, what are the names in class (1)? LLVM does not really go out of its way to provide such a list. But we gotta start somewhere, so source-diving it is.</p> <p>We can dig into <a href="https://llvm.org/doxygen/Triple_8cpp_source.html"><code class="language-plaintext highlighter-rouge">Triple.cpp</code></a> in LLVM’s target triple parser. It lists all of the names LLVM recognizes for each part of a triple. Looking at <code class="language-plaintext highlighter-rouge">Triple::parseArch()</code>, we have the following names, including many, many aliases. The first item on the right column is LLVM’s preferred name for the architecture, as indicated by <code class="language-plaintext highlighter-rouge">Triple::getArchTypeName()</code>.</p> <table> <thead> <tr> <th>Architecture</th> <th>Possible Names</th> </tr> </thead> <tbody> <tr> <td><a href="https://en.wikipedia.org/wiki/X86">Intel x86</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">i386</code>, <code class="language-plaintext highlighter-rouge">i486</code>, <code class="language-plaintext highlighter-rouge">i586</code>, <code class="language-plaintext highlighter-rouge">i686</code>, <code class="language-plaintext highlighter-rouge">i786</code>, <code class="language-plaintext highlighter-rouge">i886</code>, <code class="language-plaintext highlighter-rouge">i986</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/X86">Intel x86</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">x86_64</code>, <code class="language-plaintext highlighter-rouge">amd64</code>, <code class="language-plaintext highlighter-rouge">x86_86h</code><sup id="fnref:x86_86h" role="doc-noteref"><a href="#fn:x86_86h" class="footnote" rel="footnote">3</a></sup></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">arm</code>, <code class="language-plaintext highlighter-rouge">xscale</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (32-bit, big-endian)</td> <td><code class="language-plaintext highlighter-rouge">armeb</code>, <code class="language-plaintext highlighter-rouge">xscaleeb</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">aarch64</code>, <code class="language-plaintext highlighter-rouge">aarch64e</code>, <code class="language-plaintext highlighter-rouge">aarch64ec</code>, <code class="language-plaintext highlighter-rouge">arm64</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (64-bit, big-endian)</td> <td><code class="language-plaintext highlighter-rouge">aarch64_be</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (64-bit, ILP32<sup id="fnref:ilp32" role="doc-noteref"><a href="#fn:ilp32" class="footnote" rel="footnote">4</a></sup>)</td> <td><code class="language-plaintext highlighter-rouge">aarch64_32</code>, <code class="language-plaintext highlighter-rouge">arm64_32</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Thumb">ARM Thumb</a></td> <td><code class="language-plaintext highlighter-rouge">thumb</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Thumb">ARM Thumb</a> (big-endian)</td> <td><code class="language-plaintext highlighter-rouge">thumbeb</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a><sup id="fnref:power" role="doc-noteref"><a href="#fn:power" class="footnote" rel="footnote">5</a></sup> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">powerpc</code>, <code class="language-plaintext highlighter-rouge">powerpcspe</code>, <code class="language-plaintext highlighter-rouge">ppc</code>, <code class="language-plaintext highlighter-rouge">ppc32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a> (little-endian)</td> <td><code class="language-plaintext highlighter-rouge">powerpcle</code>, <code class="language-plaintext highlighter-rouge">ppcle</code>, <code class="language-plaintext highlighter-rouge">ppc32le</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">powerpc64</code>, <code class="language-plaintext highlighter-rouge">ppu</code>, <code class="language-plaintext highlighter-rouge">ppc64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a> (64-bit, little-endian)</td> <td><code class="language-plaintext highlighter-rouge">powerpc64le</code>, <code class="language-plaintext highlighter-rouge">ppc64le</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">mips</code>, <code class="language-plaintext highlighter-rouge">mipseb</code>, <code class="language-plaintext highlighter-rouge">mipsallegrex</code>, <code class="language-plaintext highlighter-rouge">mipsisa32r6</code>, <code class="language-plaintext highlighter-rouge">mipsr6</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (32-bit, little-endian)</td> <td><code class="language-plaintext highlighter-rouge">mipsel</code>, <code class="language-plaintext highlighter-rouge">mipsallegrexel</code>, <code class="language-plaintext highlighter-rouge">mipsisa32r6el</code>, <code class="language-plaintext highlighter-rouge">mipsr6el</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">mips64</code>, <code class="language-plaintext highlighter-rouge">mips64eb</code>, <code class="language-plaintext highlighter-rouge">mipsn32</code>, <code class="language-plaintext highlighter-rouge">mipsisa64r6</code>, <code class="language-plaintext highlighter-rouge">mips64r6</code>, <code class="language-plaintext highlighter-rouge">mipsn32r6</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (64-bit, little-endian)</td> <td><code class="language-plaintext highlighter-rouge">mips64el</code>, <code class="language-plaintext highlighter-rouge">mipsn32el</code>, <code class="language-plaintext highlighter-rouge">mipsisa64r6el</code>, <code class="language-plaintext highlighter-rouge">mips64r6el</code>, <code class="language-plaintext highlighter-rouge">mipsn32r6el</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">riscv32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">riscv64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Z/Architecture">IBM z/Architecture</a></td> <td><code class="language-plaintext highlighter-rouge">s390x</code><sup id="fnref:s390x" role="doc-noteref"><a href="#fn:s390x" class="footnote" rel="footnote">6</a></sup>, <code class="language-plaintext highlighter-rouge">systemz</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a></td> <td><code class="language-plaintext highlighter-rouge">sparc</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a> (little-endian)</td> <td><code class="language-plaintext highlighter-rouge">sparcel</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">sparcv6</code>, <code class="language-plaintext highlighter-rouge">sparc64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">wasm32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">wasm64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Loongson">Loongson</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">loongarch32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Loongson">Loongson</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">loongarch64</code></td> </tr> </tbody> <tbody> <tr> <td><a href="https://en.wikipedia.org/wiki/Radeon_HD_2000_series">Radeon R600</a></td> <td><code class="language-plaintext highlighter-rouge">r600</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Graphics_Core_Next">AMD GCN</a></td> <td><code class="language-plaintext highlighter-rouge">amdgcn</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Qualcomm_Hexagon">Qualcomm Hexagon</a></td> <td><code class="language-plaintext highlighter-rouge">hexagon</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Parallel_Thread_Execution">Nvidia PTX</a><sup id="fnref:ptx" role="doc-noteref"><a href="#fn:ptx" class="footnote" rel="footnote">7</a></sup> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">nvptx</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Parallel_Thread_Execution">Nvidia PTX</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">nvptx64</code></td> </tr> <tr> <td>AMD IL<sup id="fnref:amdil" role="doc-noteref"><a href="#fn:amdil" class="footnote" rel="footnote">8</a></sup> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">amdil</code></td> </tr> <tr> <td>AMD IL (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">amdil64</code></td> </tr> <tr> <td>Direct-X IL</td> <td><code class="language-plaintext highlighter-rouge">dxil</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Heterogeneous_System_Architecture">HSAIL</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">hsail</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Heterogeneous_System_Architecture">HSAIL</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">hsail64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">spir</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">spir64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR-V</a></td> <td><code class="language-plaintext highlighter-rouge">spirv</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR-V</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">spirv32</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR-V</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">spirv64</code>, …</td> </tr> <tr> <td><a href="https://developer.android.com/guide/topics/renderscript/compute">Android RenderScript</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">renderscript32</code></td> </tr> <tr> <td><a href="https://developer.android.com/guide/topics/renderscript/compute">Android RenderScript</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">renderscript64</code></td> </tr> <tr> <td><a href="https://en.wikichip.org/wiki/movidius/microarchitectures/shave_v2.0">Movidius SHAVE</a></td> <td><code class="language-plaintext highlighter-rouge">shave</code></td> </tr> </tbody> <tbody> <tr> <td><a href="https://en.wikipedia.org/wiki/AVR_microcontrollers">Atmel AVR</a></td> <td><code class="language-plaintext highlighter-rouge">avr</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Motorola_68000_series">Motorola 68k</a></td> <td><code class="language-plaintext highlighter-rouge">m68k</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARC_(processor)">Argonaut ARC</a></td> <td><code class="language-plaintext highlighter-rouge">arc</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/TI_MSP430">Texas Instruments MSP430</a></td> <td><code class="language-plaintext highlighter-rouge">msp430</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Tensilica">Tensilica Xtensa</a></td> <td><code class="language-plaintext highlighter-rouge">xtensa</code></td> </tr> <tr> <td><a href="https://c-sky.github.io/">C-SKY</a></td> <td><code class="language-plaintext highlighter-rouge">csky</code></td> </tr> <tr> <td><a href="https://github.com/cpc/openasip">OpenASIP</a></td> <td><code class="language-plaintext highlighter-rouge">tce</code></td> </tr> <tr> <td><a href="https://github.com/cpc/openasip">OpenASIP</a> (little-endian)</td> <td><code class="language-plaintext highlighter-rouge">tcele</code></td> </tr> <tr> <td><a href="https://q3k.org/lanai.html">Myracom Lanai</a></td> <td><code class="language-plaintext highlighter-rouge">lanai</code></td> </tr> <tr> <td>XMOS xCore</td> <td><code class="language-plaintext highlighter-rouge">xcore</code></td> </tr> <tr> <td>Kalimba<sup id="fnref:idk" role="doc-noteref"><a href="#fn:idk" class="footnote" rel="footnote">9</a></sup></td> <td><code class="language-plaintext highlighter-rouge">kalimba</code></td> </tr> <tr> <td>VE<sup id="fnref:idk:1" role="doc-noteref"><a href="#fn:idk" class="footnote" rel="footnote">9</a></sup></td> <td><code class="language-plaintext highlighter-rouge">ve</code></td> </tr> </tbody> </table> <p>Here we begin to see that target triples are not a neat system. They are <em>hell</em>. Where a list of architecture names contains a “…”, it means that LLVM accepts many more names.</p> <p>The problem is that architectures often have <em>versions</em> and <em>features</em>, which subtly change how the compiler generates code. For example, when compiling for an <code class="language-plaintext highlighter-rouge">x86_64</code>, we may want to specify that we want AVX512 instructions to be used. On LLVM, you might do that with <code class="language-plaintext highlighter-rouge">-mattr=+avx512</code>. Every architecture has a subtly-different way of doing this, because every architecture had a <em>different GCC</em>! Each variant of GCC would put different things behind <code class="language-plaintext highlighter-rouge">-mXXX</code> flags (<code class="language-plaintext highlighter-rouge">-m</code> for “machine”), meaning that the interface is not actually that uniform. The meanings of <code class="language-plaintext highlighter-rouge">-march</code>, <code class="language-plaintext highlighter-rouge">-mcpu</code>, <code class="language-plaintext highlighter-rouge">-mtune</code>, and <code class="language-plaintext highlighter-rouge">-mattr</code> thus vary wildly for this reason.</p> <p>Because LLVM is supposed to replace GCC (for the most part), it replicates a lot of this wacky behavior.</p> <p>So uh, we gotta talk about 32-bit ARM architecture names.</p> <h3 id="armtargetparsercpp"><a href="#armtargetparsercpp"><code class="language-plaintext highlighter-rouge">ARMTargetParser.cpp</code></a></h3> <p>There is a hellish file in LLVM dedicated to parsing ARM architecture names. Although members of the ARM family have many configurable features (which you can discover with <code class="language-plaintext highlighter-rouge">llc -march aarch64 -mattr help</code><sup id="fnref:llc" role="doc-noteref"><a href="#fn:llc" class="footnote" rel="footnote">10</a></sup>), the name of the architecture is somewhat meaningful, and can hav many options, mostly relating to the many versions of ARM that exist.</p> <p>How bad is it? Well, we can look at all of the various ARM targets that <code class="language-plaintext highlighter-rouge">rustc</code> supports with <code class="language-plaintext highlighter-rouge">rustc --print target-list</code>:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>rustc <span class="nt">--print</span> target-list | <span class="nb">grep</span> <span class="nt">-P</span> <span class="s1">'arm|aarch|thumb'</span> <span class="se">\</span>
<span class="go">  | cut -d- -f1 | sort | uniq
aarch64
aarch64_be
arm
arm64_32
arm64e
arm64ec
armeb
armebv7r
armv4t
armv5te
armv6
armv6k
armv7
armv7a
armv7k
armv7r
armv7s
armv8r
thumbv4t
thumbv5te
thumbv6m
thumbv7a
thumbv7em
thumbv7m
thumbv7neon
thumbv8m.base
thumbv8m.main</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Console</a></div></div> <p>Most of these are 32-bit ARM versions, with profile information attached. These correspond to the names given <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Cores">here</a>. Why does ARM stick version numbers in the architecture name, instead of using <code class="language-plaintext highlighter-rouge">-mcpu</code> like you would on x86 (e.g. <code class="language-plaintext highlighter-rouge">-mcpu alderlake</code>)? I have no idea, because ARM is not my strong suit. It’s likely because of how early ARM support was added to GCC.</p> <p>Internally, LLVM calls these “subarchitectures”, although ARM gets special handling because there’s so many variants. SPIR-V, Direct X, and MIPS all have subarchitectures, so you might see something like <code class="language-plaintext highlighter-rouge">dxilv1.7</code> if you’re having a bad day.</p> <p>Of course, LLVM’s ARM support also sports some naughty subarchitectures not part of this system, with naughty made up names.</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">arm64e</code> is an Apple thing, which is an enhancement of <code class="language-plaintext highlighter-rouge">aarch64</code> present on some Apple hardware, which adds their own flavor of <a href="https://developer.apple.com/documentation/security/preparing-your-app-to-work-with-pointer-authentication">pointer authentication</a> and some other features.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">arm64ec</code> is a completely unrelated Microsoft invention that is essentially “<code class="language-plaintext highlighter-rouge">aarch64</code> but with an <code class="language-plaintext highlighter-rouge">x86_64</code>-ey ABI” to make <code class="language-plaintext highlighter-rouge">x86_64</code> emulation on what would otherwise be <code class="language-plaintext highlighter-rouge">aarch64-pc-windows-msvc</code> target somewhat more amenable.</p> </li> </ul> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>Why the Windows people invented a whole other ABI instead of making things clean and simple like Apple did with Rosetta on ARM MacBooks? I have no idea, but <a href="http://www.emulators.com/docs/abc_arm64ec_explained.htm">http://www.emulators.com/docs/abc_arm64ec_explained.htm</a> contains various excuses, none of which I am impressed by. My read is that their compiler org was just worse at life than Apple’s, which is not surprising, since Apple does compilers better than anyone else in the business.</p> </blockquote> <p>Actually, since we’re on the topic of the names of architectures, I have a few things I need to straighten out.</p> <h3 id="made-up-names-of-architectures"><a href="#made-up-names-of-architectures">Made Up Names of Architectures</a></h3> <p>x86 and ARM both seem to attract a lot of people making up nicknames for them, which leads to a lot of confusion in:</p> <ol> <li> <p>What the “real” name is.</p> </li> <li> <p>What name a particular toolchain wants.</p> </li> <li> <p>What name you should use in your own cosmopolitan tooling.</p> </li> </ol> <p>Let’s talk about the incorrect names people like to make up for them. Please consider the following a relatively normative reference on what people call these architectures, based on my own experience with many tools.</p> <p>When we say “x86” unqualified, in 2025, we almost always mean <code class="language-plaintext highlighter-rouge">x86_64</code>, because 32-bit x86 is dead. If you need to talk about 32-bit x86, you should either say “32-bit x86”, “protected mode”<sup id="fnref:x86-modes" role="doc-noteref"><a href="#fn:x86-modes" class="footnote" rel="footnote">11</a></sup>, or “i386” (the first Intel microarchitecture that implemented protected mode)<sup id="fnref:i386" role="doc-noteref"><a href="#fn:i386" class="footnote" rel="footnote">12</a></sup>. You should not call it <code class="language-plaintext highlighter-rouge">x86_32</code> or just <code class="language-plaintext highlighter-rouge">x86</code>.</p> <p>You might also call it IA-32 for Intel Architecture 32, (or <code class="language-plaintext highlighter-rouge">ia32</code>), but nobody calls it that and you risk confusing people with <code class="language-plaintext highlighter-rouge">ia64</code>, or IA-64, the official name of Intel’s failed general-purpose VLIW architecture, <a href="https://en.wikipedia.org/wiki/Itanium">Itanium</a>, which is in no way compatible with x86. <code class="language-plaintext highlighter-rouge">ia64</code> was what GCC and LLVM named Itanium triples with. Itanium support was drowned in a bathtub during the Obama administration, so it’s not really relevant anymore. Rust has never had official Itanium support.</p> <p>32-bit x86 is <em>extremely not</em> called “x32”; this is what Linux used to call its x86 ILP32<sup id="fnref:ilp32:1" role="doc-noteref"><a href="#fn:ilp32" class="footnote" rel="footnote">4</a></sup> variant before it was removed (which, following the ARM names, would have been called <code class="language-plaintext highlighter-rouge">x86_6432</code>).</p> <p>There are also many ficticious names for 64-bit x86, which you should avoid unless you want the younger generation to make fun of you. <code class="language-plaintext highlighter-rouge">amd64</code> refers to AMD’s original implementation of long mode in their K8 microarchitecture, first shipped in their <a href="https://en.wikipedia.org/wiki/Athlon_64">Athlon 64</a> product. AMD still makes the best x86 chips (I am writing this on a machine socketed with a Zen2 Threadripper), sure, but calling it <code class="language-plaintext highlighter-rouge">amd64</code> is silly and also looks a lot like <code class="language-plaintext highlighter-rouge">arm64</code>, and I am honestly kinda annoyed at how much Go code I’ve seen with files named <code class="language-plaintext highlighter-rouge">fast_arm64.s</code> and <code class="language-plaintext highlighter-rouge">fast_amd64.s</code>. Debian also uses <code class="language-plaintext highlighter-rouge">amd64</code>/<code class="language-plaintext highlighter-rouge">arm64</code>, which makes browsing packages kind of annoying.</p> <p>On that topic, you should <em>absolutely not</em> call 64-bit mode <code class="language-plaintext highlighter-rouge">k8</code>, after the AMD K8. Nobody except for weird computer taxonomists like me know what that is. But Bazel calls it that, and it’s really irritating<sup id="fnref:piii" role="doc-noteref"><a href="#fn:piii" class="footnote" rel="footnote">13</a></sup>.</p> <p>You should also not call it <code class="language-plaintext highlighter-rouge">x64</code>. Although LLVM does accept <code class="language-plaintext highlighter-rouge">amd64</code> for historical purposes, no one calls it <code class="language-plaintext highlighter-rouge">x64</code> except for Microsoft. And even though it is fairly prevalent on Windows, I absolutely give my gamedev friends a hard time when they write <code class="language-plaintext highlighter-rouge">x64</code>.</p> <p>On the ARM side, well. Arm<sup id="fnref:arm-holdings" role="doc-noteref"><a href="#fn:arm-holdings" class="footnote" rel="footnote">14</a></sup> has a bad habit of not using consistent naming for 64-bit ARM, since they used both AArch64 and ARM64 for it. However, in compiler land, <code class="language-plaintext highlighter-rouge">aarch64</code> appears to be somewhat more popular.</p> <p>You should also probably stick to the LLVM names for the various architectures, instead of picking your favorite Arm Cortex name (like <code class="language-plaintext highlighter-rouge">cortex_m0</code>).</p> <h2 id="vendors-and-operating-systems"><a href="#vendors-and-operating-systems">Vendors and Operating Systems</a></h2> <p>The worst is over. Let’s now move onto examinining the rest of the triple: the platform vendor, and the operating system.</p> <p>The vendor is intended to identify who is responsible for the ABI definition for that target. Although provides little to no value to the compiler itself, but it does help to sort related targets together. Sort of.</p> <p>Returning to <code class="language-plaintext highlighter-rouge">llvm::Triple</code>, we can examine <code class="language-plaintext highlighter-rouge">Triple::VendorType</code>. Vendors almost always correspond to companies which develop operating systems or other platforms that code runs on, with some exceptions.</p> <p>We can also get the vendors that <code class="language-plaintext highlighter-rouge">rustc</code> knows about with a handy dandy command:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">rustc --print target-list | grep -P '\w+-\w+-' | cut -d- -f2 | sort | uniq</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Console</a></div></div> <p>The result is this. This is just a representative list; I have left off a few that are not going to be especially recognizeable.</p> <table> <thead> <tr> <th>Vendor</th> <th>Name</th> <th>Example Triple</th> </tr> </thead> <tbody> <tr> <td>Vendor Unknown<sup id="fnref:unknown" role="doc-noteref"><a href="#fn:unknown" class="footnote" rel="footnote">15</a></sup></td> <td><code class="language-plaintext highlighter-rouge">unknown</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code></td> </tr> <tr> <td>“PC”</td> <td><code class="language-plaintext highlighter-rouge">pc</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-pc-windows-msvc</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/AMD">Advanced Micro Devices Inc.</a></td> <td><code class="language-plaintext highlighter-rouge">amd</code></td> <td><code class="language-plaintext highlighter-rouge">amdgcn-amd-gfx906</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Apple_Inc.">Apple Inc.</a></td> <td><code class="language-plaintext highlighter-rouge">apple</code></td> <td><code class="language-plaintext highlighter-rouge">aarch64-apple-ios-sim</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Intel">Intel Corporation</a></td> <td><code class="language-plaintext highlighter-rouge">intel</code></td> <td><code class="language-plaintext highlighter-rouge">i386-intel-elfiamcu</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/IBM">IBM Corporation</a></td> <td><code class="language-plaintext highlighter-rouge">ibm</code></td> <td><code class="language-plaintext highlighter-rouge">powerpc64-ibm-aix</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Mesa_(computer_graphics)">Mesa3D Project</a></td> <td><code class="language-plaintext highlighter-rouge">mesa</code></td> <td><code class="language-plaintext highlighter-rouge">amdgcn-mesa-mesa3d</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_Technologies">MIPS Technologies LLC</a></td> <td><code class="language-plaintext highlighter-rouge">mti</code></td> <td><code class="language-plaintext highlighter-rouge">mips-mti-none-elf</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Nintendo">Nintendo</a></td> <td><code class="language-plaintext highlighter-rouge">nintendo</code></td> <td><code class="language-plaintext highlighter-rouge">armv6k-nintendo-3ds</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Nvidia">Nvidia Corporation</a></td> <td><code class="language-plaintext highlighter-rouge">nvidia</code></td> <td><code class="language-plaintext highlighter-rouge">nvptx64-nvidia-cuda</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Sony_Interactive_Entertainment">Sony Interactive Entertainment</a></td> <td><code class="language-plaintext highlighter-rouge">scei</code>, <code class="language-plaintext highlighter-rouge">sie</code>, <code class="language-plaintext highlighter-rouge">sony</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-sie-ps5</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a></td> <td><code class="language-plaintext highlighter-rouge">sun</code></td> <td><code class="language-plaintext highlighter-rouge">sparcv9-sun-solaris</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SUSE_S.A.">SUSE S. A.</a></td> <td><code class="language-plaintext highlighter-rouge">suse</code></td> <td><code class="language-plaintext highlighter-rouge">aarch64-suse-linux</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Red_Hat">Red Hat, Inc</a></td> <td><code class="language-plaintext highlighter-rouge">redhat</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-redhat-linux</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Universal_Windows_Platform">Universal Windows Platform</a></td> <td><code class="language-plaintext highlighter-rouge">uwp</code></td> <td><code class="language-plaintext highlighter-rouge">aarch64-uwp-windows-msvc</code></td> </tr> </tbody> </table> <p>Most vendors are the names of organizations that produce hardware or operating systems. For example <code class="language-plaintext highlighter-rouge">suse</code> and <code class="language-plaintext highlighter-rouge">redhat</code> are used for those organizations’ Linux distributions, as a funny branding thing. Some vendors are projects, like the <code class="language-plaintext highlighter-rouge">mesa</code> vendor used with the Mesa3D OpenGL implementation’s triples.</p> <p>The <code class="language-plaintext highlighter-rouge">unknown</code> vendor is used for cases where the vendor is not specified or just not important. For example, the canonical Linux triple is <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code>… although one could argue it should be <code class="language-plaintext highlighter-rouge">x86_64-torvalds-linux</code>. It is not uncommon for companies that sell/distribute Linux distributions to have their own target triples, as do SUSE and sometimes RedHat. Notably, there are no triples with a <code class="language-plaintext highlighter-rouge">google</code> vendor, even though <code class="language-plaintext highlighter-rouge">aarch64-linux-android</code> and <code class="language-plaintext highlighter-rouge">aarch64-unknown-fuchsia</code> should really be called <code class="language-plaintext highlighter-rouge">aarch64-google-linux-android</code> and <code class="language-plaintext highlighter-rouge">aarch64-google-fuchsia</code>. The target triple system begins to show cracks here.</p> <p>The <code class="language-plaintext highlighter-rouge">pc</code> vendor is a bit weirder, and is mostly used by Windows targets. The standard Windows target is <code class="language-plaintext highlighter-rouge">x86_64-pc-windows-msvc</code>, but really it should have been <code class="language-plaintext highlighter-rouge">x86_64-microsoft-windows-msvc</code>. This is likely complicated by the fact that there is also a <code class="language-plaintext highlighter-rouge">x86_64-pc-windows-gnu</code> triple, which is for <a href="https://en.wikipedia.org/wiki/MinGW">MinGW</a> code. This platform, despite running on Windows, is not provided by Microsoft, so it would probably make more sense to be called <code class="language-plaintext highlighter-rouge">x86_64-unknown-windows-gnu</code>.</p> <p>But not all Windows targets are <code class="language-plaintext highlighter-rouge">pc</code>! <a href="https://en.wikipedia.org/wiki/Universal_Windows_Platform">UWP</a> apps use a different triple, that replaces the <code class="language-plaintext highlighter-rouge">pc</code> with <code class="language-plaintext highlighter-rouge">uwp</code>. <code class="language-plaintext highlighter-rouge">rustc</code> provides targets for Windows 7 backports that use a <code class="language-plaintext highlighter-rouge">win7</code> “vendor”.</p> <h3 id="beyond-operating-systems"><a href="#beyond-operating-systems">Beyond Operating Systems</a></h3> <p>The third (or sometimes second, ugh) component of a triple is the operating system, or just “system”, since it’s much more general than that. The main thing that compilers get from this component relates to generating code to interact with the operating system (e.g. SEH on Windows) and various details related to linking, such as object file format and relocations.</p> <p>It’s also used for setting defines like <code class="language-plaintext highlighter-rouge">__linux__</code> in C, which user code can use to determine what to do based on the target.</p> <p>We’ve seen <code class="language-plaintext highlighter-rouge">linux</code> and <code class="language-plaintext highlighter-rouge">windows</code>, but you may have also seen <code class="language-plaintext highlighter-rouge">x86_64-apple-darwin</code>. <em>Darwin?</em></p> <p>The operating system formerly known as Mac OS X (now macOS<sup id="fnref:macos" role="doc-noteref"><a href="#fn:macos" class="footnote" rel="footnote">16</a></sup>) is a POSIX operating system. The POSIX substrate that all the Apple-specific things are built on top of is called Darwin. <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> is a free and open source operating system based on Mach, a research kernel whose name survives in Mach-O, the object file format used by all Apple products.</p> <p>All of the little doodads Apple sells use the actual official names of their OSes, like <code class="language-plaintext highlighter-rouge">aarch64-apple-ios</code>. For, you know, iOS. On your iPhone. Built with Xcode on your iMac.</p> <p><code class="language-plaintext highlighter-rouge">none</code> is a common value for this entry, which usually means a free-standing environment with no operating system. The object file format is usually specified in the fourth entry of the triple, so you might see something like <code class="language-plaintext highlighter-rouge">riscv32imc-unknown-none-elf</code>.</p> <p>Sometimes the triple refers not to an operating system, but to a complete hardware product. This is common with game console triples, which have “operating system” names like <code class="language-plaintext highlighter-rouge">ps4</code>, <code class="language-plaintext highlighter-rouge">psvita</code>, <code class="language-plaintext highlighter-rouge">3ds</code>, and <code class="language-plaintext highlighter-rouge">switch</code>. (Both Sony and Nintendo use LLVM as the basis for their internal toolchains; the Xbox toolchain is just MSVC).</p> <h2 id="abi-abi"><a href="#abi-abi">ABI! ABI!</a></h2> <p>The fourth entry of the triple (and I repeat myself, yes, it’s still a triple) represents the binary interface for the target, when it is ambiguous.</p> <p>For example, Apple targets never have this, because on an Apple platform, you just shut up and use <code class="language-plaintext highlighter-rouge">CoreFoundation.framework</code> as your libc. Except this isn’t true, because of things like <code class="language-plaintext highlighter-rouge">x86_64-apple-ios-sim</code>, the iOS simulator running on an x86 host.</p> <p>On the other hand, Windows targets will usually specify <code class="language-plaintext highlighter-rouge">-msvc</code> or <code class="language-plaintext highlighter-rouge">-gnu</code>, to indicate whether they are built to match MSVC’s ABI or MinGW. Linux targets will usually specify the libc vendor in this position: <code class="language-plaintext highlighter-rouge">-gnu</code> for glibc, <code class="language-plaintext highlighter-rouge">-musl</code> for musl, <code class="language-plaintext highlighter-rouge">-newlib</code> for newlib, and so on.</p> <p>This doesn’t just influence the calling convention; it also influences how language features, such as thread locals and dynamic linking, are handled. This usually requires coordination with the target libc.</p> <p>On ARM free-standing (<code class="language-plaintext highlighter-rouge">armxxx-unknown-none</code>) targets, <code class="language-plaintext highlighter-rouge">-eabi</code> specifies the ARM EABI, which is a standard embeded ABI for ARM. <code class="language-plaintext highlighter-rouge">-eabihf</code> is similar, but indicates that no soft float support is necessary (<code class="language-plaintext highlighter-rouge">hf</code> stands for hardfloat). (Note that Rust does not include a vendor with these architectures, so they’re more like <code class="language-plaintext highlighter-rouge">armv7r-none-eabi</code>).</p> <p>A lot of jankier targets use the ABI portion to specify the object file, such as the aforementioned <code class="language-plaintext highlighter-rouge">riscv32imc-unknown-none-elf</code>.</p> <h2 id="wasm-targets"><a href="#wasm-targets">WASM Targets</a></h2> <p>One last thing to note are the various WebAssembly targets, which completely ignore all of the above conventions. Their triples often only have two components (they are still called triples, hopefully I’ve made that clear by now). Rust is a little bit more on the forefront here than <code class="language-plaintext highlighter-rouge">clang</code> (and anyways I don’t want to get into Emscripten) so I’ll stick to what’s going on in <code class="language-plaintext highlighter-rouge">rustc</code>.</p> <p>There’s a few variants. <code class="language-plaintext highlighter-rouge">wasm32-unknown-unknown</code> (here using <code class="language-plaintext highlighter-rouge">unknown</code> instead of <code class="language-plaintext highlighter-rouge">none</code> as the system, oops) is a completely bare WebAssebly runtime where none of the standard library that needs to interact with the outside world works. This is essentially for building WebAssembly modules to deploy in a browser.</p> <p>There are also the WASI targets, which provide a standard ABI for talking to the host operating system. These are less meant for browsers and more for people who are using WASI as a security boundary. These have names like <code class="language-plaintext highlighter-rouge">wasm32-wasip1</code>, which, unusually, lack a vendor! A “more correct” formulation would have been <code class="language-plaintext highlighter-rouge">wasm32-unknown-wasip1</code>.</p> <h2 id="aside-on-go"><a href="#aside-on-go">Aside on Go</a></h2> <p>Go does the correct thing and distributes a cross compiler. This is well and good.</p> <p>Unfortunately, they decided to be different and special and do not use the target triple system for naming their targets. Instead, you set the <code class="language-plaintext highlighter-rouge">GOARCH</code> and <code class="language-plaintext highlighter-rouge">GOOS</code> environment variables before invoking <code class="language-plaintext highlighter-rouge">gc</code>. This will sometimes be shown printed with a slash between, such as <code class="language-plaintext highlighter-rouge">linux/amd64</code>.</p> <p>Thankfully, they at least provide documentation for a relevant internal package <a href="https://pkg.go.dev/internal/platform">here</a>, which offers the names of various <code class="language-plaintext highlighter-rouge">GOARCH</code> and <code class="language-plaintext highlighter-rouge">GOOS</code> values.</p> <p>They use completely different names from everyone else for a few things, which is guaranteed to trip you up. They use call the 32- and 64-bit variants of x86 <code class="language-plaintext highlighter-rouge">386</code> (note the lack of leading <code class="language-plaintext highlighter-rouge">i</code>) and <code class="language-plaintext highlighter-rouge">amd64</code>. They call 64-bit ARM <code class="language-plaintext highlighter-rouge">arm64</code>, instead of <code class="language-plaintext highlighter-rouge">aarch64</code>. They call little-endian MIPSes <code class="language-plaintext highlighter-rouge">mipsle</code> instead of <code class="language-plaintext highlighter-rouge">mipsel</code>.</p> <p>They also call 32-bit WebAssembly <code class="language-plaintext highlighter-rouge">wasm</code> instead of <code class="language-plaintext highlighter-rouge">wasm32</code>, which is a bit silly, and they use <code class="language-plaintext highlighter-rouge">js/wasm</code> as their equivalent of <code class="language-plaintext highlighter-rouge">wasm32-unknown-unknown</code>, which is <em>very</em> silly.</p> <p>Android is treated as its own operating system, <code class="language-plaintext highlighter-rouge">android</code>, rather than being <code class="language-plaintext highlighter-rouge">linux</code> with a particular ABI; their system also can’t account for ABI variants in general, since Go originally wanted to not have to link any system libraries, something that does not actually work.</p> <p>If you are building a new toolchain, don’t be clever by inventing a cute target triple convention. All you’ll do is annoy people who need to work with a lot of different toolchains by being different and special.</p> <h2 id="inventing-your-own-triples"><a href="#inventing-your-own-triples">Inventing Your Own Triples</a></h2> <p>Realistically, you probably shouldn’t. But if you must, you should probably figure out what you want out of the triple.</p> <p>Odds are there isn’t anything interesting to put in the vendor field, so you will avoid people a lot of pain by picking <code class="language-plaintext highlighter-rouge">unknown</code>. Just include a vendor to avoid pain for people in the future.</p> <p>You should also avoid inventing a new name for an existing architecture. Don’t name your hobby operating system’s triple <code class="language-plaintext highlighter-rouge">amd64-unknown-whatever</code>, please. And you definitely don’t want to have an ABI component. One ABI is enough.</p> <p>If you’re inventing a triple for a free-standing environment, but want to specify something about the hardware configuration, you’re probably gonna want to use <code class="language-plaintext highlighter-rouge">-none-&lt;abi&gt;</code> for your system. For some firmware use-cases, though, the system entry is a better place, such as for the UEFI triples. Although, I have unforunately seen both <code class="language-plaintext highlighter-rouge">x86_64-unknown-uefi</code> and <code class="language-plaintext highlighter-rouge">x86_64-pc-none-uefi</code> in the wild.</p> <p>And most imporantly: this sytem was built up organically. Disabuse yourself now of the idea that the system is consistent and that target triples are easy to parse. Trying to parse them will make you very sad.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:quad" role="doc-endnote"> <p>And no, a “target quadruple” is not a thing and if I catch you saying that I’m gonna bonk you with an Intel optimization manual. <a href="#fnref:quad" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:toolchain" role="doc-endnote"> <p>I’m not sure why GCC does this. I suspect that it’s because computer hard drives used to be small and a GCC with every target would have been too large to cram into every machine. Maybe it has some UNIX philosophy woo mixed into it.</p> <p>Regardless, it’s really annoying and thankfully no one else does this because cross compiling shouldn’t require hunting down a new toolchain for each platform. <a href="#fnref:toolchain" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:x86_86h" role="doc-endnote"> <p>This is for Apple’s later-gen x86 machines, before they went all-in on ARM desktop. <a href="#fnref:x86_86h" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ilp32" role="doc-endnote"> <p>ILP32 means that the <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, and pointer types in C are 32-bit, despite the architecture being 64-bit. This allows writing programs that are small enough top jive in a 32-bit address space, while taking advantage of fast 64-bit operations. It is a bit of a frankentarget. Also existed once as a process mode on <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code> by the name of <code class="language-plaintext highlighter-rouge">x32</code>. <a href="#fnref:ilp32" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:ilp32:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p> </li> <li id="fn:power" role="doc-endnote"> <p>Not to be confused with POWER, an older IBM CPU. <a href="#fnref:power" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:s390x" role="doc-endnote"> <p>This name is Linux’s name for IBM’s z/Architecture. See <a href="https://en.wikipedia.org/wiki/Linux_on_IBM_Z#Hardware">https://en.wikipedia.org/wiki/Linux_on_IBM_Z#Hardware</a>. <a href="#fnref:s390x" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptx" role="doc-endnote"> <p>Not a real chip; refers to Nvidia’s PTX IR, which is what CUDA compiles to. <a href="#fnref:ptx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:amdil" role="doc-endnote"> <p>Similar to PTX; an IR used by AMD for graphics. See <a href="https://openwall.info/wiki/john/development/AMD-IL">https://openwall.info/wiki/john/development/AMD-IL</a>. <a href="#fnref:amdil" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:idk" role="doc-endnote"> <p>No idea what this is, and Google won’t help me. <a href="#fnref:idk" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:idk:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p> </li> <li id="fn:llc" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">llc</code> is the LLVM compiler, which takes LLVM IR as its input. Its interface is much more regular than <code class="language-plaintext highlighter-rouge">clang</code>’s because it’s not intended to be a substitute for GCC the way <code class="language-plaintext highlighter-rouge">clang</code> is. <a href="#fnref:llc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:x86-modes" role="doc-endnote"> <p>Very kernel-hacker-brained name. It references the three processor modes of an x86 machine: real mode, protected mode, long mode, which correspond to 16-, 32-, and 64-bit modes. There is also a secret fourth mode called <a href="https://en.wikipedia.org/wiki/Unreal_mode">unreal mode</a>, which is just what happens when you come down to real mode from protected mode after setting up a protected mode GDT.</p> <p>If you need to refer to real mode, call it “real mode”. Don’t try to be clever by calling it “8086” because you are almost certainly going to be using features that were not in the original Intel 8086. <a href="#fnref:x86-modes" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i386" role="doc-endnote"> <p>I actually don’t like this name, but it’s the one LLVM uses so I don’t really get to complain. <a href="#fnref:i386" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:piii" role="doc-endnote"> <p>Bazel also calls 32-bit x86 <code class="language-plaintext highlighter-rouge">piii</code>, which stands for, you guessed it, “Pentium III”. Extremely unserious. <a href="#fnref:piii" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:arm-holdings" role="doc-endnote"> <p>The intelectual property around ARM, the architecture famility, is owned by the British company Arm Holdings. Yes, the spelling difference is significant.</p> <p>Relatedly, ARM is not an acronym, and is sometimes styled in all-lowercase as arm. The distant predecesor of Arm Holdings is Acorn Computers. Their first compute, the Acorn Archimedes, contained a chip whose target triple name today might have been <code class="language-plaintext highlighter-rouge">armv1</code>. Here, ARM was an acronym, for Acorn RISC Machine. Wikipedia alleges without citation that the name was at once point changed to Advanced RISC Machine at the behest of Apple, but I am unable to find more details. <a href="#fnref:arm-holdings" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unknown" role="doc-endnote"> <p>“You are not cool enough for your company to be on the list.” <a href="#fnref:unknown" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:macos" role="doc-endnote"> <p>Which I pronounce as one word, “macos”, to drive people crazy. <a href="#fnref:macos" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-08 • 743 words • 8 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/08/protobuf-tip-1/"> Protobuf Tip #1: Field Names Are Forever </a></h1> </div> <div class="post"> <p><em>I wake up every morning and grab the morning paper. Then I look at the obituary page. If my name is not on it, I get up. –Ben Franklin</em></p> <p>TL;DR: Don’t rename fields. Even though there are a slim number of cases where you can get away with it, it’s rarely worth doing, and is a potential source of bugs.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-1-field-names">buf.build blog</a>.</p> </blockquote> <h2 id="names-and-tags"><a href="#names-and-tags">Names and Tags</a></h2> <p>Protobuf message fields have <em>field tags</em> that are used in the binary wire format to discriminate fields. This means that the wire format serialization does not actually depend on the <em>names</em> of the fields. For example, the following messages will use the exact same serialization format.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">bar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Foo2</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">bar2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Protobuf</a></div></div> <p>In fact, the designers of Protobuf intended for it to be feasible to rename an in-use field. However, they were not successful: it can still be a breaking change.</p> <h2 id="schema-consumers-need-to-update"><a href="#schema-consumers-need-to-update">Schema Consumers Need to Update</a></h2> <p>If your schema is public, the generated code will change. For example, renaming a field from <code class="language-plaintext highlighter-rouge">first_name</code> to <code class="language-plaintext highlighter-rouge">given_name</code> will cause the corresponding Go accessor to change from <code class="language-plaintext highlighter-rouge">FirstName</code> to <code class="language-plaintext highlighter-rouge">GivenName</code>, potentially breaking downstream consumers.</p> <p>Renaming a field to a “better” name is almost never a worthwhile change, simply because of this breakage.</p> <h2 id="json-serialization-breaks"><a href="#json-serialization-breaks">JSON Serialization Breaks</a></h2> <p>Wire format serialization doesn’t look at names, but JSON does! This means that <code class="language-plaintext highlighter-rouge">Foo</code> and <code class="language-plaintext highlighter-rouge">Foo2</code> above serialize as <code class="language-plaintext highlighter-rouge">{"bar":"content"}</code> and <code class="language-plaintext highlighter-rouge">{"bar2":"content"}</code> respectively, making them non-interchangeable.</p> <p>This can be partially mitigated by using the <code class="language-plaintext highlighter-rouge">[json_name = "..."]</code> option on a field. However, this doesn’t actually work, because many Protobuf runtimes’ JSON codecs will accept both the name set in <code class="language-plaintext highlighter-rouge">json_name</code>, <em>and</em> the specified field name. So <code class="language-plaintext highlighter-rouge">string given_name = 1 [json_name = "firstName"];</code> will allow deserializing from a key named <code class="language-plaintext highlighter-rouge">given_name</code>, but not <code class="language-plaintext highlighter-rouge">first_name</code> like it used to. This is still a breaking protocol change!</p> <p>This is a place where Protobuf could have done better—if <code class="language-plaintext highlighter-rouge">json_name</code> had been a <code class="language-plaintext highlighter-rouge">repeated string</code>, this wire format breakage would have been avoidable. However, for reasons given below, renames are still a bad idea.</p> <h2 id="reflection"><a href="#reflection">Reflection!</a></h2> <p>Even if you could avoid source and JSON breakages, the names are always visible to reflection. Although it’s <em>very</em> hard to guard against reflection breakages in general (since it can even see the order fields are declared in), this is one part of reflection that can be especially insidious—for example, if callers choose to sort fields by name, or if some middleware is using the name of a field to identify its frequency, or logging/redaction needs.</p> <p>Don’t change the name, because reflection means you can’t know what’ll go wrong!</p> <h2 id="but-i-really-have-to"><a href="#but-i-really-have-to">But I Really Have To!</a></h2> <p>There are valid reasons for wanting to rename a field, such as expanding its scope. For example, <code class="language-plaintext highlighter-rouge">first_name</code> and <code class="language-plaintext highlighter-rouge">given_name</code> are not the same concept: in the Sinosphere, as well as in Hungary, the first name in a person’s full name is their family name, not their given name.</p> <p>Or maybe a field that previously referred to a monetary amount, say <code class="language-plaintext highlighter-rouge">cost_usd</code>, is being updated to not specify the currency:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Before</span> <span class="p">{</span>
  <span class="kt">sint64</span> <span class="na">cost_usd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">After</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">Currency</span> <span class="p">{</span>
    <span class="na">CURRENCY_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">CURRENCY_USD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">CURRENCY_EUR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">CURRENCY_JPY</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="na">CURRENCY_USD_1000TH</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 0.1 cents.</span>
  <span class="p">}</span>

  <span class="kt">sint64</span> <span class="na">cost</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">Currency</span> <span class="na">currency</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Protobuf</a></div></div> <p>In cases like this, <strong>renaming the field is a terrible idea</strong>. Setting aside source code or JSON breakage, the new field has completely different semantics. If an old consumer, expecting a price in USD, receives a new wire format message serialized from <code class="language-plaintext highlighter-rouge">{"cost":990,"currency":"CURRENCY_USD_1000TH"}</code>, it will incorrectly interpret the price as 990USD, rather than 0.99USD. That’s a disastrous bug!</p> <p>Instead, the right plan is to add <code class="language-plaintext highlighter-rouge">cost</code> and <code class="language-plaintext highlighter-rouge">currency</code> side-by-side <code class="language-plaintext highlighter-rouge">cost_usd</code>. Then, readers should first check for <code class="language-plaintext highlighter-rouge">cost_usd</code> when reading <code class="language-plaintext highlighter-rouge">cost</code>, and take that to imply that <code class="language-plaintext highlighter-rouge">currency</code> is <code class="language-plaintext highlighter-rouge">CURRENCY_USD</code> (it’s also worth generating an error if <code class="language-plaintext highlighter-rouge">cost</code> and <code class="language-plaintext highlighter-rouge">cost_usd</code> are both present).</p> <p><code class="language-plaintext highlighter-rouge">cost_usd</code> can then be marked as <code class="language-plaintext highlighter-rouge">[deprecated = true]</code> . It is possible to even delete <code class="language-plaintext highlighter-rouge">cost_usd</code> in some cases, such as when you control all readers and writers — but if you don’t, the risk is very high. Plus, you kind of need to be able to re-interpret <code class="language-plaintext highlighter-rouge">cost_usd</code> as the value of <code class="language-plaintext highlighter-rouge">cost</code> in perpetuity.</p> <p>If you do wind up deleting them, make sure to reserve the field’s number and name, to avoid accidental re-use.</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="n">reserved</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">reserved</span> <span class="s">"cost_usd"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Protobuf</a></div></div> <p>But try not to. Renaming fields is nothing but tears and pain.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-03-11 • 3738 words • 41 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> • <a href="https://mcyoung.xyz/tags.html#frontend">#frontend</a> • <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> </span> <h1><a href="/2025/03/11/formatters/"> The Art of Formatting Code </a></h1> </div> <div class="post"> <p>Every modern programming language needs a <em>formatter</em> to make your code look pretty and consistent. Formatters are source-transformation tools that parse source code and re-print the resulting AST in some canonical form that normalizes whitespace and optional syntactic constructs. They remove the tedium of matching indentation and brace placement to match a style guide.</p> <p>Go is particularly well-known for providing a formatter as part of its toolchain from day one. It is not a <em>good</em> formatter, though, because it cannot enforce a maximum column width. Later formatters of the 2010s, such as rustfmt and clang-format, do provide this feature, which ensure that individual lines of code don’t get too long.</p> <p>The reason Go doesn’t do this is because the naive approach to formatting code makes it intractable to do so. There are many approaches to implementing this, which can make it seem like a very complicated layout constraint solving problem.</p> <p>So what’s so tricky about formatting code? Aren’t you just printing out an AST?</p> <h2 id="just-an-ast"><a href="#just-an-ast">“Just” an AST</a></h2> <p>An AST<sup id="fnref:pronunciation" role="doc-noteref"><a href="#fn:pronunciation" class="footnote" rel="footnote">1</a></sup> (abstract syntax tree) is a graph representation of a program’s syntax. Let’s consider something like JSON, whose naively-defined AST type might look something like this.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Rust</a></div></div> <p>The AST for the document <code class="language-plaintext highlighter-rouge">{"foo": null, "bar": 42}</code> might look something like this:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_doc</span> <span class="o">=</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Object</span><span class="p">([</span>
  <span class="p">(</span><span class="s">"foo"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span><span class="p">),</span>
  <span class="p">(</span><span class="s">"bar"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mi">42</span><span class="p">)),</span>
<span class="p">]</span><span class="nf">.into</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <p>This AST has some pretty major problems. A formatter must <em>not</em> change the syntactic structure of the program (beyond removing things like redundant braces). Formatting must also be deterministic.</p> <p>First off, <code class="language-plaintext highlighter-rouge">Json::Object</code> is a <code class="language-plaintext highlighter-rouge">HashMap</code>, which is unordered. So it will immediately discard the order of the keys. <code class="language-plaintext highlighter-rouge">Json::String</code> does not retain the escapes from the original string, so <code class="language-plaintext highlighter-rouge">"\n"</code> and <code class="language-plaintext highlighter-rouge">"\u000a"</code> are indistinguishable. <code class="language-plaintext highlighter-rouge">Json::Number</code> will destroy information: JSON numbers can specify values outside of the <code class="language-plaintext highlighter-rouge">f64</code> representable range, but converting to <code class="language-plaintext highlighter-rouge">f64</code> will quantize to the nearest float.</p> <p>Now, JSON doesn’t have comments, but if it did, our AST has no way to record it! So it would destroy all comment information! Plus, if someone has a document that separates keys into stanzas<sup id="fnref:stanza" role="doc-noteref"><a href="#fn:stanza" class="footnote" rel="footnote">2</a></sup>, as shown below, this information is lost too.</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"this"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my first stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"second"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="p">,</span><span class="w">

  </span><span class="nl">"here"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my second stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fourth"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">JSON</a></div></div> <p>Truth is, the AST for virtually all competent toolchains are much more complicated than this. Here’s some important properties an AST needs to have to be useful.</p> <ol> <li> <p>Retain <em>span</em> information. Every node in the graph remembers what piece of the file it was parsed from.</p> </li> <li> <p>Retain whitespace information. “Whitespace” typically includes both whitespace characters, and comments.</p> </li> <li> <p>Retain ordering information. The children of each node need to be stored in ordered containers.</p> </li> </ol> <p>The first point is achieved in a number of ways, but boils down to somehow associating to each token a pair of integers<sup id="fnref:offsets" role="doc-noteref"><a href="#fn:offsets" class="footnote" rel="footnote">3</a></sup>, identifying the start and end offsets of the token in the input file.</p> <p>Given the span information for each token, we can then define the span for each node to be the <em>join</em> of its tokens’ spans, namely the start is the min of its constituent tokens’ starts and its end is the max of the ends. This can be easily calculated recursively.</p> <p>Once we have spans, it’s easy to recover the whitespace between any two adjacent syntactic constructs by calculating the text between them. This approach is more robust than, say, associating each comment with a specific token, because it makes it easier to discriminate stanzas for formatting.</p> <p>Being able to retrieve the comments between any two syntax nodes is crucial. Suppose the user writes the following Rust code:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">false</span> <span class="o">&amp;&amp;</span> <span class="c1">// HACK: disable this check.</span>
  <span class="nf">some_complicated_check</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>If we’re formatting the binary expression containing the <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, and we can’t query for comments between the LHS and the operator, or the operator and the RHS, the <code class="language-plaintext highlighter-rouge">// HACK</code> comment will get deleted on format, which is pretty bad!</p> <p>An AST that retains this level of information is sometimes called a “concrete syntax tree”. I do not consider this a useful distinction, because any useful AST must retain span and whitespace information, and it’s kind of pointless to implement the same AST more than once. To me, an AST without spans is incomplete.</p> <h3 id="updating-our-json-ast"><a href="#updating-our-json-ast">Updating Our JSON AST</a></h3> <p>With all this in mind, the bare minimum for a “good” AST is gonna be something like this.</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Rust</a></div></div> <p>There are various layout optimizations we can do: for example, the vast majority of strings exist literally in the original file, so there’s no need to copy them into a <code class="language-plaintext highlighter-rouge">String</code>; it’s only necessary if the string contains escapes. My <code class="language-plaintext highlighter-rouge">byteyarn</code> crate, which I wrote about <a href="https://mcyoung.xyz/2023/08/09/yarns">here</a>, is meant to make handling this case easy. So we might rewrite this to be lifetime-bound to the original file.</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p>But wait, there’s some things that don’t have spans here. We need to include spans for the braces of <code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">Object</code>, their commas, and the colons on object keys. So what we actually get is something like this:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Span</span> <span class="p">{</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>

  <span class="n">Array</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ArrayEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ObjectEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ArrayEntry</span> <span class="p">{</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ObjectEntry</span> <span class="p">{</span>
  <span class="n">key</span><span class="p">:</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>Implementing an AST is one of my least favorite parts of writing a toolchain, because it’s tedious to ensure all of the details are recorded and properly populated.</p> <h2 id="just-printing-an-ast"><a href="#just-printing-an-ast">“Just” Printing an AST</a></h2> <p>In Rust, you can easily get a nice recursive print of any struct using the <code class="language-plaintext highlighter-rouge">#[derive(Debug)]</code> construct. This is implemented by recursively calling <code class="language-plaintext highlighter-rouge">Debug::fmt()</code> on the elements of a struct, but passing modified <code class="language-plaintext highlighter-rouge">Formatter</code> state to each call to increase the indentation level each time.</p> <p>This enables printing nested structs in a way that looks like Rust syntax when using the <code class="language-plaintext highlighter-rouge">{:#?}</code> specifier.</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Foo</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">baz</span><span class="p">:</span> <span class="n">Baz</span> <span class="p">{</span>
    <span class="n">quux</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>We can implement a very simple formatter for our JSON AST by walking it recursively.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="p">,</span> <span class="n">json</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Json</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="o">&amp;</span><span class="n">json</span><span class="py">.kind</span> <span class="p">{</span>
    <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="c1">// Preserve the input exactly.</span>
      <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">json</span><span class="py">.span.start</span><span class="o">..</span><span class="n">json</span><span class="py">.span.end</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'['</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">']'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'{'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Preserve the key exactly.</span>
        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">entry</span><span class="py">.key_span.start</span><span class="o">..</span><span class="n">entry</span><span class="py">.key_span.end</span><span class="p">]);</span>

        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">": "</span><span class="p">);</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'}'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p>This is essentially what every JSON serializer’s “pretty” mode looks like. It’s linear, it’s simple. But it has one big problem: small lists.</p> <p>If I try to format the document <code class="language-plaintext highlighter-rouge">{"foo": []}</code> using this routine, the output will be</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">JSON</a></div></div> <p>This is pretty terrible, but easy to fix by adding a special case:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">entries</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"[]"</span><span class="p">);</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>Unfortunately, this doesn’t handle the similar case of a small but non-empty list. <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> formats as</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="mi">2</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">JSON</a></div></div> <p>Really, we’d like to keep <code class="language-plaintext highlighter-rouge">"foo": [1, 2]</code> on one line. And now we enter the realm of column wrapping.</p> <h2 id="how-wide-is-a-codepoint"><a href="#how-wide-is-a-codepoint">How Wide Is a Codepoint?</a></h2> <p>The whole point of a formatter is to work with <em>monospaced text</em>, which is text formatted using a monospaced or <em>fixed-width</em> typeface, which means each character is the same width, leading to the measure of the width of lines in <em>columns</em>.</p> <p>So how many columns does the string <code class="language-plaintext highlighter-rouge">cat</code> take up? Three, pretty easy. But we obviously don’t want to count bytes, this isn’t 1971. If we did, <code class="language-plaintext highlighter-rouge">кішка</code>, when UTF-8 encoded, it would be 10, rather than 5 columns wide. So we seem to want to count Unicode characters instead?</p> <p>Oh, but what <em>is</em> a Unicode character? Well, we could say that you’re counting Unicode scalar values (what Rust’s <code class="language-plaintext highlighter-rouge">char</code> and Go’s <code class="language-plaintext highlighter-rouge">rune</code>) types represent. Or you could count grapheme clusters (like Swift’s <code class="language-plaintext highlighter-rouge">Character</code>).</p> <p>But that would give wrong answers. CJK languages’ characters, such as <code class="language-plaintext highlighter-rouge">猫</code>, usually want to be rendered as <em>two</em> columns, even in monospaced contexts. So, you might go to Unicode and discover <a href="https://www.unicode.org/reports/tr11/">UAX#11</a>, and attempt to use it for assigning column widths. But it turns out that the precise rules that monospaced fonts use are not written down in a single place in Unicode. You would also discover that some scripts, such as Arabic, have complex ligature rules that mean that the width of a single character depends on the characters around it.</p> <p>This is a place where you should hunt for a library. <a href="https://docs.rs/unicode-width/latest/unicode_width/#rules-for-determining-width"><code class="language-plaintext highlighter-rouge">unicode_width</code></a> is the one for Rust. Given that Unicode segmentation is a closely associated operation to width, segmentation libraries are a good place to look for a width calculation routine.</p> <p>But most such libraries will still give wrong answers, because of tabs. The tab character <code class="language-plaintext highlighter-rouge">U+0009 CHARACTER TABULATION</code>’s width depends on the width of all characters before it, because a tab is as wide as needed to reach the next <em>tabstop</em>, which is a column position an integer multiple of the <em>tab width</em> (usually 2, 4, or, on most terminals, 8).</p> <p>With a tab width of 4, <code class="language-plaintext highlighter-rouge">"\t"</code>, <code class="language-plaintext highlighter-rouge">"a\t"</code>, and <code class="language-plaintext highlighter-rouge">"abc\t"</code> are all four columns wide. Depending on the context, you will either want to treat tabs as behaving as going to the next tabstop (and thus being variable width), or having a fixed width. The former is necessary for assigning correct column numbers in diagnostics, but we’ll find that the latter is a better match for what we’re doing.</p> <p>The reason for being able to calculate the width of a string is to enable line wrapping. At some point in the 2010s, people started writing a lot of code on laptops, where it is not easy to have two editors side by side on the small screen. This removes the motivation to wrap all lines at 80 columns<sup id="fnref:80-cols" role="doc-noteref"><a href="#fn:80-cols" class="footnote" rel="footnote">4</a></sup>, which in turn results in lines that tend to get arbitrarily long.</p> <p>Line wrapping helps ensure that no matter how wide everyone’s editors are, the code <em>I</em> have to read fits on my very narrow editors.</p> <h2 id="accidentally-quadratic"><a href="#accidentally-quadratic">Accidentally Quadratic</a></h2> <p>A lot of folks’ first formatter recursively formats a node by formatting its children to determine if they fit on one line or not, and based on that, and their length if they are single-line, determine if their parent should break.</p> <p>This is a naive approach, which has several disadvantages. First, it’s very easy to accidentally backtrack, trying to only break smaller and smaller subexpressions until things fit on one line, which can lead to quadratic complexity. The logic for whether a node can break is bespoke per node and that makes it easy to make mistakes.</p> <p>Consider formatting <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>. In our AST, this will look something like this:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">ObjectEntry</span> <span class="p">{</span>
      <span class="n">key</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
      <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span>
      <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">5</span> <span class="p">},</span>
      <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">9</span> <span class="p">},</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
          <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">11</span> <span class="p">}),</span>
            <span class="p">},</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">s</span><span class="na">.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">13</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">],</span>
        <span class="p">},</span>
        <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}],</span>
  <span class="p">},</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p>To format the whole document, we need to know the width of each field in the object to decide whether the object fits on one line. To do that, we need to calculate the width of each value, and add to it the width of the key, and the width of the <code class="language-plaintext highlighter-rouge">: </code> separating them.</p> <p>How can this be accidentally quadratic? If we simply say “format this node” to obtain its width, that will recursively format all of the children it contains without introducing line breaks, performing work that is linear in how many transitive children that node contains. Having done this, we can now decide if we need to introduce line breaks or not, which increases the indentation at which the children are rendered. This means that the children cannot know ahead of time how much of the line is left for them, so we need to recurse into formatting them again, now knowing the indentation at which the direct children are rendered.</p> <p>Thus, each node performs work equal to the number of nodes beneath it. This has resulted in many slow formatters.</p> <p>Now, you could be more clever and have each node be capable of returning its width based on querying its children’s width directly, but that means you need to do complicated arithmetic for each node that needs to be synchronized with the code that actually formats it. Easy to make mistakes.</p> <p>The solution is to invent some kind of model for your document that specifies how lines should be broken if necessary, and which tracks layout information so that it can be computed in one pass, and then used in a second pass to figure out whether to actually break lines or not.</p> <p>This is actually how HTML works. The markup describes constraints on the layout of the content, and then a layout engine, over several passes, calculates sizes, solves constraints, and finally produces a raster image representing that HTML document. Following the lead of HTML, we can design…</p> <h2 id="a-dom-for-your-code"><a href="#a-dom-for-your-code">A DOM for Your Code</a></h2> <p>The HTML DOM is a markup document: a tree of tags where each tag has a type, such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;hr&gt;</code>, or <code class="language-plaintext highlighter-rouge">&lt;strong&gt;</code>, properties, such as <code class="language-plaintext highlighter-rouge">&lt;a href=...&gt;</code>, and content consisting of nested tags (and bare text, which every HTML engine just handles as a special kind of tag), such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;Hello &lt;em&gt;World&lt;/em&gt;!&lt;/p&gt;</code>.</p> <p>We obviously want to have a tag for text that should be rendered literally. We also want a tag for line breaks that is distinct from the text tag, so that they can be merged during rendering. It might be good to treat text tags consisting of just whitespace, such as whitespace, specially: two newlines <code class="language-plaintext highlighter-rouge">\n\n</code> are a blank line, but we might want to merge consecutive blank lines. Similarly, we might want to merge consecutive spaces to simplify generating the DOM.</p> <p>Consider formatting a language like C++, where a function can have many modifiers on it that can show up in any order, such as <code class="language-plaintext highlighter-rouge">inline</code>, <code class="language-plaintext highlighter-rouge">virtual</code>, <code class="language-plaintext highlighter-rouge">constexpr</code>, and <code class="language-plaintext highlighter-rouge">explicit</code>. We might want to canonicalize the order of these modifiers. We don’t want to accidentally wind up printing <code class="language-plaintext highlighter-rouge">inline constexpr Foo()</code> because we printed an empty string for <code class="language-plaintext highlighter-rouge">virtual</code>. Having special merging for spaces means that all entities are always one space apart if necessary. This is a small convenience in the DOM that multiplies to significant simplification when lowering from AST to DOM.</p> <p>Another useful tag is something like <code class="language-plaintext highlighter-rouge">&lt;indent by=" "&gt;</code>, which increases the indentation level by some string (or perhaps simply a number of spaces; the string just makes supporting tabs easier) for the tags inside of it. This allows control of indentation in a carefully-scoped manner.</p> <p>Finally, we need some way to group tags that are candidates for “breaking”: if the width of all of the tags inside of a <code class="language-plaintext highlighter-rouge">&lt;group&gt;</code> is greater than the maximum width that group can have (determined by indentation and any elements on the same line as that group), we can set that group to “broken”, and… well, what should breaking do?</p> <p>We want breaking to not just cause certain newlines (at strategic locations) to appear, but we also want it to cause an indentation increase, and in languages with trailing commas like Rust and Go, we want (or in the case of Go, <em>need</em>) to insert a trailing comma only when broken into multiple lines. We can achieve this by allowing any tag to be <em>conditioned</em> on whether the enclosing group is broken or not.</p> <p>Taken all together, we can render the AST for our <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> document into this DOM, according to the tags we’ve described above.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">XML</a></div></div> <p>Notice a few things: All of the newlines are set to appear only <code class="language-plaintext highlighter-rouge">if=broken</code>. The space between the two commas only appears if the enclosing group is <em>not</em> broken, that is <code class="language-plaintext highlighter-rouge">if=flat</code>. The groups encompass everything that can move due to a break, which includes the outer braces. This is necessary because if that brace is not part of the group, and it is the only character past the line width limit, it will not cause the group to break.</p> <h3 id="laying-out-your-dom"><a href="#laying-out-your-dom">Laying Out Your DOM</a></h3> <p>The first pass is easy: it measures how wide every node is. But we don’t know whether any groups will break, so how can we measure that without calculating breaks, which depend on indentation, and the width of their children, and…</p> <p>This is one tricky thing about multi-pass graph algorithms (or graph algorithms in general): it can be easy to become overwhelmed trying to factor the dependencies at each node so that they are not cyclic. I struggled with this algorithm, until I realized that the only width we care about is the width <em>if no groups are ever broken</em>.</p> <p>Consider the following logic: if a group needs to break, all of its parents must obviously break, because the group will now contain a newline, so its parents must break no matter what. Therefore, we only consider the width of a node when deciding if a group must break intrinsically, i.e., because all of its children decided not to break. This can happen for a document like the following, where each inner node is quite large, but not large enough to hit the limit.</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span><span class="w">
  </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span><span class="w">
  </span><span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">]</span><span class="w">
</span><span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">JSON</a></div></div> <p>Because we prefer to break outer groups rather than inner groups, we can measure the “widest a single line could be” in one pass, bottom-up: each node’s width is the sum of the width of its children, or its literal contents for <code class="language-plaintext highlighter-rouge">&lt;text&gt;</code> elements. However, we must exclude all text nodes that are <code class="language-plaintext highlighter-rouge">if=broken</code>, because they obviously do not contribute to the single-line length. We can also ignore indentation because indentation never happens in a single line.</p> <p>However, this doesn’t give the full answer for whether a given group should break, because that depends on indentation and what nodes came before on the same line.</p> <p>This means we need to perform a second pass: having laid everything out assuming no group is broken, we must lay things out as they would appear when we render them, taking into account breaking. But now that we know the maximum width of each group if left unbroken, we can make breaking decisions.</p> <p>As we walk the DOM, we keep track of the current column and indentation value. For each group, we decide to break it if either:</p> <ol> <li> <p>Its width, plus the current column value, exceeds the maximum column width.</p> </li> <li> <p>It contains any newlines, something that can be determined in the first pass.</p> </li> </ol> <p>The first case is why we can’t actually treat tabs as if they advance to a tabstop. We cannot know the column at which a node will be placed at the time that we measure its width, so we need to assume the worst case.</p> <p>Whenever we hit a newline, we update the current width to the width induced by indentation, simulating a newline plus indent. We also need to evaluate the condition, if present, on each tag now, since by the time we inspect a non-group tag, we have already made a decision as to whether to break or not.</p> <h3 id="render-it"><a href="#render-it">Render It!</a></h3> <p>Now that everything is determined, rendering is super easy: just walk the DOM and print out all the text nodes that either have no condition or whose condition matches the innermost group they’re inside of.</p> <p>And, of course, this is where we need to be careful with indentation: you don’t want to have lines that end in whitespace, so you should make sure to not print out any spaces until text is written after a newline. This is also a good opportunity to merge adjacent only-newlines text blocks. The merge algorithm I like is to make sure that when <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code> newline blocks are adjacent, print <code class="language-plaintext highlighter-rouge">max(n, m)</code> newlines. This ensures that a DOM node containing <code class="language-plaintext highlighter-rouge">\n\n\n</code> is respected, while deleting a bunch of <code class="language-plaintext highlighter-rouge">\n</code>s in a row that would result in many blank lines.</p> <p>What’s awesome about this approach is that the layout algorithm is highly generic: you can re-use it for whatever compiler frontend you like, without needing to fuss with layout yourself. There is a very direct conversion from AST to DOM, and the result is very declarative.</p> <h3 id="more-complicated-yaml"><a href="#more-complicated-yaml">More Complicated: YAML</a></h3> <p>YAML is a superset of JSON that SREs use to write sentient configuration files. It has a funny list syntax that we might want to use for multi-line lists, but we might want to keep JSON-style lists for short ones.</p> <p>A document of nested lists might look something like this:</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="pi">-</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">,</span> <span class="nv">4</span><span class="pi">,</span> <span class="nv">5</span><span class="pi">,</span> <span class="nv">6</span><span class="pi">,</span> <span class="nv">7</span><span class="pi">,</span> <span class="nv">8</span><span class="pi">,</span> <span class="nv">9</span><span class="pi">,</span> <span class="nv">10</span><span class="pi">,</span> <span class="nv">11</span><span class="pi">,</span> <span class="nv">12</span><span class="pi">]</span>
<span class="pi">-</span> <span class="pi">[</span><span class="nv">13</span><span class="pi">,</span> <span class="nv">14</span><span class="pi">,</span> <span class="nv">15</span><span class="pi">,</span> <span class="nv">16</span><span class="pi">,</span> <span class="nv">17</span><span class="pi">,</span> <span class="nv">18</span><span class="pi">,</span> <span class="nv">19</span><span class="pi">,</span> <span class="nv">20</span><span class="pi">,</span> <span class="nv">21</span><span class="pi">,</span> <span class="nv">22</span><span class="pi">,</span> <span class="nv">23</span><span class="pi">]</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">YAML</a></div></div> <p>How might we represent this in the DOM? Starting from our original JSON document <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>, we might go for something like this:</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">XML</a></div></div> <p>Here, we’ve made the <code class="language-plaintext highlighter-rouge">[]</code> and the comma only appear in flat mode, while in broken mode, we have a <code class="language-plaintext highlighter-rouge">- </code> prefix for each item. The inserted newlines have also changed somewhat, and the indentation blocks have moved: now only the value is indented, since YAML allows the <code class="language-plaintext highlighter-rouge">-</code>s of list items to be at the same indentation level as the parent value for lists nested in objects. (This is a case where some layout logic is language-specific, but now the output is worrying about declarative markup rather than physical measurements.)</p> <p>There are other enhancements you might want to make to the DOM I don’t describe here. For example, comments want to be word-wrapped, but you might not know what the width is until layout happens. Having a separate tag for word-wrapped blocks would help here.</p> <p>Similarly, a mechanism for “partial breaks”, such as for the document below, could be implemented by having a type of line break tag that breaks if the text that follows overflows the column, which can be easily implemented by tracking the position of the last such break tag.</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"very"</span><span class="p">,</span><span class="w"> </span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"list"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"of"</span><span class="p">,</span><span class="w"> </span><span class="s2">"strings"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">JSON</a></div></div> <h2 id="using-this-yourself"><a href="#using-this-yourself">Using This Yourself</a></h2> <p>I think that a really good formatter is essential for any programming language, and I think that a high-quality library that does most of the heavy-lifting is important to make it easier to demand good formatters.</p> <p><a href="https://github.com/mcy/strings/tree/main/allman">So I wrote a Rust library.</a> I haven’t released it on crates.io because I don’t think it’s quite at the state I want, but it turns out that the layout algorithm is very simple, so porting this to other languages should be EZ.</p> <p>Now you have no excuse. :D</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:pronunciation" role="doc-endnote"> <p>Everyone pronounces this acronym “ay ess tee”, but I have a friend who really like to say <em>ast</em>, rhyming with <em>mast</em>, so I’m making a callout post my twitter dot com. <a href="#fnref:pronunciation" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stanza" role="doc-endnote"> <p>In computing, a group of lines not separated by blank lines is called a stanza, in analogy to the stanzas of a poem, which are typeset with no blank lines between the lines of the stanza. <a href="#fnref:stanza" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:offsets" role="doc-endnote"> <p>You could also just store a string, containing the original text, but storing offsets is necessary for <em>diagnostics</em>, which is the jargon term for a compiler error. Compiler errors are recorded using an AST node as context, and to report the line at which the error occurred, we need to be able to map the node back to its offset in the file.</p> <p>Once we have the offset, we can calculate the line in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time using binary search. Having pre-computed an array of the offset of each <code class="language-plaintext highlighter-rouge">\n</code> byte in the input file, binary search will tell us the index and offset of the <code class="language-plaintext highlighter-rouge">\n</code> before the token; this index is the zero-indexed line number, and the string from that <code class="language-plaintext highlighter-rouge">\n</code> to the offset can be used to calculate the column.</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">unicode_width</span><span class="p">::</span><span class="n">UnicodeWidthStr</span><span class="p">;</span>

<span class="cd">/// Returns the index of each newline. Can be pre-computed and re-used</span>
<span class="cd">/// multiple times.</span>
<span class="k">fn</span> <span class="nf">newlines</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">file</span><span class="nf">.bytes</span><span class="p">()</span>
      <span class="nf">.enumerate</span><span class="p">()</span>
      <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// Returns the line and column of the given offset, given the line</span>
<span class="cd">/// tarts of the file.</span>
<span class="k">fn</span> <span class="nf">location</span><span class="p">(</span>
  <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="n">newlines</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
  <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">newlines</span><span class="nf">.binary_search</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Ok means that offset refers to a newline, so this means</span>
    <span class="c1">// we want to return the width of the line that it ends as</span>
    <span class="c1">// the column.</span>
    <span class="c1">//</span>
    <span class="c1">// Err means that this is after the nth newline, except Err(0),</span>
    <span class="c1">// which means it is before the first one.</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Rust</a></div></div> <p><a href="#fnref:offsets" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:80-cols" role="doc-endnote"> <p>The Rust people keep trying to convince me that it should be 100. They are wrong. 80 is perfect. They only think they need 100 because they use the incorrect tab width of four spaces, rather than two. This is the default for clang-format and it’s <em>perfect</em>. <a href="#fnref:80-cols" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-16 • 3570 words • 39 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/16/rangefuncs/"> Go's Weird Little Iterators </a></h1> </div> <div class="post"> <p>A second post on Go silliness (Miguel, aren’t you a C++ programmer?): in 1.23, Go <em>finally</em> added custom iterators. Now, back when I was at Google and involved in the Go compiler as “the annoying Rust guy who gets lunch with us”, there were proposals suggesting adding something like this, implemented as either an interface or a func:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Iter</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Go</a></div></div> <p>This is not what Go did. No, Go did something really weird. And the implementation is <em>incredible</em>.</p> <h2 id="whats-an-iterator"><a href="#whats-an-iterator">What’s an Iterator?</a></h2> <p>An <em>iterator</em>, in the context of programming language design, is a special type of value that can be used to walk through a sequence of values, without necessarily materializing the sequence as whatever the language’s array type is.</p> <p>But, a proper iterator must fit with the language’s looping construct. An <em>iterable type</em> is one which can be used in a for-each loop, such as C++’s <code class="language-plaintext highlighter-rouge">for (T x : y)</code> or Python’s <code class="language-plaintext highlighter-rouge">for x in y</code> (modern languages usually only have a for-each loop as their only <code class="language-plaintext highlighter-rouge">for</code> loop, because C-style for loops are not in anymore).</p> <h3 id="c-iterator-pairs"><a href="#c-iterator-pairs">C++ Iterator Pairs</a></h3> <p>Every language defines a <em>desugaring</em> that defines how custom iteration works in term of the more primitive loops. For example, in C++, when we write <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> (called a <a href="https://en.cppreference.com/w/cpp/language/range-for"><em>range-based for loop</em></a>, added in C++11), desugars as follows<sup id="fnref:cc-range" role="doc-noteref"><a href="#fn:cc-range" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">__range</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">__begin</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span> <span class="c1">// ADL</span>
<span class="k">auto</span> <span class="n">__end</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span>     <span class="c1">// ADL</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">__begin</span> <span class="o">!=</span> <span class="n">__end</span><span class="p">;</span> <span class="o">++</span><span class="n">__begin</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">__begin</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> inside of the loop body require no special handling: they Just Work, because this is just a plain ol for loop.</p> <p>This begin and end weirdness is because, if the iterator backs an actual array, begin and end can just be pointers to the first element and one-past-the-end and this will Just Work. Before C++11, the convention for C++ iterators was to construct types that imitated pointers; you would usually write loops over non-array types like this:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">things</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">things</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">whatever</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">C++</a></div></div> <p>C++ simply codified common (if gross) practice. It is very tedious to implement C++ iterators, though. You need to provide a dummy end iterator, you need to provide some kind of comparison operator, and iterators that don’t return a reference out of <code class="language-plaintext highlighter-rouge">operator*()</code> are… weird.</p> <p>Begin and end can be different types (which is how C++20 ranges pretend to be iterable), but being able to query done-ness separately from the next value makes implementation annoying: it means that an iterator that has not begun iteration (i.e., <code class="language-plaintext highlighter-rouge">++</code> has not been executed yet, because it occurs in the loop’s latch, not its header<sup id="fnref:loop-jargon" role="doc-noteref"><a href="#fn:loop-jargon" class="footnote" rel="footnote">2</a></sup>) needs to do extra work to answer <code class="language-plaintext highlighter-rouge">!= end</code>, which usually means an extra bool to keep track of whether iteration has started or not.</p> <p>Here’s what writing an iterator (that is also an iterable usable in a range for-loop) over the non-zero elements of a <code class="language-plaintext highlighter-rouge">std::span&lt;const int&gt;</code> might look like.</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">NonZero</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">C++</a></div></div> <p>In this case, <code class="language-plaintext highlighter-rouge">operator==</code> is <em>not</em> <code class="language-plaintext highlighter-rouge">const</code>, which is a bit naughty. Purists might argue that this type should have a constructor, which adjusts <code class="language-plaintext highlighter-rouge">ints</code> to point to the first non-zero element on construction, and <code class="language-plaintext highlighter-rouge">operator++</code> to perform the mutation. That would look like this:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">NonZero</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">NonZero</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">)</span> <span class="o">:</span> <span class="n">ints_</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
  <span class="kt">void</span> <span class="n">skip_zeros</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">std::sentinel_for</code> (C++’s iterator concepts are terribly named) really wants <code class="language-plaintext highlighter-rouge">operator==</code> to be <code class="language-plaintext highlighter-rouge">const</code>, but I could have also just marked <code class="language-plaintext highlighter-rouge">ints</code> as <code class="language-plaintext highlighter-rouge">mutable</code> to avoid that. It it’s not already clear, I really dislike this pattern. See <a href="https://github.com/mcy/best/blob/main/best/iter/iter.h">here</a> for some faffing about with C++ iterators on my part.</p> <h3 id="java-also-got-this-wrong"><a href="#java-also-got-this-wrong">Java Also Got This Wrong</a></h3> <p>At least Java provides a standard iterable interface, thankfully.</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">java.util</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
  <span class="no">E</span> <span class="nf">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Java</a></div></div> <p>The desugaring of <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> is then:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">$iter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">$iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span> <span class="o">{</span>
  <span class="no">T</span> <span class="n">x</span> <span class="o">=</span> <span class="n">$iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Java</a></div></div> <p>Do you see the problem here? Although Java now provides a standard interface, doesn’t require annoying equality comparisons, and doesn’t require an end value, these things are <em>still</em> a pain to implement! You still need to be able to query if you’re done before you’ve had a chance to step through the iterator.</p> <p>Like before, suppose we have an <code class="language-plaintext highlighter-rouge">int[]</code>, and we want to yield every non-zero value in it. How do we construct an iterator for that?</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span><span class="o">[]</span> <span class="n">xs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">var</span> <span class="n">it</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">xs</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;</span> <span class="o">!</span><span class="n">done</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{}</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">done</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">hasNext</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">++];</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">done</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">array</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Java</a></div></div> <p>What a pain. Java’s anonymous classes being wordy aside, it’s annoying and error-prone to do this: it’s tempting to accidentally implement <code class="language-plaintext highlighter-rouge">hasNext</code> by simply checking if the array is empty. (Aside, I hate that <code class="language-plaintext highlighter-rouge">xs.length</code> throws on null arrays. Just return zero like in Go, c’mon).</p> <p>Also, it’s no a single-abstract-method interface, so I can’t use a lambda to create an iterator.</p> <p>At least <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> Just Work, because the underlying operation is a for loop like before.</p> <h3 id="rust-does-it-better"><a href="#rust-does-it-better">Rust Does It Better</a></h3> <p>Rust <em>also</em> has a standard iterable interface.</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// mod core::iter</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">IntoIterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">Iter</span><span class="p">:</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">next</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>The desugaring for <code class="language-plaintext highlighter-rouge">for x in y { ... }</code> is reasonably straightforward, like in Java:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">__it</span> <span class="o">=</span> <span class="nn">IntoIterator</span><span class="p">::</span><span class="nf">into_iter</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">__it</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p>This is so straightforward that it’s not <em>so</em> unusual to write it yourself, when you don’t plan on consuming the entire iterator. Alternatively, you can partially iterate over an iterator by taking a mutable reference to it. This is useful for iterators that can yield their remainder.</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="n">my_slice</span><span class="nf">.chunks_exact</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span> <span class="p">{</span>
  <span class="nf">do_thing</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">do_thing</span><span class="p">(</span><span class="n">it</span><span class="nf">.remainder</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> work in the obvious way.</p> <p>The interface solves the problems C++ and Java had very cleanly: <code class="language-plaintext highlighter-rouge">next</code> both computes the next item and whether the iterator has more elements. Rust even allows iterators to resume yielding <code class="language-plaintext highlighter-rouge">Some</code> after yielding <code class="language-plaintext highlighter-rouge">None</code>, although few algorithms will make use of this.</p> <p>Implementing the non-zero iterator we’ve been writing so far is quite simple:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">ints</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
  <span class="k">while</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="n">item</span>
<span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>However, this can be written far more simply<sup id="fnref:size_hint" role="doc-noteref"><a href="#fn:size_hint" class="footnote" rel="footnote">3</a></sup> using iterator combinators:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Rust</a></div></div> <p>It requires a little bit of effort to implement some iterators, but most of the common cases are easy to put together with composition.</p> <p>Python iterators are basically the same thing, but there’s no interface to implement (because Python doesn’t believe in type safety). Lua iterators are similar. The Rust pattern of a function that returns the next item (or a special end-of-sequence value) is relatively popular because of this simplicity and composability, and because they can model a lot of iteration strategies.</p> <h2 id="so-what-did-go-do"><a href="#so-what-did-go-do">So, What Did Go Do?</a></h2> <p>Well. Go has a range for syntax like many other languages. The syntax looks like this:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">y</span> <span class="p">{</span>
  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Go</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">x</code> can be a list of places, and the <code class="language-plaintext highlighter-rouge">:=</code> can be plain assignment, <code class="language-plaintext highlighter-rouge">=</code>. You can also write <code class="language-plaintext highlighter-rouge">for range y { ... }</code> if the iteration values aren’t needed.</p> <p>The behavior of this construct, like many others in Go, depends explicitly on the type after <code class="language-plaintext highlighter-rouge">range</code>. Each range iteration can yield zero or more values; the</p> <p>These are:</p> <ol> <li>For <code class="language-plaintext highlighter-rouge">[]T</code>, <code class="language-plaintext highlighter-rouge">[n]T</code>, and <code class="language-plaintext highlighter-rouge">*[n]T</code>, each step yields an index of the slice and the value at that offset, in order.</li> <li>For <code class="language-plaintext highlighter-rouge">map[K]V</code>, each step yields a key and a value, in a random order.</li> <li> <p>For <code class="language-plaintext highlighter-rouge">&lt;- chan T</code>, it desugars into</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
 <span class="n">x</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">y</span>
 <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Go</a></div></div> </li> <li> <p>Starting in Go 1.22, ranging on an integer type would desugar into</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Go</a></div></div> </li> </ol> <p>All of these desugars are essentially still just loops, so <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work as expected.</p> <p>But, how do custom types, like weird map types, implement iteration? The usual<sup id="fnref:chan-iter" role="doc-noteref"><a href="#fn:chan-iter" class="footnote" rel="footnote">4</a></sup> implementation is <a href="https://pkg.go.dev/sync#Map.Range"><code class="language-plaintext highlighter-rouge">sync.Map.Range</code></a>, which looks like this:</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">Map</span><span class="p">)</span> <span class="n">Range</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="n">any</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Go</a></div></div> <p>This function will call <code class="language-plaintext highlighter-rouge">yield</code> for each element in the map. If the function returns <code class="language-plaintext highlighter-rouge">false</code>, iteration will stop. This pattern is not uncommon, but sometimes libraries omit the <code class="language-plaintext highlighter-rouge">bool</code> return (like <a href="https://pkg.go.dev/container/ring@go1.23.4#Ring.Do"><code class="language-plaintext highlighter-rouge">container/ring.Ring.Do</code></a>). Some, like <a href="https://pkg.go.dev/path/filepath#WalkFunc"><code class="language-plaintext highlighter-rouge">filepath.WalkDir</code></a>, have a more complex interface involving errors.</p> <p>This is the template for what became <em>rangefuncs</em>, a mechanism for using the for-range syntax with certain function values.</p> <h2 id="rangefuncs"><a href="#rangefuncs">Rangefuncs</a></h2> <p>The word “rangefunc” does not appear in Go’s specification. It is a term used to refer to them in some documentation, within the compiler, and in the runtime.</p> <p>A rangefunc is any function with one of the following signatures:</p> <ul> <li><code class="language-plaintext highlighter-rouge">func(yield func() bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(V) bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(K, V) bool)</code></li> </ul> <p>They work like <code class="language-plaintext highlighter-rouge">sync.Map.Range</code> does: the function calls <code class="language-plaintext highlighter-rouge">yield</code> (hereafter simply called “the yield”) for each element, and stops early if yield returns false. The <code class="language-plaintext highlighter-rouge">iter</code> package contains types for the second and third of these:</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="k">type</span> <span class="n">Seq2</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Go</a></div></div> <p>For example, the <code class="language-plaintext highlighter-rouge">slices</code> package provides an adaptor for converting a slice into an iterator that ranges over it.</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="c">// All returns an iterator over index-value pairs in the slice</span>
<span class="c">// in the usual order.</span>
<span class="k">func</span> <span class="n">All</span><span class="p">[</span><span class="n">Slice</span> <span class="err">~</span><span class="p">[]</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="n">Slice</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
			<span class="k">if</span> <span class="o">!</span><span class="n">yield</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Go</a></div></div> <p>So. These things are actually pretty nuts. They break my brain somewhat, because this is the opposite of how iterators usually work. Go calls what I’ve described all the other languages do a “pull iterator”, whereas rangefuncs are “push iterators”.</p> <p>They have a few obvious limitations. For one, you can’t do smart sizing like with Rust or C++ iterators<sup id="fnref:size-hint2" role="doc-noteref"><a href="#fn:size-hint2" class="footnote" rel="footnote">5</a></sup>. Another is that you can’t easily “pause” iteration.</p> <p>But they do have one advantage, which I think is the real reason Go went to so much trouble to implement them (and yes, I will dig into how insane that part is). Using push iterators by default means that users “only” need to write an ordinary for loop packaged into a function. Given that Go makes major performance sacrifices in order to be easy to learn<sup id="fnref:tooling" role="doc-noteref"><a href="#fn:tooling" class="footnote" rel="footnote">6</a></sup>, trying to make it so that an iterator packages the actual looping construct it represents makes quite a bit of sense.</p> <p>Rangefuncs are actually really cool in some respects, because they enable unusual patterns. For example, you can use a rangefunc to provide RAII blocks.</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Open</span><span class="p">(</span><span class="n">fs</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">,</span> <span class="n">path</span> <span class="kt">string</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fs</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="p">{</span>
      <span class="n">yield</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="n">yield</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">DirFS</span><span class="p">(</span><span class="s">"/"</span><span class="p">),</span> <span class="s">"etc/passwd"</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">Go</a></div></div> <p>Being a block that you can put an epilog onto after yielding a single element is quite powerful! You can also use a nilary rangefunc to simply create a block that you can break out of, instead of having to use <code class="language-plaintext highlighter-rouge">goto</code>.</p> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Once</span><span class="p">()</span> <span class="k">func</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="k">range</span> <span class="n">Once</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">canDo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">break</span>
  <span class="p">}</span>

  <span class="n">do</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">Go</a></div></div> <p>So wait. You can return out of rangefunc loops. That means that… Go has non-local returns?!</p> <h2 id="go-now-has-non-local-returns"><a href="#go-now-has-non-local-returns">Go Now Has Non-Local Returns</a></h2> <p>The desugaring for rangefuncs is very complicated. This is because <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work in a rangefunc! How does this work? Let’s Godbolt it.</p> <p>Let’s start with something really basic: a loop body that just calls a function.</p> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:25">Go</a></div></div> <p>This produces the following assembly output (which I’ve reformatted into Intel syntax, and removed some extraneous ABI things, including a writer barrier where <code class="language-plaintext highlighter-rouge">(*)</code> is below).</p> <div class="codeblock" id="code:26"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>  <span class="c1">// (*)</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">api</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic2</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:26">x86 Assembly</a></div></div> <p>This is a lot to take in, but if we look carefully, we decompile this function into a Go function:</p> <div class="codeblock" id="code:27"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c">// Loop body</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:27">Go</a></div></div> <p>Go will actually enforce invariants on the yield it synthesizes in a range for, in order to catch buggy code. In particular, <code class="language-plaintext highlighter-rouge">__state</code> escapes because <code class="language-plaintext highlighter-rouge">s</code> is an arbitrary function, so it gets spilled to the heap.</p> <p>So, what happens when the loop body contains a break? Consider:</p> <div class="codeblock" id="code:28"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:28">Go</a></div></div> <p>I’ll spare you the assembly listing, since it’s very similar, so I’ll just reverse-engineer the output directly:</p> <div class="codeblock" id="code:29"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:29">Go</a></div></div> <p>Non-local returns are much more complicated. Consider:</p> <div class="codeblock" id="code:30"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:30">Go</a></div></div> <p>The resulting assembly is something like this, with some irrelevant code, such as write barriers, removed:</p> <div class="codeblock" id="code:31"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int; X1 *int; X2 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rdi</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">jne</span>     <span class="n">resume</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">resume</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">test</span>    <span class="n">al</span><span class="p">,</span> <span class="n">al</span>
    <span class="n">jeq</span>     <span class="n">cont</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_DONE</span>
    <span class="n">xor</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">cont</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:31">x86 Assembly</a></div></div> <p>Try to reverse engineer this yourself, if you like! If you write this out as Go, here’s what you get:</p> <div class="codeblock" id="code:32"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">(</span><span class="n">__ret</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">__next</span> <span class="kt">int</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="n">__next</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
      <span class="n">__ret</span> <span class="o">=</span> <span class="n">v</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
  <span class="k">if</span> <span class="n">__next</span> <span class="o">==</span> <span class="o">-</span><span class="m">1</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:32">Go</a></div></div> <p>The reason <code class="language-plaintext highlighter-rouge">__next</code> is an int is because it is also used when exiting the loop via <code class="language-plaintext highlighter-rouge">goto</code> or a <code class="language-plaintext highlighter-rouge">break</code>/<code class="language-plaintext highlighter-rouge">continue</code> with label. It specifies where to jump to after the call into the rangefunc returns. Each potential control flow out of the loop is assigned some negative number.</p> <p>The precise details of the lowering have been <a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/rangefunc/rewrite.go">exquisitely documented</a> by Russ Cox and David Chase, the primary implementers of the feature.</p> <p>You might be curious what <code class="language-plaintext highlighter-rouge">runtime.panicrangestate</code> does. It’s pretty simple, and it lives in <code class="language-plaintext highlighter-rouge">runtime/panic.go</code>:</p> <div class="codeblock" id="code:33"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="c">//go:noinline</span>
<span class="k">func</span> <span class="n">panicrangestate</span><span class="p">(</span><span class="n">state</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_State</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeDoneError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangePanicError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeExhaustedError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_MISSING_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeMissingPanicError</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">throw</span><span class="p">(</span><span class="s">"unexpected state passed to panicrangestate"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:33">Go</a></div></div> <p>If you visit this function in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/panic.go;l=306?q=panicrangestate&amp;ss=go%2Fgo">runtime/panic.go</a>, you will be greeted by this extremely terrifying comment from Russ Cox immediately after it.</p> <div class="codeblock" id="code:34"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// deferrangefunc is called by functions that are about to</span>
<span class="c">// execute a range-over-function loop in which the loop body</span>
<span class="c">// may execute a defer statement. That defer needs to add to</span>
<span class="c">// the chain for the current function, not the func literal synthesized</span>
<span class="c">// to represent the loop body. To do that, the original function</span>
<span class="c">// calls deferrangefunc to obtain an opaque token representing</span>
<span class="c">// the current frame, and then the loop body uses deferprocat</span>
<span class="c">// instead of deferproc to add to that frame's defer lists.</span>
<span class="c">//</span>
<span class="c">// The token is an 'any' with underlying type *atomic.Pointer[_defer].</span>
<span class="c">// It is the atomically-updated head of a linked list of _defer structs</span>
<span class="c">// representing deferred calls. At the same time, we create a _defer</span>
<span class="c">// struct on the main g._defer list with d.head set to this head pointer.</span>
<span class="c">//</span>
<span class="c">// The g._defer list is now a linked list of deferred calls,</span>
<span class="c">// but an atomic list hanging off:</span>
<span class="c">//</span>
<span class="c">// (increasingly terrifying discussion of concurrent data structures)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:34">Go</a></div></div> <p>This raises one more thing that works in range funcs, seamlessly: <code class="language-plaintext highlighter-rouge">defer</code>. Yes, despite the yield executing multiple call stacks away, possibly on a different goroutine… <code class="language-plaintext highlighter-rouge">defer</code> still gets attached to the calling function.</p> <h2 id="go-now-has-non-local-defer"><a href="#go-now-has-non-local-defer">Go Now Has Non-Local Defer</a></h2> <p>The way defer works is that each G (the goroutine struct, <code class="language-plaintext highlighter-rouge">runtime.g</code>) holds a linked list of defer records, of type <code class="language-plaintext highlighter-rouge">_defer</code>. Each call to <code class="language-plaintext highlighter-rouge">defer</code> sticks one of these onto this list. On function return, Go calls <code class="language-plaintext highlighter-rouge">runtime.deferreturn()</code>, which essentially executes and pops defers off of the list until it finds one whose stack pointer is not the current function’s stack pointer (so, it must belong to another function).</p> <p>Rangefuncs throw a wrench in that mix: if <code class="language-plaintext highlighter-rouge">myFunc.range-n</code> defers, that defer has to be attached to <code class="language-plaintext highlighter-rouge">myFunc</code>’s defer records somehow. So the list must have a way of inserting in the middle.</p> <p>This is what this comment is about: when <code class="language-plaintext highlighter-rouge">defer</code> occurs in the loop body, that defer gets attached to a defer record for that function, using a token that the yield captures; this is later canonicalized when walking the defer list on the way out of <code class="language-plaintext highlighter-rouge">myFunc</code>. Because the yield can escape onto another goroutine, this part of the <code class="language-plaintext highlighter-rouge">defer</code> chain has to be atomic.</p> <p>Incredibly, this approach is extremely robust. For example, if we spawn the yield as a goroutine, and carefully synchronize between that and the outer function, we can force the runtime to hard-crash when <code class="language-plaintext highlighter-rouge">defer</code>ing to a function that has returned.</p> <div class="codeblock" id="code:35"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">bad</span><span class="p">()</span> <span class="p">(</span><span class="n">out</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="n">w1</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="n">w2</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>

	<span class="n">out</span> <span class="o">=</span> <span class="n">w2</span><span class="o">.</span><span class="n">Done</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">recover</span><span class="p">()</span> <span class="p">}()</span>
	<span class="n">iter</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">yield</span><span class="p">()</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait to enter yield().</span>
    <span class="c">// This panics once w1.Done() executes, because</span>
    <span class="c">// we exit the rangefunc while yield() is still</span>
    <span class="c">// running. The runtime incorrectly attributes</span>
    <span class="c">// this to recovering in the rangefunc.</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="k">range</span> <span class="n">iter</span> <span class="p">{</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="c">// Allow the outer function to exit the loop.</span>
		<span class="n">w2</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait for bad() to return.</span>
		<span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"bang"</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="k">return</span> <span class="no">nil</span> <span class="c">// Unreachable</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">resume</span> <span class="o">:=</span> <span class="n">bad</span><span class="p">()</span>
  <span class="n">resume</span><span class="p">()</span>
  <span class="k">select</span> <span class="p">{}</span>  <span class="c">// Block til crash.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:35">Go</a></div></div> <p>This gets us <code class="language-plaintext highlighter-rouge">fatal error: defer after range func returned</code>. Pretty sick! It accomplishes this by poisoning the token the yield func uses to defer.</p> <p>I have tried various other attempts at causing memory unsafety with rangefuncs, but Go actually does a really good job of avoiding this. The only thing I’ve managed to do that’s especially interesting is to tear the return slot on a function without named returns, but that’s no worse than tearing any other value (which is still really bad, because you can tear interface values, but it’s not <em>worse</em>).</p> <h2 id="pull-iterators-and-coroutines"><a href="#pull-iterators-and-coroutines">Pull Iterators and Coroutines</a></h2> <p>Of course we’re not done. Go provides a mechanism for converting push iterators into pull iterators. Essentially, there is a function that looks like this:</p> <div class="codeblock" id="code:36"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">yield</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">})</span>
  <span class="n">pull</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}{})</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">seq</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">pull</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">yield</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">}{</span><span class="n">v</span><span class="p">,</span> <span class="no">true</span><span class="p">}</span>
    <span class="p">})</span>

    <span class="nb">close</span><span class="p">(</span><span class="n">yield</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pull</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="n">yield</span>
  <span class="p">}</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">close</span><span class="p">(</span><span class="n">pull</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:36">Go</a></div></div> <p>Essentially, you can request values with <code class="language-plaintext highlighter-rouge">next()</code>, and <code class="language-plaintext highlighter-rouge">stop()</code> can be used if you finish early. But also, this spawns a whole goroutine and uses channels to communicate and synchronize, which feels very unnecessary.</p> <p>The implementation doesn’t use goroutines. It uses coroutines.</p> <h3 id="giving-up-on-goroutines"><a href="#giving-up-on-goroutines">Giving Up on Goroutines</a></h3> <p>Spawning a goroutine is expensive. Doing so expends scheduler and memory resources. It’s overkill for a helper like this (ironic, because the original premise of Go was that goroutines would be cheap enough to allocate willy-nilly).</p> <p>Go instead implements this using “coroutines”, a mechanism for concurrency without parallelism. This is intended to make context switching very cheap, because it does not need to go through the scheduler: instead, it uses cooperative multitasking.</p> <p>The coroutine interface is something like the following. My “userland” implementation will not be very efficient, because it relies on the scheduler to transfer control. The goroutines may run on different CPUs, so synchronization is necessary for communication, even if they are not running concurrently.</p> <div class="codeblock" id="code:37"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">coro</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"runtime"</span>
  <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Coro</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">m</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="o">*</span><span class="n">Coro</span> <span class="p">{</span>
  <span class="n">c</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Coro</span><span class="p">)</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">f</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Coro</span><span class="p">)</span> <span class="n">Resume</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:37">Go</a></div></div> <p>When we create a coroutine with <code class="language-plaintext highlighter-rouge">coro.New()</code>, it spawns a goroutine that waits on a mutex. Another goroutine can “take its place” as the mutex holder by calling <code class="language-plaintext highlighter-rouge">c.Resume()</code>, which allows the coroutine spawned by <code class="language-plaintext highlighter-rouge">coro.New</code> to resume and enter <code class="language-plaintext highlighter-rouge">f()</code>.</p> <p>Using the coroutine as a rendezvous point, two goroutines can perform concurrent work: in the case of <code class="language-plaintext highlighter-rouge">iter.Pull</code>, one can be deep inside of whatever loops the iterator wants to do, and the other can request values.</p> <p>Here’s what using my <code class="language-plaintext highlighter-rouge">coro.Coro</code> to implement <code class="language-plaintext highlighter-rouge">iter.Pull</code> might look like:</p> <div class="codeblock" id="code:38"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">var</span> <span class="p">(</span>
    <span class="n">done</span> <span class="kt">bool</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">z</span> <span class="n">V</span>
  <span class="p">)</span>

  <span class="n">c</span> <span class="o">:=</span> <span class="n">coro</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v1</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Wait for a request for a value.</span>
      <span class="k">if</span> <span class="n">done</span> <span class="p">{</span>
        <span class="c">// This means we resumed from stop(). Break out of the</span>
        <span class="c">// loop.</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">v1</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
      <span class="c">// Yield the last value.</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">z</span>
    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
  <span class="p">})</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="no">false</span> <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>      <span class="c">// Request a value.</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="no">true</span>  <span class="c">// Return it.</span>
  <span class="p">}</span>

  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span> <span class="c">// Mark iteration as complete.</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Resume the iteration goroutine to it can exit.</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">next</span><span class="p">,</span> <span class="n">stop</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:38">Go</a></div></div> <p>If you look at the implementation in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/iter/iter.go"><code class="language-plaintext highlighter-rouge">iter.go</code></a>, it’s basically this, but with a lot of error checking and race detection, to prevent misuse, such as if <code class="language-plaintext highlighter-rouge">next</code> or <code class="language-plaintext highlighter-rouge">stop</code> escape to other goroutines.</p> <p>Now, the main thing that runtime support brings here is that <code class="language-plaintext highlighter-rouge">Resume()</code> is immediate: it does not go to the scheduler, which might not decide to immediately run the goroutine that last called <code class="language-plaintext highlighter-rouge">Resume()</code> for a variety of reasons (for example, to ensure wakeup fairness). Coroutines sidestep fairness, by making <code class="language-plaintext highlighter-rouge">Resume()</code> little more than a jump to the last <code class="language-plaintext highlighter-rouge">Resume()</code> (with registers fixed up accordingly).</p> <p>This is not going to be <em>that</em> cheap: a goroutine still needs to be allocated, and switching needs to poke and prod the underlying Gs a little bit. But it’s a cool optimization, and I hope coroutines eventually make their way into more things in Go, hopefully as a language or <code class="language-plaintext highlighter-rouge">sync</code> primitive.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Congratulations, you have survived over 3000 words of me going on about iterators. Go’s push iterators are a unique approach to a common language design problem (even if it took a decade for them to materialize).</p> <p>I encountered rangefuncs for the first time earlier this year and have found them absolutely fascinating, both from a “oh my god they actually did that” perspective and from a “how do we express iteration” perspective. I don’t think the result was perfect by any means, and it is unsuitable for languages that need the performance you can only get from pull iterators. I think they would be a great match for a language like Python or Java, though.</p> <p>I’d like to thank David Chase, an old colleague, for tolerating my excited contrived questions about the guts of this feature.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:cc-range" role="doc-endnote"> <p>Ugh, ok. This is the C++20 desugaring, and there are cases where we do not just call <code class="language-plaintext highlighter-rouge">std::begin()</code>. In particular, array references and class type references with <code class="language-plaintext highlighter-rouge">.begin()</code> and <code class="language-plaintext highlighter-rouge">.end()</code> do not call <code class="language-plaintext highlighter-rouge">std::begin()</code> and are open-coded. This means that you can’t use ADL to override these types’ iterator. <a href="#fnref:cc-range" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:loop-jargon" role="doc-endnote"> <p>In compiler jargon, a loop is broken up into three parts: the <em>header</em>, which is where the loop is entered, the <em>body</em>, which is one step of iteration, and the <em>latch</em>, which is the part that jumps back to the start of the body. This is where incrementation in a C-style for loop happens. <a href="#fnref:loop-jargon" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size_hint" role="doc-endnote"> <p>And with better performance. Rust’s iterators can provide a size hint to help size containers before a call to <code class="language-plaintext highlighter-rouge">collect()</code>, via the <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code class="language-plaintext highlighter-rouge">FromIterator</code></a> trait. <a href="#fnref:size_hint" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:chan-iter" role="doc-endnote"> <p>Some people observed that you can use a channel as a custom iterator, by having a parallel goroutine run a for loop to feed the channel. <em>Do not do this.</em> It is slow: it has to transit each element through the heap, forcing anything it points to escape. It takes up an extra M and a P in the scheduler, and requires potentially allocating a stack for a G. It’s probably faster to just build a slice and return that, especially for small iterations. <a href="#fnref:chan-iter" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size-hint2" role="doc-endnote"> <p>For this reason, I wish that Go had instead defined something along these lines.</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Iterate</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">Go</a></div></div> <p>This is functionally identical to what they did, but it would have permitted future extensions such as the following interface:</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">SizedSeq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">]</span>

  <span class="n">SizeHint</span><span class="p">()</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="kt">int64</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">Go</a></div></div> <p>This would mean that <code class="language-plaintext highlighter-rouge">slices.Collect</code> could be enhanced into something like this.</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="k">func</span> <span class="n">Collect</span><span class="p">[</span><span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="n">E</span><span class="p">])</span> <span class="p">[]</span><span class="n">E</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">out</span> <span class="p">[]</span><span class="n">E</span>
  <span class="k">if</span> <span class="n">sized</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">seq</span><span class="o">.</span><span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">SizedSeq</span><span class="p">[</span><span class="n">E</span><span class="p">]);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">sized</span><span class="o">.</span><span class="n">SizeHint</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">E</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">seq</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">out</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">Go</a></div></div> <p>I don’t think there’s an easy way to patch this up, at this point. <a href="#fnref:size-hint2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:tooling" role="doc-endnote"> <p>Disclaimer: I am not going to dig into Go’s rationale for rangefuncs. Knowing how the sausage is made, most big Go proposals are a mix of understandable reasoning and less reasonable veiled post-hoc justification to compensate for either Google planning/approvals weirdness or because the design was some principal engineer’s pony. This isn’t even a Go thing, it’s a Google culture problem. I say this as the architect of <a href="https://protobuf.dev/editions/overview">Protobuf Editions</a>, the biggest change to Protobuf since Rob’s misguided proto3<sup id="fnref:proto2" role="doc-noteref"><a href="#fn:proto2" class="footnote" rel="footnote">7</a></sup> experiment. <em>I</em> have written this kind of language proposal, on purpose, because bad culture mandated it.</p> <p><em>The purpose of a system is what it does.</em> It is easier to understand a system by observing its response to stimuli, rather than what it says on the tin. So let’s use that lens.</p> <p>Go wants to be easy to learn. It intended to replace C++ at Google (lol, lmao), which, of course, failed disastrously, because performance of the things already written in C++ is tied to revenue. They have successfully pivoted to being an easy-to-learn language that makes it easy to onboard programmers regardless of what they already use, as opposed to onboarding them to C++.</p> <p>This does not mean that Go is user-friendly. In fact, user-friendliness is clearly not a core value. Rob and his greybeard crowd didn’t seem to care about the human aspect of interacting with a toolchain, so Go tooling rarely provides good diagnostics, nor did the language, until the last few years, try to reduce toil. After all, if it is tedious to use but simple, that does make it easy to onboard new programmers.</p> <p>Rust is the opposite: it is very difficult to learn with a famously steep learning curve; however, it is very accessible, because the implementors have sanded down every corner and sharp edge using diagnostics, error messages, and tooling. C++ is neither of these things. It is very difficult to learn, and most compilers are pretty unhelpful (if they diagnose anything at all).</p> <p>I think that Go has at least realized the language can be a pain to use in some situations, which is fueled in part by legitimate UX research. This is why Go has generics and other recent advanced language features, like being able to use the <code class="language-plaintext highlighter-rouge">for</code> syntax with integers or with custom iterators.</p> <p>I think that rangefuncs are easy to learn in the way Go needs them to be. If you expect more users to want to write rangefuncs than users want to write complicated <em>uses</em> of rangefuncs, I think push iterators are the easiest to learn how to use.</p> <p>I think this is a much more important reason for all the trouble that rangefuncs generate for the compiler and runtime than, say, compatibility with existing code; I have not seen many cases in the wild or in the standard library that conform to the rangefunc signatures. <a href="#fnref:tooling" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:proto2" role="doc-endnote"> <p>But please don’t use proto3. I’m telling you that as the guy who maintained the compiler. Just don’t. <a href="#fnref:proto2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-12 • 2804 words • 31 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/12/go-abi/"> Things You Never Wanted To Know About Go Interfaces </a></h1> </div> <div class="post"> <p>Lately I’ve been finding myself writing a bit of Go, and I’ve picked up various fun “layout secrets” that help inform how I write code to minimize hidden allocations, and generally be kind to the optimizer. This article is a series of notes on the topic.</p> <p>This post is about Go implementation details, so they can probably break you at any time if you rely on it. On the other hand, Hyrum’s law is a bitch, so taking your chances may not be that bad. After all, they’re probably never going to be able to properly clean up the mess people made with <code class="language-plaintext highlighter-rouge">//go:linkname</code> with runtime symbols…</p> <p>As with many of my other posts, I’ll assume a basic familiarity with being able to read assembly. I’m using x86 for this post, but it’s worth looking at my <a href="https://mcyoung.xyz//2021/11/09/assembly-1">RISC-V post</a> for a refresher.</p> <h2 id="gc-shapes"><a href="#gc-shapes">GC Shapes</a></h2> <p>The most basic Go-specific concept when it comes to type layouts is the <em>shape</em> of a type. This is an implementation detail of Go’s garbage collector that leaks through the <code class="language-plaintext highlighter-rouge">unsafe</code> package.</p> <p>Like in most native programming languages, every Go type has a size (the number of bytes that type takes up in memory) and an alignment (a power of two that every pointer to that type must be divisible by). Go, like most other languages, requires that size be divisible by the alignment: that is, the size is equal to the stride of an array of that type.</p> <p>The size an alignment of a type can be queried by the intrinsics <a href="https://pkg.go.dev/unsafe#Sizeof"><code class="language-plaintext highlighter-rouge">unsafe.Sizeof</code></a> and <a href="https://pkg.go.dev/unsafe#Alignof"><code class="language-plaintext highlighter-rouge">unsafe.Alignof</code></a>. These are very unwieldy in generic code, so I like to define a couple of helpers<sup id="fnref:constants" role="doc-noteref"><a href="#fn:constants" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Size</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Align</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Go</a></div></div> <p>Together, these two quantities are called the <em>layout</em> of a type (a term common to many native languages). However, the <em>shape</em> of a type also records what pieces thereof contain <em>pointers</em>. This is because memory visible to the GC (such as globals, heap memory, or stack roots) is typed, and the GC needs to know which parts of those types are pointers that it needs to trace through.</p> <p>Because all pointers have the same size and alignment (4 or 8 bytes depending on the system) the pointer words of a type can be represented as a bitset, one bit for every 4 or 8 bytes in the type. This, in fact, is the representation used by the GC<sup id="fnref:gc-programs" role="doc-noteref"><a href="#fn:gc-programs" class="footnote" rel="footnote">2</a></sup>.</p> <p>In particular, this means that whether a field is to be interpreted as an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code> or as a <code class="language-plaintext highlighter-rouge">uintptr</code> is a static property of the type. As we will see when we discuss interfaces, this restriction prevents a few layout optimizations.</p> <h2 id="slices-and-strings"><a href="#slices-and-strings">Slices and Strings</a></h2> <p>Go is very public about the layout of slices and strings. A slice is</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">slice</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span>     <span class="o">*</span><span class="n">T</span>
  <span class="nb">len</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Go</a></div></div> <p><code class="language-plaintext highlighter-rouge">len</code> and <code class="language-plaintext highlighter-rouge">cap</code> are extracted by their eponymous builtins, and <code class="language-plaintext highlighter-rouge">data</code> can be obtained using <code class="language-plaintext highlighter-rouge">unsafe.SliceData</code> (or <code class="language-plaintext highlighter-rouge">&amp;s[0]</code> if the slice is nonempty, but that costs a bounds-check).</p> <p>A string has the same layout as a <code class="language-plaintext highlighter-rouge">[]byte</code>, except for a capacity:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="kt">string</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
  <span class="nb">len</span>  <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Go</a></div></div> <p>Despite essentially being slices, Go treats strings subtly differently. Strings are <code class="language-plaintext highlighter-rouge">comparable</code>, so they can be used as map keys. They are also immutable, which enables a handful of optimizations. Immutability is also why they are <code class="language-plaintext highlighter-rouge">comparable</code>: Go made the mistake of not keeping <code class="language-plaintext highlighter-rouge">const</code> from C, but they really want map keys to be <code class="language-plaintext highlighter-rouge">const</code>.</p> <p>There is nothing stopping us from aliasing strings to data pointed to by a slice: after all, <code class="language-plaintext highlighter-rouge">strings.Builder</code> does it to avoid a copy in <code class="language-plaintext highlighter-rouge">String()</code>. We can implement this easily enough with some <code class="language-plaintext highlighter-rouge">unsafe</code>:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">StringAlias</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Go</a></div></div> <p>Doing this is perfectly safe, so long as data is not mutated while the returned string is accessible. This allows virtually any slice type to be used as a key in a map, with some caveats.</p> <ol> <li> <p>Types which contain alignment padding cannot be used, because Go does not promise that it zeros memory returned by <code class="language-plaintext highlighter-rouge">new</code>.</p> </li> <li> <p>Types which contain pointers will cause those pointers to become unreachable if the only reference is the aliased string; this is because the pointed to data’s shape contains no pointer words.</p> </li> <li> <p>Incomparable types and interfaces will be compared by address (that is, maps, channels and funcs).</p> </li> </ol> <h3 id="dynamic-arrays-with-reflection"><a href="#dynamic-arrays-with-reflection">Dynamic Arrays with Reflection</a></h3> <p>Now, this isn’t the only to accomplish this: you can create dynamically-sized array types using reflection, like so:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Slice2Array</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span>

  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="n">elem</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">elem</span><span class="p">)</span>

  <span class="c">// NOTE: NewAt will return a reflect.Value containing a</span>
  <span class="c">// pointer, not an array!</span>
  <span class="n">refl</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">NewAt</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
  <span class="n">refl</span> <span class="o">=</span> <span class="n">refl</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span> <span class="c">// Dereference to get a pointer-to-array.</span>
  <span class="k">return</span> <span class="n">refl</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Go</a></div></div> <p>This will return an <code class="language-plaintext highlighter-rouge">any</code> whose type is <code class="language-plaintext highlighter-rouge">[len(s)]T</code>. You can even type assert it for static array sizes. This any is suitable for placing into a <code class="language-plaintext highlighter-rouge">map[any]T</code>, just as if we had built it with e.g. <code class="language-plaintext highlighter-rouge">any([...]byte("foo"))</code></p> <p>However, and this is not at all obvious from the code here, calling <code class="language-plaintext highlighter-rouge">refl.Interface()</code> will perform a copy of the whole array. <code class="language-plaintext highlighter-rouge">Interface()</code> delegates through a few functions until it calls <code class="language-plaintext highlighter-rouge">reflect.packEface()</code>.</p> <p>The code this function (<a href="https://cs.opensource.google/go/go/+/master:src/reflect/value.go;l=119?q=packEface&amp;ss=go%2Fgo">found here</a>) is reproduced below:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">reflect</span>

<span class="c">// packEface converts v to the empty interface.</span>
<span class="k">func</span> <span class="n">packEface</span><span class="p">(</span><span class="n">v</span> <span class="n">Value</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">typ</span><span class="p">()</span>
	<span class="k">var</span> <span class="n">i</span> <span class="n">any</span>
	<span class="n">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">abi</span><span class="o">.</span><span class="n">EmptyInterface</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span>
	<span class="c">// First, fill in the data portion of the interface.</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">t</span><span class="o">.</span><span class="n">IfaceIndir</span><span class="p">()</span><span class="o">:</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">"bad indir"</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c">// Value is indirect, and so is the interface we're making.</span>
		<span class="n">ptr</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagAddr</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">:=</span> <span class="n">unsafe_New</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
			<span class="n">typedmemmove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">c</span>
		<span class="p">}</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">ptr</span>
	<span class="k">case</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">!=</span> <span class="m">0</span><span class="o">:</span>
		<span class="c">// Value is indirect, but interface is direct. We need</span>
		<span class="c">// to load the data at v.ptr into the interface data word.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="c">// Value is direct, and so is the interface.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
	<span class="p">}</span>
	<span class="c">// Now, fill in the type portion. We're very careful here not</span>
	<span class="c">// to have any operation between the e.word and e.typ assignments</span>
	<span class="c">// that would let the garbage collector observe the partially-built</span>
	<span class="c">// interface value.</span>
	<span class="n">e</span><span class="o">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">t</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Go</a></div></div> <p>The switch determines precisely how the interface data pointer is computed. It turns out that (almost all) array types return true for <code class="language-plaintext highlighter-rouge">t.IfaceIndr()</code>, so the first case is selected, which triggers a copy (that being the call to <code class="language-plaintext highlighter-rouge">unsafe_New()</code> followed by a <code class="language-plaintext highlighter-rouge">typedmemmove</code>). This copy is to ensure that the value of the resulting interface cannot be mutated.</p> <p>Now, if only we knew the layout of Go’s interfaces, we might be able to get somewhere here…</p> <h2 id="the-layout-of-gos-interfaces"><a href="#the-layout-of-gos-interfaces">The Layout of Go’s Interfaces</a></h2> <p>Oh, yes, that’s what this article is about. So, if we look at the <code class="language-plaintext highlighter-rouge">runtime2.go</code> file in the runtime (yes, that’s what it’s called), nestled among the giant scheduler types for Gs, Ps, and Ms, we’ll find a couple of structs that really elucidate what’s going on:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">iface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">tab</span>  <span class="o">*</span><span class="n">itab</span>
	<span class="n">data</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">eface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">_type</span> <span class="o">*</span><span class="n">_type</span>
	<span class="n">data</span>  <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Go</a></div></div> <p><code class="language-plaintext highlighter-rouge">funcval</code> is the layout of a <code class="language-plaintext highlighter-rouge">func()</code>, more on that later. <code class="language-plaintext highlighter-rouge">iface</code> is the layout of your “usual” interface, consisting of an <code class="language-plaintext highlighter-rouge">itab</code> (an interface table, or what Go calls a vtable) and a pointer to some data. <code class="language-plaintext highlighter-rouge">eface</code> is the layout of <code class="language-plaintext highlighter-rouge">any</code> (the artist formerly known as <code class="language-plaintext highlighter-rouge">interface{}</code>, hence the name: <em>e</em>mpty inter<em>face</em>).</p> <p><code class="language-plaintext highlighter-rouge">eface</code> having its own layout is an optimization. Because <code class="language-plaintext highlighter-rouge">any</code> exists to be downcast from dynamically, storing the type directly cuts out a pointer load when doing a type switch on an <code class="language-plaintext highlighter-rouge">any</code> specifically. If we look at what an <code class="language-plaintext highlighter-rouge">itab</code> is (which is “just” an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/iface.go;l=14"><code class="language-plaintext highlighter-rouge">abi.ITab</code></a>):</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="c">// The first word of every non-empty interface type contains an *ITab.</span>
<span class="c">// It records the underlying concrete type (Type), the interface type</span>
<span class="c">// it is implementing (Inter), and some ancillary information.</span>
<span class="c">//</span>
<span class="c">// allocated in non-garbage-collected memory</span>
<span class="k">type</span> <span class="n">ITab</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Inter</span> <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">Type</span>  <span class="o">*</span><span class="n">Type</span>
	<span class="n">Hash</span>  <span class="kt">uint32</span>     <span class="c">// copy of Type.Hash. Used for type switches.</span>
	<span class="n">Fun</span>   <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c">// fun[0]==0 means Type does not implement Inter.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Go</a></div></div> <h3 id="codegen-for-interface-operations"><a href="#codegen-for-interface-operations">Codegen for Interface Operations</a></h3> <p>An <code class="language-plaintext highlighter-rouge">ITab</code> contains the same type it would have as an <code class="language-plaintext highlighter-rouge">any</code>, which makes the generated code for a function that upcasts an interface to <code class="language-plaintext highlighter-rouge">any</code> very simple<sup id="fnref:asm" role="doc-noteref"><a href="#fn:asm" class="footnote" rel="footnote">3</a></sup>:</p> <div class="code-multicol"> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Upcast</span><span class="p">(</span><span class="n">i</span> <span class="n">MyIface</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Go</a></div></div> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">F</span><span class="o">:</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">x86 Assembly</a></div></div> </div> <p>In the register ABI, the x86 argument (and return) registers are <code class="language-plaintext highlighter-rouge">rax</code>, <code class="language-plaintext highlighter-rouge">rbx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, <code class="language-plaintext highlighter-rouge">r10</code> and <code class="language-plaintext highlighter-rouge">r11</code> (with <code class="language-plaintext highlighter-rouge">rdx</code> reserved for passing a closure capture, more on that later; <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the currently running G).</p> <p>The <code class="language-plaintext highlighter-rouge">*ITab</code> comes in on <code class="language-plaintext highlighter-rouge">rax</code> and the data pointer on <code class="language-plaintext highlighter-rouge">rbx</code>. First, we need to check if this is the nil interface, identified by having a nil itab (or type, in the case of <code class="language-plaintext highlighter-rouge">any</code>). If it is nil, we just return: <code class="language-plaintext highlighter-rouge">rax:rbx</code> already contain the data of a nil <code class="language-plaintext highlighter-rouge">any</code>. Otherwise, we load <code class="language-plaintext highlighter-rouge">ITab.Type</code>, at offset 8, into <code class="language-plaintext highlighter-rouge">rax</code>, and return.</p> <p>How do interface function calls work?</p> <div class="code-multicol"> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span><span class="n">m</span> <span class="n">MyIface</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">Method</span><span class="p">(</span><span class="m">42</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Go</a></div></div> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rsp</span><span class="p">,</span> <span class="n">rbp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="mi">42</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="n">nop</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">morestack_noctxt</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">x86 Assembly</a></div></div> </div> <p>This function seems to be doing a lot more than it actually is. Part of it is that its prologue has to do a call to <code class="language-plaintext highlighter-rouge">runtime.morestack_noctxt()</code>, which is simply a call to <code class="language-plaintext highlighter-rouge">runtime.morestack</code> that clobbers <code class="language-plaintext highlighter-rouge">rdx</code>, the closure capture parameter. The meat of it comes when it loads <code class="language-plaintext highlighter-rouge">[rax + 24]</code>, the first element of <code class="language-plaintext highlighter-rouge">ITab.Fun</code>. It then moves the data pointer in <code class="language-plaintext highlighter-rouge">rbx</code> to <code class="language-plaintext highlighter-rouge">rax</code>, the argument into <code class="language-plaintext highlighter-rouge">rbx</code>, and issues the call.</p> <p>What about upcasts? An upcast to a concrete type is quite simple: simply compare the type in the interface (either directly or in the <code class="language-plaintext highlighter-rouge">*ITab</code>) to a particular statically-known one. Downcasting to an interface (sometimes called a <em>sidecast</em>) is much more complicated, because it essentially requires a little bit of reflection.</p> <div class="code-multicol"> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Downcast</span><span class="p">(</span><span class="n">m</span> <span class="n">any</span><span class="p">)</span> <span class="n">MyIface</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="p">(</span><span class="n">MyIface</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Go</a></div></div> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">hashProbe</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rsi</span>
    <span class="n">and</span>     <span class="n">rsi</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">shl</span>     <span class="n">rsi</span><span class="p">,</span> <span class="mi">4</span>
    <span class="n">mov</span>     <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jeq</span>     <span class="n">found</span>
    <span class="n">lea</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">test</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jnz</span>     <span class="n">hashProbe</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">leq</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">typeAssert</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">done</span>
<span class="n">found</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">done</span><span class="o">:</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="n">foo</span><span class="p">.</span><span class="n">MyIface</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicnildottype</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as it was in foo.Call above.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">x86 Assembly</a></div></div> </div> <p>When we request an interface downcast, the Go compiler synthesizes a symbol of type <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code>. Its definition is reproduced below.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="k">type</span> <span class="n">TypeAssert</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Cache</span>   <span class="o">*</span><span class="n">TypeAssertCache</span>
	<span class="n">Inter</span>   <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">CanFail</span> <span class="kt">bool</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCache</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Mask</span>    <span class="kt">uintptr</span>
	<span class="n">Entries</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="n">TypeAssertCacheEntry</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCacheEntry</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// type of source value (a *runtime._type)</span>
	<span class="n">Typ</span> <span class="kt">uintptr</span>
	<span class="c">// itab to use for result (a *runtime.itab)</span>
	<span class="c">// nil if CanFail is set and conversion would fail.</span>
	<span class="n">Itab</span> <span class="kt">uintptr</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Go</a></div></div> <p>The first thing this function does is check if <code class="language-plaintext highlighter-rouge">rax</code> contains 0, i.e., if this is a nil <code class="language-plaintext highlighter-rouge">any</code>, and panics if that’s the case (that’s a call to <code class="language-plaintext highlighter-rouge">runtime.panicnildottype</code>). It then loads <code class="language-plaintext highlighter-rouge">foo..typeAssert0</code>, a synthetic global variable containing an <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code> value. It loads the <code class="language-plaintext highlighter-rouge">Cache</code> field, as well as the <code class="language-plaintext highlighter-rouge">Hash</code> field of the <code class="language-plaintext highlighter-rouge">abi.Type</code> attached to the <code class="language-plaintext highlighter-rouge">any</code>. It masks off the low bits using <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Mask</code>, and uses that to start probing the very simple open-addressed hash table located in <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Entries</code>.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with the type we’re looking for (compared by address), we’ve found it. We load that entry’s <code class="language-plaintext highlighter-rouge">Itab</code> value into <code class="language-plaintext highlighter-rouge">rax</code> to change the value from being an <code class="language-plaintext highlighter-rouge">any</code> to being a <code class="language-plaintext highlighter-rouge">MyIface</code>, and we’re done.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with a nil <code class="language-plaintext highlighter-rouge">Typ</code> pointer, we’re forced to hit the slow path, implemented at <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code>. This dynamically builds an itab by searching the method set of the type inside the <code class="language-plaintext highlighter-rouge">any</code>.</p> <p>This then calls the reflection code in <code class="language-plaintext highlighter-rouge">runtime.getitab()</code>, which is what actually performs the messy search through the method set, comparing the names and signatures of methods with those in the interface, to produce an itab at runtime.</p> <p>Then, it shoves this the resulting itab into the global itab cache, which is protected by a global lock! There are lots of scary atomics in this code. There are many places where this can potentially panic, bubbling up a type assertion failure to the user.</p> <p>When <code class="language-plaintext highlighter-rouge">runtime.getitab()</code> returns, <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code> will <em>maybe</em><sup id="fnref:maybe-update" role="doc-noteref"><a href="#fn:maybe-update" class="footnote" rel="footnote">4</a></sup> update the type assertion cache, and return the new itab. This allows the code in our function to return directly, without needing to take another trip into the <code class="language-plaintext highlighter-rouge">hashProbe</code> loop.</p> <p>In theory, PGO could be used to pre-fill the cache, but I couldn’t find any code in the compiler that indicates that this is something they do. In the meantime, you can optimize a hot type assert ahead of time by asserting to a known common type:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">rs</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span>
  <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Check for a known implementation first. This only costs</span>
    <span class="c">// a pointer comparison with the *abi.Type in the itab.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Do an interface type assertion. This would eventually</span>
    <span class="c">// learn os.File, but the branch above skips that "warmup"</span>
    <span class="c">// time. It also lets the hardware branch predictor allocate</span>
    <span class="c">// a prediction slot just for os.File.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// ...</span>
  <span class="p">}</span>
<span class="p">}</span> </code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Go</a></div></div> <p>Type switches, incidentally, use a very similar caching mechanism for switches that include interface types among the cases.</p> <h3 id="what-was-that-about-indirect-interfaces"><a href="#what-was-that-about-indirect-interfaces">What Was That About Indirect Interfaces?</a></h3> <p>Back when we were hacking arrays into existence with reflection, there was some trouble in <code class="language-plaintext highlighter-rouge">reflect.Value.Interface()</code>, where it would do a seemingly unnecessary copy.</p> <p>This is because an interface’s data pointer must be a pointer. If you cram, say, an <code class="language-plaintext highlighter-rouge">int</code> into an <code class="language-plaintext highlighter-rouge">any</code>, Go will spill it to the heap. This is often called <em>boxing</em>, but the Go runtime refers to it as an “indirect interface”.</p> <div class="code-multicol"> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Go</a></div></div> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">push</span>     <span class="n">rbp</span>
  <span class="n">mov</span>      <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
  <span class="n">call</span>     <span class="n">runtime</span><span class="p">.</span><span class="n">convT64</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">pop</span>      <span class="n">rbp</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">x86 Assembly</a></div></div> </div> <p>Like many other managed languages, Go will skip boxing very small values by instead returning pointers into some global array.</p> <p>Now, this boxing could be avoided: after all, an <code class="language-plaintext highlighter-rouge">int</code> is no larger than a pointer, so we could cram it into the data pointer field directly. However, the GC <em>really</em> doesn’t like that: the GC assumes it can trace through any pointer. Now, the GC <em>could</em> treat interfaces differently, and look at the type/itab pointer to determine if the data value pointer or a scalar. However, this would add significant complexity to both the representation of shapes, and to the tracing code in the GC, resulting in more branches and slower tracing.</p> <p>However, if the type being wrapped in an interface happens to be a pointer, it can just use that pointer value directly.</p> <div class="code-multicol"> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Go</a></div></div> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">x86 Assembly</a></div></div> </div> <p>Any type that has the same shape as a pointer will be indirect. This includes maps, channels, and funcs. It also includes one element arrays of such types, such as <code class="language-plaintext highlighter-rouge">[1]*int</code> and <code class="language-plaintext highlighter-rouge">[1]chan error</code>, and single-field structs of such types. Curiously, this does not include structs which contain a zero-sized field before the pointer-sized field, even though those have the same shape as a pointer.</p> <p>This means it’s generally not safe to play games with forging an interface out of a pointer to some type: whether that type is indirect in an interface is a subtle implementation detail of the compiler.</p> <p>And of course, it’s important to remember that if you want to return a value by interface, you had best hope it can get inlined, so the compiler can promote the heap allocation to the stack.</p> <h2 id="function-pointers"><a href="#function-pointers">Function Pointers</a></h2> <p>The last thing to look at are Go’s function pointers. For the longest time, I assumed they had the same layout as an interface: a pointer to closure data, and a hardware function pointer.</p> <p>It turns out the layout is weirder: let’s revisit the <code class="language-plaintext highlighter-rouge">runtime.funcval</code> we found in <code class="language-plaintext highlighter-rouge">runtime2.go</code> earlier.</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">Go</a></div></div> <p>This unusual layout is best understood by looking at the generated assembly.</p> <div class="code-multicol"> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span>
  <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span>
  <span class="n">x</span> <span class="kt">int</span><span class="p">,</span>
<span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">Go</a></div></div> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">x86 Assembly</a></div></div> </div> <p>To call <code class="language-plaintext highlighter-rouge">f</code>, first we interpret it as a <code class="language-plaintext highlighter-rouge">*funcval</code> and load <code class="language-plaintext highlighter-rouge">f.fn</code> into a temporary. That is, the first word pointed to by <code class="language-plaintext highlighter-rouge">rax</code> (which holds <code class="language-plaintext highlighter-rouge">f</code> on function entry). Then, we place <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">rdx</code>, the closure context register. The reason for using this extra magic register will become clear shorter. Then, we arrange the rest of the arguments in their usual registers, and we jump to the address stored in <code class="language-plaintext highlighter-rouge">f.fn</code>.</p> <p>Inside of <code class="language-plaintext highlighter-rouge">f</code>, captures are accessed by offsetting from <code class="language-plaintext highlighter-rouge">rdx</code>. What does one of those closures look like?</p> <div class="code-multicol"> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">Go</a></div></div> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">imul</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rcx</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:25">x86 Assembly</a></div></div> </div> <p>All <code class="language-plaintext highlighter-rouge">Capture</code> is doing is allocating a <code class="language-plaintext highlighter-rouge">funcval</code> with a single <code class="language-plaintext highlighter-rouge">int</code> capture; that’s the <code class="language-plaintext highlighter-rouge">{ F uintptr; X0 int }</code> in the code above. It then places the address of <code class="language-plaintext highlighter-rouge">Capture.func1</code>, which implements the callback, into <code class="language-plaintext highlighter-rouge">F</code>, and the argument of <code class="language-plaintext highlighter-rouge">Capture</code> into <code class="language-plaintext highlighter-rouge">X0</code>.</p> <p>What about when returning a reference to a function? In that case, all that happens is it returns a reference to a global containing the address of the function.</p> <div class="code-multicol"> <div class="codeblock" id="code:26"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Id</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Id</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:26">Go</a></div></div> <div class="codeblock" id="code:27"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="p">]</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="o">:</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="o">:</span>
    <span class="p">.</span><span class="n">quad</span> <span class="n">foo</span><span class="p">.</span><span class="n">Id</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:27">x86 Assembly</a></div></div> </div> <p>Because we pass the closure arguments in an extra register not used by regular functions, we don’t need to create a thunk for this case.</p> <p>Unfortunately, we do need to create a thunk for methods, even methods with a pointer receiver. This is because of the following incompatible constraints:</p> <ol> <li> <p>The receiver pointer for a method must point exactly to the value the method is called on. It can’t be a fixed offset before, because that would create an out-of-bounds pointer, which the GC does not tolerate.</p> </li> <li> <p>The closure pointer must point to the start of the funcval, <em>not</em> its captures, because adjusting the pointer to point to the captures would cause it to point one-past-the-end of a value, which the GC <em>also</em> does not tolerate!</p> </li> </ol> <p>Thus, <em>even</em> if methods accepted a pointer receiver via <code class="language-plaintext highlighter-rouge">rdx</code>, closures and methods disagree about where that pointer should be passed.</p> <p>Of course, there are adjustments we can make to fix this problem. For example, we could require that all <code class="language-plaintext highlighter-rouge">funcval</code> values have at least one capture. No-capture <code class="language-plaintext highlighter-rouge">funcvals</code> would have a synthetic <code class="language-plaintext highlighter-rouge">_ byte</code> field. This is not unlike how a non-empty struct whose final field is empty will be padded with an extra <code class="language-plaintext highlighter-rouge">_ byte</code> field: this is specifically to avoid a pointer to that field being a past-the-end pointer. The cost is that every non-capturing closure costs twice as much binary size.</p> <p>Another fix is to make the GC blind to the pointer in <code class="language-plaintext highlighter-rouge">rdx</code>. This will never be the only pointer by which a value is reachable, so it would be safe to replace <code class="language-plaintext highlighter-rouge">mov rdx, rax</code> with a <code class="language-plaintext highlighter-rouge">lea rdx, [rax + 8]</code>. The GC would never know!</p> <p>Until then, beware that writing <code class="language-plaintext highlighter-rouge">return foo.Method</code> secretly allocates 16 bytes or so. (Aside: I used to sit next to the Go team at Google, and I remember having a conversation with Austin Clements about this. Apparently I misremembered, because until recently I thought Go already implemented this optimization!)</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>If you made it this far this is probably you right now:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/stickers/dizzy.png" alt="Miguel as a Whimsicott, dizzy with register names."/></p> </figure> <p>This isn’t intended to be as polished as most of my articles, but there’s been enough things I’ve come across that I wanted to write this all up for my own reference.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:constants" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Sizeof</code> and <code class="language-plaintext highlighter-rouge">Alignof</code> are intrinsics, so the compiler will turn them into constants. However, they are only constants if the type being measured is not generic, so wrapping them in a function like this doesn’t actually hurt in generic code. <a href="#fnref:constants" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:gc-programs" role="doc-endnote"> <p>Except for very large types that would have more words than can be recorded by an array of size <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/type.go;l=803;bpv=0"><code class="language-plaintext highlighter-rouge">abi.MaxPtrmaskBytes</code></a>. For larger types, we use GC programs! A GC program is an LZ-compressed bitset serving the same purpose as the pointer bitset most smaller types use. See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/cmd/internal/gcprog/gcprog.go">gcprog.go</a>.</p> <p>In fact, <code class="language-plaintext highlighter-rouge">reflection</code> knows how to create programs on the fly for most types! See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/reflect/type.go;l=2658">reflect/type.go</a>. <a href="#fnref:gc-programs" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:asm" role="doc-endnote"> <p>I will be writing assembly examples in Intel-syntax x86. Go’s assembly syntax is horrible and an impediment to the point I’m making. <a href="#fnref:asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:maybe-update" role="doc-endnote"> <p>Maybe? Well, the cache will only get updated about 0.1% of the time. This is to amortize the costs of growing the cache. I assume they benchmarked this, and found that the cost of growing the cache makes it only worthwhile when that assertion is getting hammered. <a href="#fnref:maybe-update" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-10 • 2589 words • 28 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> • <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> </span> <h1><a href="/2024/12/10/json-sucks/"> Nobody Gets Fired for Picking JSON, but Maybe They Should? </a></h1> </div> <div class="post"> <p>JSON is extremely popular but deeply flawed. This article discusses the details of JSON’s design, how it’s used (and misused), and how seemingly helpful “human readability” features cause headaches instead. Crucially, you rarely find JSON-based tools (except dedicated tools like <code class="language-plaintext highlighter-rouge">jq</code>) that can safely handle arbitrary JSON documents without a schema—common corner cases can lead to data corruption!</p> <h2 id="what-is-json"><a href="#what-is-json">What is JSON?</a></h2> <p>JSON is famously simple. In fact, you can <a href="https://www.flickr.com/photos/equanimity/3763158824/in/photostream/">fit the entire grammar on the back of a business card</a>. It’s so omnipresent in REST APIs that you might assume you already know JSON quite well. It has decimal numbers, quoted strings, arrays with square brackets, and key-value maps (called “objects”) with curly braces. A JSON document consists of any of these constructs: <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">42</code>, and <code class="language-plaintext highlighter-rouge">{"foo":"bar"}</code> are all valid JSON documents.</p> <p>However, the formal definition of JSON is quite complicated. JSON is defined by the IETF document <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC8259</a> (if you don’t know what the IETF is, it’s the standards body for Internet protocols). However, it’s <em>also</em> normatively defined by <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a>, which is from ECMA, the standards body that defines JavaScript[^json.org].</p> <p>[^json.org]: Of course, some wise guy will probably want to cite <json.org>. I should underscore: <json.org> is __NOT__ a standard. It is __NOT__ normative. the documents produced by the IETF and by ECMA, which are international standards organizations that represent the industry __ARE__ normative. When a browser implementer wants to implement JSON to the letter, they go to ECMA, not to some dude's 90's ass website.</json.org></json.org></p> <p>JavaScript? Yes, JSON (JavaScript Object Notation) is closely linked with JavaScript and is, in fact, (almost) a subset of it. While JSON’s JavaScript ancestry is the main source of its quirks, several other poor design decisions add additional unforced errors.</p> <p>However, the biggest problem with JSON isn’t any specific design decision but rather the incredible diversity of parser behavior and non-conformance across and within language ecosystems. RFC8259 goes out of its way to call this out:</p> <blockquote id="ref:1" class="ref"> <p><a href="#ref:1"><span class="chip">reference</span></a></p> <p>Note, however, that ECMA-404 allows several practices that this specification recommends avoiding in the interests of maximal interoperability.</p> </blockquote> <p>The RFC makes many observations regarding interoperability elsewhere in the document. Probably the most glaring—and terrifying—is how numbers work.</p> <h2 id="everything-is-implementation-defined"><a href="#everything-is-implementation-defined">Everything is Implementation-Defined</a></h2> <p>JSON numbers are encoded in decimal, with an optional minus sign, a fractional part after a decimal point, and a scientific notation exponent. This is similar to how many programming languages define their own numeric literals.</p> <p>Presumably, JSON numbers are meant to be floats, right?</p> <p>Wrong.</p> <p>RFC8259 reveals that the answer is, unfortunately, “whatever you want.”</p> <blockquote> <p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">binary64</code> is the “standards-ese” name for the type usually known as <code class="language-plaintext highlighter-rouge">double</code> or <code class="language-plaintext highlighter-rouge">float64</code>. Floats have great dynamic range but often can’t represent exact values. For example, <code class="language-plaintext highlighter-rouge">1.1</code> isn’t representable as a float because all floats are fractions of the form <code class="language-plaintext highlighter-rouge">n / 2^m</code> for integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code>, but <code class="language-plaintext highlighter-rouge">1.1 = 11/10</code>, which has a factor of 5 in its denominator. The closest <code class="language-plaintext highlighter-rouge">float64</code> value is</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-text" data-lang="text">2476979795053773 / 2^51 = 1.100000000000000088817841970012523233890533447265625</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Plaintext</a></div></div> <p>Of course, you might think to declare “all JSON values map to their closest <code class="language-plaintext highlighter-rouge">float64</code> value”. Unfortunately, this value might not be unique. For example, the value <code class="language-plaintext highlighter-rouge">900000000000.00006103515625</code> isn’t representable as a <code class="language-plaintext highlighter-rouge">float64</code>, and it’s precisely between two exact <code class="language-plaintext highlighter-rouge">float64</code> values. Depending on the rounding mode, this rounds to either or <code class="language-plaintext highlighter-rouge">900000000000</code> or <code class="language-plaintext highlighter-rouge">900000000000.0001220703125</code> .</p> <p>IEEE 754 recommends “round ties to even” as the default rounding mode, so for almost all software, the result is <code class="language-plaintext highlighter-rouge">900000000000</code>. But remember, floating-point state is a global variable implemented in hardware, and might just happen to be clobbered by some dependency that calls <code class="language-plaintext highlighter-rouge">fesetround()</code> or a similar system function.</p> <h2 id="data-loss-data-loss"><a href="#data-loss-data-loss">Data Loss! Data Loss!</a></h2> <p>You’re probably thinking, “I don’t care about such fussy precision stuff. None of my numbers have any fractional parts—and there is where you would be wrong. The <code class="language-plaintext highlighter-rouge">n</code> part of <code class="language-plaintext highlighter-rouge">n / 2^m</code> only has 53 bits available, but <code class="language-plaintext highlighter-rouge">int64</code> values fall outside of that range. This means that for very large 64-bit integers, such as randomly generated IDs, a JSON parser that converts integers into floats results in <em>data loss.</em> Go’s <code class="language-plaintext highlighter-rouge">encoding/json</code> package does this, for example.</p> <p>How often does this actually happen for randomly-generated numbers? We can do a little Monte Carlo simulation to find out.</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
	<span class="s">"math/big"</span>
	<span class="s">"math/rand"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">trials</span> <span class="o">=</span> <span class="m">5</span><span class="n">_000_000</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">misses</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">err</span> <span class="n">big</span><span class="o">.</span><span class="n">Float</span>
	<span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
		<span class="n">y</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c">// Round-trip through binary64.</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
			<span class="n">misses</span><span class="o">++</span>
			<span class="n">err</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span><span class="o">.</span><span class="n">Quo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">trials</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"misses: %d/%d, avg: %f"</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">trials</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// misses: 4970572/5000000, avg: 170.638499</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Go</a></div></div> <p>It turns out that almost all randomly distributed <code class="language-plaintext highlighter-rouge">int64</code> values are affected by round-trip data loss. Roughly, the only numbers that are safe are those with at most 16 digits (although not exactly: 9,999,999,999,999,999, for example, gets rounded up to a nice round 10 quadrillion).</p> <p>How does this affect you? Suppose you have a JSON document somewhere that includes a user ID and a transcript of their private messages with another user. Data loss due to rounding would result in the wrong user ID being associated with the private messages, which could result in leaking PII or incorrect management of privacy consent (such as GDPR requirements).</p> <p>This isn’t just about <em>your</em> user IDs, mind you. Plenty of other vendors’ IDs are nice big integers, which the JSON grammar can technically accommodate and which random tools will mangle. Some examples:</p> <ul> <li> <p>License keys: for example, Adobe uses 24 digits for <a href="https://helpx.adobe.com/x-productkb/global/invalid-revoked-serial-numbers.html">their serial numbers</a>, which may be tempting to store as an integer.</p> </li> <li> <p>Barcode IDs like the unique serial numbers of medical devices, <a href="https://www.fda.gov/medical-devices/unique-device-identification-system-udi-system/udi-basics">which are tightly regulated</a>.</p> </li> <li> <p>Visa and Mastercard credit card numbers <em>happen</em> to fit in the “safe” range for <code class="language-plaintext highlighter-rouge">binary64</code> , which may lull you into a false sense of security, since they’re so common. But not all credit cards have 16 digit numbers: <a href="https://en.wikipedia.org/wiki/Payment_card_number#Structure">some now support 19</a>.</p> </li> </ul> <p>These are pretty bad compliance consequences purely due to a data serialization format.</p> <p>This problem is avoidable with care. After all, Go can parse JSON into any arbitrary type using reflection. For example, if we replace the inner loop of the Monte Carlo simulation with something like the following:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
	<span class="k">var</span> <span class="n">v</span> <span class="k">struct</span><span class="p">{</span> <span class="n">N</span> <span class="kt">int64</span> <span class="p">}</span>
	<span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">`{"N":%d}`</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
	<span class="n">y</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">N</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
		<span class="c">// ...</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Go</a></div></div> <p>We suddenly see that <code class="language-plaintext highlighter-rouge">x == y</code> in every trial. This is because with type information, Go’s JSON library knows exactly what the target precision is. If we were parsing to an <code class="language-plaintext highlighter-rouge">any</code> instead of to a <code class="language-plaintext highlighter-rouge">struct { N int64 }</code>, we’d be in deep trouble: the outer object would be parsed into a <code class="language-plaintext highlighter-rouge">map[string]any</code>, and the <code class="language-plaintext highlighter-rouge">N</code> field would become a <code class="language-plaintext highlighter-rouge">float64</code>.</p> <p>This means that your system probably can’t safely handle JSON documents with unknown fields. Tools like <code class="language-plaintext highlighter-rouge">jq</code> must be extremely careful about number handling to avoid data loss. This is an easy mistake for third-party tools to make.</p> <p>But again, <code class="language-plaintext highlighter-rouge">float64</code> isn’t the standard—there is no standard. Some implementations might only have 32-bit floats available, making the problem worse. Some implementations might try to be clever, using a <code class="language-plaintext highlighter-rouge">float64</code> for fractional values and an <code class="language-plaintext highlighter-rouge">int64</code> for integer values; however, this still imposes arbitrary limits on the parsed values, potentially resulting in data loss.</p> <p>Some implementations such as Python use bignums, so they appear not to have this problem. However, this can lead to a false sense of security where issues are not caught until it’s too late: some database now contains ostensibly valid but non-interoperable JSON.</p> <p>Protobuf is forced to deal with this in a pretty non-portable way. To avoid data loss, large 64-bit integers are serialized as quoted strings when serializing to JSON. So, instead of writing <code class="language-plaintext highlighter-rouge">{"foo":6574404881820635023}</code>, it emits <code class="language-plaintext highlighter-rouge">{"foo":"6574404881820635023"}</code>. This solves the data loss issue but does not work with other JSON libraries such as Go’s, producing errors like this one:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-text" data-lang="text">json: cannot unmarshal string into Go struct field .N of type int64</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Plaintext</a></div></div> <h3 id="non-finite-values"><a href="#non-finite-values">Non-Finite Values</a></h3> <p>The special floating point values <code class="language-plaintext highlighter-rouge">Infinity</code>, <code class="language-plaintext highlighter-rouge">-Infinity</code>, and <code class="language-plaintext highlighter-rouge">NaN</code> are not representable: it’s the wild west as to what happens when you try to serialize the equivalent of <code class="language-plaintext highlighter-rouge">{x:1.0/0.0}</code>.</p> <ul> <li>Go refuses to serialize, citing <code class="language-plaintext highlighter-rouge">json: unsupported value: +Inf</code>.</li> <li>Protobuf serializes it as <code class="language-plaintext highlighter-rouge">{"x":"inf"}</code> (or should—it’s unclear which implementations get it right).</li> <li>JavaScript won’t even bother trying: <code class="language-plaintext highlighter-rouge">JSON.stringify({x:Infinity})</code> prints <code class="language-plaintext highlighter-rouge">{"x":null}.</code></li> <li>Python is arguably the worst offender: <code class="language-plaintext highlighter-rouge">json.dumps({"x":float("inf")})</code> prints <code class="language-plaintext highlighter-rouge">{"x":Infinity}</code>, which isn’t even valid JSON per RFC8259.</li> </ul> <p>NaN is arguably an even worse offender, because the NaN payload (yes, <a href="https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns">NaNs have a special payload</a>) is discarded when converting to <code class="language-plaintext highlighter-rouge">"nan"</code> or however your library represents it.</p> <p>Does this affect you? Well, if you’re doing anything with floats, you’re one division-by-zero or overflow away from triggering serialization errors. At best, it’s “benign” data corruption (JavaScript). At worst, when the data is partially user-controlled, it might result in crashes or unparseable output, which is the making of a DoS vector.</p> <p>In comparison, Protobuf serialization can’t fail except due to non-UTF-8 <code class="language-plaintext highlighter-rouge">string</code> fields or cyclic message references, both of which are comparatively unlikely to a NaN popping up in a calculation.</p> <p>The upshot is that all the parsers end up parsing a bunch of crazy things for the special floating-point values over time because of <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s law</a>. RFC8259 makes no effort to provide suggestions for dealing with such real-world situations beyond “tough luck, not interoperable.”</p> <h2 id="text-encodings-and-invalid-unicode"><a href="#text-encodings-and-invalid-unicode">Text Encodings and Invalid Unicode</a></h2> <p>JSON strings are relatively tame, with some marked (but good) divergence from JavaScript. Specifically, JavaScript, being a language of a certain age (along with Java), uses UTF-16 as its Unicode text encoding. Most of the world has realized this is a bad idea (it doubles the size of ASCII text, which makes up almost all of Internet traffic), so JSON uses UTF-8 instead. RFC8259 actually specifies that the whole document MUST be encoded in UTF-8.</p> <p>But when we go to read about Unicode characters in §8.2, we are disappointed: it merely says that it’s <em>really great</em> when all quoted strings consist entirely of Unicode characters, which means that unpaired surrogates are allowed. In effect, the spec merely requires that JSON strings be <a href="https://en.wikipedia.org/wiki/UTF-8#Surrogates">WTF-8</a>: UTF-8 that permits unpaired surrogates.</p> <p>What’s an unpaired surrogate? It’s any encoded Unicode 32-bit value in the range <code class="language-plaintext highlighter-rouge">U+D800</code> to <code class="language-plaintext highlighter-rouge">U+DFFF</code> , which form a gap in the Unicode codepoint range. UTF-8’s variable-length integer encoding can encode them, but their presence in a bytestream makes it invalid UTF-8. WTF-8 is UTF-8 but permitting the appearance of these values.</p> <p>So, who actually supports parsing (or serializing) these? Consider the document <code class="language-plaintext highlighter-rouge">{"x":"\udead"}</code>, which contains an unpaired surrogate, <code class="language-plaintext highlighter-rouge">U+DEAD</code>.</p> <ul> <li> <p>Go gladly deserializes AND serializes it (Go’s strings are arbitrary byte strings, not UTF-8). However, Go serializes a non-UTF-8 string such as <code class="language-plaintext highlighter-rouge">"\xff"</code> as <code class="language-plaintext highlighter-rouge">"\ufffd"</code>, having replaced the invalid byte with a <code class="language-plaintext highlighter-rouge">U+FFFD</code> replacement character (this thing: �).</p> </li> <li> <p>Most Java parsers seem to follow the same behavior as Go, but there are many different parsers available, and we’ve already learned that different JSON parsers may behave differently.</p> </li> <li> <p>JavaScript and Python similarly gladly parse unpaired surrogates, but they also serialize them back without converting them into <code class="language-plaintext highlighter-rouge">U+FFFD</code>.</p> </li> <li> <p>Different Protobuf runtimes may not handle this identically, but the reference C++ implementation (whose JSON codec I wrote!) refuses to parse unpaired surrogates.</p> </li> </ul> <p>There are other surprising pitfalls around strings: are <code class="language-plaintext highlighter-rouge">"x"</code> and <code class="language-plaintext highlighter-rouge">“\x78"</code> the same string? RFC8259 feels the need to call out that they are, for the purposes of checking that object keys are equal. The fact that they feel the need to call it out indicates that this is also a source of potential problems.</p> <h2 id="byte-strings"><a href="#byte-strings">Byte Strings</a></h2> <p>What if I don’t want to send text? A common type of byte blob to send is a cryptographic hash that identifies a document in a content-addressed blobstore, or perhaps a digital signature (an encrypted hash). JSON has no native way of representing byte strings.</p> <p>You could send a quoted string full of ASCII and <code class="language-plaintext highlighter-rouge">\xNN</code> escapes (for bytes which are not in the ASCII range), but this is wasteful in terms of bandwidth, and has serious interoperability problems (as noted above, Go actively destroys data in this case). You could also encode it as an array of JSON numbers, which is much worse for bandwidth and serialization speed.</p> <p>What everyone winds up doing, one way or another, is to rely on base64 encoding. Protobuf, for example, encodes <code class="language-plaintext highlighter-rouge">bytes</code> fields into base64 strings in JSON. This has the unfortunate side-effect of defeating JSON’s human-readable property: if the blob contains mostly ASCII, a human reader can’t tell.</p> <p>Because this isn’t part of JSON, virtually no JSON codec does this decoding for you, particularly because in a schema-less context, there’s nothing to distinguish a byte blob encoded with base64 from an actual textual string that <em>happens</em> to contain valid base64, such as an alphanumeric username.</p> <p>Compared to other problems, this is more like a paper cut, but it’s unnecessary and adds complexity and interop problems. <a href="https://en.wikipedia.org/wiki/Base64#Variants_summary_table">By the way, did you know there are multiple incompatible Base64 alphabets?</a></p> <h1 id="streaming-doesnt-work"><a href="#streaming-doesnt-work">Streaming Doesn’t Work</a></h1> <p>A less obvious problem with JSON is that it can’t be streamed. Almost all JSON documents are objects or arrays and are therefore <em>incomplete</em> until they reach the closing <code class="language-plaintext highlighter-rouge">}</code> or <code class="language-plaintext highlighter-rouge">]</code>, respectively. This means you can’t send a stream of JSON documents that form a part of a larger document without some additional protocol for combining them in post-processing.</p> <p><a href="https://jsonlines.org/">JSONL</a> is the world’s silliest spec that “solves” this problem in the simplest way possible: a JSONL document is a sequence of JSON documents separated by newlines. JSONL <em>is</em> streamable, but because it’s done in the simplest way possible, it only supports streaming a giant array. You can’t, for example, stream an object field-by-field or stream an array within that object.</p> <p>Protobuf doesn’t have this problem: in a nutshell, the Protobuf wire format is as if we removed the braces and brackets from the top-level array or object of a document, and made it so that values with the same key get merged. In the wire format, the equivalent of the JSONL document</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">JSON</a></div></div> <p>is automatically “merged” into the single document</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w"> </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">JSON</a></div></div> <p>This forms the basis of the “message merge” operation, which is intimately connected to how the wire format was designed. We’ll dive into this fundamental operation in a future article.</p> <h1 id="canonicalization-leads-to-data-loss"><a href="#canonicalization-leads-to-data-loss">Canonicalization Leads to Data Loss</a></h1> <p>Thanks to <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC7519</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC7515</a>, which define JSON Web Tokens (JWT) and JSON Web Signatures (JWS), digitally signing JSON documents is a very common operation. However, digital signatures can only sign specific byte blobs and are sensitive to things that JSON isn’t, such as whitespace and key ordering.</p> <p>This results in specifications like <a href="https://datatracker.ietf.org/doc/html/rfc8785">RFC8785</a> for <em>canonicalization</em> of JSON documents. This introduces a new avenue by which existing JSON documents, which accidentally happen to contain non-interoperable (or, thanks to non-conforming implementations such as Python’s) invalid JSON that must be manipulated and reformatted by third-party tools. RFC8785 itself references ECMA-262 (the JavaScript standard) for how to serialize numbers, meaning that it’s <em>required</em> to induce data loss for 64-bit numerical values!</p> <h1 id="is-json-fixable"><a href="#is-json-fixable">Is JSON Fixable?</a></h1> <p>Plainly? No. JSON can’t be fixed because of how extremely popular it is. Common mistakes are baked into the format. Are comments allowed? Trailing commas? Number formats? Nobody knows!</p> <p>What tools are touching your JSON? Are they aware of all of the rakes they can step on? Do they emit invalid JSON (like Python does)? How do you even begin to audit that?</p> <p>Thankfully, you don’t have to use JSON. There are alternatives—BSON, UBJSON, MessagePack, and CBOR are just a few binary formats that try to replicate JSON’s data model. Unfortunately, many of them have their own problems.</p> <p>Protobuf, however, has none of these problems, because it was <em>designed</em> to fulfill needs JSON couldn’t meet. Using a strongly-typed schema system, like Protobuf, makes all of these problems go away.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-04-17 • 3689 words • 40 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2024/04/17/calling-convention/"> The Rust Calling Convention We Deserve </a></h1> </div> <div class="post"> <p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified0- calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>However, we are too conservative. We get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Rust</a></div></div> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">x86 Assembly</a></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Rust</a></div></div> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">x86 Assembly</a></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>Not only does clang produce patently <em>bad</em> code for passing things by value, but it also knows how to do it better, if you request a standard calling convention! We could be generating <em>way</em> better code than Clang, but we don’t!</p> <p>Hereforth, I will describe how to do it.</p> <h3 id="-zcallconv"><a href="#-zcallconv"><code class="language-plaintext highlighter-rouge">-Zcallconv</code></a></h3> <p>Let’s suppose that we keep the current calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code><sup id="fnref:just-use-extern-c" role="doc-noteref"><a href="#fn:just-use-extern-c" class="footnote" rel="footnote">1</a></sup>, but we add a flag <code class="language-plaintext highlighter-rouge">-Zcallconv</code> that sets the calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code> when compiling a crate. The supported values will be <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> for the current one, and <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for the one we’re going to design. We could even let <code class="language-plaintext highlighter-rouge">-O</code> set <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> automatically.</p> <p>Why keep the old calling convention? Although I did sweep debugability under the rug, one nice property <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> will not have is that it does not place arguments in the C ABI order, which means that a reader replying on the “Diana’s silk dress cost $89” mnemonic on x86 will get fairly confused.</p> <p>I am also assuming we may not even support <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for some targets, like WASM, where there is no concept of “registers” and “spilling”. It may not even make sense to enable it for for debug builds, because it will produce much worse code with optimizations turned off.</p> <p>There is also a mild wrinkle with function pointers, and <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code> blocks. Because this flag is per-crate, even though functions can advertise which version of <code class="language-plaintext highlighter-rouge">extern "Rust"</code> they use, function pointers have no such luxury. However, calling through a function pointer is slow and rare, so we can simply force them to use <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. We can generate a shim to translate calling conventions as needed.</p> <p>Similarly, we can, in principle, call any Rust function like this:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">secret_call</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">my_func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">my_func</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>However, this mechanism can only be used to call unmangled symbols. Thus, we can simply force <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> symbols to use the legacy calling convention.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following procedure.</p> <ol> <li> <p>First, determine, for a given target triple, the maximum number of values that can be passed “by register”. I will explain how to do this below.</p> </li> <li> <p>Decide how to pass the return value. It will either fit in the output registers, or it will need to be returned “by reference”, in which case we pass an extra <code class="language-plaintext highlighter-rouge">ptr</code> argument to the function (tagged with the <code class="language-plaintext highlighter-rouge">sret</code> attribute) and the actual return value of the function is that pointer.</p> </li> <li> <p>Decide which arguments that have been passed by value need to be demoted to being passed by reference. This will be a heuristic, but generally will be approximately “arguments larger than the by-register space”. For example, on x86, this comes out to 176 bytes.</p> </li> <li> <p>Decide which arguments get passed by register, so as to maximize register space usage. This problem is NP-hard (it’s the knapsack problem) so it will require a heuristic. All other arguments are passed on the stack.</p> </li> <li> <p>Generate the function signature in LLVM IR. This will be all of the arguments that are passed by register encoded as various non-aggregates, such as <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">ptr</code>, <code class="language-plaintext highlighter-rouge">double</code>, and <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>. What valid choices are for said non-aggregates depends on the target, but the above are what you will generally get on a 64-bit architecture. Arguments passed on the stack will follow the “register inputs”.</p> </li> <li> <p>Generate a function prologue. This is code to decode each Rust-level argument from the register inputs, so that there are <code class="language-plaintext highlighter-rouge">%ssa</code> values corresponding to those that would be present when using <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This allows us to generate the same code for the body of the function regardless of calling convention. Redundant decoding code will be eliminated by DCE passes.</p> </li> <li> <p>Generate a function exit block. This is a block that contains a single <code class="language-plaintext highlighter-rouge">phi</code> instruction for the return type as it would be for <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This block will encode it into the requisite output format and then <code class="language-plaintext highlighter-rouge">ret</code> as appropriate. All exit paths through the function should <code class="language-plaintext highlighter-rouge">br</code> to this block instead of <code class="language-plaintext highlighter-rouge">ret</code>-ing.</p> </li> <li> <p>If a non-polymorphic, non-inline function may have its address taken (as a function pointer), either because it is exported out of the crate or the crate takes a function pointer to it, generate a shim that uses <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> and immediately tail-calls the real implementation. This is necessary to preserve function pointer equality.</p> </li> </ol> <p>The main upshot here is that we need to cook up heuristics for figuring out what goes in registers (since we allow reordering arguments to get better throughput). This is equivalent to the knapsack problem; knapsack heuristics are beyond the scope of this article. This should happen early enough that this information can be stuffed into <code class="language-plaintext highlighter-rouge">rmeta</code> to avoid needing to recompute it. We may want to use different, faster heuristics depending on <code class="language-plaintext highlighter-rouge">-Copt-level</code>. Note that correctness requires that we forbid linking code generated by multiple different Rust compilers, which is already the case, since Rust breaks ABI from release to release.</p> <h3 id="what-is-llvm-willing-to-do"><a href="#what-is-llvm-willing-to-do">What Is LLVM Willing to Do?</a></h3> <p>Assuming we do that, how do we actually get LLVM to pass things in the way we want it to? We need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">LLVM IR</a></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of<sup id="fnref:doubles-and-vectors" role="doc-noteref"><a href="#fn:doubles-and-vectors" class="footnote" rel="footnote">2</a></sup>).</p> <p>The above values are for x86<sup id="fnref:official-support" role="doc-noteref"><a href="#fn:official-support" class="footnote" rel="footnote">3</a></sup>. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>I recommend that <em>every function</em> have the same number of by-register arguments. So on x86, EVERY <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> function’s signature should look like this:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">declare</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span> <span class="vg">@my_func</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span><span class="p">,</span>
  <span class="c1">; other args...</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">LLVM IR</a></div></div> <p>When passing pointers, the appropriate <code class="language-plaintext highlighter-rouge">i64</code>s should be replaced by <code class="language-plaintext highlighter-rouge">ptr</code>, and when passing <code class="language-plaintext highlighter-rouge">double</code>s, they replace <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>s.</p> <p>But you’re probably saying, “Miguel, that’s crazy! Most functions don’t pass 176 bytes!” And you’d be right, if not for the magic of LLVM’s very well-specified <code class="language-plaintext highlighter-rouge">poison</code> semantics.</p> <p>We can get away with not doing extra work if every argument we do not use is passed <code class="language-plaintext highlighter-rouge">poison</code>. Because <code class="language-plaintext highlighter-rouge">poison</code> is equal to “the most convenient possible value at the present moment”, when LLVM sees <code class="language-plaintext highlighter-rouge">poison</code> passed into a function via register, it decides that the most convenient value is “whatever happens to be in the register already”, and so it doesn’t have to touch that register!</p> <p>For example, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we would generate the following code.</p> <div class="code-multicol"> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; This is a -Zcallconv=fast-style function.</span>
<span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@load_rcx</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%load</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%load</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="nv">%1</span><span class="p">,</span>     <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">LLVM IR</a></div></div> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span>  <span class="n">rax</span>
  <span class="n">mov</span>   <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span>  <span class="n">malloc</span>
  <span class="n">mov</span>   <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>  <span class="n">load_rcx</span>
  <span class="n">add</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">pop</span>   <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">x86 Assembly</a></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any proscribed way. And as we see, <code class="language-plaintext highlighter-rouge">load_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into the other thirteen registers compiles down to nothing<sup id="fnref:requires-opt" role="doc-noteref"><a href="#fn:requires-opt" class="footnote" rel="footnote">4</a></sup>, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, it is not total. In an ideal world, the same registers are used for input and output, to allow easier pipelining of calls without introducing extra register traffic. This is true on ARM and RISC-V, but not x86. However, because register ordering is merely a suggestion for us, we can choose to allocate the return registers in whatever order we want. For example, we can pretend the order registers should be allocated in is <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code> for inputs, and <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rax</code> for outputs.</p> <div class="code-multicol"> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%sq</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%sq</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">LLVM IR</a></div></div> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">x86 Assembly</a></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">LLVM IR</a></div></div> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">ARM Assembly</a></div></div> </div> <h3 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h3> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>First, return values. This is relatively straightforward, since there is only one value to pass. The amount of data we need to return is <em>not</em> the size of the struct. For example, <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code> measures 32 bytes wide. However, eight of those bytes are padding! We do not need to preserve padding when returning by value, so we can flatten the struct into <code class="language-plaintext highlighter-rouge">(u64, u32, u64, u32)</code> and sort by size into <code class="language-plaintext highlighter-rouge">(u64, u64, u32, u32)</code>. This has no padding and is 24 bytes wide, which fits into the three return registers LLVM gives us on x86. We define the <em>effective size</em> of a type to be the number of non-<code class="language-plaintext highlighter-rouge">undef</code> bits it occupies. For <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code>, this is 192 bits, since it excludes the padding. For <code class="language-plaintext highlighter-rouge">bool</code>, this is one. For <code class="language-plaintext highlighter-rouge">char</code> this is technically 21, but it’s simpler to treat <code class="language-plaintext highlighter-rouge">char</code> as an alias for <code class="language-plaintext highlighter-rouge">u32</code>.</p> <p>The reason for counting bits this way is that it permits significant compaction. For example, returning a struct full of bools can simply bit-pack the bools into a single register.</p> <p>So, a return value is converted to a by-ref return if its effective size is smaller than the output register space (on x86, this is three integer registers and four SSE registers, so we get 88 bytes total, or 704 bits).</p> <p>Argument registers are much harder, because we hit the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, which is NP-hard. The following relatively naive heuristic is where I would start, but it can be made infinitely smarter over time.</p> <p>First, demote to by-ref any argument whose effective size is larget than the total by-register input space (on x86, 176 bytes or 1408 bits). This means we get a pointer argument instead. This is beneficial to do first, since a single pointer might pack better than the huge struct.</p> <p>Enums should be replaced by the appropriate discriminant-union pair. For example, <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> is, internally, <code class="language-plaintext highlighter-rouge">(union { i32, () }, i1)</code>, while <code class="language-plaintext highlighter-rouge">Option&lt;Option&lt;i32&gt;&gt;</code> is <code class="language-plaintext highlighter-rouge">(union { i32, (), () }, i2)</code>. Using a small non-power-of-two integer improves our ability to pack things, since enum discriminants are often quite tiny.</p> <p>Next, we need to handle unions. Because mucking about with unions’ uninitialized bits behind our backs is allowed, we need to either pass it as an array of <code class="language-plaintext highlighter-rouge">u8</code>, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">5</a></sup>.</p> <p>Now, we can proceed to flatten everything. All of the converted arguments are flattened into their most primitive components: pointers, integers, floats, and bools. Every field should be no larger than the smallest argument register; this may require splitting large types such as <code class="language-plaintext highlighter-rouge">u128</code> or <code class="language-plaintext highlighter-rouge">f64</code>.</p> <p>This big list of primitives is next sorted by effective size, from smallest to largest. We take the largest prefix of this that will fit in the available register space; everything else goes on the stack.</p> <p>If part of a Rust-level input is sent to the stack in this way, and that part is larger than a small multiple of the pointer size (e.g., 2x), it is demoted to being passed by pointer-on-the-stack, to minimize memory traffic. Everything else is passed directly on the stack in the order those inputs were before the sort. This helps keep regions that need to be copied relatively contiguous, to minimize calls to <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>The things we choose to pass in registers are allocated to registers in reverse size order, so e.g. first 64-bit things, then 32-bit things, etc. This is the same layout algorithm that <code class="language-plaintext highlighter-rouge">repr(Rust)</code> structs use to move all the padding into the tail. Once we get to the <code class="language-plaintext highlighter-rouge">bool</code>s, those are bit-packed, 64 to a register.</p> <p>Here’s a relatively complicated example. My Rust function is as follows:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Context</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_thing</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">6</span><span class="p">],</span>
                <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">op_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">op_count</span> <span class="p">{</span>
    <span class="n">context</span><span class="nf">.check</span><span class="p">(</span><span class="n">op_count</span><span class="p">,</span> <span class="n">options</span><span class="py">.colorize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">code</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">suf</span><span class="p">))</span> <span class="o">=</span> <span class="n">name</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">suf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="s">"idk"</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p>The codegen for this function is quite complex, so I’ll only cover the prologue and epilogue. After sorting and flattening, our raw argument LLVM types are something like this:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nl">gprs:</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm0:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm1:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">LLVM IR</a></div></div> <p>Everything fits in registers! So, what does the LLVM function look like on x86?</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@do_thing</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="c1">; Unused.</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">; First, unpack all the primitives.</span>
  <span class="nv">%r9.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%r9.1.i64</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span> <span class="m">32</span>
  <span class="nv">%r9.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9.1.i64</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%xmm0.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm0.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm0.2</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%xmm0.3</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span>
  <span class="nv">%xmm1.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm1.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.1.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.1.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.2.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%xmm1.1.2</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.2.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.3.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%xmm1.1.3</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.3.i32</span> <span class="k">to</span> <span class="kt">i1</span>

  <span class="c1">; Next, reassemble them into concrete values as needed.</span>
  <span class="nv">%op_count.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%op_count</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%op_count.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%context.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%context</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="nv">%context.0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%name.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%name</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="nv">%name.0</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%code.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.0</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.1</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.0</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%code.3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.2</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%code.4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.3</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.2</span><span class="p">,</span> <span class="m">4</span>
  <span class="nv">%code</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.4</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.3</span><span class="p">,</span> <span class="m">5</span>
  <span class="nv">%options.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm1.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%options.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%options.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.2</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%options</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.2</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.3</span><span class="p">,</span> <span class="m">3</span>

  <span class="c1">; Codegen as usual.</span>
  <span class="c1">; ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">LLVM IR</a></div></div> <p>Above, <code class="language-plaintext highlighter-rouge">!dbg</code> metadata for the argument values should be attached to the instruction that actually materializes it. This ensures that gdb does something halfway intelligent when you ask it to print argument values.</p> <p>On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what returns <em>could</em> look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does)! When we’re generating the ABI that all callers will see (for <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code>), we can look at the function body. This means that a crate can advertise the <em>precise</em> ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABIs. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it.</p> <p>Another example: suppose that we know that an <code class="language-plaintext highlighter-rouge">&amp;T</code> argument is not retained (a question the borrow checker can answer at this point in the compiler) and is never converted to a raw pointer (or written to memory a raw pointer is taken of, etc). We also know that <code class="language-plaintext highlighter-rouge">T</code> is fairly small, and <code class="language-plaintext highlighter-rouge">T: Freeze</code>. Then, we can replace the reference with the pointee directly, passed by value.</p> <p>The most obvious candidates for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is a step further. We might know that some arguments are hotter than others, which might cause them to be prioritized in the register allocation order.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find really frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. But <code class="language-plaintext highlighter-rouge">-Zcallconv</code> is intended to only be used with optimizations turned on, so I don’t think this is a meaningful complaint. Nor do I think the project’s Goodhartization of compilation time as a metric is healthy… but I do not think this is ultimately a relevant drawback.</p> <p>I, unfortunately, do not have the spare time to dive into fixing rustc’s ABI code, but I do know LLVM really well, and I know that this is a place where Rust has a low bus factor. For that reason, I am happy to provide the Rust compiler team expert knowledge on getting LLVM to do the right thing in service of making optimized code faster.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:just-use-extern-c" role="doc-endnote"> <p>Or just switch it to the codepath for <code class="language-plaintext highlighter-rouge">extern "C"</code> or <code class="language-plaintext highlighter-rouge">extern "fastcall"</code> since those are clearly better. We will always need to know how to generate code for the non-<code class="language-plaintext highlighter-rouge">extern "Rust"</code> calling conventions. <a href="#fnref:just-use-extern-c" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:doubles-and-vectors" role="doc-endnote"> <p>It’s Complicated. Passing a <code class="language-plaintext highlighter-rouge">double</code> burns a whole <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code> slot. This seems bad, but it can be beneficial since keeping a <code class="language-plaintext highlighter-rouge">double</code> in vector registers reduces register traffic, since usually, fp instructions use the vector registers (or the fp registers shadow the vector registers, like on ARM). <a href="#fnref:doubles-and-vectors" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:official-support" role="doc-endnote"> <p>On the one hand, you might say this “extended calling convention” isn’t an explicitly supported part of LLVM’s <code class="language-plaintext highlighter-rouge">ccc</code> calling convention. On the other hand, <a href="hyrumslaw.com">Hyrum’s Law</a> cuts both ways: Rust is big enough of an LLVM user that LLVM cannot simply miscompile all Rust programs at this point, and the IR I propose Rust emits is extremely reasonable.</p> <p>If Rust causes LLVM to misbehave, that’s an LLVM bug, and we should fix LLVM bugs, not work around them. <a href="#fnref:official-support" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-opt" role="doc-endnote"> <p>Only on <code class="language-plaintext highlighter-rouge">-O1</code> or higher, bizarrely. At <code class="language-plaintext highlighter-rouge">-O0</code>, LLVM decides that all of the <code class="language-plaintext highlighter-rouge">poison</code>s must have the same value, so it copies a bunch of registers around needlessly. This seems like a bug? <a href="#fnref:requires-opt" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-11-27 • 6485 words • 72 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#bit-tricks">#bit-tricks</a> • <a href="https://mcyoung.xyz/tags.html#optimization">#optimization</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/11/27/simd-base64/"> Designing a SIMD Algorithm from Scratch </a></h1> </div> <div class="post"> <p>Another explainer on a fun, esoteric topic: optimizing code with SIMD (single instruction multiple data, also sometimes called <em>vectorization</em>). Designing a good, fast, portable SIMD algorithm is not a simple matter and requires thinking a little bit like a circuit designer.</p> <p>Here’s the mandatory performance benchmark graph to catch your eye.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph.png" alt="perf perf perf"/></p> <p>“SIMD” often gets thrown around as a buzzword by performance and HPC (high performance computing) nerds, but I don’t think it’s a topic that has very friendly introductions out there, for a lot of reasons.</p> <ul> <li>It’s not something you will really want to care about unless you think performance is cool.</li> <li>APIs for programming with SIMD in most programming languages are <em>garbage</em> (I’ll get into why).</li> <li>SIMD algorithms are hard to think about if you’re very procedural-programming-brained. A functional programming mindset can help a lot.</li> </ul> <p>This post is mostly about <a href="https://docs.rs/vb64/latest/vb64/"><code class="language-plaintext highlighter-rouge">vb64</code></a> (which stands for <em>v</em>ector <em>b</em>ase<em>64</em>), a base64 codec I wrote to see for myself if Rust’s <code class="language-plaintext highlighter-rouge">std::simd</code> library is any good, but it’s also an excuse to talk about SIMD in general.</p> <p>What <em>is</em> SIMD, anyways? Let’s dive in.</p> <p>If you want to skip straight to the writeup on <code class="language-plaintext highlighter-rouge">vb64</code>, click <a href="#parsing-with-simd">here</a>.</p> <h2 id="problems-with-physics"><a href="#problems-with-physics">Problems with Physics</a></h2> <p>Unfortunately, computers exist in the real world<sup>[citation-needed]</sup>, and are bound by the laws of nature. SIMD has relatively little to do with theoretical CS considerations, and everything to do with <em>physics</em>.</p> <p>In the infancy of modern computing, you could simply improve performance of existing programs by buying new computers. This is often incorrectly attributed to Moore’s law (the number of transistors on IC designs doubles every two years). Moore’s law still appears to hold as of 2023, but some time in the last 15 years the <a href="https://en.wikipedia.org/wiki/Dennard_scaling">Dennard scaling</a> effect broke down. This means that denser transistors eventually means increased power dissipation density. In simpler terms, we don’t know how to continue to increase the clock frequency of computers without literally <em>liquefying</em> them.</p> <p>So, since the early aughts, the hot new thing has been bigger core counts. Make your program more multi-threaded and it will run faster on bigger CPUs. This comes with synchronization overhead, since now the cores need to cooperate. All control flow, be it jumps, virtual calls, or synchronization will result in “stall”.</p> <p>The main causes of stall are <em>branches</em>, instructions that indicate code can take one of two possible paths (like an <code class="language-plaintext highlighter-rouge">if</code> statement), and <em>memory operations</em>. Branches include all control flow: <code class="language-plaintext highlighter-rouge">if</code> statements, loops, function calls, function returns, even <code class="language-plaintext highlighter-rouge">switch</code> statements in C. Memory operations are loads and stores, especially ones that are cache-unfriendly.</p> <h3 id="procedural-code-is-slow"><a href="#procedural-code-is-slow">Procedural Code Is Slow</a></h3> <p>Modern compute cores do not execute code line-by-line, because that would be very inefficient. Suppose I have this program:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{a}, {b}"</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Rust</a></div></div> <p>There’s no reason for the CPU to wait to finish computing <code class="language-plaintext highlighter-rouge">a</code> before it begins computing <code class="language-plaintext highlighter-rouge">b</code>; it does not depend on <code class="language-plaintext highlighter-rouge">a</code>, and while the add is being executed, the xor circuits are idle. Computers say “program order be damned” and issue the add for <code class="language-plaintext highlighter-rouge">a</code> and the xor for <code class="language-plaintext highlighter-rouge">b</code> simultaneously. This is called <em>instruction-level parallelism</em>, and dependencies that get in the way of it are often called <em>data hazards</em>.</p> <p>Of course, the Zen 2 in the machine I’m writing this with does not have one measly adder per core. It has dozens and dozens! The opportunities for parallelism are massive, as long as the compiler in your CPU’s execution pipeline can clear any data hazards in the way.</p> <p>The better the core can do this, the more it can saturate all of the “functional units” for things like arithmetic, and the more numbers it can crunch per unit time, approaching maximum utilization of the hardware. Whenever the compiler can’t do this, the execution pipeline stalls and your code is slower.</p> <p>Branches stall because they need to wait for the branch condition to be computed before fetching the next instruction (speculative execution is a somewhat iffy workaround for this). Memory operations stall because the data needs to physically arrive at the CPU, and the speed of light is finite in this universe.</p> <p>Trying to reduce stall by improving opportunities for single-core parallelism is not a new idea. Consider the not-so-humble GPU, whose purpose in life is to render images. Images are vectors of pixels (i.e., color values), and rendering operations tend to be highly local. For example, a convolution kernel for a Gaussian blur will be two or even three orders of magnitude smaller than the final image, lending itself to locality.</p> <p>Thus, GPUs are built for divide-and-conquer: they provide primitives for doing batched operations, and extremely limited control flow.</p> <p>“SIMD” is synonymous with “batching”. It stands for “single instruction, multiple data”: a single instruction dispatches parallel operations on multiple <em>lanes</em> of data. GPUs are the original SIMD machines.</p> <h2 id="lane-wise"><a href="#lane-wise">Lane-Wise</a></h2> <p>“SIMD” and “vector” are often used interchangeably. The fundamental unit a SIMD instruction (or “vector instruction”) operates on is a vector: a fixed-size array of numbers that you primarily operate on component-wise These components are called <em>lanes</em>.</p> <p>SIMD vectors are usually quite small, since they need to fit into registers. For example, on my machine, the largest vectors are 256 bits wide. This is enough for 32 bytes (a <code class="language-plaintext highlighter-rouge">u8x32</code>), 4 double-precision floats (an <code class="language-plaintext highlighter-rouge">f64x8</code>), or all kinds of things in between.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/vectors.png" alt="some 256-bit vectors"/></p> <p>Although this doesn’t seem like much, remember that offloading the overhead of keeping the pipeline saturated by a factor of 4x can translate to that big of a speedup in latency.</p> <h3 id="one-bit-lanes"><a href="#one-bit-lanes">One-Bit Lanes</a></h3> <p>The simplest vector operations are bitwise: and, or, xor. Ordinary integers can be thought of as vectors themselves, with respect to the bitwise operations. That’s literally what “bitwise” means: lanes-wise with lanes that are one bit wide. An <code class="language-plaintext highlighter-rouge">i32</code> is, in this regard, an <code class="language-plaintext highlighter-rouge">i1x32</code>.</p> <p>In fact, as a warmup, let’s look at the problem of counting the number of 1 bits in an integer. This operation is called “population count”, or <code class="language-plaintext highlighter-rouge">popcnt</code>. If we view an <code class="language-plaintext highlighter-rouge">i32</code> as an <code class="language-plaintext highlighter-rouge">i1x32</code>, <code class="language-plaintext highlighter-rouge">popcnt</code> is just a fold or reduce operation:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">popcnt</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">32</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bit</span><span class="p">)</span> <span class="k">in</span> <span class="n">bits</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">total</span><span class="p">,</span> <span class="n">bit</span><span class="p">|</span> <span class="n">total</span> <span class="o">+</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBwb3BjbnQobXV0IHg6IHUzMikgLT4gdTMyIHtcbiAgbGV0 IG11dCBiaXRzID0gWzA7IDMyXTtcbiAgZm9yIChpLCBiaXQpIGluIGJpdHMu aXRlcl9tdXQoKS5lbnVtZXJhdGUoKSB7XG4gICAgKmJpdCA9ICh4ID4+IGkp ICYgMTtcbiAgfVxuICBiaXRzLmludG9faXRlcigpLmZvbGQoMCwgfHRvdGFs LCBiaXR8IHRvdGFsICsgYml0KVxufSIsImNvbXBpbGVycyI6W3siaWQiOiJi ZXRhIiwib3B0aW9ucyI6Ii1PIn1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <p>In other words, we interpret the integer as an array of bits and then add the bits together to a 32-bit accumulator. Note that the accumulator needs to be higher precision to avoid overflow: accumulating into an <code class="language-plaintext highlighter-rouge">i1</code> (as with the <code class="language-plaintext highlighter-rouge">Iterator::reduce()</code> method) will only tell us whether the number of 1 bits is even or odd.</p> <p>Of course, this produces… comically bad code, frankly. We can do much better if we notice that we can <em>vectorize</em> the addition: first we add all of the adjacent pairs of bits together, then the pairs of pairs, and so on. This means the number of adds is logarithmic in the number of bits in the integer.</p> <p>Visually, what we do is we “unzip” each vector, shift one to line up the lanes, add them, and then repeat with lanes twice as big.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/popcnt.png" alt="first two popcnt merge steps"/></p> <p>This is what that looks like in code.</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">popcnt</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="c1">// View x as a i1x32, and split it into two vectors</span>
  <span class="c1">// that contain the even and odd bits, respectively.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x55555555</span><span class="p">;</span> <span class="c1">// 0x5 == 0b0101.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xaaaaaaaa</span><span class="p">;</span> <span class="c1">// 0xa == 0b1010.</span>
  <span class="c1">// Shift odds down to align the bits, and then add them together.</span>
  <span class="c1">// We interpret x now as a i2x16. When adding, each two-bit</span>
  <span class="c1">// lane cannot overflow, because the value in each lane is</span>
  <span class="c1">// either 0b00 or 0b01.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Repeat again but now splitting even and odd bit-pairs.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x33333333</span><span class="p">;</span> <span class="c1">// 0x3 == 0b0011.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xcccccccc</span><span class="p">;</span> <span class="c1">// 0xc == 0b1100.</span>
  <span class="c1">// We need to shift by 2 to align, and now for this addition</span>
  <span class="c1">// we interpret x as a i4x8.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Again. The pattern should now be obvious.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x0f0f0f0f</span><span class="p">;</span> <span class="c1">// 0x0f == 0b00001111.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xf0f0f0f0</span><span class="p">;</span> <span class="c1">// 0xf0 == 0b11110000.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// i8x4</span>

  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x00ff00ff</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xff00ff00</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>  <span class="c1">// i16x2</span>

  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x0000ffff</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xffff0000</span><span class="p">;</span>
  <span class="c1">// Because the value of `x` is at most 32, although we interpret this as a</span>
  <span class="c1">// i32x1 add, we could get away with just one e.g. i16 add.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

  <span class="n">x</span> <span class="c1">// Done. All bits have been added.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBwb3BjbnQobXV0IHg6IHUzMikgLT4gdTMyIHtcbiAgLy8g VmlldyB4IGFzIGEgaTF4MzIsIGFuZCBzcGxpdCBpdCBpbnRvIHR3byB2ZWN0 b3JzXG4gIC8vIHRoYXQgY29udGFpbiB0aGUgZXZlbiBhbmQgb2RkIGJpdHMs IHJlc3BlY3RpdmVseS5cbiAgbGV0IGV2ZW4gPSB4ICYgMHg1NTU1NTU1NTsg Ly8gMHg1ID09IDBiMDEwMS5cbiAgbGV0IG9kZHMgPSB4ICYgMHhhYWFhYWFh YTsgLy8gMHhhID09IDBiMTAxMC5cbiAgLy8gU2hpZnQgb2RkcyBkb3duIHRv IGFsaWduIHRoZSBiaXRzLCBhbmQgdGhlbiBhZGQgdGhlbSB0b2dldGhlci5c biAgLy8gV2UgaW50ZXJwcmV0IHggbm93IGFzIGEgaTJ4MTYuIFdoZW4gYWRk aW5nLCBlYWNoIHR3by1iaXRcbiAgLy8gbGFuZSBjYW5ub3Qgb3ZlcmZsb3cs IGJlY2F1c2UgdGhlIHZhbHVlIGluIGVhY2ggbGFuZSBpc1xuICAvLyBlaXRo ZXIgMGIwMCBvciAwYjAxLlxuICB4ID0gZXZlbiArIChvZGRzID4+IDEpO1xu XG4gIC8vIFJlcGVhdCBhZ2FpbiBidXQgbm93IHNwbGl0dGluZyBldmVuIGFu ZCBvZGQgYml0LXBhaXJzLlxuICBsZXQgZXZlbiA9IHggJiAweDMzMzMzMzMz OyAvLyAweDMgPT0gMGIwMDExLlxuICBsZXQgb2RkcyA9IHggJiAweGNjY2Nj Y2NjOyAvLyAweGMgPT0gMGIxMTAwLlxuICAvLyBXZSBuZWVkIHRvIHNoaWZ0 IGJ5IDIgdG8gYWxpZ24sIGFuZCBub3cgZm9yIHRoaXMgYWRkaXRpb25cbiAg Ly8gd2UgaW50ZXJwcmV0IHggYXMgYSBpNHg4LlxuICB4ID0gZXZlbiArIChv ZGRzID4+IDIpO1xuXG4gIC8vIEFnYWluLiBUaGUgcGF0dGVybiBzaG91bGQg bm93IGJlIG9idmlvdXMuXG4gIGxldCBldmVuID0geCAmIDB4MGYwZjBmMGY7 IC8vIDB4MGYgPT0gMGIwMDAwMTExMS5cbiAgbGV0IG9kZHMgPSB4ICYgMHhm MGYwZjBmMDsgLy8gMHhmMCA9PSAwYjExMTEwMDAwLlxuICB4ID0gZXZlbiAr IChvZGRzID4+IDQpOyAvLyBpOHg0XG5cbiAgbGV0IGV2ZW4gPSB4ICYgMHgw MGZmMDBmZjtcbiAgbGV0IG9kZHMgPSB4ICYgMHhmZjAwZmYwMDtcbiAgeCA9 IGV2ZW4gKyAob2RkcyA+PiA4KTsgIC8vIGkxNngyXG5cbiAgbGV0IGV2ZW4g PSB4ICYgMHgwMDAwZmZmZjtcbiAgbGV0IG9kZHMgPSB4ICYgMHhmZmZmMDAw MDtcbiAgLy8gQmVjYXVzZSB0aGUgdmFsdWUgb2YgYHhgIGlzIGF0IG1vc3Qg MzIsIGFsdGhvdWdoIHdlIGludGVycHJldCB0aGlzIGFzIGFcbiAgLy8gaTMy eDEgYWRkLCB3ZSBjb3VsZCBnZXQgYXdheSB3aXRoIGp1c3Qgb25lIGUuZy4g aTE2IGFkZC5cbiAgeCA9IGV2ZW4gKyAob2RkcyA+PiAxNik7XG5cbiAgeCAv LyBEb25lLiBBbGwgYml0cyBoYXZlIGJlZW4gYWRkZWQuXG59IiwiY29tcGls ZXJzIjpbeyJpZCI6ImJldGEiLCJvcHRpb25zIjoiLU8ifV19XX0=">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:3">Rust</a></div></div> <p>This still won’t optimize down to a <code class="language-plaintext highlighter-rouge">popcnt</code> instruction, of course. The search scope for such a simplification is in the regime of superoptimizers. However, the generated code is small and fast, which is why this is the ideal implementation of <code class="language-plaintext highlighter-rouge">popcnt</code> for systems without such an instruction.</p> <p>It’s <em>especially</em> nice because it is implementable for e.g. <code class="language-plaintext highlighter-rouge">u64</code> with only one more reduction step (remember: it’s <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>!), and does not at any point require a full <code class="language-plaintext highlighter-rouge">u64</code> addition.</p> <p>Even though this is “just” using scalars, divide-and-conquer approaches like this are the bread and butter of the SIMD programmer.</p> <h3 id="scaling-up-operations-on-real-vectors"><a href="#scaling-up-operations-on-real-vectors">Scaling Up: Operations on Real Vectors</a></h3> <p>Proper SIMD vectors provide more sophisticated semantics than scalars do, particularly because there is more need to provide replacements for things like control flow. Remember, control flow is slow!</p> <p>What’s actually available is highly dependent on the architecture you’re compiling to (more on this later), but the way vector instruction sets are usually structured is something like this.</p> <p>We have <em>vector registers</em> that are kind of like really big general-purpose registers. For example, on x86, most “high performance” cores (like my Zen 2) implement AVX2, which provides 256 bit <code class="language-plaintext highlighter-rouge">ymm</code> vectors. The registers themselves do not have a “lane count”; that is specified by the instructions. For example, the “vector byte add instruction” interprets the register as being divided into eight-byte lanes and adds them. The corresponding x86 instruction is <code class="language-plaintext highlighter-rouge">vpaddb</code>, which interprets a <code class="language-plaintext highlighter-rouge">ymm</code> as an <code class="language-plaintext highlighter-rouge">i8x32</code>.</p> <p>The operations you usually get are:</p> <ol> <li> <p>Bitwise operations. These don’t need to specify a lane width because it’s always implicitly <code class="language-plaintext highlighter-rouge">1</code>: they’re <em>bit</em>wise.</p> </li> <li> <p>Lane-wise arithmetic. This is addition, subtraction, multiplication, division (both int and float), and shifts<sup id="fnref:shifts-are-arithmetic" role="doc-noteref"><a href="#fn:shifts-are-arithmetic" class="footnote" rel="footnote">1</a></sup> (int only). Lane-wise min and max are also common. These require specifying a lane width. Typically the smallest number of lanes is two or four.</p> </li> <li> <p>Lane-wise compare. Given <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, we can create a new <em>mask vector</em> <code class="language-plaintext highlighter-rouge">m</code> such that <code class="language-plaintext highlighter-rouge">m[i] = a[i] &lt; b[i]</code> (or any other comparison operation). A mask vector’s lanes contain boolean values with an unusual bit-pattern: all-zeros (for false) or all-ones (for true)<sup id="fnref:minus-true" role="doc-noteref"><a href="#fn:minus-true" class="footnote" rel="footnote">2</a></sup>.</p> <ul> <li>Masks can be used to select between two vectors: for example, given <code class="language-plaintext highlighter-rouge">m</code>, <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">y</code>, you can form a fourth vector <code class="language-plaintext highlighter-rouge">z</code> such that <code class="language-plaintext highlighter-rouge">z[i] = m[i] ? a[i] : b[i]</code>.</li> </ul> </li> <li> <p>Shuffles (sometimes called swizzles). Given <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">x</code>, create a third vector <code class="language-plaintext highlighter-rouge">s</code> such that <code class="language-plaintext highlighter-rouge">s[i] = a[x[i]]</code>. <code class="language-plaintext highlighter-rouge">a</code> is used as a lookup table, and <code class="language-plaintext highlighter-rouge">x</code> as a set of indices. Out of bounds produces a special value, usually zero. This emulates parallelized array access without needing to actually touch RAM (RAM is extremely slow).</p> <ul> <li>Often there is a “shuffle2” or “riffle” operation that allows taking elements from one of two vectors. Given <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">x</code>, we now define <code class="language-plaintext highlighter-rouge">s</code> as being <code class="language-plaintext highlighter-rouge">s[i] = (a ++ b)[x[i]]</code>, where <code class="language-plaintext highlighter-rouge">a ++ b</code> is a double-width concatenation. How this is actually implemented depends on architecture, and it’s easy to build out of single shuffles regardless.</li> </ul> </li> </ol> <p>(1) and (2) are ordinary number crunching. Nothing deeply special about them.</p> <p>The comparison and select operations in (3) are intended to help SIMD code stay “branchless”. Branchless code is written such that it performs the same operations regardless of its inputs, and relies on the properties of those operations to produce correct results. For example, this might mean taking advantage of identities like <code class="language-plaintext highlighter-rouge">x * 0 = 0</code> and <code class="language-plaintext highlighter-rouge">a ^ b ^ a = b</code> to discard “garbage” results.</p> <p>The shuffles described in (4) are much more powerful than meets the eye.</p> <p>For example, “broadcast” (sometimes called “splat”) makes a vector whose lanes are all the same scalar, like Rust’s <code class="language-plaintext highlighter-rouge">[42; N]</code> array literal. A broadcast can be expressed as a shuffle: create a vector with the desired value in the first lane, and then shuffle it with an index vector of <code class="language-plaintext highlighter-rouge">[0, 0, ...]</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/broadcast.png" alt="diagram of a broadcast"/></p> <p>“Interleave” (also called “zip” or “pack”) takes two vectors <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> and creates two new vectors <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> whose lanes are alternating lanes from <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. If the lane count is <code class="language-plaintext highlighter-rouge">n</code>, then <code class="language-plaintext highlighter-rouge">c = [a[0], b[0], a[1], b[1], ...]</code> and <code class="language-plaintext highlighter-rouge">d = [a[n/2], b[n/2], a[n/2 + 1], b[n/2 + 1], ...]</code>. This can also be implemented as a shuffle2, with shuffle indices of <code class="language-plaintext highlighter-rouge">[0, n, 1, n + 1, ...]</code>. “Deinterleave” (or “unzip”, or “unpack”) is the opposite operation: it interprets a pair of vectors as two halves of a larger vector of pairs, and produces two new vectors consisting of the halves of each pair.</p> <p>Interleave can also be interpreted as taking a <code class="language-plaintext highlighter-rouge">[T; N]</code>, transmuting it to a <code class="language-plaintext highlighter-rouge">[[T; N/2]; 2]</code>, performing a matrix transpose to turn it into a <code class="language-plaintext highlighter-rouge">[[T; 2]; N/2]</code>, and then transmuting that back to <code class="language-plaintext highlighter-rouge">[T; N]</code> again. Deinterleave is the same but it transmutes to <code class="language-plaintext highlighter-rouge">[[T; 2]; N/2]</code> first.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/interleave.png" alt="diagram of a interleave"/></p> <p>“Rotate” takes a vector <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">n</code> lanes and produces a new vector <code class="language-plaintext highlighter-rouge">b</code> such that <code class="language-plaintext highlighter-rouge">b[i] = a[(i + j) % n]</code>, for some chosen integer <code class="language-plaintext highlighter-rouge">j</code>. This is yet another shuffle, with indices <code class="language-plaintext highlighter-rouge">[j, j + 1, ..., n - 1, 0, 1, ... j - 1]</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/rotate.png" alt="diagram of a rotate"/></p> <p>Shuffles are worth trying to wrap your mind around. SIMD programming is all about reinterpreting larger-than-an-integer-sized blocks of data as smaller blocks of varying sizes, and shuffling is important for getting data into the right “place”.</p> <h3 id="intrinsics-and-instruction-selection"><a href="#intrinsics-and-instruction-selection">Intrinsics and Instruction Selection</a></h3> <p>Earlier, I mentioned that what you get varies by architecture. This section is basically a giant footnote.</p> <p>So, there’s two big factors that go into this.</p> <ol> <li>We’ve learned over time which operations tend to be most useful to programmers. x86 might have something that ARM doesn’t because it “seemed like a good idea at the time” but turned out to be kinda niche.</li> <li>Instruction set extensions are often market differentiators, even within the same vendor. Intel has AVX-512, which provides even more sophisticated instructions, but it’s only available on high-end server chips, because it makes manufacturing more expensive.</li> </ol> <p>Toolchains generalize different extensions as “target features”. Features can be detected at runtime through architecture-specific magic. On Linux, the <code class="language-plaintext highlighter-rouge">lscpu</code> command will list what features the CPU advertises that it recognizes, which correlate with the names of features that e.g. LLVM understands. What features are enabled for a particular function affects how LLVM compiles it. For example, LLVM will only emit <code class="language-plaintext highlighter-rouge">ymm</code>-using code when compiling with <code class="language-plaintext highlighter-rouge">+avx2</code>.</p> <p>So how do you write portable SIMD code? On the surface, the answer is mostly “you don’t”, but it’s more complicated than that, and for that we need to understand how the later parts of a compiler works.</p> <p>When a user requests an add by writing <code class="language-plaintext highlighter-rouge">a + b</code>, how should I decide which instruction to use for it? This seems like a trick question… <em>just</em> an <code class="language-plaintext highlighter-rouge">add</code> right? On x86, even this isn’t so easy, since you have a choice between the actual <code class="language-plaintext highlighter-rouge">add</code> instruction, or a <code class="language-plaintext highlighter-rouge">lea</code> instruction (which, among other things, preserves the <code class="language-plaintext highlighter-rouge">rflags</code> register). This question becomes more complicated for more sophisticated operations. This general problem is called <em>instruction selection</em>.</p> <p>Because which “target features” are enabled affects which instructions are available, they affect instruction selection. When I went over operations “typically available”, this means that compilers will usually be able to select good choices of instructions for them on most architectures.</p> <p>Compiling with something like <code class="language-plaintext highlighter-rouge">-march=native</code> or <code class="language-plaintext highlighter-rouge">-Ctarget-cpu=native</code> gets you “the best” code possible for the machine you’re building on, but it might not be portable<sup id="fnref:abi" role="doc-noteref"><a href="#fn:abi" class="footnote" rel="footnote">3</a></sup> to different processors. Gentoo was quite famous for building packages from source on user machines to take advantage of this (not to mention that they loved using <code class="language-plaintext highlighter-rouge">-O3</code>, which mostly exists to slow down build times with little benefit).</p> <p>There is also runtime feature detection, where a program decides which version of a function to call at runtime by asking the CPU what it supports. Code deployed on heterogenous devices (like cryptography libraries) often make use of this. Doing this correctly is very hard and something I don’t particularly want to dig deeply into here.</p> <p>The situation is made worse by the fact that in C++, you usually write SIMD code using “intrinsics”, which are special functions with inscrutable names like <code class="language-plaintext highlighter-rouge">_mm256_cvtps_epu32</code> that represent a low-level operation in a specific instruction set (this is a float to int cast from AVX2). Intrinsics are defined by hardware vendors, but don’t necessarily map down to single instructions; the compiler can still optimize these instructions by merging, deduplication, and through instruction selection.</p> <p>As a result you wind up writing the same code multiple times for different instruction sets, with only minor maintainability benefits over writing assembly.</p> <p>The alternative is a portable SIMD library, which does some instruction selection behind the scenes at the library level but tries to rely on the compiler for most of the heavy-duty work. For a long time I was skeptical that this approach would actually produce good, competitive code, which brings us to the actual point of this article: using Rust’s portable SIMD library to implement a somewhat fussy algorithm, and measuring performance.</p> <h2 id="parsing-with-simd"><a href="#parsing-with-simd">Parsing with SIMD</a></h2> <p>Let’s design a SIMD implementation for a well-known algorithm. Although it doesn’t look like it at first, the power of shuffles makes it possible to parse text with SIMD. And this parsing can be very, very fast.</p> <p>In this case, we’re going to implement base64 decoding. To review, base64 is an encoding scheme for arbitrary binary data into ASCII. We interpret a byte slice as a bit vector, and divide it into six-bit chunks called <em>sextets</em>. Then, each sextet from 0 to 63 is mapped to an ASCII character:</p> <ol> <li><code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">25</code> go to <code class="language-plaintext highlighter-rouge">'A'</code> to <code class="language-plaintext highlighter-rouge">'Z'</code>.</li> <li><code class="language-plaintext highlighter-rouge">26</code> to <code class="language-plaintext highlighter-rouge">51</code> go to <code class="language-plaintext highlighter-rouge">'a'</code> to <code class="language-plaintext highlighter-rouge">'z'</code>.</li> <li><code class="language-plaintext highlighter-rouge">52</code> to <code class="language-plaintext highlighter-rouge">61</code> go to <code class="language-plaintext highlighter-rouge">'0'</code> to <code class="language-plaintext highlighter-rouge">'9'</code>.</li> <li><code class="language-plaintext highlighter-rouge">62</code> goes to <code class="language-plaintext highlighter-rouge">+</code>.</li> <li><code class="language-plaintext highlighter-rouge">63</code> goes to <code class="language-plaintext highlighter-rouge">/</code>.</li> </ol> <p>There <em>are</em> other variants of base64, but the bulk of the complexity is the same for each variant.</p> <p>There are a few basic pitfalls to keep in mind.</p> <ol> <li> <p>Base64 is a “big endian” format: specifically, the bits in each byte are big endian. Because a sextet can span only parts of a byte, this distinction is important.</p> </li> <li> <p>We need to beware of cases where the input length is not divisible by 4; ostensibly messages should be padded with <code class="language-plaintext highlighter-rouge">=</code> to a multiple of 4, but it’s easy to just handle messages that aren’t padded correctly.</p> </li> </ol> <p>The length of a decoded message is given by this function:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">input</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="k">match</span> <span class="n">input</span> <span class="o">%</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="p">|</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="mi">3</span> <span class="k">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>Given all this, the easiest way to implement base64 is something like this.</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Tear off at most two trailing =.</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// Split the input into chunks of at most 4 bytes.</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">byte</span> <span class="k">in</span> <span class="n">chunk</span> <span class="p">{</span>
      <span class="c1">// Translate each ASCII character into its corresponding</span>
      <span class="c1">// sextet, or return an error.</span>
      <span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
        <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
        <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
        <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
        <span class="sc">b'+'</span> <span class="k">=&gt;</span> <span class="mi">62</span><span class="p">,</span>
        <span class="sc">b'/'</span> <span class="k">=&gt;</span> <span class="mi">63</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nf">Error</span><span class="p">(</span><span class="o">...</span><span class="p">)),</span>
      <span class="p">};</span>

      <span class="c1">// Append the sextet to the temporary buffer.</span>
      <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
      <span class="n">bytes</span> <span class="p">|</span><span class="o">=</span> <span class="n">sextet</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Shift things so the actual data winds up at the</span>
    <span class="c1">// top of `bytes`.</span>
    <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">32</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">chunk</span><span class="nf">.len</span><span class="p">();</span>

    <span class="c1">// Append the decoded data to `out`, keeping in mind that</span>
    <span class="c1">// `bytes` is big-endian encoded.</span>
    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="nf">.to_be_bytes</span><span class="p">()[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Rust</a></div></div> <p>So, what’s the process of turning this into a SIMD version? We want to follow one directive with inexorable, robotic dedication.</p> <p><strong>Eliminate all branches.</strong></p> <p>This is not completely feasible, since the input is of variable length. But we can try. There are several branches in this code:</p> <ol> <li>The <code class="language-plaintext highlighter-rouge">for chunk in</code> line. This one is is the length check: it checks if there is any data left to process.</li> <li>The <code class="language-plaintext highlighter-rouge">for &amp;byte in</code> line. This is the hottest loop: it branches once per input byte.</li> <li>The <code class="language-plaintext highlighter-rouge">match byte</code> line is several branches, to determine which of the five “valid” match arms we land in.</li> <li>The <code class="language-plaintext highlighter-rouge">return Err</code> line. Returning in a hot loop is extra control flow, which is not ideal.</li> <li>The call to <code class="language-plaintext highlighter-rouge">decoded_len</code> contains a <code class="language-plaintext highlighter-rouge">match</code>, which generates branches.</li> <li>The call to <code class="language-plaintext highlighter-rouge">Vec::extend_from_slice</code>. This contains not just branches, but potential calls into the allocator. Extremely slow.</li> </ol> <p>(5) is the easiest to deal with. The <code class="language-plaintext highlighter-rouge">match</code> is mapping the values <code class="language-plaintext highlighter-rouge">0, 1, 2, 3</code> to <code class="language-plaintext highlighter-rouge">0, 1, 1, 2</code>. Call this function <code class="language-plaintext highlighter-rouge">f</code>. Then, the sequence given by <code class="language-plaintext highlighter-rouge">x - f(x)</code> is <code class="language-plaintext highlighter-rouge">0, 0, 1, 1</code>. This just happens to equal <code class="language-plaintext highlighter-rouge">x / 2</code> (or <code class="language-plaintext highlighter-rouge">x &gt;&gt; 1</code>), so we can write a completely branchless version of <code class="language-plaintext highlighter-rouge">decoded_len</code> like so.</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">mod4</span> <span class="o">=</span> <span class="n">input</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">input</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">mod4</span> <span class="o">-</span> <span class="n">mod4</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBkZWNvZGVkX2xlbihpbnB1dDogdXNpemUpIC0+IHVzaXpl IHtcbiAgbGV0IG1vZDQgPSBpbnB1dCAlIDQ7XG4gIGlucHV0IC8gNCAqIDMg KyAobW9kNCAtIG1vZDQgLyAyKVxufSIsImNvbXBpbGVycyI6W3siaWQiOiJi ZXRhIiwib3B0aW9ucyI6Ii1PIn1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p>That’s one branch eliminated<sup id="fnref:why-cant-llvm-do-it" role="doc-noteref"><a href="#fn:why-cant-llvm-do-it" class="footnote" rel="footnote">4</a></sup>. ✅</p> <p>The others will not prove so easy. Let’s turn our attention to the innermost loop next, branches (2), (3), and (4).</p> <h3 id="the-hottest-loop"><a href="#the-hottest-loop">The Hottest Loop</a></h3> <p>The superpower of SIMD is that because you operate on so much data at a time, you can unroll the loop so hard it becomes branchless.</p> <p>The insight is this: we want to load at most four bytes, do something to them, and then spit out at most three decoded bytes. While doing this operation, we may encounter a syntax error so we need to report that somehow.</p> <p>Here’s some facts we can take advantage of.</p> <ol> <li>We don’t need to figure out how many bytes are in the “output” of the hot loop: our handy branchless <code class="language-plaintext highlighter-rouge">decoded_len()</code> does that for us.</li> <li>Invalid base64 is extremely rare. We want that syntax error to cost as little as possible. If the user still cares about which byte was the problem, they can scan the input for it after the fact.</li> <li><code class="language-plaintext highlighter-rouge">A</code> is zero in base64. If we’re parsing a truncated chunk, padding it with <code class="language-plaintext highlighter-rouge">A</code> won’t change the value<sup id="fnref:pad-with-A" role="doc-noteref"><a href="#fn:pad-with-A" class="footnote" rel="footnote">5</a></sup>.</li> </ol> <p>This suggests an interface for the body of the “hottest loop”. We can factor it out as a separate function, and simplify since we can assume our input is always four bytes now.</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="p">([</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ok</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">byte</span> <span class="k">in</span> <span class="n">ascii</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
      <span class="sc">b'+'</span> <span class="k">=&gt;</span> <span class="mi">62</span><span class="p">,</span>
      <span class="sc">b'/'</span> <span class="k">=&gt;</span> <span class="mi">63</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">bytes</span> <span class="p">|</span><span class="o">=</span> <span class="n">sextet</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="n">ok</span> <span class="o">&amp;=</span> <span class="n">byte</span> <span class="o">==</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This is the `to_be_bytes()` call.</span>
  <span class="k">let</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">bytes</span><span class="nf">.to_le_bytes</span><span class="p">();</span>
  <span class="p">([</span><span class="n">b3</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">],</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// In decode()...</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
  <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

  <span class="k">let</span> <span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">);</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
  <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>You’re probably thinking: why not return <code class="language-plaintext highlighter-rouge">Option&lt;[u8; 3]&gt;</code>? Returning an enum will make it messier to eliminate the <code class="language-plaintext highlighter-rouge">if !ok</code> branch later on (which we will!). We want to write branchless code, so let’s focus on finding a way of producing that three-byte output without needing to do early returns.</p> <p>Now’s when we want to start talking about vectors rather than arrays, so let’s try to rewrite our function as such.</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="nd">unimplemented!</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>Note that the output is now four bytes, not three. SIMD lane counts need to be powers of two, and that last element will never get looked at, so we don’t need to worry about what winds up there.</p> <p>The callsite also needs to be tweaked, but only slightly, because <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> is <code class="language-plaintext highlighter-rouge">From&lt;[u8; 4]&gt;</code>.</p> <h3 id="ascii-to-sextet"><a href="#ascii-to-sextet">ASCII to Sextet</a></h3> <p>Let’s look at the first part of the <code class="language-plaintext highlighter-rouge">for byte in ascii</code> loop. We need to map each lane of the <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> to the corresponding sextet, and somehow signal which ones are invalid. First, notice something special about the <code class="language-plaintext highlighter-rouge">match</code>: almost every arm can be written as <code class="language-plaintext highlighter-rouge">byte - C</code> for some constant <code class="language-plaintext highlighter-rouge">C</code>. The non-range case looks a little silly, but humor me:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
  <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
  <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
  <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
  <span class="sc">b'+'</span>        <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'+'</span> <span class="o">+</span> <span class="mi">62</span><span class="p">,</span>
  <span class="sc">b'/'</span>        <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'/'</span> <span class="o">+</span> <span class="mi">63</span><span class="p">,</span>
  <span class="n">_</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p>So, it should be sufficient to build a vector <code class="language-plaintext highlighter-rouge">offsets</code> that contains the appropriate constant <code class="language-plaintext highlighter-rouge">C</code> for each lane, and then <code class="language-plaintext highlighter-rouge">let sextets = ascii - offsets;</code></p> <p>How can we build <code class="language-plaintext highlighter-rouge">offsets</code>? Using compare-and-select.</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// A lane-wise version of `x &gt;= start &amp;&amp; x &lt;= end`.</span>
<span class="k">fn</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">bytes</span><span class="nf">.simd_ge</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">bytes</span><span class="nf">.simd_le</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Create masks for each of the five ranges.</span>
<span class="c1">// Note that these are disjoint: for any two masks, m1 &amp; m2 == 0.</span>
<span class="k">let</span> <span class="n">uppers</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'A'</span><span class="p">,</span> <span class="sc">b'Z'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">lowers</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'a'</span><span class="p">,</span> <span class="sc">b'z'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">digits</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'0'</span><span class="p">,</span> <span class="sc">b'9'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">pluses</span> <span class="o">=</span> <span class="n">ascii</span><span class="nf">.simd_eq</span><span class="p">([</span><span class="sc">b'+'</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span><span class="nf">.into</span><span class="p">());</span>
<span class="k">let</span> <span class="n">solidi</span> <span class="o">=</span> <span class="n">ascii</span><span class="nf">.simd_eq</span><span class="p">([</span><span class="sc">b'/'</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span><span class="nf">.into</span><span class="p">());</span>

<span class="c1">// If any byte was invalid, none of the masks will select for it,</span>
<span class="c1">// so that lane will be 0 in the or of all the masks. This is our</span>
<span class="c1">// validation check.</span>
<span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">uppers</span> <span class="p">|</span> <span class="n">lowers</span> <span class="p">|</span> <span class="n">digits</span> <span class="p">|</span> <span class="n">pluses</span> <span class="p">|</span> <span class="n">solidi</span><span class="p">)</span><span class="nf">.all</span><span class="p">();</span>

<span class="c1">// Given a mask, create a new vector by splatting `value`</span>
<span class="c1">// over the set lanes.</span>
<span class="k">fn</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">mask</span><span class="nf">.select</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Fill the the lanes of the offset vector by filling the</span>
<span class="c1">// set lanes with the corresponding offset. This is like</span>
<span class="c1">// a "vectorized" version of the `match`.</span>
<span class="k">let</span> <span class="n">offsets</span> <span class="o">=</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">uppers</span><span class="p">,</span>  <span class="mi">65</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span>  <span class="mi">71</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">pluses</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">solidi</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">);</span>

<span class="c1">// Finally, Build the sextets vector.</span>
<span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-</span> <span class="n">offsets</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <p>This solution is quite elegant, and will produce very competitive code, but it’s not actually ideal. We need to do a lot of comparisons here: eight in total. We also keep lots of values alive at the same time, which might lead to unwanted register pressure.</p> <h3 id="simd-hash-table"><a href="#simd-hash-table">SIMD Hash Table</a></h3> <p>Let’s look at the byte representations of the ranges. <code class="language-plaintext highlighter-rouge">A-Z</code>, <code class="language-plaintext highlighter-rouge">a-z</code>, and <code class="language-plaintext highlighter-rouge">0-9</code> are, as byte ranges, <code class="language-plaintext highlighter-rouge">0x41..0x5b</code>, <code class="language-plaintext highlighter-rouge">0x61..0x7b</code>, and <code class="language-plaintext highlighter-rouge">0x30..0x3a</code>. Notice they all have different high nybbles! What’s more, <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">/</code> are <code class="language-plaintext highlighter-rouge">0x2b</code> and <code class="language-plaintext highlighter-rouge">0x2f</code>, so the function <code class="language-plaintext highlighter-rouge">byte &gt;&gt; 4</code> is <em>almost</em> enough to distinguish all the ranges. If we subtract one if <code class="language-plaintext highlighter-rouge">byte == b'/'</code>, we have a <em>perfect hash</em> for the ranges.</p> <p>In other words, the value <code class="language-plaintext highlighter-rouge">(byte &gt;&gt; 4) - (byte == '/')</code> maps the ranges as follows:</p> <ul> <li><code class="language-plaintext highlighter-rouge">A-Z</code> goes to 4 or 5.</li> <li><code class="language-plaintext highlighter-rouge">a-z</code> goes to 6 or 7.</li> <li><code class="language-plaintext highlighter-rouge">0-9</code> goes to 3.</li> <li><code class="language-plaintext highlighter-rouge">+</code> goes to 2.</li> <li><code class="language-plaintext highlighter-rouge">/</code> goes to 1.</li> </ul> <p>This is small enough that we could cram a lookup table of values for building the <code class="language-plaintext highlighter-rouge">offsets</code> vector into another SIMD vector, and use a shuffle operation to do the lookup.</p> <p>This is not my original idea; I came across a <a href="https://github.com/WojciechMula/base64simd/issues/3">GitHub issue</a> where an anonymous user points out this perfect hash.</p> <p>Our new ascii-to-sextet code looks like this:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Compute the perfect hash for each lane.</span>
<span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
  <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
    <span class="nf">.to_int</span><span class="p">()</span>  <span class="c1">// to_int() is equivalent to masked_splat(-1, 0).</span>
    <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Look up offsets based on each hash and subtract them from `ascii`.</span>
<span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="c1">// This lookup table corresponds to the offsets we used to build the</span>
    <span class="c1">// `offsets` vector in the previous implementation, placed in the</span>
    <span class="c1">// indices that the perfect hash produces.</span>
  <span class="o">-</span> <span class="nn">Simd</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
    <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>There is a small wrinkle here: <a href="https://doc.rust-lang.org/std/simd/struct.Simd.html#method.swizzle_dyn"><code class="language-plaintext highlighter-rouge">Simd::swizzle_dyn()</code></a> requires that the index array be the same length as the lookup table. This is annoying because right now <code class="language-plaintext highlighter-rouge">ascii</code> is a <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code>, but that will not be the case later on, so I will simply sweep this under the rug.</p> <p>Note that we no longer get validation as a side-effect of computing the sextets vector. The same GitHub issue also provides an exact bloom-filter for checking that a particular byte is valid; you can see my implementation <a href="https://github.com/mcy/vb64/blob/894f833e933860e070dabcfcc189430c45fecbd7/src/simd.rs#L93">here</a>. I’m not sure how the OP constructed the bloom filter, but the search space is small enough that you could have written a little script to brute force it.</p> <h3 id="riffling-the-sextets"><a href="#riffling-the-sextets">Riffling the Sextets</a></h3> <p>Now comes a much tricker operation: we need to somehow pack all four sextets into three bytes. One way to try to wrap our head around what the packing code in <code class="language-plaintext highlighter-rouge">decode_hot()</code> is doing is to pass in the all-ones sextet in one of the four bytes, and see where those ones end up in the return value.</p> <p>This is not unlike how they use radioactive dyes in biology to track the moment of molecules or cells through an organism.</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">bits</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">b4</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="nf">.reverse_bits</span><span class="p">()</span><span class="nf">.to_le_bytes</span><span class="p">();</span>
  <span class="nd">format!</span><span class="p">(</span><span class="s">"{b1:08b} {b2:08b} {b3:08b} {b4:08b}"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">decode_pack</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">byte</span> <span class="k">in</span> <span class="n">input</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">output</span> <span class="p">|</span><span class="o">=</span> <span class="n">byte</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">output</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="nf">bits</span><span class="p">(</span><span class="nn">u32</span><span class="p">::</span><span class="nf">from_be_bytes</span><span class="p">(</span><span class="n">input</span><span class="p">)),</span> <span class="nf">bits</span><span class="p">(</span><span class="n">output</span><span class="p">));</span>
<span class="p">}</span>

<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">]);</span>

<span class="c1">// Output:</span>
<span class="c1">// 11111100 00000000 00000000 00000000</span>
<span class="c1">// 00111111 00000000 00000000 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 11111100 00000000 00000000</span>
<span class="c1">// 11000000 00001111 00000000 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 00000000 11111100 00000000</span>
<span class="c1">// 00000000 11110000 00000011 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 00000000 00000000 11111100</span>
<span class="c1">// 00000000 00000000 11111100 00000000</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xuZm4gYml0cyh2YWx1ZTogdTMyKSAtPiBT dHJpbmcge1xuICBsZXQgW2IxLCBiMiwgYjMsIGI0XSA9IHZhbHVlLnJldmVy c2VfYml0cygpLnRvX2xlX2J5dGVzKCk7XG4gIGZvcm1hdCEoXCJ7YjE6MDhi fSB7YjI6MDhifSB7YjM6MDhifSB7YjQ6MDhifVwiKVxufVxuXG5mbiBkZWNv ZGVfcGFjayhpbnB1dDogW3U4OyA0XSkge1xuICBsZXQgbXV0IG91dHB1dCA9 IDB1MzI7XG4gIGZvciBieXRlIGluIGlucHV0IHtcbiAgICBvdXRwdXQgPDw9 IDY7XG4gICAgb3V0cHV0IHw9IGJ5dGUgYXMgdTMyO1xuICB9XG4gIG91dHB1 dCA8PD0gODtcblxuICBwcmludGxuIShcInt9XFxue31cXG5cIiwgYml0cyh1 MzI6OmZyb21fYmVfYnl0ZXMoaW5wdXQpKSwgYml0cyhvdXRwdXQpKTtcbn1c blxuZGVjb2RlX3BhY2soWzBiMTExMTExLCAwLCAwLCAwXSk7XG5kZWNvZGVf cGFjayhbMCwgMGIxMTExMTEsIDAsIDBdKTtcbmRlY29kZV9wYWNrKFswLCAw LCAwYjExMTExMSwgMF0pO1xuZGVjb2RlX3BhY2soWzAsIDAsIDAsIDBiMTEx MTExXSk7XG5cbi8vIE91dHB1dDpcbi8vIDExMTExMTAwIDAwMDAwMDAwIDAw MDAwMDAwIDAwMDAwMDAwXG4vLyAwMDExMTExMSAwMDAwMDAwMCAwMDAwMDAw MCAwMDAwMDAwMFxuLy9cbi8vIDAwMDAwMDAwIDExMTExMTAwIDAwMDAwMDAw IDAwMDAwMDAwXG4vLyAxMTAwMDAwMCAwMDAwMTExMSAwMDAwMDAwMCAwMDAw MDAwMFxuLy9cbi8vIDAwMDAwMDAwIDAwMDAwMDAwIDExMTExMTAwIDAwMDAw MDAwXG4vLyAwMDAwMDAwMCAxMTExMDAwMCAwMDAwMDAxMSAwMDAwMDAwMFxu Ly9cbi8vIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDExMTExMTAwXG4v LyAwMDAwMDAwMCAwMDAwMDAwMCAxMTExMTEwMCAwMDAwMDAwMFxufVxuIiwi Y29tcGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlclZpc2libGUi OmZhbHNlLCJjb21waWxlck91dHB1dFZpc2libGUiOnRydWUsImNvbXBpbGVy Ijp7ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiIifX1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:13">Rust</a></div></div> <p>Bingo. Playing around with the inputs lets us verify which pieces of the bytes wind up where. For example, by passing <code class="language-plaintext highlighter-rouge">0b110000</code> as <code class="language-plaintext highlighter-rouge">input[1]</code>, we see that the two high bits of <code class="language-plaintext highlighter-rouge">input[1]</code> correspond to the low bits of <code class="language-plaintext highlighter-rouge">output[0]</code>. I’ve written the code so that the bits in each byte are printed in little-endian order, so bits on the left are the low bits.</p> <p>Putting this all together, we can draw a schematic of what this operation does to a general <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/riffle.png" alt="the riffling operation"/></p> <p>Now, there’s no single instruction that will do this for us. Shuffles can be used to move bytes around, but we’re dealing with <em>pieces</em> of bytes here. We also can’t really do a shift, since we need bits that are overshifted to move into adjacent lanes.</p> <p>The trick is to just make the lanes bigger.</p> <p>Among the operations available for SIMD vectors are lane-wise casts, which allow us to zero-extend, sign-extend, or truncate each lane. So what we can do is cast <code class="language-plaintext highlighter-rouge">sextets</code> to a vector of <code class="language-plaintext highlighter-rouge">u16</code>, do the shift there and then… somehow put the parts back together?</p> <p>Let’s see how far shifting gets us. How much do we need to shift things by? First, notice that the order of the bits within each chunk that doesn’t cross a byte boundary doesn’t change. For example, the four low bits of <code class="language-plaintext highlighter-rouge">input[1]</code> are in the same order when they become the high bits of <code class="language-plaintext highlighter-rouge">output[1]</code>, and the two high bits of <code class="language-plaintext highlighter-rouge">input[1]</code> are also in the same order when they become the low bits of <code class="language-plaintext highlighter-rouge">output[0]</code>.</p> <p>This means we can determine how far to shift by comparing the bit position of the lowest bit of a byte of <code class="language-plaintext highlighter-rouge">input</code> with the bit position of the corresponding bit in <code class="language-plaintext highlighter-rouge">output</code>.</p> <p><code class="language-plaintext highlighter-rouge">input[0]</code>’s low bit is the third bit of <code class="language-plaintext highlighter-rouge">output[0]</code>, so we need to shift <code class="language-plaintext highlighter-rouge">input[0]</code> by 2. <code class="language-plaintext highlighter-rouge">input[1]</code>’s lowest bit is the fifth bit of <code class="language-plaintext highlighter-rouge">output[1]</code>, so we need to shift by 4. Analogously, the shifts for <code class="language-plaintext highlighter-rouge">input[2]</code> and <code class="language-plaintext highlighter-rouge">input[3]</code> turn out to be 6 and 0. In code:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p>So now we have a <code class="language-plaintext highlighter-rouge">Simd&lt;u16, 4&gt;</code> that contains the individual chunks that we need to move around, in the high and low bytes of each <code class="language-plaintext highlighter-rouge">u16</code>, which we can think of as being analogous to a <code class="language-plaintext highlighter-rouge">[[u8; 2]; 4]</code>. For example, <code class="language-plaintext highlighter-rouge">shifted[0][0]</code> contains <code class="language-plaintext highlighter-rouge">sextet[0]</code>, but shifted. This corresponds to the red segment in the first schematic. The smaller blue segment is given by <code class="language-plaintext highlighter-rouge">shifted[1][1]</code>, i.e., the high byte of the second <code class="language-plaintext highlighter-rouge">u16</code>. It’s already in the right place within that byte, so we want <code class="language-plaintext highlighter-rouge">output[0] = shifted[0][0] | shifted[1][1]</code>.</p> <p>This suggests a more general strategy: we want to take two vectors, the low bytes and the high bytes of each <code class="language-plaintext highlighter-rouge">u16</code> in <code class="language-plaintext highlighter-rouge">shifted</code>, respectively, and somehow shuffle them so that when or’ed together, they give the desired output.</p> <p>Look at the schematic again: if we had a vector consisting of <code class="language-plaintext highlighter-rouge">[..aaaaaa, ....bbbb, ......cc]</code>, we could or it with a vector like <code class="language-plaintext highlighter-rouge">[bb......, cccc...., dddddd..]</code> to get the desired result.</p> <p>One problem: <code class="language-plaintext highlighter-rouge">dddddd..</code> is <code class="language-plaintext highlighter-rouge">shifted[3][0]</code>, i.e., it’s a low byte. If we change the vector we shift by to <code class="language-plaintext highlighter-rouge">[2, 4, 6, 8]</code>, though, it winds up in <code class="language-plaintext highlighter-rouge">shifted[3][1]</code>, since it’s been shifted up by <code class="language-plaintext highlighter-rouge">8</code> bits: a full byte.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Split shifted into low byte and high byte vectors.</span>
<span class="c1">// Same way you'd split a single u16 into bytes, but lane-wise.</span>
<span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">8</span><span class="p">;</span> <span class="mi">4</span><span class="p">]))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Align the lanes: we want to get shifted[0][0] | shifted[1][1],</span>
<span class="c1">// shifted[1][0] | shifted[2][1], etc.</span>
<span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Rust</a></div></div> <p>Et voila, here is our new, totally branchless implementation of <code class="language-plaintext highlighter-rouge">decode_hot()</code>.</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
      <span class="nf">.to_int</span><span class="p">()</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="o">-</span> <span class="nn">Simd</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
      <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span>  <span class="c1">// Note quite right yet, see next section.</span>

  <span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="cm">/* bloom filter shenanigans */</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
  <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Rust</a></div></div> <p>The compactness of this solution should not be understated. The simplicity of this solution is a large part of what makes it so efficient, because it aggressively leverages the primitives the hardware offers us.</p> <h3 id="scaling-up"><a href="#scaling-up">Scaling Up</a></h3> <p>Ok, so now we have to contend with a new aspect of our implementation that’s crap: a <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> is tiny. That’s not even 128 bits, which are the smallest vector registers on x86. What we need to do is make <code class="language-plaintext highlighter-rouge">decode_hot()</code> generic on the lane count. This will allow us to tune the number of lanes to batch together depending on benchmarks later on.</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode_hot</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="k">where</span>
  <span class="c1">// This makes sure N is a small power of 2.</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
      <span class="nf">.to_int</span><span class="p">()</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="o">-</span> <span class="nf">tiled</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
      <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span>  <span class="c1">// Works fine now, as long as N &gt;= 8.</span>

  <span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="cm">/* bloom filter shenanigans */</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nf">tiled</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
  <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Generates a new vector made up of repeated "tiles" of identical</span>
<span class="cd">/// data.</span>
<span class="k">const</span> <span class="k">fn</span> <span class="n">tiled</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">tile</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">N</span><span class="p">];</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="p">{</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">tile</span><span class="nf">.len</span><span class="p">()];</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nn">Simd</span><span class="p">::</span><span class="nf">from_array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Rust</a></div></div> <p>We have to change virtually nothing, which is pretty awesome! But unfortunately, this code is subtly incorrect. Remember how in the <code class="language-plaintext highlighter-rouge">N = 4</code> case, the result of <code class="language-plaintext highlighter-rouge">output</code> had a garbage value that we ignore in its highest lane? Well, now that garbage data is interleaved into output: every fourth lane contains garbage.</p> <p>We can use a shuffle to delete these lanes, thankfully. Specifically, we want <code class="language-plaintext highlighter-rouge">shuffled[i] = output[i + i / 3]</code>, which skips every forth index. So, <code class="language-plaintext highlighter-rouge">shuffled[3] = output[4]</code>, skipping over the garbage value in <code class="language-plaintext highlighter-rouge">output[3]</code>. If <code class="language-plaintext highlighter-rouge">i + i / 3</code> overflows <code class="language-plaintext highlighter-rouge">N</code>, that’s ok, because that’s the high quarter of the final output vector, which is ignored anyways. In code:</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode_hot</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="k">where</span>
  <span class="c1">// This makes sure N is a small power of 2.</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>

  <span class="k">let</span> <span class="n">decoded_chunks</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="nd">swizzle!</span><span class="p">(</span><span class="n">N</span><span class="p">;</span> <span class="n">decoded_chunks</span><span class="p">,</span> <span class="nd">array!</span><span class="p">(</span><span class="n">N</span><span class="p">;</span> <span class="p">|</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Rust</a></div></div> <blockquote> <p><code class="language-plaintext highlighter-rouge">swizzle!()</code> is a helper macro<sup id="fnref:macros" role="doc-noteref"><a href="#fn:macros" class="footnote" rel="footnote">6</a></sup> for generating generic implementations of <code class="language-plaintext highlighter-rouge">std::simd::Swizzle</code>, and <code class="language-plaintext highlighter-rouge">array!()</code> is something I wrote for generating generic-length array constants; the closure is called once for each <code class="language-plaintext highlighter-rouge">i in 0..N</code>.</p> </blockquote> <p>So now we can decode 32 base64 bytes in parallel by calling <code class="language-plaintext highlighter-rouge">decode_hot::&lt;32&gt;()</code>. We’ll try to keep things generic from here, so we can tune the lane parameter based on benchmarks.</p> <h3 id="the-outer-loop"><a href="#the-outer-loop">The Outer Loop</a></h3> <p>Let’s look at <code class="language-plaintext highlighter-rouge">decode()</code> again. Let’s start by making it generic on the internal lane count, too.</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// N-sized chunks now.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dec</span><span class="p">[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Rust</a></div></div> <p>What branches are left? There’s still the branch from <code class="language-plaintext highlighter-rouge">for chunks in ...</code>. It’s not ideal because it can’t do an exact pointer comparison, and needs to do a <code class="language-plaintext highlighter-rouge">&gt;=</code> comparison on a length instead.</p> <p>We call <code class="language-plaintext highlighter-rouge">[T]::copy_from_slice</code>, which is super slow because it needs to make a variable-length <code class="language-plaintext highlighter-rouge">memcpy</code> call, which can’t be inlined. Function calls are branches! The bounds checks are also a problem.</p> <p>We branch on <code class="language-plaintext highlighter-rouge">ok</code> every loop iteration, still. Not returning early in <code class="language-plaintext highlighter-rouge">decode_hot</code> doesn’t win us anything (yet).</p> <p>We potentially call the allocator in <code class="language-plaintext highlighter-rouge">extend_from_slice</code>, and perform another non-inline-able <code class="language-plaintext highlighter-rouge">memcpy</code> call.</p> <h3 id="preallocating-with-slop"><a href="#preallocating-with-slop">Preallocating with Slop</a></h3> <p>The last of these is the easiest to address: we can reserve space in <code class="language-plaintext highlighter-rouge">out</code>, since we know exactly how much data we need to write thanks to <code class="language-plaintext highlighter-rouge">decoded_len</code>. Better yet, we can reserve some “slop”: i.e., scratch space past where the end of the message would be, so we can perform full SIMD stores, instead of the variable-length memcpy.</p> <p>This way, in each iteration, we write the full SIMD vector, including any garbage bytes in the upper quarter. Then, the next write is offset <code class="language-plaintext highlighter-rouge">3/4 * N</code> bytes over, so it overwrites the garbage bytes with decoded message bytes. The garbage bytes from the final right get “deleted” by not being included in the final <code class="language-plaintext highlighter-rouge">Vec::set_len()</code> that “commits” the memory we wrote to.</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">let</span> <span class="n">final_len</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="n">out</span><span class="nf">.reserve</span><span class="p">(</span><span class="n">final_len</span> <span class="o">+</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// Reserve with slop.</span>

  <span class="c1">// Get a raw pointer to where we should start writing.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">out</span><span class="nf">.as_mut_ptr_range</span><span class="p">()</span><span class="nf">.end</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// N-sized chunks now.</span>
    <span class="cm">/* snip */</span>

    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// Do a raw write and advance the pointer.</span>
      <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">dec</span><span class="p">);</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">decoded</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="c1">// Update the vector's final length.</span>
    <span class="c1">// This is the final "commit".</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">out</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">Rust</a></div></div> <p>This is safe, because we’ve pre-allocated exactly the amount of memory we need, and where <code class="language-plaintext highlighter-rouge">ptr</code> lands is equal to the amount of memory actually decoded. We could also compute the final length of <code class="language-plaintext highlighter-rouge">out</code> ahead of time.</p> <p>Note that if we early return due to <code class="language-plaintext highlighter-rouge">if !ok</code>, <code class="language-plaintext highlighter-rouge">out</code> remains unmodified, because even though we did write to its buffer, we never execute the “commit” part, so the code remains correct.</p> <h3 id="delaying-failure"><a href="#delaying-failure">Delaying Failure</a></h3> <p>Next up, we can eliminate the <code class="language-plaintext highlighter-rouge">if !ok</code> branches by waiting to return an error until as late as possible: just before the <code class="language-plaintext highlighter-rouge">set_len</code> call.</p> <p>Remember our observation from before: most base64 encoded blobs are valid, so this unhappy path should be very rare. Also, syntax errors cannot cause code that follows to misbehave arbitrarily, so letting it go wild doesn’t hurt anything.</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">error</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="n">error</span> <span class="p">|</span><span class="o">=</span> <span class="o">!</span><span class="n">ok</span><span class="p">;</span>

    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">out</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">Rust</a></div></div> <p>The branch is still “there”, sure, but it’s out of the hot loop.</p> <p>Because we never hit the <code class="language-plaintext highlighter-rouge">set_len</code> call and commit whatever garbage we wrote, said garbage essentially disappears when we return early, to be overwritten by future calls to <code class="language-plaintext highlighter-rouge">Vec::push()</code>.</p> <h3 id="unroll-it-harder"><a href="#unroll-it-harder">Unroll It Harder</a></h3> <p>Ok, let’s look at the memcpy from <code class="language-plaintext highlighter-rouge">copy_from_slice</code> at the start of the hot loop. The loop has already been partly unrolled: it does <code class="language-plaintext highlighter-rouge">N</code> iterations with SIMD each step, doing something funny on the last step to make up for the missing data (padding with <code class="language-plaintext highlighter-rouge">A</code>).</p> <p>We can take this a step further by doing an “unroll and jam” optimization. This type of unrolling splits the loop into two parts: a hot vectorized loop and a cold remainder part. The hot loop <em>always</em> handles length <code class="language-plaintext highlighter-rouge">N</code> input, and the remainder runs at most once and handles <code class="language-plaintext highlighter-rouge">i &lt; N</code> input.</p> <p>Rust provides an iterator adapter for hand-rolled (lol) unroll-and-jam: <code class="language-plaintext highlighter-rouge">Iterator::chunks_exact()</code>.</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">error</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">chunks</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.chunks_exact</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">chunks</span> <span class="p">{</span>
    <span class="c1">// Simd::from_slice() can do a load in one instruction.</span>
    <span class="c1">// The bounds check is easy for the compiler to elide.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>
    <span class="n">error</span> <span class="p">|</span><span class="o">=</span> <span class="o">!</span><span class="n">ok</span><span class="p">;</span>
    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">chunks</span><span class="nf">.remainder</span><span class="p">();</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="cm">/* snip */</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">Rust</a></div></div> <p>Splitting into two parts lets us call <code class="language-plaintext highlighter-rouge">Simd::from_slice()</code>, which performs a single, vector-sized load.</p> <h2 id="so-how-fast-is-it"><a href="#so-how-fast-is-it">So, How Fast Is It?</a></h2> <p>At this point, it looks like we’ve addressed every branch that we can, so some benchmarks are in order. I wrote a benchmark that decodes messages of every length from 0 to something like 200 or 500 bytes, and compared it against the baseline base64 implementation on crates.io.</p> <p>I compiled with <code class="language-plaintext highlighter-rouge">-Zbuild-std</code> and <code class="language-plaintext highlighter-rouge">-Ctarget-cpu=native</code> to try to get the best results. Based on some tuning, <code class="language-plaintext highlighter-rouge">N = 32</code> was the best length, since it used one YMM register for each iteration of the hot loop.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph-old.png" alt="a performance graph; our code is really good compared to the baseline, but variance is high"/></p> <p>So, we have the baseline beat. But what’s up with that crazy heartbeat waveform? You can tell it has something to do with the “remainder” part of the loop, since it correlates strongly with <code class="language-plaintext highlighter-rouge">data.len() % 32</code>.</p> <p>I stared at the assembly for a while. I don’t remember what was there, but I think that <code class="language-plaintext highlighter-rouge">copy_from_slice</code> had been inlined and unrolled into a loop that loaded each byte at a time. The moral equivalent of this:</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="nn">Iterator</span><span class="p">::</span><span class="nf">zip</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">ascii</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">Rust</a></div></div> <p>I decided to try <code class="language-plaintext highlighter-rouge">Simd::gather_or()</code>, which is kind of like a “vectorized load”. It wound up producing worse assembly, so I gave up on using a gather and instead wrote a carefully optimized loading function by hand.</p> <h3 id="unroll-and-jam-revisited"><a href="#unroll-and-jam-revisited">Unroll and Jam, Revisited</a></h3> <p>The idea here is to perform the largest scalar loads Rust offers where possible. The strategy is again unroll and jam: perform <code class="language-plaintext highlighter-rouge">u128</code> loads in a loop and deal with the remainder separately.</p> <p>The hot part looks like this:</p> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>

<span class="c1">// Load a bunch of big 16-byte chunks. LLVM will lower these to XMM loads.</span>
<span class="k">let</span> <span class="n">ascii_ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">write_at</span> <span class="o">=</span> <span class="n">ascii_ptr</span><span class="p">;</span>
<span class="k">if</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">16</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">/</span> <span class="mi">16</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">write_at</span> <span class="o">=</span> <span class="n">write_at</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">word</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="nf">.read_unaligned</span><span class="p">();</span>
      <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">Rust</a></div></div> <p>The cold part seems hard to optimize at first. What’s the least number of unaligned loads you need to do to load 15 bytes from memory? It’s two! You can load a <code class="language-plaintext highlighter-rouge">u64</code> from <code class="language-plaintext highlighter-rouge">p</code>, and then another one from <code class="language-plaintext highlighter-rouge">p + 7</code>; these loads (call them <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>) overlap by one byte, but we can or them together to merge that byte, so our loaded value is <code class="language-plaintext highlighter-rouge">a as u128 | (b as u128 &lt;&lt; 56)</code>.</p> <p>A similar trick works if the data to load is between a <code class="language-plaintext highlighter-rouge">u32</code> and a <code class="language-plaintext highlighter-rouge">u64</code>. Finally, to load 1, 2, or 3 bytes, we can load <code class="language-plaintext highlighter-rouge">p</code>, <code class="language-plaintext highlighter-rouge">p + len/2</code> and <code class="language-plaintext highlighter-rouge">p + len-1</code>; depending on whether <code class="language-plaintext highlighter-rouge">len</code> is 1, 2, or 3, this will potentially load the same byte multiple times; however, this reduces the number of branches necessary, since we don’t need to distinguish the 1, 2, or 3 lines.</p> <p>This is the kind of code that’s probably easier to read than to explain.</p> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.offset</span><span class="p">(</span><span class="n">write_at</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">ascii_ptr</span><span class="p">));</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>

  <span class="k">if</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">8</span> <span class="p">{</span>
    <span class="c1">// Load two overlapping u64s.</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u128</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">16</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="c1">// Load two overlapping u32s.</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u64</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">8</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Load 3 overlapping u8s.</span>

    <span class="c1">// For len       1       2       3     ...</span>
    <span class="c1">// ... this is  ptr[0]  ptr[0]  ptr[0]</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="c1">// ... this is  ptr[0]  ptr[1]  ptr[1]</span>
    <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="c1">// ... this is  ptr[0]  ptr[1]  ptr[2]</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="p">|</span> <span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u32</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:25">Rust</a></div></div> <p>I learned this type of loading code while contributing to Abseil: it’s very useful for loading variable-length data for data-hungry algorithms, like a codec or a hash function.</p> <p>Here’s the same benchmark again, but with our new loading code.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph.png" alt="a performance graph; our code is even better and the variance is very tight"/></p> <p>The results are really, really good. The variance is super tight, and our performance is 2x that of the baseline pretty much everywhere. <em>Success.</em></p> <h3 id="encoding-web-safe"><a href="#encoding-web-safe">Encoding? Web-Safe?</a></h3> <p>Writing an encoding function is simple enough: first, implement an <code class="language-plaintext highlighter-rouge">encode_hot()</code> function that reverses the operations from <code class="language-plaintext highlighter-rouge">decode_hot()</code>. The perfect hash from before won’t work, so you’ll need to <a href="https://github.com/mcy/vb64/blob/main/src/simd.rs#L170">invent a new one</a>.</p> <p>Also, the loading/storing code around the encoder is slightly different, too. <code class="language-plaintext highlighter-rouge">vb64</code> implements a very efficient encoding routine too, so I suggest taking a look at the source code if you’re interested.</p> <p>There is a base64 variant called web-safe base64, that replaces the <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">/</code> characters with <code class="language-plaintext highlighter-rouge">-</code> and <code class="language-plaintext highlighter-rouge">_</code>. Building a perfect hash for these is trickier: you would probably have to do something like <code class="language-plaintext highlighter-rouge">(byte &gt;&gt; 4) - (byte == '_' ? '_' : 0)</code>. I don’t support web-safe base64 yet, but only because I haven’t gotten around to it.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>My library doesn’t really solve an important problem; base64 decoding isn’t a bottleneck… anywhere that I know of, really. But writing SIMD code is really fun! Writing branchless code is often overkill but can give you a good appreciation for what your compilers can and <em>can’t</em> do for you.</p> <p>This project was also an excuse to try <code class="language-plaintext highlighter-rouge">std::simd</code>. I think it’s great overall, and generates excellent code. There’s some rough edges I’d like to see fixed to make SIMD code even simpler, but overall I’m very happy with the work that’s been done there.</p> <p>This is probably one of the most complicated posts I’ve written in a long time. SIMD (and performance in general) is a complex topic that requires a breadth of knowledge of tricks and hardware, a lot of which isn’t written down. More of it is written down now, though.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:shifts-are-arithmetic" role="doc-endnote"> <p>Shifts are better understood as arithmetic. They have a lane width, and closely approximate multiplication and division. AVX2 doesn’t even have vector shift <em>or</em> vector division: you emulate it with multiplication. <a href="#fnref:shifts-are-arithmetic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:minus-true" role="doc-endnote"> <p>The two common representations of <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code>, i.e. <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">0xff...</code> and <code class="language-plaintext highlighter-rouge">0</code>, are related by the two’s complement operation.</p> <p>For example, if I write <code class="language-plaintext highlighter-rouge">uint32_t m = -(a == b);</code>, <code class="language-plaintext highlighter-rouge">m</code> will be zero if <code class="language-plaintext highlighter-rouge">a == b</code> is false, and all-ones otherwise. This because applying any arithmetic operation to a <code class="language-plaintext highlighter-rouge">bool</code> promotes it to <code class="language-plaintext highlighter-rouge">int</code>, so <code class="language-plaintext highlighter-rouge">false</code> maps to <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">true</code> maps to <code class="language-plaintext highlighter-rouge">1</code>. Applying the <code class="language-plaintext highlighter-rouge">-</code> sends <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">-1</code>, and it’s useful to know that in two’s complement, <code class="language-plaintext highlighter-rouge">-1</code> is represented as all-ones.</p> <p>The all-ones representation for <code class="language-plaintext highlighter-rouge">true</code> is useful, because it can be used to implement branchless select very easily. For example,</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">select_if_eq</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">C++</a></div></div> <p>This function returns <code class="language-plaintext highlighter-rouge">x</code> if <code class="language-plaintext highlighter-rouge">a == b</code>, and <code class="language-plaintext highlighter-rouge">y</code> otherwise. Can you tell why? <a href="#fnref:minus-true" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:abi" role="doc-endnote"> <p>Target features also affect ABI in subtle ways that I could write many, many more words on. Compiling libraries you plan to distribute with weird target feature flags is a recipe for disaster. <a href="#fnref:abi" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:why-cant-llvm-do-it" role="doc-endnote"> <p>Why can’t we leave this kind of thing to LLVM? Finding this particular branchless implementation is tricky. LLVM is smart enough to fold the match into a switch table, but that’s unnecessary memory traffic to look at the table. (In this domain, unnecessary memory traffic makes our code slower.)</p> <p>Incidentally, with the code I wrote for the original <code class="language-plaintext highlighter-rouge">decoded_len()</code>, LLVM produces a jump <em>and</em> a lookup table, which is definitely an odd choice? I went down something of a rabbit-hole. https://github.com/rust-lang/rust/issues/118306</p> <p>As for getting LLVM to find the “branchless” version of the lookup table? The search space is quite large, and this kind of “general strength reduction” problem is fairly open (keywords: “superoptimizers”). <a href="#fnref:why-cant-llvm-do-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:pad-with-A" role="doc-endnote"> <p>To be clear on why this works: suppose that in our reference implementation, we only handle inputs that are a multiple-of-4 length, and are padded with <code class="language-plaintext highlighter-rouge">=</code> as necessary, and we treat <code class="language-plaintext highlighter-rouge">=</code> as zero in the <code class="language-plaintext highlighter-rouge">match</code>. Then, for the purposes of computing the <code class="language-plaintext highlighter-rouge">bytes</code> value (before appending it to <code class="language-plaintext highlighter-rouge">out</code>), we can assume the chunk length is always 4. <a href="#fnref:pad-with-A" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:macros" role="doc-endnote"> <p>See <a href="https://github.com/mcy/vb64/blob/ed75566393a25d174a2766c3f8947d9c6a506315/src/util.rs"><code class="language-plaintext highlighter-rouge">vb64/src/util.rs</code></a>. <a href="#fnref:macros" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-09-29 • 2871 words • 31 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#math">#math</a> </span> <h1><a href="/2023/09/29/what-is-a-matrix/"> What is a Matrix? A Miserable Pile of Coefficients! </a></h1> </div> <div class="post"> <p>Linear algebra is undoubtedly the most useful field in all of algebra. It finds applications in all kinds of science and engineering, like quantum mechanics, graphics programming, and machine learning. It is the “most well-behaved” algebraic theory, in that other abstract algebra topics often try to approximate linear algebra, when possible.</p> <p>For many students, linear algebra means vectors and matrices and determinants, and complex formulas for computing them. Matrices, in particular, come equipped with a fairly complicated, and <em>a fortiori</em> convoluted, multiplication operation.</p> <p>This is not the only way to teach linear algebra, of course. Matrices and their multiplication appear complicated, but actually are a natural and compact way to represent a particular type of <em>function</em>, i.e., a linear map (or linear transformation).</p> <p>This article is a short introduction to viewing linear algebra from the perspective of abstract algebra, from which matrices arise as a computational tool, rather than an object of study in and of themselves. I do assume some degree of familiarity with the idea of a matrix.</p> <h2 id="linear-spaces"><a href="#linear-spaces">Linear Spaces</a></h2> <p>Most linear algebra courses open with a description of vectors in Euclidean space: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>. Vectors there are defined as tuples of real numbers that can be added, multiplied, and scaled. Two vectors can be combined into a number through the dot product. Vectors come equipped with a notion of magnitude and direction.</p> <p>However, this highly geometric picture can be counterproductive, since it is hard to apply geometric intuition directly to higher dimensions. It also obscures how this connects to working over a different number system, like the complex numbers.</p> <p>Instead, I’d like to open with the concept of a <em>linear space</em>, which is somewhat more abstract than a vector space<sup id="fnref:vs-in-generality" role="doc-noteref"><a href="#fn:vs-in-generality" class="footnote" rel="footnote">1</a></sup>.</p> <p>First, we will need a notion of a “coefficient”, which is essentially something that you can do arithmetic with. We will draw coefficients from a designated <em>ground field</em> <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>. A field is a setting for doing arithmetic: a set of objects that can be added, subtracted, and multiplied, and divided in the “usual fashion” along with special <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span> values. E.g. <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + 0 = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>a</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">1a = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>b</mi><mo>+</mo><mi>a</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">a(b + c) = ab + ac</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span></span></span></span></span>, and so on.</p> <p>Not only are the real numbers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> a field, but so are the complex numbers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span></span>, and the rational numbers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">Q</span></span></span></span></span>. If we drop the “division” requirement, we can also include the integers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span></span>, or polynomials with rational coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Q[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span>, for example.</p> <p>Having chosen our coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>, a linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> <em>over</em> <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> is another set of objects that can be added and subtracted (and including a special value <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span>)<sup id="fnref:ab-group" role="doc-noteref"><a href="#fn:ab-group" class="footnote" rel="footnote">2</a></sup>, along with a <em>scaling operation</em>, which takes a coefficient <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> and one of our objects <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> and produces a new <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">cv \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <p>The important part of the scaling operation is that it’s compatible with addition: if we have <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">a, b \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v, w \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we require that</p> <div class="codeblock" id="code:1"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>v</mi><mo>+</mo><mi>a</mi><mi>w</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mi>v</mi><mo>=</mo><mi>a</mi><mi>v</mi><mo>+</mo><mi>b</mi><mi>v</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}a (v + w) = av + aw \\ (a + b) v = av + bv\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Math</a></div></div> <p>This is what makes a linear space “linear”: you can write equations that look like first-degree polynomials (e.g. <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">ax + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span>), and which can be <em>manipulated like first-degree polynomials</em>.</p> <p>These polynomials are called linear because their graph looks like a line. There’s no multiplication, so we can’t have <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>, but we do have multiplication by a coefficient. This is what makes linear algebra is “linear”.</p> <p>Some examples: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>-tuples of elements drawn from any field are a linear space over that field, by componentwise addition and scalar multiplication; e.g., <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">R^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>. Setting <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span> shows that every field is a linear space over itself.</p> <p>Polynomials in one variable over some field, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span>, are also a linear space, since polynomials can be added together and scaled by a any value in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> (since lone coefficients are degree zero polynomials). Real-valued functions also form a linear space over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> in a similar way.</p> <h3 id="linear-transformations"><a href="#linear-transformations">Linear Transformations</a></h3> <p>A linear map is a function <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> between two linear spaces <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> which “respects” the linear structure in a particular way. That is, for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c\in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v, w \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>,</p> <div class="codeblock" id="code:2"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>⋅</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}f(v + w) = f(v) + f(w) \\ f(cv) = c \cdot f(v)\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Math</a></div></div> <p>We call this type of relationship (respecting addition and scaling) “linearity”. One way to think of this relationship is that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> is kind of like a different kind of coefficient, in that it distributes over addition, which commutes with the “ordinary” coefficients from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>. However, applying <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> produces a value from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> rather than <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <p>Another way to think of it is that if we have a linear polynomial like <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">p(x) = ax + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span> in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, then <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(p(x)) = p(f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></span>. We say that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> <em>commutes</em> with all linear polynomials.</p> <p>The most obvious sort of linear map is scaling. Given any coefficient <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>, it defines a “scaling map”:</p> <div class="codeblock" id="code:3"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>μ</mi><mi>c</mi></msub><mo>:</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>v</mi><mo>↦</mo><mi>c</mi><mi>v</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}\mu_c: V \to V \\ v \mapsto cv\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Math</a></div></div> <p>It’s trivial to check this is a linear map, by plugging it into the above equations: it’s linear because scaling is distributive and commutative.</p> <p>Linear maps are the essential thing we study in linear algebra, since they describe all the different kinds of relationships between linear spaces.</p> <p>Some linear maps are complicated. For example, a function from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup><mo>→</mo><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\R^2 \to \R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> that rotates the plane by some angle <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span> is linear, as are operations that stretch or shear the plane. However, they can’t “bend” or “fold” the plane: they are all fairly rigid motions. In the linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Q[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span> of rational polynomials, multiplication by <em>any</em> polynomial, such as <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> or <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^2 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>, is a linear map. The notion of “linear map” depends heavily on the space we’re in.</p> <p>Unfortunately, linear maps as they are quite opaque, and do not lend themselves well to calculation. However, we can build an explicit representation using a <em>linear basis</em>.</p> <h2 id="linear-basis"><a href="#linear-basis">Linear Basis</a></h2> <p>For any linear space, we can construct a relatively small of elements such that any element of the space can be expressed as some linear function of these elements.</p> <p>Explicitly, for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we can construct a sequence<sup id="fnref:indices" role="doc-noteref"><a href="#fn:indices" class="footnote" rel="footnote">3</a></sup> <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> such that for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we can find <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c_i \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> such that</p> <div class="codeblock" id="code:4"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">v = \sum_i c_i e_i.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Math</a></div></div> <p>Such a set <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is called a <em>basis</em> if it is linearly independent: no one <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> can be expressed as a linear function of the rest. The <em>dimension</em> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, denoted <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\dim V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, is the number of elements in any choice of basis. This value does not depend on the choice of basis<sup id="fnref:invariant-dim" role="doc-noteref"><a href="#fn:invariant-dim" class="footnote" rel="footnote">4</a></sup>.</p> <p>Constructing a basis for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> is easy: we can do this recursively. First, pick a random element <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, and define a new linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> where we have identified all elements that differ by a factor of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> as equal (i.e., if <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>−</mo><mi>w</mi><mo>=</mo><mi>c</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v - w = ce_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, we treat <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></span> as equal in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>).</p> <p>Then, a basis for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> is a basis of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> with <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> added. The construction of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is essentially “collapsing” the dimension <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> “points” in, giving us a new space where we’ve “deleted” all of the elements that have a nonzero <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> component.</p> <p>However, this only works when the dimension is finite; more complex methods must be used for infinite-dimensional spaces. For example, the polynomials <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Q[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span> are an infinite-dimensional space, with basis elements <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace linebreak="newline"></mspace><mrow><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mn>2</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>3</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\\{1, x, x^2, x^3, ...\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">…</span><span class="mspace newline"></span></span></span></span></span></span>. In general, for any linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, it <em>is</em> always possible to arbitrarily choose a basis, although it may be infinite<sup id="fnref:rq" role="doc-noteref"><a href="#fn:rq" class="footnote" rel="footnote">5</a></sup>.</p> <p>Bases are useful because they give us a concrete representation of any element of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>. Given a fixed basis <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, we can represent any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w = \sum_i c_i e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> by the coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> themselves. For a finite-dimensional <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, this brings us back <em>column vectors</em>: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>dim</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\dim V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></span>-tuples of coefficients from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> that are added and scaled componentwise.</p> <div class="codeblock" id="code:5"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>0</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mtext> </mtext><mo><munder><mo><mo>:</mo><mo>=</mo></mo><mrow><mtext>given </mtext><msub><mi>e</mi><mi>i</mi></msub></mrow></munder></mo><mtext> </mtext><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Mat{c_0 \\ c_1 \\ \vdots \\ c_n} \,\underset{\text{given } e_i}{:=}\, \sum_i c_i e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3665em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">given </span></span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">:=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8696em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Math</a></div></div> <p>The <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>th basis element is represented as the vector whose entries are all <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> except for the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>th one, which is <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>. E.g.,</p> <div class="codeblock" id="code:6"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mtext> </mtext><mo><munder><mo><mo>=</mo></mo><mrow><mtext>given </mtext><msub><mi>e</mi><mi>i</mi></msub></mrow></munder></mo><mtext> </mtext><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mtext> </mtext><mo><munder><mo><mo>=</mo></mo><mrow><mtext>given </mtext><msub><mi>e</mi><mi>i</mi></msub></mrow></munder></mo><mtext> </mtext><msub><mi>e</mi><mn>2</mn></msub><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Mat{1 \\ 0 \\ \vdots \\ 0} \,\underset{\text{given } e_i}{=}\, e_1, \,\,\, \Mat{0 \\ 1 \\ \vdots \\ 0} \,\underset{\text{given } e_i}{=}\, e_2, \,\,\, ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3665em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">given </span></span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8696em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3665em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">given </span></span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8696em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Math</a></div></div> <p>It is important to recall that the choice of basis is <em>arbitrary</em>. From the mathematical perspective, any basis is just as good as any other, although some may be more computationally convenient.</p> <p>Over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> are sometimes called the “standard basis”, but <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mo>−</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3, -4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> are also a basis for this space. One easy mistake to make, particularly when working over the tuple space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">K^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>, is to confuse the actual elements of the linear space with the coefficient vectors that represent them. Working with abstract linear spaces eliminates this source of confusion.</p> <h3 id="representing-linear-transformations"><a href="#representing-linear-transformations">Representing Linear Transformations</a></h3> <p>Working with finite-dimensional linear spaces <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span>, let’s choose bases <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> for them, and let’s consider a linear map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span>.</p> <p>The powerful thing about bases is that we can more compactly express the information content of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>. Given any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we can decompose it into a linear function of the basis (for some coefficients), so we can write</p> <div class="codeblock" id="code:7"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mi>f</mi><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><mo>⋅</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v) = f\left(\sum_i c_i e_i\right) = \sum_i f(c_i e_i) = \sum_i c_i \cdot f(e_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0277em;vertical-align:-1.2777em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Math</a></div></div> <p>In other words, to specify <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>, we <em>only</em> need to specify what it does to each of the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\dim V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> basis elements. But what’s more, because <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> also has a basis, we can write</p> <div class="codeblock" id="code:8"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">f(e_i) = \sum_j A_{ij} d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4638em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Math</a></div></div> <p>Putting these two formulas together, we have an explicit closed form for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>, given the coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>, and the coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>:</p> <div class="codeblock" id="code:9"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">f(v) = \sum_{i,j} c_i A_{ij} d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4638em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Math</a></div></div> <p>Alternatively, we can express <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> as column vectors, and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> as the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> matrix with entires <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>. The entries of the resulting column vector are given by the above explicit formula for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>, fixing the value of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span> in each entry.</p> <div class="codeblock" id="code:10"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><munder><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mi>n</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mi>n</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>0</mn><mo separator="true">,</mo><mi>m</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>m</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo stretchy="true">⏟</mo></munder><mi>A</mi></munder><mtext> </mtext><munder><munder><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>0</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo stretchy="true">⏟</mo></munder><mi>v</mi></munder><mo>=</mo><munder><munder><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo stretchy="true">⏟</mo></munder><mrow><mi>A</mi><mi>v</mi></mrow></munder></mrow><annotation encoding="application/x-tex">\underbrace{\Mat{ A_{0,0} &amp; A_{1,0} &amp; \cdots &amp; A_{n,0} \\ A_{1,0} &amp; A_{1,1} &amp; \cdots &amp; A_{n,1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ A_{0,m} &amp; A_{1,m} &amp; \cdots &amp; A_{n,m} }}_A \, \underbrace{\Mat{c_0 \\ c_1 \\ \vdots \\ c_n}}_v = \underbrace{\Mat{ \sum_i c_i A_{i,0} \\ \sum_i c_i A_{i,1} \\ \vdots \\ \sum_i c_i A_{i,m} }}_{Av}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.7863em;vertical-align:-3.8063em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-1.1737em;"><span class="pstrut" style="height:4.98em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span class="svg-align" style="top:-1.852em;"><span class="pstrut" style="height:4.98em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7 -331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214 c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0 -5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237 -174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.38em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.128em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.8063em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-1.3506em;"><span class="pstrut" style="height:4.98em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span class="svg-align" style="top:-1.852em;"><span class="pstrut" style="height:4.98em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7 -331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214 c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0 -5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237 -174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.128em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.6294em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:6.7863em;vertical-align:-3.8063em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-1.1737em;"><span class="pstrut" style="height:4.98em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span class="svg-align" style="top:-1.852em;"><span class="pstrut" style="height:4.98em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7 -331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214 c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0 -5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237 -174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.128em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.8063em;"><span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Math</a></div></div> <p>(Remember, this is all dependent on the choices of bases <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>!)</p> <p>Behold, we have derived the matrix-vector multiplication formula: the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>th entry of the result is the dot product of the vector and the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>th row of the matrix.</p> <p>But it is crucial to keep in mind that we had to choose bases <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> to be entitled to write down a matrix for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>. The values of the coefficients depend on the choice of basis.</p> <p>If your linear space happens to be <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>, there is an “obvious” choice of basis, but not every linear space over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> is <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>! Importantly, the actual linear algebra <em>does not</em> change depending on the basis<sup id="fnref:similar" role="doc-noteref"><a href="#fn:similar" class="footnote" rel="footnote">6</a></sup>.</p> <h2 id="matrix-multiplication"><a href="#matrix-multiplication">Matrix Multiplication</a></h2> <p>So, where does matrix multiplication come from? An <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span><sup id="fnref:rc" role="doc-noteref"><a href="#fn:rc" class="footnote" rel="footnote">7</a></sup> matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> <em>represents</em> some linear map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span>, where <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\dim V = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>W</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\dim W = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>, and appropriate choices of basis (<span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>) have been made.</p> <p>Keeping in mind that linear maps are supreme over matrices, suppose we have a third linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span>, and a map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">g: U \to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, and let <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>=</mo><mi>dim</mi><mo>⁡</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\ell = \dim U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span>. Choosing a basis <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">h_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span>, we can represent <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span> as a matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> of dimension <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\ell \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>.</p> <p>Then, we’d like for the matrix product <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> to be the same matrix we’d get from representing the composite map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">fg: U \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> as a matrix, using the aforementioned choices of bases for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> (the basis choice for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> should “cancel out”).</p> <p>Recall our formula for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> in terms of its matrix coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> and the coefficients of the input <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>, which we call <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>. We can produce a similar formula for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span></span>, giving it matrix coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, and coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span>. (I appologize for the number of indices and coefficients here.)</p> <div class="codeblock" id="code:11"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></munder><msub><mi>b</mi><mi>k</mi></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub><msub><mi>e</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}f(v) &amp;= \sum_{i,j} c_i A_{ij} d_j \\ g(u) &amp;= \sum_{k,i} b_k B_{ki} e_i\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.552em;vertical-align:-2.526em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.026em;"><span style="top:-5.026em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span><span style="top:-2.2622em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.526em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.026em;"><span style="top:-5.026em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.2622em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.526em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Math</a></div></div> <p>If we write <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(u))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">))</span></span></span></span></span>, then <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is the coefficient <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is multiplied by; i.e., we fix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>, and drop it from the summation: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mi>k</mi></msub><msub><mi>b</mi><mi>k</mi></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_i = \sum_k b_k B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>.</p> <p>Substituting that into the above formula, we now have something like the following.</p> <div class="codeblock" id="code:12"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><munder><mo>∑</mo><mi>k</mi></munder><msub><mi>b</mi><mi>k</mi></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><msub><mi>b</mi><mi>k</mi></msub><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub><mo fence="true">)</mo></mrow><msub><mi>d</mi><mi>j</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}f(g(u)) &amp;= \sum_{i,j} \sum_{k} b_k B_{ki} A_{ij} d_j \\ f(g(u)) &amp;= \sum_{k,j} b_k \left(\sum_{i} A_{ij} B_{ki} \right) d_j &amp;(\star)\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.252em;vertical-align:-2.876em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.376em;"><span style="top:-6.076em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">))</span></span></span><span style="top:-2.6122em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">))</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.876em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.376em;"><span style="top:-6.076em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.6122em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.876em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6122em;"><span style="top:-2.6122em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">⋆</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.876em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Math</a></div></div> <p>In <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\star)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">⋆</span><span class="mclose">)</span></span></span></span></span>, we’ve rearranged things so that the sum in parenthesis is the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span>th matrix coefficient of the composite <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">fg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span>. Because we wanted <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> to represent <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">fg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span>, it must be an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\ell \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> matrix whose entries are</p> <div class="codeblock" id="code:13"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>B</mi><msub><mo stretchy="false">)</mo><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(AB)_{kj} = \sum_{i} A_{ij} B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Math</a></div></div> <p><em>This</em> is matrix multiplication. It arises naturally out of composition of linear maps. In this way, the matrix multiplication formula is not a definition, but a <em>theorem</em> of linear algebra!</p> <blockquote id="thm:matrix-multiplication" class="thm"> <p><a href="#thm:matrix-multiplication"><span class="chip">theorem</span><span class="title">Matrix Multiplication</span></a></p> <p>Given an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\ell \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>, both with coefficients in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>, then <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> is an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\ell \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> matrix with entires</p> <div class="codeblock" id="code:14"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>B</mi><msub><mo stretchy="false">)</mo><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex"> (AB)_{kj} = \sum_{i} A_{ij} B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Math</a></div></div> </blockquote> <p>If the matrix dimension is read as <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \to m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> instead of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>, the shape requirements are more obvious: two matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> can be multiplied together only when they represent a pair of maps <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U \to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <h3 id="other-consequences-and-conclusion"><a href="#other-consequences-and-conclusion">Other Consequences, and Conclusion</a></h3> <p>The identity matrix is an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> matrix:</p> <div class="codeblock" id="code:15"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">I_n = \Mat{ 1 \\ &amp; 1 \\ &amp;&amp; \ddots \\ &amp;&amp;&amp; 1 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.95em;"><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Math</a></div></div> <p>We want it to be such that for any appropriately-sized matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>, it has <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mi>I</mi><mi>n</mi></msub><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">AI_n = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub><mi>B</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">I_n B = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>. Lifted up to linear maps, this means that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> should represent the identity map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">V \to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, when <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\dim V = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>. This map sends each basis element <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> to itself, so the columns of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> should be the basis vectors, in order:</p> <div class="codeblock" id="code:16"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>⋯</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\Mat{1 \\ 0 \\ \vdots \\ 0} \Mat{0 \\ 1 \\ \vdots \\ 0} \cdots \Mat{0 \\ 0 \\ \vdots \\ 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Math</a></div></div> <p>If we shuffle the columns, we’ll get a <em>permutation matrix</em>, which shuffles the coefficients of a column vector. For example, consider this matrix.</p> <div class="codeblock" id="code:17"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\Mat{ 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Math</a></div></div> <p>This is similar to the identity, but we’ve swapped the first two columns. Thus, it will swap the first two coefficients of any column vector.</p> <p>Matrices may seem unintuitive when they’re introduced as a subject of study. Every student encountering matrices for the same time may ask “If they add componentwise, why don’t they multiply componentwise too?”</p> <p>However, approaching matrices as a computational and representational tool shows that the convoluted-looking matrix multiplication formula is a direct consequence of linearity.</p> <div class="codeblock" id="code:18"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>⋅</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}f(v + w) = f(v) + f(w) \\ f(cv) = c \cdot f(v)\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Math</a></div></div> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:vs-in-generality" role="doc-endnote"> <p>In actual modern mathematics, the objects I describe are still called vector spaces, which I think generates unnecessary confusion in this case. “Linear space” is a bit more on the nose for what I’m going for. <a href="#fnref:vs-in-generality" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ab-group" role="doc-endnote"> <p>This type of structure (just the addition part) is also called an “abelian group”. <a href="#fnref:ab-group" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:indices" role="doc-endnote"> <p>Throughout <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>, and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> are indices in some unspecified but ordered indexing set, usually <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, ..., n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">…</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span></span>. I will not bother giving this index set a name. <a href="#fnref:indices" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:invariant-dim" role="doc-endnote"> <p>This is sometimes called the <a href="https://en.wikipedia.org/wiki/Dimension_theorem_for_vector_spaces"><em>dimension theorem</em></a>, which is somewhat tedious to prove. <a href="#fnref:invariant-dim" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rq" role="doc-endnote"> <p>An example of a messy infinite-dimensional basis is <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> considered as linear space over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">Q</span></span></span></span></span> (in general, every field is a linear space over its subfields). The basis for this space essentially has to be “<span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>, and all irrational numbers” except if we include e.g. <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span> we can’t include <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>π</mi></mrow><annotation encoding="application/x-tex">e + \frac{1}{2}\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span>, which is a <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">Q</span></span></span></span></span>-linear combination of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span>.</p> <p>On the other hand, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span></span> is two-dimensional over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span>, with basis <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace linebreak="newline"></mspace><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\\{1, i\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace newline"></span></span></span></span></span></span>.</p> <p>Incidentally, this idea of “view a field <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> as a linear space over its subfield <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span>” is such a useful concept that it is called the “degree of the field extension <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">K/F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span>”, and given the symbol <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>K</mi><mo>:</mo><mi>F</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[K : F]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">]</span></span></span></span></span>.</p> <p>This, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="double-struck">R</mi><mo>:</mo><mi mathvariant="double-struck">Q</mi><mo stretchy="false">]</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">[\R : \Q] = \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathbb">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="double-struck">C</mi><mo>:</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">[\C : \R] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathbb">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">R</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span>. <a href="#fnref:rq" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:similar" role="doc-endnote"> <p>You may recall from linear algebra class that two matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> of the same shape are <em>similar</em> if there are two appropriately-sized square matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span> such that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>A</mi><mi>R</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">SAR = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>. These matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span> represent a <em>change of basis</em>, and indicate that the linear maps <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">A, B: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> these matrices come from do “the same thing” to elements of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <p>Over an algebraically closed field like <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span></span> (i.e. all polynomials have solutions), there is an even stronger way to capture the information content of a linear map via <a href="https://en.wikipedia.org/wiki/Jordan_normal_form"><em>Jordan canonicalization</em></a>, which takes any square matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and produces an almost-diagonal square matrix that only depends on the eigenvalues of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>, which is the same for similar matrices, and thus basis-independent. <a href="#fnref:similar" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rc" role="doc-endnote"> <p>Here, as always, matrix dimensions are given in RC (row-column) order. You can think of this as being “input dimension” to “output dimension”. <a href="#fnref:rc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-08-09 • 2856 words • 31 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/08/09/yarns/"> I Wrote A String Type<br/> </a></h1> </div> <div class="post"> <p>I write compilers for fun. I can’t help it. Consequently, I also write a lot of parsers. In systems programming, it’s usually a good idea to try to share memory rather than reuse it, so as such my AST types tend to look like this.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">enum</span> <span class="n">Expr</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">Int</span><span class="p">(</span><span class="nb">u32</span><span class="p">)</span>
  <span class="nf">Ident</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'src</span> <span class="nb">str</span><span class="p">),</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Rust</a></div></div> <p>Whenever we parse an identifier, rather than copy its name into a fresh <code class="language-plaintext highlighter-rouge">String</code>, we borrow from the input source string. This avoids an extra allocation, an extra copy, and saves a word in the representation. Compilers can be memory-hungry, so it helps to pick a lean representation.</p> <p>Unfortunately, it’s not so easy for quoted strings. Most strings, like <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code>, are “literally” in the original source, like an identifier. But strings with escapes aren’t: <code class="language-plaintext highlighter-rouge">\n</code> is encoded in the source code with the bytes <code class="language-plaintext highlighter-rouge">[0x5c, 0x6e]</code>, but the actual “decoded” value of a string literal replaces each escape with a single <code class="language-plaintext highlighter-rouge">0x0a</code>.</p> <p>The usual solution is a <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code></a>. In the more common, escape-less verison, we can use <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code>, which avoids the extra allocation and copy, and in the escaped version, we decode the escapes into a <code class="language-plaintext highlighter-rouge">String</code> and wrap it in a <code class="language-plaintext highlighter-rouge">Cow::Owned</code>.</p> <p>For example, suppose that we’re writing a parser for a language that has quoted strings with escapes. The string <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code> can be represented as a byte string that borrows the input source code, so we’d use the <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code> variant. This is most strings in any language: escapes tend to be rare.</p> <p>For example, if we have the string <code class="language-plaintext highlighter-rouge">"not UTF-8 \xff"</code>, the actual byte string value is different from that in the source code.</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-text" data-lang="text">// Bytes in the source.
hex:   6e 6f 74 20 55 54 46 2d 38 20 5c 78 66 66
ascii: n  o  t     U  T  F  -  8     \  x  f  f

// Bytes represented by the string.
hex:   6e 6f 74 20 55 54 46 2d 38 20 ff
ascii: n  o  t     U  T  F  -  8</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Plaintext</a></div></div> <p>Escapes are relatively rare, so most strings processed by the parser do not need to pay for an allocation.</p> <p>However, we still pay for that extra word, since <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> is 24 bytes (unless otherwise specified, all byte counts assume a 64-bit system), which is eight more than our <code class="language-plaintext highlighter-rouge">&amp;str</code>. Even worse, this is bigger than the string data itself, which is 11 bytes.</p> <p>If most of your strings are small (which is not uncommon in an AST parser), you will wind up paying for significant overhead.</p> <p>Over the years I’ve implemented various optimized string types to deal with this use-case, in various contexts. I finally got around to putting all of the tricks I know into a library, which I call <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a>. It advertises the following nice properties.</p> <blockquote id="ref:1" class="ref"> <p><a href="#ref:1"><span class="chip">reference</span></a></p> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>I’d like to share how these properties are achieved through careful layout optimization.</p> <h2 id="assumptions"><a href="#assumptions">Assumptions</a></h2> <p>We’re going to start by stating assumptions about how our strings will be used:</p> <ol> <li>Most strings are not mutated most of the time.</li> <li>Most strings are small.</li> <li>Most strings are substrings.</li> </ol> <h3 id="most-strings-are-immutable"><a href="#most-strings-are-immutable">Most Strings are Immutable</a></h3> <p><code class="language-plaintext highlighter-rouge">String</code> is modeled after C++’s <code class="language-plaintext highlighter-rouge">std::string</code>, which is a growable buffer that implements amortized linear-time append. This means that if we are appending <code class="language-plaintext highlighter-rouge">n</code> bytes to the buffer, we only pay for <code class="language-plaintext highlighter-rouge">n</code> bytes of <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>This is a useful but often unnecessary property. For example, Go strings are immutable, and when building up a large string, you are expected to use <code class="language-plaintext highlighter-rouge">strings.Builder</code>, which is implemented as essentially a Rust <code class="language-plaintext highlighter-rouge">String</code>. Java also as a similar story for strings, which allows for highly compact representations of <code class="language-plaintext highlighter-rouge">java.lang.String</code>s.</p> <p>In Rust, this kind of immutable string is represented by a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>, which is eight bytes smaller than <code class="language-plaintext highlighter-rouge">String</code>. Converting from <code class="language-plaintext highlighter-rouge">String</code> to <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is just a call to <code class="language-plaintext highlighter-rouge">realloc()</code> to resize the underlying allocation (which is often cheap<sup id="fnref:size-classes" role="doc-noteref"><a href="#fn:size-classes" class="footnote" rel="footnote">1</a></sup>) from being <code class="language-plaintext highlighter-rouge">capacity</code> bytes long to <code class="language-plaintext highlighter-rouge">len</code> bytes long.</p> <p>Thus, this assumption means we only need to store a pointer and a length, which puts our memory footprint floor at 16 bytes.</p> <h3 id="most-strings-are-substrings"><a href="#most-strings-are-substrings">Most Strings are Substrings</a></h3> <p>Suppose again that we’re parsing some textual format. Many structural elements will be verbatim references into the textual input. Not only string literals without escapes, but also identifiers.</p> <p><code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> cannot hold borrowed data, because it will always instruct the allocator to free its pointer when it goes out of scope. <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>, as we saw above, allows us to handle maybe-owned data uniformly, but has a minimum 24 byte overhead. This can’t be made any smaller, because a <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> can contain a 24-byte <code class="language-plaintext highlighter-rouge">String</code> value.</p> <p>But, we don’t want to store a capacity. Can we avoid the extra word of overhead in <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>?</p> <h3 id="most-strings-are-small"><a href="#most-strings-are-small">Most Strings are Small</a></h3> <p>Consider a string that is not a substring but which is small. For example, when parsing a string literal like <code class="language-plaintext highlighter-rouge">"Hello, world!\n"</code>, the trailing <code class="language-plaintext highlighter-rouge">\n</code> (bytes <code class="language-plaintext highlighter-rouge">0x5c 0x6e</code>) must be replaced with a newline byte (<code class="language-plaintext highlighter-rouge">0x0a</code>). This means we must handle a tiny heap allocation, 14 bytes long, that is smaller than a <code class="language-plaintext highlighter-rouge">&amp;str</code> referring to it.</p> <p>This is worse for single character<sup id="fnref:character" role="doc-noteref"><a href="#fn:character" class="footnote" rel="footnote">2</a></sup> strings. The overhead for a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is large.</p> <ul> <li>The <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> struct itself has a pointer field (eight bytes), and a length field (also eight bytes). Spelled out to show all the stored bits, the length is <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0001</code>. That’s a lot of zeroes!</li> <li>The pointer itself points to a heap allocation, which will not be a single byte! Allocators are not in the business of handing out such small pieces of memory. Instead, the allocation is likely costing us another eight bytes!</li> </ul> <p>So, the string <code class="language-plaintext highlighter-rouge">"a"</code>, whose data is just a <em>single byte</em>, instead takes up 24 bytes of memory.</p> <p>It turns out that for really small strings we can avoid the allocation altogether, <em>and</em> make effective use of all those zeroes in the <code class="language-plaintext highlighter-rouge">len</code> field.</p> <h2 id="stealing-bits"><a href="#stealing-bits">Stealing Bits</a></h2> <p>Let’s say we want to stick to a budget of 16 bytes for our <code class="language-plaintext highlighter-rouge">Yarn</code> type. Is there any extra space left for data in a <code class="language-plaintext highlighter-rouge">(*mut u8, usize)</code> pair?</p> <p><em>*cracks Fermi estimation knuckles*</em></p> <p>A <code class="language-plaintext highlighter-rouge">usize</code> is 64 bits, which means that the length of an <code class="language-plaintext highlighter-rouge">&amp;str</code> can be anywhere from zero to 18446744073709551615, or around 18 exabytes. For reference, “hundreds of exabytes” is a reasonable ballpark guess for how much RAM exists in 2023 (consider: 4 billion smartphones with 4GB each). More practically, the largest quantity of RAM you can fit in a server blade is measured in terabytes (much more than your measly eight DIMs on your gaming rig).</p> <p>If we instead use one less bit, 63 bits, this halves the maximum representable memory to nine exabytes. If we take another, it’s now four exabytes. Much more memory than you will ever <em>ever</em> want to stick in a string. <a href="https://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia#Size_of_the_English_Wikipedia_database">Wikpedia asserts</a> that Wikimedia Commons contains around 428 terabytes of media (the articles’ text with history is a measly 10 TB).</p> <p>Ah, but you say you’re programming for a 32-bit machine (today, this likely means either a low-end mobile phone, an embedded micro controller, or WASM).</p> <p>On a 32-bit machine it’s a little bit harrier: Now <code class="language-plaintext highlighter-rouge">usize</code> is 32 bits, for a maximum string size of 4 gigabytes (if you remember the 32-bit era, this limit may sound familiar). “Gigabytes” is an amount of memory that you can actually imagine having in a string.</p> <p>Even then, 1 GB of memory (if we steal two bits) on a 32-bit machine is a lot of data. You can only have four strings that big in a single address space, and every 32-bit allocator in the universe will refuse to serve an allocation of that size. If your strings are comparable in size to the whole address space, you should build your own string type.</p> <p>The upshot is that every <code class="language-plaintext highlighter-rouge">&amp;str</code> contains two bits we can reasonably assume are not used. <em>Free real-estate.</em><sup id="fnref:isize" role="doc-noteref"><a href="#fn:isize" class="footnote" rel="footnote">3</a></sup></p> <h3 id="a-hand-written-niche-optimization"><a href="#a-hand-written-niche-optimization">A Hand-Written Niche Optimization</a></h3> <p>Rust has the concept of <em>niches</em>, or invalid bit-patterns of a particular type, which it uses for automatic layout optimization of <code class="language-plaintext highlighter-rouge">enum</code>s. For example, references cannot be null, so the pointer bit-pattern of <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0000</code> is never used; this bit-pattern is called a “niche”. Consider:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">),</span>
  <span class="n">Second</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Rust</a></div></div> <p>An <code class="language-plaintext highlighter-rouge">enum</code> of this form will not need any “extra” space to store the value that discriminates between the two variants: if a <code class="language-plaintext highlighter-rouge">Foo</code>’s bits are all zero, it’s <code class="language-plaintext highlighter-rouge">Foo::Second</code>; otherwise it’s a <code class="language-plaintext highlighter-rouge">Foo::First</code> and the payload is formed from <code class="language-plaintext highlighter-rouge">Foo</code>’s bit-pattern. This, incidentally, is what makes <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code> a valid representation for a “nullable pinter”.</p> <p>There are more general forms of this: <code class="language-plaintext highlighter-rouge">bool</code> is represented as a single byte, of which two bit are valid; the other 254 potential bit-patterns are niches. In Recent versions of Rust, <code class="language-plaintext highlighter-rouge">RawFd</code> has a niche for the all-ones bit-pattern, since POSIX file descriptors are always non-negative <code class="language-plaintext highlighter-rouge">int</code>s.</p> <p>By stealing two bits off of the length, we have given ourselves four niches, which essentially means we’ll have a hand-written version of something like this <code class="language-plaintext highlighter-rouge">enum</code>.</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Yarn</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Second</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Third</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Fourth</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Rust</a></div></div> <p>For reasons that will become clear later, we will specifically steal the <em>high</em> bits of the length, so that to recover the length, we do two shifts<sup id="fnref:two-shifts" role="doc-noteref"><a href="#fn:two-shifts" class="footnote" rel="footnote">4</a></sup> to shift in two high zero bits. Here’s some code that actually implements this for the low level type our string type will be built on.</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">,</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the kind back out.</span>
  <span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="k">as</span> <span class="nb">u8</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Rust</a></div></div> <p>Note that I’ve made this type <code class="language-plaintext highlighter-rouge">Copy</code>, and some functions take it by value. This is for two reasons.</p> <ol> <li> <p>There is a type of <code class="language-plaintext highlighter-rouge">Yarn</code> that is itself <code class="language-plaintext highlighter-rouge">Copy</code>, although I’m not covering it in this article.</p> </li> <li> <p>It is a two-word struct, which means that on most architectures it is eligible to be passed in a pair of registers. Passing it by value in the low-level code helps promote keeping it in registers. This isn’t always possible, as we will see when we discuss “SSO”.</p> </li> </ol> <p>Let’s chose kind <code class="language-plaintext highlighter-rouge">0</code> to mean “this is borrowed data”, and kind <code class="language-plaintext highlighter-rouge">1</code> to be “this is heap-allocated data”. We can use this to remember whether we need to call a destructor.</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">raw</span><span class="p">:</span> <span class="n">RawYarn</span><span class="p">,</span>
  <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">BORROWED</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">HEAP</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// SAFETY: initialized either from uniquely-owned data,</span>
      <span class="c1">// or borrowed data of lifetime 'a that outlives self.</span>
      <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_slice</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">HEAP</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">dropped</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
        <span class="c1">// SAFETY: This is just reconstituting the box we dismantled</span>
        <span class="c1">// in Yarn::owned().</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_mut_slice</span><span class="p">())</span>
      <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// Same thing as as_slice, basically. This is just to make</span>
    <span class="c1">// Box::from_raw() above typecheck.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p>This gives us a type that strongly resembles <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> with only half of the bytes. We can even write code to extend the lifetime of a <code class="language-plaintext highlighter-rouge">Yarn</code>:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Removes the bound lifetime from the yarn, allocating if</span>
  <span class="cd">/// necessary.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">immortalize</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">BORROWED</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.as_slice</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
      <span class="k">self</span> <span class="o">=</span> <span class="nn">Yarn</span><span class="p">::</span><span class="nf">owned</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// We need to be careful that we discard the old yarn, since its</span>
    <span class="c1">// destructor may run and delete the heap allocation we created</span>
    <span class="c1">// above.</span>
    <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">;</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
    <span class="nn">Yarn</span><span class="p">::</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">,</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>The remaining two niches can be put to use for optimizing small strings.</p> <h2 id="small-string-optimization"><a href="#small-string-optimization">Small String Optimization</a></h2> <p>C++’s <code class="language-plaintext highlighter-rouge">std::string</code> also makes the “most strings are small” assumption. In the <code class="language-plaintext highlighter-rouge">libc++</code> implementation of the standard library, <code class="language-plaintext highlighter-rouge">std::string</code>s of up to 23 bytes never hit the heap!</p> <p>C++ implementations do this by using most of the pointer, length, and capacity fields as a storage buffer for small strings, the so-called “small string optimization” (SSO). In <code class="language-plaintext highlighter-rouge">libc++</code>, in SSO mode, a <code class="language-plaintext highlighter-rouge">std::string</code>’s length fits in one byte, so the other 23 bytes can be used as storage. The capacity isn’t stored at all: an SSO string always has a capacity of 23.</p> <p><code class="language-plaintext highlighter-rouge">RawYarn</code> still has another two niches, so let’s dedicate one to a “small” representation. In small mode, the kind will be 2, and only the 16th byte will be the length.</p> <p>This is why we used the two <em>high</em> bits of <code class="language-plaintext highlighter-rouge">len</code> for our scratch space: no matter what mode it’s in, we can easily extract these bits<sup id="fnref:big-endian" role="doc-noteref"><a href="#fn:big-endian" class="footnote" rel="footnote">5</a></sup>. Some of the existing <code class="language-plaintext highlighter-rouge">RawYarn</code> methods need to be updated, though.</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">SMALL</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">adjust</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">SMALL</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.assume_init</span><span class="p">(),</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">adjust</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>In the non-<code class="language-plaintext highlighter-rouge">SMALL</code> case, we shift twice as before, but in the <code class="language-plaintext highlighter-rouge">SMALL</code> case, we need to get the high byte of the <code class="language-plaintext highlighter-rouge">len</code> field, so we need to shift down by an additional <code class="language-plaintext highlighter-rouge">usize::BITS - 8</code>. No matter what we’ve scribbled on the low bytes of <code class="language-plaintext highlighter-rouge">len</code>, we will always get just the length this way.</p> <p>We also need to use a different pointer value depending on whether we’re in <code class="language-plaintext highlighter-rouge">SMALL</code> mode. This is why <code class="language-plaintext highlighter-rouge">as_slice</code> needs to take a reference argument, since the slice data may be <em>directly</em> in <code class="language-plaintext highlighter-rouge">self</code>!</p> <p>Also, <code class="language-plaintext highlighter-rouge">ptr</code> is a <code class="language-plaintext highlighter-rouge">MaybeUninit</code> now, which will become clear in the next code listing.</p> <p>We should also provide a way to construct small strings.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">SSO_LEN</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Create a new small yarn. `data` must be valid for `len` bytes</span>
  <span class="cd">/// and `len` must be smaller than `SSO_LEN`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RawYarn</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span><span class="p">);</span>

    <span class="c1">// Create a yarn with an uninitialized pointer value (!!)</span>
    <span class="c1">// and a length whose high byte is packed with `small` and</span>
    <span class="c1">// `len`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">yarn</span> <span class="o">=</span> <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">(),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">SMALL</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span> <span class="p">|</span> <span class="n">len</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// Memcpy the data to the new yarn.</span>
    <span class="c1">// We write directly onto the `yarn` variable. We won't</span>
    <span class="c1">// overwrite the high-byte length because `len` will</span>
    <span class="c1">// never be &gt;= 16.</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">copy_nonoverlapping</span><span class="p">(</span>
      <span class="n">data</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="k">mut</span> <span class="n">yarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">RawYarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
      <span class="n">data</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="n">yarn</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p>The precise maximum size of an SSO string is a bit more subtle than what’s given above, but it captures the spirit. The <code class="language-plaintext highlighter-rouge">RawYarn::from_small</code> illustrates why the pointer value is hidden in a <code class="language-plaintext highlighter-rouge">MaybeUninit</code>: we’re above to overwrite it with garbage, and in that case it won’t be a pointer at all.</p> <p>We can update our public <code class="language-plaintext highlighter-rouge">Yarn</code> type to use the new small representation whenever possible.</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">())</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <p>It’s also possible to construct a <code class="language-plaintext highlighter-rouge">Yarn</code> directly from a character now, too!</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_char</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.encode_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>(Note that we do not need to update <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code>; why?)</p> <p>What we have now is a maybe-owned string that does not require an allocation for small strings. However, we still have an extra niche…</p> <h2 id="string-constants"><a href="#string-constants">String Constants</a></h2> <p>String constants in Rust are interesting, because we can actually detect them at compile-time<sup id="fnref:leaks" role="doc-noteref"><a href="#fn:leaks" class="footnote" rel="footnote">6</a></sup>.</p> <p>We can use the last remaining niche, 3, to represent data that came from a string constant, which means that it does not need to be boxed to be immortalized.</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">STATIC</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_static</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">STATIC</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Rust</a></div></div> <p>This function is identical to <code class="language-plaintext highlighter-rouge">Yarn::borrowed</code>, except that <code class="language-plaintext highlighter-rouge">data</code> most now have a static lifetime, and we pass <code class="language-plaintext highlighter-rouge">STATIC</code> to <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code>.</p> <p>Because of how we’ve written all of the prior code, this does not require any special support in <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code> or in the low-level <code class="language-plaintext highlighter-rouge">RawYarn</code> code.</p> <p>The actual <code class="language-plaintext highlighter-rouge">byteyarn</code> library provides a <code class="language-plaintext highlighter-rouge">yarn!()</code> macro that has the same syntax as <code class="language-plaintext highlighter-rouge">format!()</code>. This is the primary way in which yarns are created. It is has been carefully written so that <code class="language-plaintext highlighter-rouge">yarn!("this is a literal")</code> always produces a <code class="language-plaintext highlighter-rouge">STATIC</code> string, rather than a heap-allocated string.</p> <h2 id="an-extra-niche-as-a-treat"><a href="#an-extra-niche-as-a-treat">An extra niche, as a treat?</a></h2> <p>Unfortunately, because of how we’ve written it, <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is 24 bytes, a whole word larger than a <code class="language-plaintext highlighter-rouge">Yarn</code>. However, there’s still a little gap where we can fit the <code class="language-plaintext highlighter-rouge">None</code> variant. It turns out that because of how we’ve chosen the discriminants, <code class="language-plaintext highlighter-rouge">len</code> is zero if and only if it is an empty <code class="language-plaintext highlighter-rouge">BORROWED</code> string. But this is not the only zero: if the high byte is <code class="language-plaintext highlighter-rouge">0x80</code>, this is an empty <code class="language-plaintext highlighter-rouge">SMALL</code> string. If we simply require that no other empty string is ever constructed (by marking <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code> as unsafe and specifying it should not be passed a length of zero), we can guarantee that <code class="language-plaintext highlighter-rouge">len</code> is <em>never</em> zero.</p> <p>Thus, we can update <code class="language-plaintext highlighter-rouge">len</code> to be a <code class="language-plaintext highlighter-rouge">NonZeroUsize</code>.</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="n">NonZeroUsize</span><span class="p">,</span>  <span class="c1">// (!!)</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a *nonzero* length, and a pointer.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="nn">NonZeroUsize</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
        <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p>This is a type especially known to the Rust compiler to have a niche bit-pattern of all zeros, which allows <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> to be 16 bytes too. This also has the convenient property that the all zeros bit-pattern for <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is <code class="language-plaintext highlighter-rouge">None</code>.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>The <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a> blurb describes what we’ve built:</p> <blockquote id="ref:2" class="ref"> <p><a href="#ref:2"><span class="chip">reference</span></a></p> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>There are, of course, some trade-offs. Not only do we need the assumptions we made originally to hold, but we also need to relatively care more about memory than cycle-count performance, since basic operations like reading the length of the string require more math (but no extra branching).</p> <p>The actual implementation of <code class="language-plaintext highlighter-rouge">Yarn</code> is a bit more complicated, partly to keep all of the low-level book-keeping in one place, and partly to offer an ergonomic API that makes <code class="language-plaintext highlighter-rouge">Yarn</code> into a mostly-drop-in replacement for <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>.</p> <p>I hope this peek under the hood has given you a new appreciation for what can be achieved by clever layout-hacking.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:size-classes" role="doc-endnote"> <p>Allocators rarely serve you memory with precisely the size you asked for. Instead, they will have some notion of a “size class” that allows them to use more efficient allocation techniques, <a href="https://mcyoung.xyz//2022/06/07/alkyne-gc">which I have written about</a>.</p> <p>As a result, if the size change in a <code class="language-plaintext highlighter-rouge">realloc()</code> would not change the size class, it becomes a no-op, especially if the allocator can take advantage of the current-size information Rust provides it. <a href="#fnref:size-classes" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:character" role="doc-endnote"> <p>Here and henceforth “character” means “32-bit Unicode scalar”. <a href="#fnref:character" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:isize" role="doc-endnote"> <p>Now, you might also point out that Rust and C do not allow an allocation whose size is larger than the pointer offset type (<code class="language-plaintext highlighter-rouge">isize</code> and <code class="language-plaintext highlighter-rouge">ptrdiff_t</code>, respectively). In practice this means that the high bit is <em>always</em> zero according to the language’s own rules.</p> <p>This is true, but we need to steal two bits, and I wanted to demonstrate that this is an extremely reasonable desire. 64-bit integers are so comically large. <a href="#fnref:isize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:two-shifts" role="doc-endnote"> <p>Interestingly, LLVM will compile <code class="language-plaintext highlighter-rouge">(x &lt;&lt; 2) &gt;&gt; 2</code> to</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">movabs</span> <span class="n">rax</span><span class="p">,</span><span class="mh">0x3fffffffffffffff</span>
<span class="n">and</span>    <span class="n">rax</span><span class="p">,</span><span class="n">rdi</span>
<span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">x86 Assembly</a></div></div> <p>If we want to play the byte-for-byte game, this costs 14 bytes when encoded in the Intel variable-length encoding. You would think that two shifts would result in marginally smaller code, but no, since the input comes in in <code class="language-plaintext highlighter-rouge">rdi</code> and needs to wind up in <code class="language-plaintext highlighter-rouge">rax</code>.</p> <p>On RISC-V, though, it seems to decide that two shifts is in fact cheaper, and will even optimize <code class="language-plaintext highlighter-rouge">x &amp; 0x3fff_ffff_ffff_ffff</code> back into two shifts. <a href="#fnref:two-shifts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:big-endian" role="doc-endnote"> <p>This only works on little endian. Thankfully all computers are little endian. <a href="#fnref:big-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:leaks" role="doc-endnote"> <p>Technically, a <code class="language-plaintext highlighter-rouge">&amp;'static str</code> may also point to leaked memory. For our purposes, there is no essential difference. <a href="#fnref:leaks" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-08-01 • 5265 words • 58 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2023/08/01/llvm-ir/"> A Gentle Introduction to LLVM IR<br/> </a></h1> </div> <div class="post"> <p>The other day, I saw <a href="https://twitter.com/burntsushi5/status/1684204136571478021?s=20">this tweet</a>. In it, Andrew Gallant argues that reaching for LLVM IR, instead of assembly, is a useful tool for someone working on performance. Unfortunately, learning material on LLVM is usually aimed at compiler engineers, not generalist working programmers.</p> <p>Now, <em>I’m</em> a compiler engineer, so my answer is <em>of course</em> you should know your optimizer’s IR. But I do think there’s a legitimate reason to be able to read it, in the same way that being able to read assembly to understand what your processor is doing is a powerful tool. I wrote an <a href="https://mcyoung.xyz//2021/11/29/assembly-1">introduction to assembly</a> over a year ago (still have to finish the followups… 💀), which I recommend reading first.</p> <p>Learning LLVM IR is similar, but it helps you understand what your <em>compiler</em> is doing to create highly optimized code. LLVM IR is very popular, and as such well-documented and reasonably well-specified, to the point that we can just treat it as a slightly weird programming language.</p> <p>In this article, I want to dig into what LLVM IR <em>is</em> and how to read it.</p> <h2 id="whats-llvm-ir"><a href="#whats-llvm-ir">What’s LLVM IR?</a></h2> <p>“LLVM” is an umbrella name for a number of software components that can be used to build compilers. If you write performance-critical code, you’ve probably heard of it.</p> <p>Its flagship product is Clang, a high-end C/C++/Objective-C compiler. Clang follows the orthodox compiler architecture: a frontend that parses source code into an AST and lowers it into an <em>intermediate representation</em>, an “IR”; an optimizer (or “middle-end”) that transforms IR into better IR, and a backend that converts IR into machine code for a particular platform.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-text" data-lang="text">                               optimizer (opt)
                                    ___
                                   |   v
          .c file  --&gt;  AST  --&gt;  LLVM IR  --&gt;  assembly
                    ^         ^             ^
                 parser    lowering    backend (llc)

         \____________________/  \_____________________/
             Clang Frontend                LLVM</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1"></a></div></div> <p>LLVM often also refers to just the optimizer and backend parts of Clang; this is can be thought of as a compiler for the “LLVM language” or “LLVM assembly”. Clang, and other language frontends like Rust, essentially compile to LLVM IR, which LLVM then compiles to machine code.</p> <p>LLVM IR is well documented and… <em>somewhat</em> stable, which makes it a very good compilation target, since language implementers can re-use the thousands of engineer hours poured into LLVM already. The source of truth for “what is LLVM IR?” is the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>.</p> <p>LLVM IR is also binary format (sometimes called “bitcode”), although we will be working exclusively with its text format (which uses the <code class="language-plaintext highlighter-rouge">.ll</code> extension).</p> <p>LLVM-targeting compilers will have debugging flags to make them emit IR instead of their final output. For Clang, this is e.g. <code class="language-plaintext highlighter-rouge">clang++ -S -emit-llvm foo.cc</code>, while for Rust this is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir foo.rs</code>. Godbolt will also respect these options and correctly display LLVM IR output.</p> <h2 id="back-to-basic-blocks"><a href="#back-to-basic-blocks">Back to Basic Blocks</a></h2> <p>LLVM IR can be quite intimidating to read, since it contains much more ancillary information than an assembly dump. Consider this function:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <p>If you click on the “Godbolt” widget, it will take you to a Godbolt that lowers it to LLVM IR. Most of that code is just metadata, but it’s really intimidating!</p> <p>Starting from compiler output will have a steep difficulty curve, because we have to face the full complexity of LLVM IR. For Rust, this will likely mean encountering exception-handling, which is how panics are implemented, and function attributes that forward Rust’s guarantees (e.g. non-null pointers) to LLVM.</p> <p>Instead, we’ll start by introducing the basic syntax of LLVM IR, and <em>then</em> we’ll tackle reading compiler output.</p> <h3 id="a-trivial-function"><a href="#a-trivial-function">A Trivial Function</a></h3> <p>The meat of LLVM IR is function definitions, introduced with a <code class="language-plaintext highlighter-rouge">define</code>. There is also <code class="language-plaintext highlighter-rouge">declare</code>, which has exactly the same purpose as a function without a body in C: it brings an external symbol into scope.</p> <p>For example, the following function takes no arguments and returns immediately:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_nothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">LLVM IR</a></div></div> <p>The return type of the function (<code class="language-plaintext highlighter-rouge">void</code>) immediately follows the <code class="language-plaintext highlighter-rouge">define</code> keyword; the name of the function starts with an <code class="language-plaintext highlighter-rouge">@</code>, which introduces us to the concept of <em>sigils</em>: every user-defined symbol starts with a sigil, indicating what kind of symbol it is. <code class="language-plaintext highlighter-rouge">@</code> is used for global and functions: things you can take the address of (when used as a value, they are always <code class="language-plaintext highlighter-rouge">ptr</code>-typed).</p> <p>The body of a function resembles assembly: a list of labels and instructions. Unlike ordinary assembly, however, there are significant restrictions on the structure of these instructions.</p> <p>In this case, there is only one instruction: a <code class="language-plaintext highlighter-rouge">void</code>-typed return. Unlike most assembly languages, LLVM IR is strongly typed, and requires explicit type annotations almost everywhere.</p> <p>Here is another trivial function.</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_not_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">unreachable</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">LLVM IR</a></div></div> <p>This function will trigger undefined behavior upon being called: the <code class="language-plaintext highlighter-rouge">unreachable</code> instruction represents a codepath that the compiler can assume is never executed; this is unlike e.g. the unimplemented <code class="language-plaintext highlighter-rouge">ud2</code> instruction in x86, which is guaranteed to issue a fault.</p> <p>This is an important distinction between LLVM IR and an assembly language: some operations are explicitly left undefined to leave room for potential optimizations. For example, LLVM can reason that, because <code class="language-plaintext highlighter-rouge">@do_not_call</code> immediately triggers undefined behavior, all calls to <code class="language-plaintext highlighter-rouge">@do_not_call</code> are also unreachable (and propagate unreachability from there).</p> <h3 id="purely-scalar-code"><a href="#purely-scalar-code">Purely Scalar Code</a></h3> <p>Let’s start with basic functions that only operate on integers. Consider the following function, that squares a 32-bit integer:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">LLVM IR</a></div></div> <p>Now our function takes arguments and has multiple instructions.</p> <p>The argument is specified as <code class="language-plaintext highlighter-rouge">i32 %x</code>. Names a <code class="language-plaintext highlighter-rouge">%</code> sigil are sort of like local variables, but with some restrictions that make them more optimization-friendly; as we’ll see later, they’re not really “variable” at all. LLVM sometimes calls them <em>registers</em>; in a sense, LLVM IR is assembly for an abstract machine with an infinite number of registers. I’ll be calling <code class="language-plaintext highlighter-rouge">%</code>-prefixed names “registers” throughout this article.</p> <p><code class="language-plaintext highlighter-rouge">i32</code> is a primitive integer types. All integer types in LLVM are of the form <code class="language-plaintext highlighter-rouge">iN</code>, for any <code class="language-plaintext highlighter-rouge">N</code> (even non-multiples of eight). There are no signed or unsigned types; instead, instructions that care about signedness will specify which semantic they use.</p> <p>The first instruction is a <code class="language-plaintext highlighter-rouge">mul i32</code>, which multiples the two <code class="language-plaintext highlighter-rouge">i32</code> operands together, and returns a value; we assign this to the new register <code class="language-plaintext highlighter-rouge">%1</code><sup id="fnref:numeric-names" role="doc-noteref"><a href="#fn:numeric-names" class="footnote" rel="footnote">1</a></sup>. The next instruction returns this value.</p> <p>The other arithmetic operations have the names you expect: <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">shl</code> (shift left). There are two division and remainder instructions, signed (<code class="language-plaintext highlighter-rouge">sdiv</code>, <code class="language-plaintext highlighter-rouge">srem</code>) and unsigned (<code class="language-plaintext highlighter-rouge">udiv</code>, <code class="language-plaintext highlighter-rouge">urem</code>). There two shift right instructions, again signed (<code class="language-plaintext highlighter-rouge">ashr</code>) and unsigned (<code class="language-plaintext highlighter-rouge">lshr</code>).</p> <blockquote id="tip:1" class="tip"> <p><a href="#tip:1"><span class="chip">tip</span></a></p> <p>Exercise for the reader: why are <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">%</code>, and <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> the only operations with signed and unsigned versions?</p> </blockquote> <p>We can also convert from one integer type to another using <code class="language-plaintext highlighter-rouge">trunc</code>, <code class="language-plaintext highlighter-rouge">zext</code>, and <code class="language-plaintext highlighter-rouge">sext</code>, which truncate, zero-extend, and sign-extend, respectively (<code class="language-plaintext highlighter-rouge">sext</code> and <code class="language-plaintext highlighter-rouge">zext</code> are another signed/unsigned pair). For example, if we wanted the <code class="language-plaintext highlighter-rouge">square</code> function to never overflow, we could write</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">sext</span> <span class="kt">i32</span> <span class="nv">%x</span> <span class="k">to</span> <span class="kt">i64</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%1</span><span class="p">,</span> <span class="nv">%1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">LLVM IR</a></div></div> <p>Here, we cast <code class="language-plaintext highlighter-rouge">%x</code> to <code class="language-plaintext highlighter-rouge">i64</code> by sign-extension (since we’ve decided we’re squaring signed integers) and then square the result. <code class="language-plaintext highlighter-rouge">trunc</code> and <code class="language-plaintext highlighter-rouge">zext</code> both have the same syntax as <code class="language-plaintext highlighter-rouge">sext</code>.</p> <h3 id="ill-be-back"><a href="#ill-be-back">“I’ll Be Back”</a></h3> <p>Of course, interesting functions have <em>control flow</em>. Suppose we want a safe division function: division by zero is UB, so we need to handle it explicitly. Perhaps something like this:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p>We could try doing this using <code class="language-plaintext highlighter-rouge">select</code>, LLVM’s “ternary” operation.</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">select</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">-1</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%2</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">LLVM IR</a></div></div> <p>However, this has a problem: division by zero is UB<sup id="fnref:divz" role="doc-noteref"><a href="#fn:divz" class="footnote" rel="footnote">2</a></sup>, and <code class="language-plaintext highlighter-rouge">select</code> is not short-circuiting: its semantics are closer to that of <code class="language-plaintext highlighter-rouge">cmov</code> in x86.</p> <p>To compile this correctly, need to use the <code class="language-plaintext highlighter-rouge">br</code> instruction, which represents a general branch operation<sup id="fnref:br-on-real-machines" role="doc-noteref"><a href="#fn:br-on-real-machines" class="footnote" rel="footnote">3</a></sup>. In C terms, a <code class="language-plaintext highlighter-rouge">br i1 %cond, label %a, label %b</code> is equivalent to <code class="language-plaintext highlighter-rouge">if (cond) goto a; else goto b;</code>.</p> <p>This is how we might write that:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%iszero</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%nonzero</span>

<span class="nl">iszero:</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="m">-1</span>

<span class="nl">nonzero:</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">LLVM IR</a></div></div> <p>Now our function has labels, which are used by the <code class="language-plaintext highlighter-rouge">br</code> instruction as jump targets.</p> <p>In the first block, we do the <code class="language-plaintext highlighter-rouge">d == 0</code> check, implemented by an <code class="language-plaintext highlighter-rouge">icmp eq</code> instruction. This returns an <code class="language-plaintext highlighter-rouge">i1</code> (the type LLVM uses for booleans). We then pass the result into a <code class="language-plaintext highlighter-rouge">br</code> instruction, which jumps to the first label if it’s zero, otherwise to the second if it isn’t.</p> <p>The second block is the early-return; it returns the “sentinel” value; the third block is self-explanatory.</p> <p>Each of these blocks is a “basic block”: a sequence of non-control flow operations, plus an instruction that moves control flow away from the block. These blocks form the control flow graph (CFG) of the function.</p> <p>There are a few other “block terminator” instructions. The one-argument form of <code class="language-plaintext highlighter-rouge">br</code> takes a single label, and is a simple unconditional <code class="language-plaintext highlighter-rouge">goto</code>. There’s also <code class="language-plaintext highlighter-rouge">switch</code>, which is similar to a C <code class="language-plaintext highlighter-rouge">switch</code>:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">switch</span> <span class="kt">i32</span> <span class="nv">%value</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%default</span> <span class="p">[</span>
  <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_zero</span>
  <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_one</span><span class="p">,</span>
  <span class="c1">; etc</span>
<span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">LLVM IR</a></div></div> <p>The type of the <code class="language-plaintext highlighter-rouge">switch</code> must be an integer type. Although you could represent this operation with a chain of <code class="language-plaintext highlighter-rouge">br</code>s, a separate <code class="language-plaintext highlighter-rouge">switch</code> instruction makes it easier for LLVM to generate jump tables.</p> <p><code class="language-plaintext highlighter-rouge">unreachable</code>, which we saw before, is a special terminator that does not trigger control flow per se, but which can terminate a block because reaching it is undefined behavior; it is equivalent to e.g. <code class="language-plaintext highlighter-rouge">std::unreachable()</code> in C++.</p> <blockquote id="aside:llvm-deleted-my-code" class="aside"> <p><a href="#aside:llvm-deleted-my-code"><span class="chip">aside</span><span class="title">LLVM Deleted My Code!</span></a></p> <p>The <code class="language-plaintext highlighter-rouge">unreachable</code> instruction provides a good example of why LLVM uses a basic block CFG: a naive dead code elimination (DCE) optimization pass can be implemented as follows:</p> <ol> <li>Fill a set with every block that ends in <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>For every block, if its terminator references a block in the unreachable set, delete that label from the terminator. For example, if we have <code class="language-plaintext highlighter-rouge">br i1 %c, label %a, label %b</code>, and the unreachable set contains <code class="language-plaintext highlighter-rouge">%a</code>, we can replace this with a <code class="language-plaintext highlighter-rouge">br label %b</code>.</li> <li>If every outgoing edge from a block is deleted in (2), replace the terminator with <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>Delete all blocks in the unreachable set.</li> <li>Repeat from (1) as many times as desired.</li> </ol> <p>Intuitively, <code class="language-plaintext highlighter-rouge">unreachable</code>s bubble <em>upwards</em> in the CFG, dissolving parts of the CFG among them. Other passes can generate <code class="language-plaintext highlighter-rouge">unreachable</code>s to represent UB: interplay between this and DCE results in the “the compiler <em>will</em> delete your code” outcome from UB.</p> <p>The actual DCE pass is much more complicated, since function calls make it harder to decide if a block is “pure” and thus transparently deletable.</p> </blockquote> <p>But, what if we want to implement something more complicated, like <code class="language-plaintext highlighter-rouge">a / b + 1</code>? This expression needs the intermediate result, so we can’t use two return statements as before.</p> <p>Working around this is not so straightforward: if we try to assign the same register in different blocks, the IR verifier will complain. This brings us to the concept of static single assignment.</p> <h3 id="phony-phony"><a href="#phony-phony">Phony! Phony!</a></h3> <p>LLVM IR is a <em>static single assignment form</em> (SSA) IR. LLVM was actually started at the turn of the century to create a modern SSA optimizer as an academic project. These days, SSA is extremely fashionable for optimizing imperative code.</p> <p>SSA form means that every register is assigned by at most one instruction per function. Different executions of the same block in the same function may produce different values for particular registers, but we cannot <em>mutate</em> already-assigned registers.</p> <p>In other words:</p> <ol> <li>Every register is guaranteed to be initialized by a single expression.</li> <li>Every register depends only on the values of registers assigned before its definition.</li> </ol> <p>This has many useful properties for writing optimizations: for example, within a basic block, every use of a particular register <code class="language-plaintext highlighter-rouge">%x</code> always refers to the same value, which makes optimizations like <a href="https://en.wikipedia.org/wiki/Value_numbering">global value numbering</a> and constant-folding much simpler to write, since the state of a register throughout a block doesn’t need to be tracked separately.</p> <p>In SSA, we reinterpret mutation as many <em>versions</em> of a single variable. Thus, we might lower <code class="language-plaintext highlighter-rouge">x += y</code> as</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x.1</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%x.0</span><span class="p">,</span> <span class="nv">%y.0</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">LLVM IR</a></div></div> <p>Here, we’ve used a <code class="language-plaintext highlighter-rouge">var.n</code> convention to indicate which version of a variable a specific register represents (LLVM does not enforce any naming conventions).</p> <p>However, when loops enter the mix, it’s not clear how to manage versions. The number of registers in a function is static, but the number of loop iterations is dynamic.</p> <p>Concretely, how do we implement this function?</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">y</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>We could try something like this:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>  <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>   <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">LLVM IR</a></div></div> <p>But there’s a problem! What are the original definitions of <code class="language-plaintext highlighter-rouge">%r</code> and <code class="language-plaintext highlighter-rouge">%i</code>? The IR verifier will complain that these registers depend directly on themselves, which violates SSA form. What’s the “right” way to implement this function?</p> <p>One option is to ask LLVM! We’ll implement the function poorly, and let the optimizer clean it up for us.</p> <p>First, let’s write the function using memory operations, like <code class="language-plaintext highlighter-rouge">load</code>s and <code class="language-plaintext highlighter-rouge">store</code>s, to implement mutation. We can use the <code class="language-plaintext highlighter-rouge">alloca</code> instruction to create statically-sized stack slots; these instructions return a <code class="language-plaintext highlighter-rouge">ptr</code>[^clang-codegen].</p> <blockquote id="aside:clang-makes-a-mess-llvm-cleans-it-up" class="aside"> <p><a href="#aside:clang-makes-a-mess-llvm-cleans-it-up"><span class="chip">aside</span><span class="title">Clang Makes a Mess, LLVM Cleans It Up</span></a></p> <p>Incidentally, this is how Clang and Rust both generate LLVM IR: stack variables are turned into <code class="language-plaintext highlighter-rouge">alloca</code>s and manipulated through loads and stores; temporaries are mostly turned into <code class="language-plaintext highlighter-rouge">%regs</code>s, but the compiler will sometimes emit extra allocas to avoid thinking too hard about needing to create <code class="language-plaintext highlighter-rouge">phi</code> instructions.</p> <p>This is pretty convenient, because it avoids needing to think very hard about SSA form outside of LLVM, and LLVM can trivially eliminate unnecessary allocas. The code I wrote for the codegen of <code class="language-plaintext highlighter-rouge">@pow</code> is very similar to what Rust would send to LLVM (although because we used an iterator, there’s a lot of extra junk Rust emits that LLVM has to work to eliminate).</p> </blockquote> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">; Create slots for r and the index, and initialize them.</span>
  <span class="c1">; This is equivalent to something like</span>
  <span class="c1">;   int i = 0, r = 1;</span>
  <span class="c1">; in C.</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="c1">; Load the index and check if it equals y.</span>
  <span class="nv">%i.check</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.check</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="c1">; r *= x</span>
  <span class="nv">%r.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.old</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%r.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>

  <span class="c1">; i += 1</span>
  <span class="nv">%i.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.old</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%i.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>

  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="nv">%r.ret</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.ret</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">LLVM IR</a></div></div> <p>Next, we can pass this into the LLVM optimizer. The command <code class="language-plaintext highlighter-rouge">opt</code>, which is part of the LLVM distribution, runs specific optimizer passes on the IR. In our case, we want <code class="language-plaintext highlighter-rouge">opt -p mem2reg</code>, which runs a single “memory to register” pass. We can also just run <code class="language-plaintext highlighter-rouge">opt --O2</code> or similar to get similar<sup id="fnref:frontend-optimization" role="doc-noteref"><a href="#fn:frontend-optimization" class="footnote" rel="footnote">4</a></sup> optimizations to the ones <code class="language-plaintext highlighter-rouge">clang -O2</code> runs.</p> <p>This is the result.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; After running through `opt -p mem2reg`</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="nv">%i.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%i.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%r.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%r.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.0</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.0</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">LLVM IR</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">alloca</code>s are gone, but now we’re faced with a new instruction: <code class="language-plaintext highlighter-rouge">phi</code>. “φ node” is jargon from the original SSA paper; the greek letter φ means “phoney”. These instructions select a value from a list based on which basic block we jumped to the block from.</p> <p>For example, <code class="language-plaintext highlighter-rouge">phi i32 [0, %start], [%i.new, %loop]</code> says “this value should be 0 if we came from the <code class="language-plaintext highlighter-rouge">start</code> block; otherwise <code class="language-plaintext highlighter-rouge">%i.new</code> if it came from <code class="language-plaintext highlighter-rouge">%loop</code>”.</p> <p>Unlike all other instructions, <code class="language-plaintext highlighter-rouge">phi</code> can refer to values that are not defined in all blocks that dominate the current block. This lets us have a dynamic number of versions of a variable! Here’s what that looks like in a dynamic execution context.</p> <blockquote id="tip:dominators" class="tip"> <p><a href="#tip:dominators"><span class="chip">tip</span><span class="title">Dominators</span></a></p> <p>A block <code class="language-plaintext highlighter-rouge">%a</code> is said to dominate a block <code class="language-plaintext highlighter-rouge">%b</code> if each of its predecessors is either <code class="language-plaintext highlighter-rouge">%a</code> or a block dominated by <code class="language-plaintext highlighter-rouge">%a</code>. In other words, every path from the first block to <code class="language-plaintext highlighter-rouge">%b</code> passes through <code class="language-plaintext highlighter-rouge">%a</code>. In general instructions can only refer to values defined in previous instructions in the current block or values from blocks that dominate it.</p> </blockquote> <ol> <li> <p><code class="language-plaintext highlighter-rouge">%start</code> directly jumps into <code class="language-plaintext highlighter-rouge">%loop_start</code>. The first block cannot be a jump target, since it cannot have <code class="language-plaintext highlighter-rouge">phi</code> nodes because its predecessors include function’s callsite.</p> </li> <li> <p>In <code class="language-plaintext highlighter-rouge">%loop_start</code>, since we’ve entered from <code class="language-plaintext highlighter-rouge">%start</code>, <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are selected to be the first versions of the (platonic) <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code> variables, i.e., their initial values; we jump to <code class="language-plaintext highlighter-rouge">%loop</code>.</p> </li> <li> <p>Then, <code class="language-plaintext highlighter-rouge">%loop</code> is dominated by <code class="language-plaintext highlighter-rouge">%loop_start</code> so we can use <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> there directly; these are the <code class="language-plaintext highlighter-rouge">*=</code> and <code class="language-plaintext highlighter-rouge">+=</code> operations. Then we jump back to <code class="language-plaintext highlighter-rouge">%loop_start</code>.</p> </li> <li> <p>Back in <code class="language-plaintext highlighter-rouge">%loop_start</code>, the <code class="language-plaintext highlighter-rouge">phi</code>s now select <code class="language-plaintext highlighter-rouge">%i.new</code> and <code class="language-plaintext highlighter-rouge">%r.new</code>, so now <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are the <em>second</em> versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>. By induction, the nth execution of <code class="language-plaintext highlighter-rouge">%loop_start</code> has the nth versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>.</p> </li> <li> <p>When we finally get sent to <code class="language-plaintext highlighter-rouge">%exit</code>, we can use <code class="language-plaintext highlighter-rouge">%r.0</code> (since <code class="language-plaintext highlighter-rouge">%loop_start</code> dominates <code class="language-plaintext highlighter-rouge">%r.0</code>), which will be the <code class="language-plaintext highlighter-rouge">%y</code>th version of <code class="language-plaintext highlighter-rouge">r</code>; this is our return value.</p> </li> </ol> <p>This is a good place to stop and think about what we’ve done so far. SSA, domination, and <code class="language-plaintext highlighter-rouge">phi</code>s can be hard to wrap your head around, and are not absolutely necessary for reading most IR. However, it is absolutely worth trying to understand, because it captures essential facts about how compilers like to reason about code<sup id="fnref:block-args" role="doc-noteref"><a href="#fn:block-args" class="footnote" rel="footnote">5</a></sup>.</p> <p>With <code class="language-plaintext highlighter-rouge">phi</code> and <code class="language-plaintext highlighter-rouge">br</code>, we can build arbitrarily complicated control flow within a function<sup id="fnref:viz" role="doc-noteref"><a href="#fn:viz" class="footnote" rel="footnote">6</a></sup>.</p> <h2 id="types-and-aggregates"><a href="#types-and-aggregates">Types and Aggregates</a></h2> <p>Now that we have basic scalar functions, let’s review LLVM’s type system.</p> <p>We’ve seen <code class="language-plaintext highlighter-rouge">i32</code> and its friends; these are arbitrary-bit-with integers. <code class="language-plaintext highlighter-rouge">i1</code> is special because it is used as the boolean type. LLVM optimizations have been known to generate integer types with non-power-of-two sizes.</p> <p>LLVM also has <code class="language-plaintext highlighter-rouge">float</code> and <code class="language-plaintext highlighter-rouge">double</code>, and some exotic float types like <code class="language-plaintext highlighter-rouge">bfloat</code>; these use their own arithmetic instructions with different options. I’ll pass on them in this explainer; see <code class="language-plaintext highlighter-rouge">fadd</code> and friends in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> for more.</p> <p>We’ve also seen <code class="language-plaintext highlighter-rouge">void</code>, which is only used as a return value, and <code class="language-plaintext highlighter-rouge">ptr</code>, which is an untyped<sup id="fnref:typed-pointers" role="doc-noteref"><a href="#fn:typed-pointers" class="footnote" rel="footnote">7</a></sup> pointer.</p> <p>We’ve also seen the <code class="language-plaintext highlighter-rouge">label</code> pseudo-type, which represents a block label. It does not appear directly at runtime and has limited uses; the <code class="language-plaintext highlighter-rouge">token</code> and <code class="language-plaintext highlighter-rouge">metadata</code> types are similar.</p> <p>Arrays are spelled <code class="language-plaintext highlighter-rouge">[n x T]</code>; the number must be an integer and the type must have a definite size. E.g., <code class="language-plaintext highlighter-rouge">[1024 x i8]</code>. Zero-sized arrays are supported.</p> <p>Structs are spelled <code class="language-plaintext highlighter-rouge">{T1, T2, ...}</code>. E.g., <code class="language-plaintext highlighter-rouge">{i64, ptr}</code> is a Rust slice. Struct fields do not have names and are indexed, instead. The form <code class="language-plaintext highlighter-rouge">&lt;{...}&gt;</code> is a <em>packed</em> struct, which removes inter-field padding. E.g. <code class="language-plaintext highlighter-rouge">#[repr(packed)]</code> compiles down to this.</p> <p>Vectors are like arrays but spelled <code class="language-plaintext highlighter-rouge">&lt;n x T&gt;</code>. These are used to represent types used in SIMD operations. For example, adding two <code class="language-plaintext highlighter-rouge">&lt;4 x i32&gt;</code> would lower to an AVX2 vector add on x86. I will not touch on SIMD stuff beyond this, although at higher optimization levels LLVM will merge scalar operations into vector operations, so you may come across them.</p> <p>Type aliases can be created at file scope with the syntax</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Slice</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">LLVM IR</a></div></div> <p>This means that <code class="language-plaintext highlighter-rouge">%T</code> can be either a type or a register/label inside of a function, depending on syntactic position.</p> <h3 id="operations-on-aggregates"><a href="#operations-on-aggregates">Operations on Aggregates</a></h3> <p>The <code class="language-plaintext highlighter-rouge">insertvalue</code> and <code class="language-plaintext highlighter-rouge">extractvalue</code> can be used with struct or array types to statically access a field. For example,</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%MyStruct</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i32</span><span class="p">,</span> <span class="p">{[</span><span class="m">5</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">],</span> <span class="kt">i64</span><span class="p">}}</span>

<span class="c1">; In Rust-like syntax, this is `let v = s.1.0[4];`</span>
<span class="nv">%v</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">LLVM IR</a></div></div> <p><code class="language-plaintext highlighter-rouge">insertvalue</code> is the reverse: it produces a copy of the aggregate with a specific field changed. It <em>does not</em> mutate in-place, because SSA forbids that.</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; In Rust-like syntax, this is</span>
<span class="c1">;   let s2 = { let mut s = s; s2.1.1 = 42; s };</span>
<span class="nv">%s2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">LLVM IR</a></div></div> <p>There are similar operations called <code class="language-plaintext highlighter-rouge">insertelement</code> and <code class="language-plaintext highlighter-rouge">extractelement</code> work on vectors, but have slightly different syntax and semantics.</p> <p>Finally, there’s <code class="language-plaintext highlighter-rouge">getelementptr</code>, the “pointer arithmetic instruction”, often abbreviated to GEP. A GEP can be used to calculate an offset pointer into a struct. For example,</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="err">ptr</span> <span class="vg">@get_inner_in_array</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%q</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%MyStruct</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="err">ptr</span> <span class="nv">%q</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">LLVM IR</a></div></div> <p>This function takes in a pointer, ostensibly pointing to an array of <code class="language-plaintext highlighter-rouge">%MyStruct</code>s, and an index. This returns a pointer to the <code class="language-plaintext highlighter-rouge">i64</code> field of the <code class="language-plaintext highlighter-rouge">%idx</code>th element of <code class="language-plaintext highlighter-rouge">%p</code>.</p> <p>A few important differences between GEP and <code class="language-plaintext highlighter-rouge">extractvalue</code>:</p> <ol> <li>It takes an untyped pointer instead of a value of a particular struct/array type.</li> <li>There is an extra parameter that specifies an index; from the perspective of GEP, every pointer is a pointer to an array of unspecified bound. When operating on a pointer that does not (at runtime) point to an array, an index operand of <code class="language-plaintext highlighter-rouge">0</code> is still required. (Alternatively, you can view a pointer to <code class="language-plaintext highlighter-rouge">T</code> as being a pointer to a one-element array.)</li> <li>The index parameters need explicit types.</li> </ol> <p>LLVM provides a helpful<sup id="fnref:sarcasm" role="doc-noteref"><a href="#fn:sarcasm" class="footnote" rel="footnote">8</a></sup> FAQ on the GEP instruction: <a href="https://llvm.org/docs/GetElementPtr.html">https://llvm.org/docs/GetElementPtr.html</a>.</p> <h2 id="other-operations"><a href="#other-operations">Other Operations</a></h2> <p>Some other operations are very relevant for reading IR, but don’t fit into any specific category. As always, the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> provides a full description of what all of these instructions do.</p> <h3 id="function-calls"><a href="#function-calls">Function Calls</a></h3> <p><code class="language-plaintext highlighter-rouge">call</code>, which calls any <code class="language-plaintext highlighter-rouge">ptr</code> as a function. For example:</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; Arguments are passed in parentheses.</span>
<span class="nv">%r</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@my_func</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">LLVM IR</a></div></div> <p>Note that this could have been a <code class="language-plaintext highlighter-rouge">%reg</code> instead of a <code class="language-plaintext highlighter-rouge">@global</code>, which indicates a function pointer call.</p> <p>Sometimes you will see <code class="language-plaintext highlighter-rouge">invoke</code>, which is used to implement “call a function inside of a C++ <code class="language-plaintext highlighter-rouge">try {}</code> block”. This is rare in Rust, but can occur in some C++ code.</p> <p>Function calls are often noisy areas of IR, because they will be very heavily annotated.</p> <h3 id="synchronization"><a href="#synchronization">Synchronization</a></h3> <p>The <code class="language-plaintext highlighter-rouge">load</code> and <code class="language-plaintext highlighter-rouge">store</code> instructions we’ve already seen can be annotated as <code class="language-plaintext highlighter-rouge">atomic</code>, which is used to implement e.g. <code class="language-plaintext highlighter-rouge">AtomicU32::load</code> in Rust; this requires that an atomic ordering be specified, too. E.g.,</p> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%v</span> <span class="p">=</span> <span class="k">load</span> <span class="k">atomic</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span> <span class="k">acquire</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">LLVM IR</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">fence</code> operation is a general memory fence operation corresponding to e.g. Rust’s <code class="language-plaintext highlighter-rouge">std::sync::atomic::fence</code> function.</p> <p><code class="language-plaintext highlighter-rouge">cmpxchg</code> provides the CAS (compare-and-swap) primitive. It returns a <code class="language-plaintext highlighter-rouge">{T, i1}</code> containing the old value and whether the CAS succeeded. <code class="language-plaintext highlighter-rouge">cmpxchg weak</code> implements the spuriously-failing “weak CAS” primitive.</p> <p>Finally, <code class="language-plaintext highlighter-rouge">atomicrmw</code> performs a read-modify-write (e.g., <code class="language-plaintext highlighter-rouge">*p = op(*p, val)</code>) atomically. This is used to implement things like <code class="language-plaintext highlighter-rouge">AtomicU32::fetch_add</code> and friends.</p> <p>All of these operations, except for <code class="language-plaintext highlighter-rouge">fence</code>, can also be marked as <code class="language-plaintext highlighter-rouge">volatile</code>. In LLVM IR, much like in Rust but unlike in C/C++, individual loads and stores are volatile (i.e., have compiler-invisible side-effects). <code class="language-plaintext highlighter-rouge">volatile</code> <em>can</em> be combined with atomic operations (e.g. <code class="language-plaintext highlighter-rouge">load atomic volatile</code>), although most languages don’t provide access to these (except older C++ versions).</p> <h3 id="reinterpret-shenanigans"><a href="#reinterpret-shenanigans">Reinterpret Shenanigans</a></h3> <p><code class="language-plaintext highlighter-rouge">bitcast</code> is what <code class="language-plaintext highlighter-rouge">mem::transmute</code> and <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> in Rust and C++, respectively, ultimately compile into. It can convert any non-aggregate type (integers, vectors) to any other type of the same bit width. For example, it can be used to get at the bits of a floating-point value:</p> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%bits</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span> <span class="nv">%fp</span> <span class="k">to</span> <span class="kt">i64</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:25">LLVM IR</a></div></div> <p>It also used to be what was used to cast pointer types (e.g. <code class="language-plaintext highlighter-rouge">i32*</code> to <code class="language-plaintext highlighter-rouge">i8*</code>). Pointers are now all untyped (<code class="language-plaintext highlighter-rouge">ptr</code>) so this use is no longer present.</p> <p>However, <code class="language-plaintext highlighter-rouge">bitcast</code> cannot cast between pointer and integer data. For this we must use the <code class="language-plaintext highlighter-rouge">inttoptr</code> and <code class="language-plaintext highlighter-rouge">ptrtoint</code><sup id="fnref:i2p" role="doc-noteref"><a href="#fn:i2p" class="footnote" rel="footnote">9</a></sup> instructions. These have the same syntax, but interact with the sketchy semantics of pointer-to-integer conversion and pointer provenance. This part of LLVM’s semantics is a bit of an ongoing trashfire; see <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">Ralf Jung’s post</a> for an introduction to this problem.</p> <h3 id="intrinsics"><a href="#intrinsics">Intrinsics</a></h3> <p>There is also a vast collection of LLVM intrinsics, which are specified in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>. For example, if we need a particular built-in memcpy, we can bring it into scope with a <code class="language-plaintext highlighter-rouge">declare</code>:</p> <div class="codeblock" id="code:26"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ptr %dst, ptr %src, i64 %len, i1 %volatile</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.memcpy.p0.p0.i64</span><span class="p">(</span><span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:26">LLVM IR</a></div></div> <p>All of the LLVM intrinsics are functions that start with <code class="language-plaintext highlighter-rouge">llvm.</code>; diving into all of them is far beyond what we can do here.</p> <p>I’m also leaving out discussion of floating point, SIMD, and exception handling, each of which would require their own articles!</p> <h2 id="undefined-behavior"><a href="#undefined-behavior">Undefined Behavior</a></h2> <p>LLVM exists to generate optimized code, and optimizations require that we declare certain machine states “impossible”, so that we can detect when we can simplify what the programmer has said. This is “undefined behavior”.</p> <p>For example, we’ve already encountered <code class="language-plaintext highlighter-rouge">unreachable</code>, which LLVM assumes cannot be executed. Division by zero and accessing memory out of bounds is also undefined.</p> <p>Most LLVM UB factors through the concept of “poisoned values”. A poison value can be thought of as “taking on every value at once”, whichever is convenient for the current optimization pass with no respect to any other passes. This also means that if optimizations <em>don’t</em> detect a use of poison, it is ok from LLVM’s perspective to give you a garbage value. This is most visible at <code class="language-plaintext highlighter-rouge">-O0</code>, which performs minimal optimization.</p> <p>Using a poison value as a pointer in a <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">store</code>, or <code class="language-plaintext highlighter-rouge">call</code> must be UB, because LLVM can choose it to be a null pointer. It also can’t be the denominator of a <code class="language-plaintext highlighter-rouge">udiv</code> or similar, because LLVM can choose it to be zero, which is UB. Passing poison into a <code class="language-plaintext highlighter-rouge">br</code> or a <code class="language-plaintext highlighter-rouge">switch</code> is also defined to be UB.</p> <p>LLVM can perform dataflow analysis to try to determine what operations a poisonous value that was used in a UB way came from, and thus assume those operations cannot produce poison. Because all operations (other than <code class="language-plaintext highlighter-rouge">select</code> and <code class="language-plaintext highlighter-rouge">phi</code>) with a poison input produce poison, backwards reasoning allows LLVM to propagate UB forward. This is where so-called “time traveling UB” comes from.</p> <p>Many operations generate poison. For example, in C, signed overflow is UB, so addition lowers to an <code class="language-plaintext highlighter-rouge">add nsw</code> (<code class="language-plaintext highlighter-rouge">nsw</code> stands for no signed wrap). Instead of wrapping on overflow, the instruction produces poison. There is also an unsigned version of the annotation, <code class="language-plaintext highlighter-rouge">nuw</code>.</p> <p>Many other operations have “less defined” versions, which are either generated by optimizations, or inserted directly by the compiler that invokes LLVM when the language rules allow it (see C above). More examples include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">udiv</code> and friends have an <code class="language-plaintext highlighter-rouge">exact</code> annotation, which requires that the division have a zero remainder, else poison.</li> <li><code class="language-plaintext highlighter-rouge">getelementptr</code> has an <code class="language-plaintext highlighter-rouge">inbounds</code> annotation, which produces poison if the access is actually out of bounds. This changes it from a pure arithmetic operation to one more closely matching C’s pointer arithmetic restrictions. GEP without <code class="language-plaintext highlighter-rouge">inbounds</code> corresponds to Rust’s <code class="language-plaintext highlighter-rouge">&lt;*mut T&gt;::wrapping_offset()</code> function.</li> <li>Floating point operations marked with <code class="language-plaintext highlighter-rouge">nnan</code> and <code class="language-plaintext highlighter-rouge">ninf</code> will produce poison instead of a NaN or an infinite value, respectively (or when a NaN or infinity is an argument).</li> </ul> <p>Creating poison is <em>not</em> UB; only using it is. This is weaker than the way UB works in most languages; in C, overflow is instantly UB, but in LLVM overflow that is never “witnessed” is simply ignored. This is a simpler operational semantics for reasoning about the validity of optimizations: UB must often be viewed as a side-effect, because the compiler will generate code that puts the program into a broken state. For example, division by zero will cause a fault in many architectures. This means UB-causing operations cannot always be reordered soundly. Replacing “causes UB” with “produces poison” ensures the vast majority of operations are pure and freely reorderable.</p> <h2 id="reading-some-codegen"><a href="#reading-some-codegen">Reading Some Codegen</a></h2> <p>Let’s go back to our original Rust example!</p> <div class="codeblock" id="code:27"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:27">Rust</a></div></div> <p>This is the output, with metadata redacted and some things moved around for readability.</p> <div class="codeblock" id="code:28"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">source_filename</span> <span class="p">=</span> <span class="s">"example.b6eb2c7a6b40b4d2-cgu.0"</span>
<span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"</span>
<span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">"x86_64-unknown-linux-gnu"</span>

<span class="c1">; example::square</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@_ZN7example6square17hb32bcde4463f37c3E</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span>
  <span class="nv">%_2.0</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%_2.1</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span> <span class="nv">%_2.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="k">false</span><span class="p">)</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%panic</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb1</span>

<span class="nl">bb1:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%_2.0</span>

<span class="nl">panic:</span>
  <span class="c1">; core::panicking::panic</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span> <span class="vg">@str.0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="m">33</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span> <span class="vg">@alloc_1368addac7d22933d93af2809439e507</span>
  <span class="p">)</span>
  <span class="k">unreachable</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">)</span> <span class="vg">#1</span>
<span class="k">declare</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span> <span class="vg">#2</span>

<span class="c1">; core::panicking::panic</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span><span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#3</span>

<span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"/app/example.rs"</span> <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">1</span>

<span class="vg">@alloc_1368addac7d22933d93af2809439e507</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="err">ptr</span><span class="p">,</span> <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span> <span class="p">&lt;{</span>
    <span class="err">ptr</span> <span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span><span class="p">,</span>
    <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"\0F\00\00\00\00\00\00\00\02\00\00\00\03\00\00\00"</span>
  <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">8</span>

<span class="vg">@str.0</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">33</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"attempt to multiply with overflow"</span>

<span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#1</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">speculatable</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#2</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#3</span> <span class="p">=</span> <span class="p">{</span> <span class="k">cold</span> <span class="k">noinline</span> <span class="k">noreturn</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:28">LLVM IR</a></div></div> <p>The main function is <code class="language-plaintext highlighter-rouge">@_ZN7example6square17hb32bcde4463f37c3E</code>, which is the mangled name of <code class="language-plaintext highlighter-rouge">example::square</code>. Because this code was compiled in debug mode, overflow panics, so we need to generate code for that. The first operation is a <code class="language-plaintext highlighter-rouge">call</code> to the LLVM intrinsic for “multiply and tell us if it overflowed”. This returns the equivalent of a <code class="language-plaintext highlighter-rouge">(i32, bool)</code>; we extract both value out of it with <code class="language-plaintext highlighter-rouge">extractvalue</code>. We then pass the bool through <code class="language-plaintext highlighter-rouge">@llvm.expect</code>, which is used to tell the optimizer to treat the panicking branch as “cold”. The success branch goes to a return, which returns the product; otherwise, we go to a function that calls <code class="language-plaintext highlighter-rouge">core::panicking::panic()</code> to panic the current thread. This function never returns, so we can terminate the block with an <code class="language-plaintext highlighter-rouge">unreachable</code>.</p> <p>The rest of the file consists of:</p> <ul> <li><code class="language-plaintext highlighter-rouge">declare</code>s for the llvm intrinsics we used.</li> <li>A <code class="language-plaintext highlighter-rouge">declare</code> for <code class="language-plaintext highlighter-rouge">core::panicking::panic</code>. Any external function we call needs to be <code class="language-plaintext highlighter-rouge">declare</code>d. This also gives us a place to hang attributes for the function off of.</li> <li>Global constants for a <code class="language-plaintext highlighter-rouge">core::panic::Location</code> and a panic message.</li> <li>Attributes for the functions above.</li> </ul> <p>This is a good place to mention attributes: LLVM has all kinds of attributes that can be placed on functions (and function calls) to record optimization-relevant information. For example, <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code> is annotated as <code class="language-plaintext highlighter-rouge">willreturn</code>, which means this function will eventually return; this means that, for example, any UB that comes after the function is guaranteed to occur after finite time, so LLVM can conclude that the code is unreachable despite the call to <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code>. The full set of attributes is vast, but the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> documents all of them!</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>LLVM IR is huge, bigger than any individual ISA, because it is intended to capture <em>every</em> interesting operation. It also has a rich annotation language, so passes can record information for future passes to make use of. Its operational semantics attempt to leave enough space for optimizations to occur, while ensuring that multiple sound optimizations in sequence are not unsound (this last part is a work in progress).</p> <p>Being able to read assembly reveals what will happen, exactly, when code is executed, but reading IR, before and after optimization, shows how the compiler is <em>thinking</em> about your code. Using <code class="language-plaintext highlighter-rouge">opt</code> to run individual optimization passes can also help further this understanding (in fact, “bisecting on passes” is a powerful debugging technique in compiler development).</p> <p>I got into compilers by reading LLVM IR. Hopefully this article inspires you to learn more, too!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:numeric-names" role="doc-endnote"> <p>Registers within a function may have a numeric name. They must be defined in order: you must define <code class="language-plaintext highlighter-rouge">%0</code> (either as a register or a label), then <code class="language-plaintext highlighter-rouge">%1</code>, then <code class="language-plaintext highlighter-rouge">%2</code>, etc. These are often used to represent “temporary results”.</p> <p>If a function does not specify names for its parameters, they will be given the names <code class="language-plaintext highlighter-rouge">%0</code>, <code class="language-plaintext highlighter-rouge">%1</code>, etc implicitly, which affect what the first explicit numeric register name you can use is. Similarly, if the function does not start with a label, it will be implicitly be given the next numeric name.</p> <p>This can result in significant confusion, because if we have <code class="language-plaintext highlighter-rouge">define void @foo(i32, i32) { ... }</code>, the arguments will be <code class="language-plaintext highlighter-rouge">%0</code> and <code class="language-plaintext highlighter-rouge">%1</code>, but if we tried to write <code class="language-plaintext highlighter-rouge">%2 = add i32 %0, %1</code>, we would get an extremely confusing parser error, because <code class="language-plaintext highlighter-rouge">%2</code> is already taken as the name of the first block. <a href="#fnref:numeric-names" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:divz" role="doc-endnote"> <p>For some reason, the optimizer can’t figure out that the <code class="language-plaintext highlighter-rouge">select</code> is redundant? Alive2 (an SMT-solver correctness checker for optimizations) <a href="https://alive2.llvm.org/ce/z/7nLDRe">seems to agree</a> this is a valid optimization.</p> <p><a href="https://github.com/llvm/llvm-project/issues/64240">So I’ve filed a bug.</a> :D <a href="#fnref:divz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:br-on-real-machines" role="doc-endnote"> <p>If you read my assembly article, you’ll recall that there are many branch instructions. On RV, we have <code class="language-plaintext highlighter-rouge">beq</code>, <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">bgt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>. Later on in the compilation process, after the optimizer runs, LLVM will perform <em>instruction selection</em> (isel) to choose the best machine instruction(s) to implement a particular LLVM instruction (or sequence), which is highly context-dependent: for example, we want to fuse an <code class="language-plaintext highlighter-rouge">icmp eq</code> followed by a <code class="language-plaintext highlighter-rouge">br</code> on the result into a <code class="language-plaintext highlighter-rouge">beq</code>.</p> <p>Isel is far outside my wheelhouse, and doing it efficiently and profitably is an active area of academic research. <a href="#fnref:br-on-real-machines" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:frontend-optimization" role="doc-endnote"> <p>Not exactly the same: language frontends like Clang and Rust will perform their own optimizations. For example, I have an <a href="https://github.com/llvm/llvm-project/issues/59484">open bug</a> for LLVM being unable to convert <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> into <code class="language-plaintext highlighter-rouge">&amp;</code> in some cases; this was never noticed, because Clang performs this optimization while lowering from C/C++ to LLVM, but Rust does not do the equivalent optimization. <a href="#fnref:frontend-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:block-args" role="doc-endnote"> <p>A more intuitive model is used in more modern IRs, like MLIR. In MLIR, you cannot use variables defined in other blocks; instead, each block takes a set of <em>arguments</em>, just like a function call. This is equivalent to <code class="language-plaintext highlighter-rouge">phi</code> instructions, except that now instead of selecting which value we want in the target, each predecessor specifies what it wants to send to the target.</p> <p>If we instead treat each block as having “arguments”, we can rewrite it in the following fantasy syntax where register names are scoped to their block.</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">;; Not actual LLVM IR! ;;</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">)</span>

<span class="err">loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="nv">%exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">),</span> <span class="nv">%loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">LLVM IR</a></div></div> <p><a href="#fnref:block-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:viz" role="doc-endnote"> <p>What does the CFG look like? LLVM contains “optimization” passes that print the CFG as a file as a <code class="language-plaintext highlighter-rouge">.dot</code> file, which can be rendered with the <code class="language-plaintext highlighter-rouge">dot</code> command. For <code class="language-plaintext highlighter-rouge">@safe_div</code>, we get something like the following.</p> <figure style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/safe_div.svg" alt=""/></p> </figure> <p>This is useful for understanding complex functions. Consider this Rust hex-parsing function.</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// hex.rs</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">parse_hex</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0u64</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.bytes</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">digit</span> <span class="o">=</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'f'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'F'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'A'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_mul</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_add</span><span class="p">(</span><span class="n">digit</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Rust</a></div></div> <p>Then, we can generate our CFG with some shell commands.</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>rustc <span class="nt">-O</span> <span class="nt">--crate-type</span> lib <span class="nt">--emit</span> llvm-ir hex.rs
<span class="nv">$ </span>opt <span class="nt">-p</span> dot-cfg <span class="nt">-o</span> /dev/null hex.ll
Writing <span class="s1">'.parse_hex.dot'</span>...
<span class="nv">$ </span>dot <span class="nt">-Tsvg</span> .parse_hex.dot <span class="nt">-o</span> parse_hex.svg</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Shell</a></div></div> <p>The result is this mess.</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex.svg" alt=""/></p> </div> <p>Without optimizations, we get a bigger mess (most optimization passes are various CFG cleanups).</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex_unopt.svg" alt=""/></p> </div> <p>Exercise: try to trace through what each basic block is doing. You will want to open the SVGs in a separate tab to do that. I recommend following the optimized version, since it is much less noisy.</p> <p>Comparing optimized vs. unoptimized is a good way to see how much the compiler does to simplify the stuff the language frontend gives it. At -O0? All allocas. At -O2? No allocas! <a href="#fnref:viz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:typed-pointers" role="doc-endnote"> <p>Once upon a time we had typed pointers, like <code class="language-plaintext highlighter-rouge">i32*</code>. These turned out to generate more problems than they solved, requiring frequent casts in IR in exchange for mediocre type safety. See <a href="https://llvm.org/docs/OpaquePointers.html">https://llvm.org/docs/OpaquePointers.html</a> for a more complete history. <a href="#fnref:typed-pointers" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:sarcasm" role="doc-endnote"> <p>Sarcasm. <a href="#fnref:sarcasm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i2p" role="doc-endnote"> <p>I quietly judge LLVM for having instructions named <code class="language-plaintext highlighter-rouge">inttoptr</code> when <code class="language-plaintext highlighter-rouge">int2ptr</code> just reads so much nicer. <a href="#fnref:i2p" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-05-11 • 2076 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/05/11/sam-closures/"> Single Abstract Method Traits </a></h1> </div> <div class="post"> <p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">C++</a></div></div> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">C++</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Rust</a></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Rust</a></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Java gets a bad rap but the core language does have some interesting features in it. A very handy one is an <em>anonymous class</em>.</p> <p>Let’s suppose I want to pass a callback into something. In Java 6, which I grew up on, you did it like this:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Java</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Interface() {...}</code> syntax mints a new class on the spot that implements <code class="language-plaintext highlighter-rouge">Interface</code>. You provide a standard class body between the braces, after the name of the type. You can also do this with a class type too.</p> <p>Now, this is a bit tedious: I need to re-type the signature of the one method. This is fine if I need to implement a bunch of methods, but it’s a little annoying in the one-method case.</p> <p>In Java 8 we got lambdas (syntax: <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>). Java made the interesting choice of not adding a <code class="language-plaintext highlighter-rouge">Function</code> type to be “the type of lambdas”. For a long time I thought this was a weird cop-out but I have since come to regard it as a masterclass in language design.</p> <p>Instead, Java’s lambdas are a sort of syntax sugar over this anonymous class syntax.<sup id="fnref:invokedynamic" role="doc-noteref"><a href="#fn:invokedynamic" class="footnote" rel="footnote">1</a></sup> Instead, you need to assign a lambda to an interface type with a single abstract method, and it will use the body of the lambda to implement that one method.</p> <p>Interfaces compatible with lambdas are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Java</a></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation, which must satisfy the following constraints:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the aforementioned <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts and no GATs.</li> <li>All of its supertraits are <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, or <code class="language-plaintext highlighter-rouge">Sync</code>.</li> </ol> <p>These restrictions are chosen so that we have a shot at actually implementing the entire trait.</p> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, ordinary closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate.</p> <p>None of these traits are SAM, so we can safely allow them to be automatically derived for SAM closures to, under the same rules as for ordinary closures.</p> </blockquote> <p>To request a SAM closure, I will use the tentative syntax of <code class="language-plaintext highlighter-rouge">impl Trait |args| expr</code>. This syntax is unambiguously an expression rather than an <code class="language-plaintext highlighter-rouge">impl</code> item, because a <code class="language-plaintext highlighter-rouge">|</code> cannot appear in a path-in-type, and <code class="language-plaintext highlighter-rouge">impl $path</code> must be followed by <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">where</code>. The precise syntax is unimportant.</p> <p>Applied to the <code class="language-plaintext highlighter-rouge">call_many</code> example above, we get this.</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="n">Callback</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p>The compiler rewrites this into something like this.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">CallbackImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CallbackImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CallbackImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Rust</a></div></div> <p>This rewrite can happen relatively early, before we need to infer a type for <code class="language-plaintext highlighter-rouge">x</code>. We also need to verify that this trait’s captures are compatible with an <code class="language-plaintext highlighter-rouge">&amp;self</code> receiver The same rules for when a trait implements <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code> would decide which of the three receiver types the closure is compatible with.</p> <p>Note that SAM closures WOULD NOT implement any <code class="language-plaintext highlighter-rouge">Fn</code> traits.</p> <h3 id="more-complicated-examples"><a href="#more-complicated-examples">More Complicated Examples</a></h3> <p>We are required to name the trait we want but its type parameters can be left up in the air. For example:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Out</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Display</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Out</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// We can infer `T = i32` and `Tr::Out = String`.</span>
<span class="k">let</span> <span class="n">tr</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Rust</a></div></div> <p>In general, unspecified parameters and associated types result in inference variables, which are resolved in the same way as the parameters of the <code class="language-plaintext highlighter-rouge">Fn</code> closures are.</p> <p>In fact, we can emulate ordinary closures using SAM closures.</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.map</span><span class="p">(</span><span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">_</span> <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Rust</a></div></div> <p>Note that because <code class="language-plaintext highlighter-rouge">Fn</code> and <code class="language-plaintext highlighter-rouge">FnMut</code> have non-trival supertraits we can’t make them out of SAM closures.</p> <p>One application is to completely obsolete <code class="language-plaintext highlighter-rouge">std::iter::from_fn</code>.</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">u64</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Copy</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Rust</a></div></div> <p>Or, if you need a quick helper implementation of <code class="language-plaintext highlighter-rouge">Debug</code>…</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="n">f</span><span class="nf">.debug_list</span><span class="p">()</span>
    <span class="nf">.entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">impl</span> <span class="n">Debug</span> <span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"something something {}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.next_thingy</span><span class="p">())</span>
    <span class="p">})</span>
    <span class="nf">.finish</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Rust</a></div></div> <p>There are probably additional restrictions we will want to place on the SAM trait, but it’s not immediately clear what the breadth of those are. For example, we probably shouldn’t try to make this work:</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">UniversalFactory</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">make</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">UniversalFactory</span> <span class="p">||</span> <span class="p">{</span>
  <span class="c1">// How do I name T so that I can pass it to size_of?</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">Rust</a></div></div> <p>There are definitely clever tricks you <em>can</em> play to make this work, but the benefit seems slim.</p> <h2 id="future-work"><a href="#future-work">Future Work</a></h2> <p>There’s two avenues for how we could extend this concept. The first is straightforward and desireable; the second is probably unimplementable.</p> <h3 id="anonymous-trait-impls"><a href="#anonymous-trait-impls">Anonymous Trait Impls</a></h3> <p>Backing up from the Java equivalent of lambdas, it seems not unreasonable to have a full-fledged expression version of <code class="language-plaintext highlighter-rouge">impl</code> that can make captures.</p> <p>Syntactically, I will use <code class="language-plaintext highlighter-rouge">impl Trait for { ... }</code>. This is currently unambiguous, although I think that making it so that <code class="language-plaintext highlighter-rouge">{</code> cannot start a type is probably a non-starter.</p> <p>Let’s pick something mildly complicated… like <code class="language-plaintext highlighter-rouge">Iterator</code> with an overriden method. Then we might write something like this.</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">[</span><span class="o">...</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iterator</span> <span class="o">=</span> <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="o">*</span><span class="n">my_list</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">my_list</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">Rust</a></div></div> <p>The contents of the braces after <code class="language-plaintext highlighter-rouge">for</code> is an item list, except that variables from the outside are available, having the semantics of captures; they are, in effect, accesses of <code class="language-plaintext highlighter-rouge">self</code> without the <code class="language-plaintext highlighter-rouge">self.</code> prefix.</p> <p>Hammering out precisely how this would interact with the self types of the functions in the body seems… complicated. Pretty doable, just fussy. There are also awkward questions about what <code class="language-plaintext highlighter-rouge">Self</code> is here and to what degree you’re allowed to interact with it.</p> <h3 id="trait-inference"><a href="#trait-inference">Trait Inference</a></h3> <p>Suppose that we could instead “just” write <code class="language-plaintext highlighter-rouge">impl |x| x * x</code> and have the compiler figure out what trait we want (to say nothing of making this the default behavior and dropping the leading <code class="language-plaintext highlighter-rouge">impl</code> keyword).</p> <p>This means that I could just write</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">Rust</a></div></div> <p>We get into trouble fast.</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">Rust</a></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <p>Currently, rustc does not have to produce impls “on demand”; the trait solver has a finite set of impls to look at. What we are asking the trait solver to do is to, for certain types, attempt to reify impls based on <em>usage</em>. I.e., I have my opaque closure type <code class="language-plaintext highlighter-rouge">T</code> and I the compiler decided it needed to prove a <code class="language-plaintext highlighter-rouge">T: Foo</code> bound so now it gets to perform type checking to validate whether it has an <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>This seems unimplementable with how the solver currently works. It is not insurmountable! But it would be very hard.</p> <p>It is possible that there are relaxations of this that are not insane to implement, e.g. the <code class="language-plaintext highlighter-rouge">impl ||</code> expression is used to initialize an argument to a function that happens to be generic, so we can steal the bounds off of that type variable and hope it’s SAM. But realistically, this direction is more trouble than its worth.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:invokedynamic" role="doc-endnote"> <p>Except for the part where they are extremely not. Where <code class="language-plaintext highlighter-rouge">new T() {}</code> mints a brand new class and accompanying <code class="language-plaintext highlighter-rouge">.class</code> file, Java lambdas use this complicated machinery from Java 7 to generate method handles on the fly, via the <code class="language-plaintext highlighter-rouge">invokedynamic</code> JVM instruction. This, I’m told, makes them much easier to optimize. <a href="#fnref:invokedynamic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-04-04 • 1311 words • 14 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/04/04/trait-rez-wishlist/"> Better Trait Resolution in Rust </a></h1> </div> <div class="post"> <p>Traits are the core of polymorphism in Rust. Let’s review:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{self}"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Prints `42`.</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="mi">42</span><span class="nf">.string</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xudHJhaXQgU3RyaW5nZXIge1xuICBmbiBz dHJpbmcoJnNlbGYpIC0+IFN0cmluZztcbn1cblxuaW1wbCBTdHJpbmdlciBm b3IgaTMyIHtcbiAgZm4gc3RyaW5nKCZzZWxmKSAtPiBTdHJpbmcge1xuICAg IGZvcm1hdCEoXCJ7c2VsZn1cIilcbiAgfVxufVxuXG4vLyBQcmludHMgYDQy YC5cbnByaW50bG4hKFwie31cIiwgNDIuc3RyaW5nKCkpO1xufVxuIiwiY29t cGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlclZpc2libGUiOmZh bHNlLCJjb21waWxlck91dHB1dFZpc2libGUiOnRydWUsImNvbXBpbGVyIjp7 ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiIifX1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:1">Rust</a></div></div> <p>Notice that we call the trait method <code class="language-plaintext highlighter-rouge">Stringer::string</code> directly on the value in question. This means that traits (at least, those currently in scope) inject their methods into the namespace of anything that implements them.</p> <p>Now, this isn’t immediately a problem, because Rust’s namespace lookup rules are such that methods <em>inherent</em> to a type are searched for first:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Woofer</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"woof"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"bark"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Prints `bark`.</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">Woofer</span><span class="nf">.string</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xudHJhaXQgU3RyaW5nZXIge1xuICBmbiBz dHJpbmcoJnNlbGYpIC0+IFN0cmluZztcbn1cblxuc3RydWN0IFdvb2Zlcjtc bmltcGwgU3RyaW5nZXIgZm9yIFdvb2ZlciB7XG4gIGZuIHN0cmluZygmc2Vs ZikgLT4gU3RyaW5nIHtcbiAgICBmb3JtYXQhKFwid29vZlwiKVxuICB9XG59 XG5cbmltcGwgV29vZmVyIHtcbiAgZm4gc3RyaW5nKCZzZWxmKSAtPiBTdHJp bmcge1xuICAgIGZvcm1hdCEoXCJiYXJrXCIpXG4gIH1cbn1cblxuLy8gUHJp bnRzIGBiYXJrYC5cbnByaW50bG4hKFwie31cIiwgV29vZmVyLnN0cmluZygp KTtcbn1cbiIsImNvbXBpbGVycyI6W10sImV4ZWN1dG9ycyI6W3siY29tcGls ZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJPdXRwdXRWaXNpYmxlIjp0cnVl LCJjb21waWxlciI6eyJpZCI6ImJldGEiLCJvcHRpb25zIjoiIn19XX1dfQ== ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <p>This means that traits cannot <em>easily</em> break downstream code by adding new methods, but there are a few possible hazards:</p> <ul> <li> <p>If the owner of a type adds a method with the same name as a trait method, it will override direct (i.e., <code class="language-plaintext highlighter-rouge">foo.string()</code>) calls to that trait method, even if the type owner is unaware of the trait method.</p> </li> <li> <p>If traits <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are in scope, and <code class="language-plaintext highlighter-rouge">String</code> implements both, and we call <code class="language-plaintext highlighter-rouge">str.foo()</code> (which resolves to <code class="language-plaintext highlighter-rouge">A::foo()</code>), and later <code class="language-plaintext highlighter-rouge">B</code> adds a new method <code class="language-plaintext highlighter-rouge">B::foo()</code>, the callsite for <code class="language-plaintext highlighter-rouge">String</code> will break. <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>’s owners do not need to be aware of each other for this to happen.</p> </li> </ul> <p>Of course, Rust has a disambiguation mechanism. Given any trait implementation <code class="language-plaintext highlighter-rouge">Foo: Bar</code>, we can reference its items by writing <code class="language-plaintext highlighter-rouge">&lt;Foo as Bar&gt;::baz</code>. However, this syntax is <em>very</em> unweildy (it doesn’t work with method chaining), so it doesn’t get used. As a result, small evolution hazards can build up in a large codebase.</p> <p>Those who know me know that I often talk about a syntax that I call <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>, or “qualified method call syntax”. In this post, I want to discuss this syntax in more detail, and some related ideas, and how they factor into type and trait design.</p> <h2 id="paths-as-methods"><a href="#paths-as-methods">Paths-as-Methods</a></h2> <p>This idea isn’t new; others have proposed it, and it forms the core of Carbon’s version of trait method calls (you can read more about Carbon’s name lookup story <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/member_access.md">here</a>).</p> <p>Let’s recreate the original example in Carbon (bear in mind that I am not an expert on this language, and the semantics are still up in the air).</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">interface</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">external</span> <span class="k">impl</span> <span class="nb">i32</span> <span class="k">as</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Carbon</span><span class="nf">.Print</span><span class="p">(</span><span class="mf">42.</span><span class="p">(</span><span class="n">Stringer</span><span class="py">.String</span><span class="p">)())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Carbon</a></div></div> <p>Notice <code class="language-plaintext highlighter-rouge">42.(Stringer.String)()</code>: Carbon <em>requires</em> that we qualify the method call, because <code class="language-plaintext highlighter-rouge">42</code> has the concrete type <code class="language-plaintext highlighter-rouge">i32</code>. If this were in a generic context and we had a type variable bounded by <code class="language-plaintext highlighter-rouge">Stringer</code>, we could just write <code class="language-plaintext highlighter-rouge">x.String()</code>; no ambiguity.</p> <p>In Carbon, all qualification uses <code class="language-plaintext highlighter-rouge">.</code>, so they have to add parens. Because Rust uses <code class="language-plaintext highlighter-rouge">::</code> for qualifying paths, we don’t have this syntactic abiguity, so we can augment the syntax to allow more path expressions after the <code class="language-plaintext highlighter-rouge">.</code>.</p> <p>The current grammar is</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-text" data-lang="text">MethodCallExpression :
   Expression . PathExprSegment (CallParams?)

PathExprSegment :
   PathIdentSegment (:: GenericArgs)?</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Plaintext</a></div></div> <p>That is, exactly one identifier and an optional turbofish. I would like to see this extended to allow any <code class="language-plaintext highlighter-rouge">QualifiedPathInExpression</code> after the <code class="language-plaintext highlighter-rouge">.</code> and before the parens. This would allow, for example:</p> <ul> <li><code class="language-plaintext highlighter-rouge">expr.Trait::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.Self::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.&lt;Foo as Trait&gt;::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.::path::to::Trait::&lt;Args&gt;::method::&lt;MoreArgs&gt;()</code></li> </ul> <p>These would all be desugared as the equivalent UFCS, taking into account that method call syntax can trigger autoref.</p> <ul> <li><code class="language-plaintext highlighter-rouge">Trait::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">Self::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">&lt;Foo as Trait&gt;::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">::path::to::Trait::&lt;Args&gt;::method::&lt;MoreArgs&gt;(expr)</code></li> </ul> <p>The method would still need to be valid to have been called via <code class="language-plaintext highlighter-rouge">.</code> syntax; I’m not proposing we add the following, even though it is unambiguous.</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span>

<span class="c1">// Would be equivalent to `square(42)`.</span>
<span class="mi">42</span><span class="py">.self</span><span class="p">::</span><span class="nf">square</span><span class="p">()</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>Trait method callers can now use qualified method call syntax where they might want to use UFCS without issues around wordiness.</p> <h2 id="impl-modality"><a href="#impl-modality">Impl Modality</a></h2> <p>Of course, this isn’t the only idea from Carbon’s interfaces worth stealing; Carbon also has a notion of “external” and “internal” <code class="language-plaintext highlighter-rouge">impl</code>s; I will call these “<code class="language-plaintext highlighter-rouge">impl</code> modes”.</p> <p>An external <code class="language-plaintext highlighter-rouge">impl</code> is like the one we showed above, whose methods can only be found by qualified lookup: <code class="language-plaintext highlighter-rouge">foo.(Bar.Baz)()</code>. An internal <code class="language-plaintext highlighter-rouge">impl</code> is one which is “part” of a type.</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">interface</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">class</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">impl</span> <span class="k">as</span> <span class="n">Stringer</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">w</span><span class="p">:</span> <span class="n">Woofer</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
  <span class="n">w</span><span class="nf">.String</span><span class="p">()</span>  <span class="c1">// Unqualified!</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Carbon</a></div></div> <p>This also implies that we don’t need to import <code class="language-plaintext highlighter-rouge">Stringer</code> to call <code class="language-plaintext highlighter-rouge">w.String()</code>.</p> <p>There are definitely traits in Rust which fit into these modes.</p> <p><code class="language-plaintext highlighter-rouge">Clone</code> and <code class="language-plaintext highlighter-rouge">Iterator</code> almost always want to be internal. An iterator exists to implement <code class="language-plaintext highlighter-rouge">Iterator</code>, and cloning is a fundamental operation. Because both of these traits are in the prelude, it’s not a problem, but it is a problem for traits provided by a non-<code class="language-plaintext highlighter-rouge">std</code> crate, like <a href="https://docs.rs/rand/latest/rand/trait.Rng.html"><code class="language-plaintext highlighter-rouge">rand::Rng</code></a>. The lack of a way to do this leads to the proliferation of <code class="language-plaintext highlighter-rouge">prelude</code> modules and namespace pollution. (I think that <code class="language-plaintext highlighter-rouge">prelude</code>s are bad library design.)</p> <p>On the other hand, something like <code class="language-plaintext highlighter-rouge">Debug</code> wants to be external very badly. It almost never makes sense to call <code class="language-plaintext highlighter-rouge">foo.fmt()</code>, since that gets called for you by <code class="language-plaintext highlighter-rouge">println!</code> and friends; not to mention that all of the <code class="language-plaintext highlighter-rouge">std::fmt</code> traits have a method <code class="language-plaintext highlighter-rouge">fmt()</code>, making such a call likely to need disambiguation with UFCS. <code class="language-plaintext highlighter-rouge">Borrow</code> is similar; it exists to be a bound for things like <code class="language-plaintext highlighter-rouge">Cow</code> more than to provide the <code class="language-plaintext highlighter-rouge">.borrow()</code> method.</p> <p>There’s also a third mode, which I will call “extension impls”. These want to inject methods into a type, either to extend it, like <a href="https://docs.rs/itertools/latest/itertools/"><code class="language-plaintext highlighter-rouge">itertools</code></a>, or as part of some framework, like <a href="https://docs.rs/tap/latest/tap/"><code class="language-plaintext highlighter-rouge">tap</code></a>. This use of traits is somewhat controversial, but I can sympathize with wanting to have this.</p> <p>If we have paths-as-methods, we can use this classification to move towards something more like the Carbon model of method lookup, without impacting existing uses.</p> <p>My strawman is to add a <code class="language-plaintext highlighter-rouge">#[mode]</code> attribute to place on trait <code class="language-plaintext highlighter-rouge">impls</code>, which allows a caller to select the behavior:</p> <ul> <li><code class="language-plaintext highlighter-rouge">#[mode(extension)]</code> is today’s behavior. The <code class="language-plaintext highlighter-rouge">impl</code>’s trait must be in scope so that unqualified calls like <code class="language-plaintext highlighter-rouge">foo.method()</code> resolve to it.</li> <li><code class="language-plaintext highlighter-rouge">#[mode(internal)]</code> makes it so that <code class="language-plaintext highlighter-rouge">foo.method()</code> can resolve to a method from this <code class="language-plaintext highlighter-rouge">impl</code> without its trait being in scope<sup id="fnref:internal-restrictions" role="doc-noteref"><a href="#fn:internal-restrictions" class="footnote" rel="footnote">1</a></sup>. It can only be applied to <code class="language-plaintext highlighter-rouge">impl</code>s that are such that you could write a corresponding inherent impl, so things like <code class="language-plaintext highlighter-rouge">#[mode(internal)] impl&lt;T&gt; Trait for T { .. }</code> are forbidden.</li> <li><code class="language-plaintext highlighter-rouge">#[mode(external)]</code> makes it so that <code class="language-plaintext highlighter-rouge">foo.method()</code> never resolves to a method from this <code class="language-plaintext highlighter-rouge">impl</code>. It must be called as <code class="language-plaintext highlighter-rouge">Trait::method(foo)</code> or <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>.</li> </ul> <p>Every trait would be <code class="language-plaintext highlighter-rouge">#[mode(extension)]</code> if not annotated, and it would be easy to migrate to external-by-default across an edition. Similarly, we could change whether a <code class="language-plaintext highlighter-rouge">std</code> impl is external vs extension based on the edition of the caller, and provide a <code class="language-plaintext highlighter-rouge">cargo fix</code> rewrite to convert from <code class="language-plaintext highlighter-rouge">foo.method()</code> to <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>.</p> <p>It may also make sense for traits to be able to specify the default modality of their <code class="language-plaintext highlighter-rouge">impl</code>s, but I haven’t thought very carefully about this.</p> <p>Note that moving in the external -&gt; extension -&gt; internal direction is not a breaking change, but moving the other way is.</p> <h2 id="what-about-delegation"><a href="#what-about-delegation">What about Delegation?</a></h2> <p>A related feature that I will touch on lightly is delegation; that is, being able to write something like the following:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// crate a</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">boing</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// crate b</span>
<span class="k">trait</span> <span class="n">Bar</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">boing</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Bar</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nn">Foo</span><span class="p">::</span><span class="n">boing</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">use</code> in the <code class="language-plaintext highlighter-rouge">impl</code> indicates that we want to re-use <code class="language-plaintext highlighter-rouge">Foo::boing</code> to implement <code class="language-plaintext highlighter-rouge">&lt;Foo as Bar&gt;::boing</code>. This saves us having to write out a function signature, and results in less work for the compiler because that’s one less function we risk asking LLVM to codegen for us (at scale, this is a Big Deal).</p> <p>You could imagine using delegation instead of <code class="language-plaintext highlighter-rouge">#[mode]</code>:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Woofer</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"woof"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nn">Stringer</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>The reason I haven’t gone down this road is because delegation is a very large feature, and doesn’t give us a clean way to express <code class="language-plaintext highlighter-rouge">#[mode(external)]</code>, which is a big part of what I want. A delegation-compatible way to express this proposal is to not add <code class="language-plaintext highlighter-rouge">#[mode(internal)]</code>, and add <code class="language-plaintext highlighter-rouge">use Trait::method;</code> and <code class="language-plaintext highlighter-rouge">use Trait::*;</code> (and no other variations) inside of inherent <code class="language-plaintext highlighter-rouge">impl</code> blocks.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>I don’t have the personal bandwidth to write RFCs for any of this stuff, but it’s something I talk about a lot as a potential evolution hazard for Rust. I hope that putting these ideas to paper can help make name resolution in Rust more robust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:internal-restrictions" role="doc-endnote"> <p>This needs to carry a bunch of other restrictions, because it’s equivalent to adding inherent methods to the implee. For example, none of the methods can have the same name as a method in any other inherent or internal impl block, and internal impl methods should take lookup priority over extension impl methods during name lookup. <a href="#fnref:internal-restrictions" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-03-29 • 2769 words • 30 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#concurrency">#concurrency</a> • <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/03/29/rseq-checkout/"> Atomicless Concurrency </a></h1> </div> <div class="post"> <p>Let’s say we’re building an allocator. Good allocators need to serve many threads simultaneously, and as such any lock they take is going to be highly contended. One way to work around this, pioneered by TCMalloc, is to have thread-local caches of blocks (hence, the “TC” - thread cached).</p> <p>Unfortunately threads can be ephemeral, so book-keeping needs to grow dynamically, and large, complex programs (like the Google Search ranking server) can have tens of thousands of threads, so per-thread cost can add up. Also, any time a thread context-switches and resumes, its CPU cache will contain different cache lines – likely the wrong ones. This is because either another thread doing something compeltely different executed on that CPU, or the switched thread <em>migrated</em> to execute on a different core.</p> <p>These days, instead of caching per-thread, TCMalloc uses <em>per-CPU</em> data. This means that book-keeping is fixed, and this is incredibly friendly to the CPU’s cache: in the steady-state, each piece of the data will only ever be read or written to by a single CPU. It also has the amazing property that <em>there are no atomic operations involved</em> in the fast path, because operations on per-CPU data, by definition, do not need to be synchronized with other cores.</p> <p>This post gives an overview of how to build a CPU-local data structure on modern Linux. The exposition will be for x86, but other than the small bits of assembly you need to write, the technique is architecture-independent.</p> <h2 id="the-kernel-primitive"><a href="#the-kernel-primitive">The Kernel Primitive</a></h2> <p>Concurrency primitives require cooperating with the kernel, which is responsible for global scheduling decisions on the system. However, making syscalls is quite expensive; to alieviate this, there has been a trend in Linux to use shared memory as a kernelspace/userspace communication channel.</p> <p><a href="https://en.wikipedia.org/wiki/Futex">Futexes</a> are the classic “cas-with-the-kernel” syscall (I’m assuming basic knowledge of atomic operations like cas in this article). In the happy path, we just need to cas on some memory to lock a futex, and only make a syscall if we need to go to sleep because of contention. The kernel will perform its own cas on this variable if necessary.</p> <p><em>Restartable sequences</em> are another such proto-primitive, which are used for per-CPUuprogramming. The relevant syscall for us, <code class="language-plaintext highlighter-rouge">rseq(2)</code>, was added in Linux 4.18. Its manpage reads</p> <blockquote id="ref:1" class="ref"> <p><a href="#ref:1"><span class="chip">reference</span></a></p> <p>A restartable sequence is a sequence of instructions guaranteed to be executed atomically with respect to other threads and signal handlers on the current CPU. If its execution does not complete atomically, the kernel changes the execution flow by jumping to an abort handler defined by userspace for that restartable sequence.</p> </blockquote> <p>A restartable sequence, or “rseq” is a special kind of critical section that the kernel guarantees executes from start to finish without any kind of preemption. If preemption <em>does</em> happen (because of a signal or whatever), userspace observes this as a jump to a special handler for that critical section. Conceptually it’s like handling an exception:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">try</span> <span class="p">{</span>
  <span class="c1">// Per-CPU code here.</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">PremptionException</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Handle having been preempted, which usally just means</span>
  <span class="c1">// "try again".</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">C++</a></div></div> <p>These critical sections are usually of the following form:</p> <ol> <li>Read the current CPU index (the rseq mechanism provides a way to do this).</li> <li>Index into some data structure and do something to it.</li> <li>Complete the operation with a single memory write. This is the “commit”.</li> </ol> <p>All the kernel tells us is that we couldn’t finish successfully. We can always try again, but the critical section needs to be such that executing any prefix of it, up to the commit, has no effect on the data structure. We get no opportunity to perform “partial rollbacks”.</p> <p>In other words, the critical section must be a <em>transaction</em>.</p> <h3 id="enabling-rseq"><a href="#enabling-rseq">Enabling <code class="language-plaintext highlighter-rouge">rseq</code></a></h3> <p>Using rseqs requires turning on support for it for a particular thread; this is what calling <code class="language-plaintext highlighter-rouge">rseq(2)</code> (the syscall) accomplishes.</p> <p>The signature for this syscall looks like this:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// This type is part of Linux's ABI.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="n">cpu_id_start</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">cpu_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">crit_sec</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Note: this is a syscall, not an actual Rust function.</span>
<span class="k">fn</span> <span class="nf">rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <p>The syscall registers “the” <code class="language-plaintext highlighter-rouge">Rseq</code> struct for the current thread; there can be at most one, per thread.</p> <p><code class="language-plaintext highlighter-rouge">rseq</code> is a pointer to this struct. <code class="language-plaintext highlighter-rouge">len</code> should be <code class="language-plaintext highlighter-rouge">size_of::&lt;Rseq&gt;()</code>, and <code class="language-plaintext highlighter-rouge">signature</code> can be any 32-bit integer (more on this later). For our purposes, we can ignore <code class="language-plaintext highlighter-rouge">flags</code> on the struct.</p> <p><code class="language-plaintext highlighter-rouge">flags</code> on the syscall, on the other hand, is used to indicate whether we’re unregistering the struct; this is explained below.</p> <p>In the interest of exposition, we’ll call the syscall directly. If you’ve never seen how a Linux syscall is done (on x86), you load the syscall number into <code class="language-plaintext highlighter-rouge">rax</code>, then up to six arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">r10</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code><sup id="fnref:mnemonic" role="doc-noteref"><a href="#fn:mnemonic" class="footnote" rel="footnote">1</a></sup>. We only need the first four.</p> <p>The return value comes out in <code class="language-plaintext highlighter-rouge">rax</code>, which is 0 on success, and a negative of an <code class="language-plaintext highlighter-rouge">errno</code> code otherwise. In particular, we need to check for <code class="language-plaintext highlighter-rouge">EINTR</code> to deal with syscall interruption. (every Linux syscall can be interrupted).</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">unregister</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Perform an open-coded Linux syscall.</span>
  <span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rax</span> <span class="o">=</span> <span class="mi">334</span><span class="p">;</span>  <span class="c1">// rseq(2) syscall number; x86-specific.</span>
    <span class="nd">asm!</span> <span class="p">{</span>
      <span class="s">"syscall"</span><span class="p">,</span>
      <span class="nf">inout</span><span class="p">(</span><span class="s">"rax"</span><span class="p">)</span> <span class="n">rax</span><span class="p">,</span>
      <span class="cm">/* rseq:      */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdi"</span><span class="p">)</span> <span class="n">rseq</span><span class="p">,</span>
      <span class="cm">/* len:       */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rsi"</span><span class="p">)</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;</span><span class="p">(),</span>
      <span class="cm">/* flags:     */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdx"</span><span class="p">)</span> <span class="n">unregister</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">,</span>
      <span class="cm">/* signature: */</span> <span class="k">in</span><span class="p">(</span><span class="s">"r10"</span><span class="p">)</span> <span class="n">signature</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">match</span> <span class="n">rax</span> <span class="p">{</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>      <span class="c1">// Success, we're done.</span>
      <span class="o">-</span><span class="mi">4</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>  <span class="c1">// EINTR, try again.</span>
      <span class="n">errno</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"error calling rseq(2): {}"</span><span class="p">,</span> <span class="o">-</span><span class="n">errno</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Rust</a></div></div> <p>Note the <code class="language-plaintext highlighter-rouge">unregister</code> parameter: this is used to tear down <code class="language-plaintext highlighter-rouge">rseq</code> support on the way out of a thread. Generally, <code class="language-plaintext highlighter-rouge">rseq</code> will be a thread-local, and registration happens at thread startup. Glibc will do this and has a mechanism for acquiring the <code class="language-plaintext highlighter-rouge">rseq</code> pointer. Unfortunately, the glibc I have isn’t new enough to know to do this, so I hacked up something to register my own thread local.</p> <p>I had the bright idea of putting my <code class="language-plaintext highlighter-rouge">Rseq</code> struct in a box, which triggered an interesting bug: when a thread exits, it destroys all of the thread local variables, including the box to hold our <code class="language-plaintext highlighter-rouge">Rseq</code>. But if the thread then syscalls to deallocate its stack, when the kernel goes to resume, it will attempt to write the current CPU index to the <code class="language-plaintext highlighter-rouge">rseq.cpu_id</code> field.</p> <p>This presents a problem, because the kernel is probably going to write to a garbage location. This is all but guaranteed to result in a segfault. Debuggers observe this as a segfault on the instruction right after the <code class="language-plaintext highlighter-rouge">syscall</code> instruction; I spent half an hour trying to figure out what was causing a call to <code class="language-plaintext highlighter-rouge">madvise(2)</code> to segfault.</p> <p>Hence, we need to wrap our thread local in something that will call <code class="language-plaintext highlighter-rouge">rseq(2)</code> to unregister the struct. Putting everything together we get something like this.</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">current_thread_rseq</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="c1">// This has to be its own struct so we can run a thread-exit destructor.</span>
  <span class="k">pub</span> <span class="k">struct</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;&gt;</span><span class="p">);</span>
  <span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">RseqBox</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="k">true</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nd">thread_local!</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">RSEQ</span><span class="p">:</span> <span class="n">RseqBox</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// Has to be in a box, since we need pointer stability.</span>
      <span class="k">let</span> <span class="n">rseq</span> <span class="o">=</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Rseq</span> <span class="p">{</span>
        <span class="n">cpu_id_start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">cpu_id</span><span class="p">:</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">crit_sec</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="p">})));</span>

      <span class="c1">// Register it!!!</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
      <span class="n">rseq</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="n">RSEQ</span><span class="nf">.with</span><span class="p">(|</span><span class="n">ra</span><span class="p">|</span> <span class="n">ra</span><span class="na">.0</span><span class="nf">.get</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Rust</a></div></div> <p>Per Rust’s semantics, this will execute the first time we access this thread local, instead of at thread startup. Not <em>ideal</em>, since now we pay for an (uncontended) atomic read every time we touch RSEQ, but it will do.</p> <h3 id="creating-a-critical-section"><a href="#creating-a-critical-section">Creating a Critical Section</a></h3> <p>To set up and execute a restartable sequence, we need to assemble a struct that describes it. The following struct is also defined by Linux’s syscall ABI:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CritSec</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">abort_handler</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">start</code> is the address of the first instruction in the sequence, and <code class="language-plaintext highlighter-rouge">len</code> is the length of the sequence in bytes. <code class="language-plaintext highlighter-rouge">abort_handler</code> is the address of the abort handler. <code class="language-plaintext highlighter-rouge">version</code> must be 0 and we can ignore <code class="language-plaintext highlighter-rouge">flags</code>.</p> <p>Once we have a value of this struct (on the stack or as a constant), we grab <code class="language-plaintext highlighter-rouge">RSEQ</code> and atomically store the address of our <code class="language-plaintext highlighter-rouge">CritSec</code> to <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code>. This needs to be atomic because the kernel may decide to look at this pointer from a different CPU core, but it likely will not be contended.</p> <p>Note that <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> should be null before we do this; restartable sequences can’t nest.</p> <p>Next time the kernel preempts our thread (and later gets ready to resume it), it will look at <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to decide if it preempted a restartable sequence and, if so, jump to the abort handler.</p> <p>Once we finish our critical section, we must reset <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to 0.</p> <blockquote id="aside:labels-and-constants-oh-my" class="aside"> <p><a href="#aside:labels-and-constants-oh-my"><span class="chip">aside</span><span class="title">Labels and Constants, Oh My</span></a></p> <p>There is a wrinkle: we would like for our <code class="language-plaintext highlighter-rouge">CritSec</code> value to be a constant, but Rust doesn’t provide us with a way to initialize the <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">abort_handler</code> fields directly, since it doesn’t have a way to refer<sup id="fnref:relocations" role="doc-noteref"><a href="#fn:relocations" class="footnote" rel="footnote">2</a></sup> to the labels (jump targets) inside the inline assembly. The simplest way to get around this is to assemble (lol) the <code class="language-plaintext highlighter-rouge">CritSec</code> on the stack, with inline assembly. The overhead is quite minimal.</p> </blockquote> <p>On x86, this is what our boilerplate will look like:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">cs</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">CritSec</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nd">asm!</span> <span class="p">{</span><span class="s">r"
  // We meed to do `rip`-relative loads so that this code is PIC;
  // otherwise we'll get linker errors. Thus, we can't `mov`
  // directly; we need to compute the address with a `lea`
  // first.

  // Initialize the first two fields to zero.
  mov qword ptr [{_cs}], 0

  // Load `90f` into `cs.start`. Note that this is 'forward
  // reference' to the jump target `90:` below.
  lea {_pc}, [90f + rip]
  mov qword ptr [{_cs} + 8], {_pc}

  // We need to get the difference `91f - 90f` into `cs.len`.
  // To do that, we write `-90f` to it, and then add `91f`.
  neg {_pc}
  mov qword ptr [{_cs} + 16], {_pc}
  lea {_pc}, [91f + rip]
  add qword ptr [{_cs} + 16], {_pc}

  // Same as the first line, but loading `cs.abort_handler`.
  lea {_pc}, [92f + rip]
  mov qword ptr [{_cs} + 24], {_pc}

  // Write `&amp;cs` to `RSEQ.crit_sec`. This turns on
  // restartable sequence handling.
  mov qword ptr [{rseq} + 8], {_cs}

90:
  // Do something cool here (coming soon).

91:
  // Jump over the abort handler.
  jmp 93f

  .int 0x53053053  // The signature!
92:
  // Nothing special, just zero `ok` to indicate this was a failure.
  // This is written this way simply because we can't early-return
  // out of inline assembly.
  xor {_ok:e}, {_ok:e}

93:
  // Clear `RSEQ.crit_sec`, regardless of which exit path
  // we took.
  mov qword ptr [{rseq} + 8], 0
  "</span><span class="p">,</span>
  <span class="n">_pc</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
  <span class="n">_ok</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ok</span><span class="p">,</span>
  <span class="n">_cs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cs</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CritSec</span><span class="p">,</span>
  <span class="n">rseq</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="nf">current_thread_rseq</span><span class="p">(),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>A few things to note:</p> <ol> <li>Because this is inline assembly, we need to use numeric labels. I’ve chosen labels in the 90s for no particular reason. <code class="language-plaintext highlighter-rouge">90:</code> declares a jump target, and <code class="language-plaintext highlighter-rouge">90f</code> is a forward reference to that instruction address.</li> <li>Most of this assembly is just initalizing a struct<sup id="fnref:cs-init" role="doc-noteref"><a href="#fn:cs-init" class="footnote" rel="footnote">3</a></sup>. It’s not until the <code class="language-plaintext highlighter-rouge">mov</code> right before <code class="language-plaintext highlighter-rouge">90:</code> (the critical section start) that anything interesting happens.</li> <li>Immediately before <code class="language-plaintext highlighter-rouge">92:</code> (the abort handler) is an <code class="language-plaintext highlighter-rouge">.int</code> directive that emits the same four-byte signature we passed to <code class="language-plaintext highlighter-rouge">rseq(2)</code> into the instruction stream. This <em>must</em> be here, otherwise the kernel will issue a segfault to the thread. This is a very basic control-flow integrity feature.</li> <li>We clear <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> at the very end.</li> </ol> <p>This is a lot of boilerplate. In an ideal world, we could have something like the following:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">run_rseq</span><span class="p">(</span><span class="n">cs</span><span class="p">:</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">unsafe</span> <span class="k">fn</span><span class="p">(</span><span class="nb">u32</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <p>Unfortunately, this is very hard to do, because the constraints on restartable sequences are draconian:</p> <ul> <li>Can’t jump out of the critical section until it completes or aborts. This means you can’t call functions or make syscalls!</li> <li>Last instruction must be the commit, which is a memory store operation, <em>not</em> a return.</li> </ul> <p>This means that you can’t have the compiler generating code for you; it might outline things or move things around in ways you don’t want. In something like ASAN mode, it might inject function calls that will completely break the primitive.</p> <p>This means we muyst write our critical section in assembly. That assembly also almost unavoidably needs to be part of the boilerplate given above, and it means it can’t participate in ASAN or TSAN instrumentation.</p> <p>In the interest of exposition, we can build a wrapper over this inline assembly boilerplate that looks something like this:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
    // Assembly for our critical section...
  "</span><span class="p">,</span>
  <span class="c1">// Inline asm constraints.</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>When I wrote the snippet above, I chose numeric labels in the 90s to avoid potential conflicts with whatever assembly gets pasted here. This is also why I used a leading <code class="language-plaintext highlighter-rouge">_</code> on the names of some of the assembly constraints; thise are private to the macro. <code class="language-plaintext highlighter-rouge">rseq</code> isn’t, though, since callers will want to access the CPU id in it.</p> <p>The intent is for the assembly string to be pasted over the <code class="language-plaintext highlighter-rouge">// Do something cool here</code> comment, and for the constraints to be tacked on after the boilerplate’s constraints.</p> <p>But with that we now have access to the full rseq primitive, in slightly sketchy macro form. Let’s use it to build a CPU-local data structure.</p> <h2 id="a-checkout-desk"><a href="#a-checkout-desk">A Checkout Desk</a></h2> <p>Let’s say we have a pool of objects that are needed to perform an allocation, our putative page caches. Let’s say we have the following interface:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">FreeList</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">get_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">return_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">get_cache()</code> grabs a cache of pages off the global free list. This requires taking a lock or traversing a lockless linked list, so it’s pretty expensive. <code class="language-plaintext highlighter-rouge">return_cache()</code> returns a cache back to the global free list for re-use; it is a similarly expensive operation. Both of these operations are going to be contended like crazy, so we want to memoize them.</p> <p>To achieve this, we want one slot for every CPU to hold the cache it (or rather, a thread running on it) most recently acquired, so that it can be reused. These slots will have “checkout desk” semantics: if you take a thing, you must put something in its place, even if it’s just a sign that says you took the thing.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/golden-idol.gif" alt=""/></p> </figure> <p><a href="https://fowles.github.io/">Matthew Kulukundis</a> came up with this idea, and he’d totally put this gif in a slide deck about this data structure.</p> <p>As a function signature, this is what it looks like:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p>We can then use it like this.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">free_list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FreeList</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">per_cpu</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">PageCache</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">iou</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>

<span class="c1">// Check out this CPU's cache pointer, and replace it with</span>
<span class="c1">// an IOU note (a null pointer).</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">iou</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">==</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// If we got an IOU ourselves, this means another thread that</span>
  <span class="c1">// was executing on this CPU took the cache and left *us* with</span>
  <span class="c1">// a null, so we need to perform the super-expensive operation</span>
  <span class="c1">// to acquire a new one.</span>
  <span class="n">cache</span> <span class="o">=</span> <span class="n">free_list</span><span class="nf">.get_cache</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Do stuff with `cache` here. We have unique access to it.</span>
<span class="n">cache</span><span class="nf">.alloc_page</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

<span class="c1">// Return the pointer to the checkout desk.</span>
<span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">!=</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// Usually, we expect to get back the IOU we put into the cache.</span>
  <span class="c1">// If we don't, that probably means another thread (or</span>
  <span class="c1">// hundreds) are hammering this slot and fighting for page caches.</span>
  <span class="c1">// If this happens, we need to throw away the cache.</span>
  <span class="n">free_list</span><span class="nf">.return_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Rust</a></div></div> <p>The semantics of <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> is that it is an array of <code class="language-plaintext highlighter-rouge">nprocs</code> (the number of logical cores on the system) pointers, all initialized to null. <code class="language-plaintext highlighter-rouge">checkout()</code> swaps the pointer stored in the current CPU’s slot in the <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> with the replacement argument.</p> <h3 id="building-the-checkout-desk"><a href="#building-the-checkout-desk">Building the Checkout Desk</a></h3> <p>The implementation of this type is relatively simple, but the devil is in the details. Naively, you’d think you literally want an array of pointers:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Rust</a></div></div> <p>Unfortunately, this is cache-hostile. We expect that (depending on how <code class="language-plaintext highlighter-rouge">ptrs</code> is aligned in memory) for eight CPUs’ checkout pointers to be on the same cache line. This means eight separate cores are going to be writing to the same cache line, which is going to result in a lot of cache thrash. This memory wants to be in L1 cache, but will probably wind up mostly in shared L3 cache.</p> <p>This effect is called “false sharing”, and is a fundamental part of the design of modern processors. We have to adjust for this.</p> <p>Instead, we want to give each core a full cache line (64 bytes aligned to a 64-byte boundary) for it to store its pointer in. This sounds super wasteful (56 of those bytes will go unused), but this is the right call for a perf-sensitive primitive.</p> <p>This amount of memory can add up pretty fast (two whole pages of memory for a 128-core server!), so we’ll want to lazilly initialize them. Our cache-friendly struct will look more like this:</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">AtomicPtr</span><span class="o">&lt;</span><span class="n">CacheLine</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// This struct wraps a T and forces it to take up an entire cache line.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">64</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CacheLine</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Rust</a></div></div> <p>Initializing it requires finding out how many cores there are on the machine. This is a… fairly platform-specific affair. Rust <em>does</em> offer a “maximum paralellism” query in its standard library, but it is intended as a hint for how many worker threads to spawn, as opposed to a hard upper bound on the number of CPU indices.</p> <p>Instead, we call <code class="language-plaintext highlighter-rouge">get_nprocs_conf()</code>, which is fine since we’re already extremely non-portable already. This is a GNU libc extension.</p> <p>In code…</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
      <span class="c1">// #include &lt;sys/sysinfo.h&gt;</span>
      <span class="c1">//</span>
      <span class="c1">// This function returns the maximum number of cores the</span>
      <span class="c1">// kernel knows of for the current machine. This function</span>
      <span class="c1">// is very expensive to call, so we need to cache it.</span>
      <span class="k">fn</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">mut</span> <span class="n">NPROCS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">INIT</span><span class="p">:</span> <span class="n">Once</span> <span class="o">=</span> <span class="nn">Once</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">INIT</span><span class="nf">.call_once</span><span class="p">(||</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">NPROCS</span> <span class="o">=</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">NPROCS</span> <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="p">{</span>
      <span class="n">ptrs</span><span class="nf">.push</span><span class="p">(</span><span class="nn">AtomicPtr</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span> <span class="n">ptrs</span><span class="p">:</span> <span class="n">ptrs</span><span class="nf">.into_boxed_slice</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Rust</a></div></div> <p>(I’m not going to implement <code class="language-plaintext highlighter-rouge">Drop</code> for this type. That’s an exercise for the reader.)</p> <h3 id="implementing-checkout"><a href="#implementing-checkout">Implementing <code class="language-plaintext highlighter-rouge">checkout()</code></a></h3> <p>Now’s the moment we’ve all be waiting for: writing our restartable sequence. As critical sections go, this one’s pretty simple:</p> <ol> <li>Index into the <code class="language-plaintext highlighter-rouge">ptrs</code> array to get this CPU’s pointer-to-cache-line.</li> <li>If that pointer is null, bail out of the rseq and initialize a fresh cache line (and then try again).</li> <li>If it’s not null, swap <code class="language-plaintext highlighter-rouge">replacement</code> with the value in the cache line.</li> </ol> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
    <span class="c1">// We need to try this operation in a loop, to deal with</span>
    <span class="c1">// rseq aborts.</span>
    <span class="k">loop</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="nf">.as_ptr</span><span class="p">();</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">vcpu</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">need_alloc</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
        // Load the current CPU number.
        mov {vcpu:e}, dword ptr [{rseq} + 4]

        // Load the `vcpu`th pointer from `ptrs`.
        // On x86, `mov` is atomic. The only threads we might
        // be condending with are those that are trying to
        // initialize this pointer if it's null.
        mov {scratch}, qword ptr [{ptrs} + 8 * {vcpu:r}]

        // If null, exit early and trigger an allocation
        // for this vcpu.
        test {scratch}, {scratch}
        jz 1f

        // Make sure the outer code knows not to allocate
        // a new cache line.
        xor {need_alloc:e}, {need_alloc:e}

        // Commit the checkout by exchanging `replacement`.
        xchg {ptr}, qword ptr [{scratch}]
      1:
        "</span><span class="p">,</span>
        <span class="n">ptrs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ptrs</span><span class="p">,</span>
        <span class="n">scratch</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">replacement</span><span class="p">,</span>
        <span class="n">vcpu</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">vcpu</span><span class="p">,</span>
        <span class="n">need_alloc</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">need_alloc</span><span class="p">,</span>
      <span class="p">};</span>

      <span class="c1">// We got preempted, so it's time to try again.</span>
      <span class="k">if</span> <span class="n">result</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>

      <span class="c1">// If we don't need to allocate, we're done.</span>
      <span class="k">if</span> <span class="n">need_alloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="n">replacement</span> <span class="p">}</span>

      <span class="c1">// Otherwise, allocate a new cache line and cas it into</span>
      <span class="c1">// place. This is Atomics 101, nothing fancy.</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache_line</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">CacheLine</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
      <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cas</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="p">[</span><span class="n">vcpu</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span><span class="nf">.compare_exchange_weak</span><span class="p">(</span>
          <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span> <span class="n">cache_line</span><span class="nf">.as_mut</span><span class="p">(),</span>
          <span class="nn">Ordering</span><span class="p">::</span><span class="n">AcqRel</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="k">match</span> <span class="n">cas</span> <span class="p">{</span>
          <span class="nf">Ok</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Successful allocation.</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_null</span><span class="p">());</span>
            <span class="c1">// Make sure to stop `cache_line`'s memory</span>
            <span class="c1">// from being freed by `Box`'s dtor.</span>
            <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">cache_line</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Try again: this is a spurious failure.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="nf">.is_null</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
          <span class="c1">// Someone got here first; we can just discard</span>
          <span class="c1">// `Box`.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Rust</a></div></div> <p>This code listing is a lot to take in. It can be broken into two parts: the restartable sequence itself, and the allocation fallback if the pointer-to-cache-line happens to be null.</p> <p>The restartable sequence is super short. It looks at the pointer-to-cache-line, bails if its null (this triggers the later part of the function) and then does an <code class="language-plaintext highlighter-rouge">xchg</code> between the actual <code class="language-plaintext highlighter-rouge">*mut T</code> in the per-CPU cache line, and the replacement.</p> <p>If the rseq aborts, we just try again. This is short enough that preemption in the middle of the rseq is quite rare. Then, if <code class="language-plaintext highlighter-rouge">need_alloc</code> was zeroed, that means we successfully committed, so we’re done.</p> <p>Otherwise we need to allocate a cache line for this CPU. We’re now outside of the rseq, so we’re back to needing atomics. Many threads might be racing to be the thread that initializes the pointer-to-cache-line; we use a basic cas loop to make sure that we only initialize from null, and if someone beats us to it, we don’t leak the memory we had just allocated. This is an RMW operation, so we want both acquire and release ordering. Atomics 101!</p> <p>Then, we try again. Odds are good we won’t have migrated CPUs when we execute again, so we won’t need to allocate again. Eventually all of the pointers in the <code class="language-plaintext highlighter-rouge">ptrs</code> array will be non-null, so in the steady state this <code class="language-plaintext highlighter-rouge">needs_alloc</code> case doesn’t need to happen.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is just a glimpse of what per-CPU concurrent programming looks like. I’m pretty new to it myself, and this post was motivated by building an end-to-end example in Rust. You can read more about how TCMalloc makes use of restartable sequences <a href="https://google.github.io/tcmalloc/rseq.html">here</a>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:mnemonic" role="doc-endnote"> <p>This is annoyingly <em>different</em> from the function calling convention, which passes arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, with the mnemonic “Diana’s silk dress cost $89.” I don’t know a cute mnemonic for the syscall registers. <a href="#fnref:mnemonic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:relocations" role="doc-endnote"> <p>It’s actually worse than that. You’d think you could do</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">jmp</span> <span class="n">foo</span>
<span class="n">pointers</span><span class="o">:</span>
  <span class="p">.</span><span class="kt">int</span> <span class="n">foo</span>

<span class="n">foo</span><span class="o">:</span>
  <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">pointers</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">x86 Assembly</a></div></div> <p>but this makes the resulting code non-position-independent on x86. What this means is that the code must know at link time what address it will be loaded at, which breaks the position-independent requirement of many modern platforms.</p> <p>Indeed, this code will produce a linker error like the following:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-text" data-lang="text">= note: /usr/bin/ld: /home/mcyoung/projects/cpulocal/target/debug/deps/cpulocal-a7eeabaf0b1f2c43.2l48u2rfiak1q1ik.rcgu.o:
      relocation R_X86_64_32 against `.text._ZN8cpulocal15PerCpu$LT$T$GT$8checkout17h42fde3ce3bd0180aE'
      can not be used when making a PIE object; recompile with -fPIE
      collect2: error: ld returned 1 exit status</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Plaintext</a></div></div> <p>Not only is <code class="language-plaintext highlighter-rouge">.int foo</code> a problem, but so is referring to <code class="language-plaintext highlighter-rouge">pointers</code>. Instead we must write</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">lea</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">pointers</span> <span class="o">+</span> <span class="n">rip</span><span class="p">]</span>
<span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">x86 Assembly</a></div></div> <p>to be able to load the address of <code class="language-plaintext highlighter-rouge">pointers</code> at all. This <em>can</em> be worked around if you’re smart; after all, it is possible to put the addresses of functions into static variables and not have the linker freak out. It’s too hard to do in inline assembly tho. <a href="#fnref:relocations" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:cs-init" role="doc-endnote"> <p>Basically this code, which can’t be properly-expressed in Rust.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">CrtiticalSection</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="cm">/* &amp;90f */</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="cm">/* &amp;91f - &amp;90f */</span><span class="p">,</span>
  <span class="n">abort</span><span class="p">:</span> <span class="cm">/* &amp;92f */</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p><a href="#fnref:cs-init" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2022-07-24 • 2777 words • 30 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#etc">#etc</a> </span> <h1><a href="/2022/07/24/curta/"> 3Hz Computer, Hold the Transistors<br/> </a></h1> </div> <div class="post"> <p>I’m not really one to brag publicly about expensive toys, but a few weeks ago I managed to get one that’s really something special. It is a <em>Curta Type II</em>, a mechanical digital<sup id="fnref:mech-digital" role="doc-noteref"><a href="#fn:mech-digital" class="footnote" rel="footnote">1</a></sup> calculator manufactured in Liechtenstein between the 50s and 70s, before solid-state calculators killed them and the likes of slide-rules.</p> <p>I have wanted one since I was a kid, and I managed to win an eBay auction for one.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/with_case.jpg" alt="The Curta"/></p> <figcaption>The Curta Type II (and Solomon the cat)</figcaption> </figure> <p>It’s a funny looking device, somewhere between a peppermill and a scifi grenade. Mine has serial number 544065, for those keeping score, and comes in a cute little bakelite pod (which has left hand thread?!).</p> <p>I wanna talk about this thing because unlike something like a slide rule, it shares many features with modern computers. It has operations, flags, and registers. Its core primitive is an adder, but many other operations can be built on top of it: it is very much a platform for complex calculations.</p> <p>I’m the sort of person who read <em>Hacker’s Delight</em> for fun, so I really like simple numerical algorithms. This article is a survey of the operation of a Curta calculator and algorithms you can implement on it, from the perspective of a professional assembly programmer.</p> <p>Many of the algorithms I’m going to describe here exist online, but I’ve found them to be a bit difficult to wrap my head around, so this article is also intended as a reference card for myself.</p> <p>Let’s dive in!</p> <h2 id="a-well-lubricated-alu"><a href="#a-well-lubricated-alu">A Well-Lubricated ALU</a></h2> <p>There are two Curta models, Type I and Type II, which primarily differ in the sizes of their registers. I have a Type II, so I will focus on the layout of that one.</p> <p>The Curta is not a <em>stored program</em> computer like the one you’re reading this article on. An operator needs to manually execute operations. It is as if we had taken a CPU and pared it down to two of its most basic components: a register file and an arithmetic logic unit (ALU).</p> <h3 id="the-register-file"><a href="#the-register-file">The Register File</a></h3> <p>The Curta’s register file consists of three digital registers, each of which contains a decimal integer (i.e., each digit is from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">9</code>, rather than <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">1</code> like on a binary computer):</p> <ul> <li><code class="language-plaintext highlighter-rouge">sr</code>, the <em>setting register</em>, is located on the side of the device. The value in <code class="language-plaintext highlighter-rouge">sr</code> can be set manually by the operator using a set of knobs on the side of the device. The machine will never write to it, only read from it. It has 11 digits.</li> <li><code class="language-plaintext highlighter-rouge">rr</code>, the <em>results register</em>, is located at the top of the device along the black part of the dial. It is readable and writable by the machine, but not directly modifiable by the operator. It has 15 digits.</li> <li><code class="language-plaintext highlighter-rouge">cr</code>, the <em>counting register</em>, is located next to <code class="language-plaintext highlighter-rouge">rr</code> along the silver part of the dial. Like <code class="language-plaintext highlighter-rouge">rr</code>, it is only machine-modifiable. It has 8 digits.</li> </ul> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/sr.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">sr</code>, set to <code class="language-plaintext highlighter-rouge">1997</code>.</p> </figcaption> </figure> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/cr_rr.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">rr</code> is the black dial; <code class="language-plaintext highlighter-rouge">cr</code> is the silver one.</p> </figcaption> </figure> <p>There are also two settings on the device that aren’t really registers, but, since they are changed as part of operation, they are a lot like the control registers of a modern computer.</p> <p>The <em>carriage</em> (there isn’t an abbreviation for this one, so I’ll call it <code class="language-plaintext highlighter-rouge">ca</code>) is the upper knurled ring on the machine. It can be set to a value from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">7</code><sup id="fnref:one-index" role="doc-noteref"><a href="#fn:one-index" class="footnote" rel="footnote">2</a></sup>. To set it, the operator lifts the ring up (against spring tension), twists it, and lets it spring back into the detent for the chosen value. This is a one-hand motion.</p> <p>There is a small triangle in the middle of the top of the device that points at which of the digits in <code class="language-plaintext highlighter-rouge">cr</code> will get incremented.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/ca.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">ca</code> raised and in motion.</p> </figcaption> </figure> <p>Finally, <code class="language-plaintext highlighter-rouge">rl</code>, the <em>reversing lever</em>, is a small switch near the back of the device that can be in the up or down position. This is like a flag register: up is cleared, down is set.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/rl.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">rl</code> in the up position.</p> </figcaption> </figure> <h3 id="the-instruction-set"><a href="#the-instruction-set">The Instruction Set</a></h3> <p>We have all this memory, but the meat of a machine is what it can <em>do</em>. I will provide an <em>instruction set</em> for the Curta to aid in giving rigorous descriptions of operations you can perform with it.</p> <p>The core operation of the Curta is “add-with-shift-and-increment”. This is a mouthful. At the very top of the machine is the handle, which is analogous to a clock signal pin. Every clockwise turn of this handle executes one of these operations. Internally, this is implemented using a variation on the <a href="https://en.wikipedia.org/wiki/Leibniz_wheel">Leibniz gear</a>, a common feature of mechanical calculators.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/pturn.jpg" alt=""/></p> <figcaption>The handle in "addition" mode.</figcaption> </figure> <p>This operation is not that complicated, it just does a lot of stuff. It takes the value of <code class="language-plaintext highlighter-rouge">sr</code>, left-shifts it (in decimal) by the value in <code class="language-plaintext highlighter-rouge">ca</code>, and adds it to <code class="language-plaintext highlighter-rouge">rr</code>. Also, it increments <code class="language-plaintext highlighter-rouge">CR</code> by <code class="language-plaintext highlighter-rouge">1</code> shifted by <code class="language-plaintext highlighter-rouge">ca</code>. In other words:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-text" data-lang="text">rr += sr &lt;&lt; ca
cr += 1 &lt;&lt; ca</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Plaintext</a></div></div> <p>Recall that this is a decimal machine, so <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> is the same as multiplication by a power of 10, not a power of 2.</p> <p>Addition can overflow, and it wraps around as expected: adding one to <code class="language-plaintext highlighter-rouge">999_999_999_999_999_999</code> already in <code class="language-plaintext highlighter-rouge">rr</code> will fill it with zeroes.</p> <p>Pulling the handle up reveals a red ring, indicating the machine is in <em>subtraction mode</em>. This flips the signs of both the <code class="language-plaintext highlighter-rouge">rr</code> and <code class="language-plaintext highlighter-rouge">cr</code> modifications:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-text" data-lang="text">rr -= sr &lt;&lt; ca
cr -= 1 &lt;&lt; ca</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Plaintext</a></div></div> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/mturn.jpg" alt=""/></p> <figcaption>The handle in "subtraction" mode.</figcaption> </figure> <p>The Curta cannot handle negative numbers, so it will instead display the ten’s complement<sup id="fnref:10s-cmp" role="doc-noteref"><a href="#fn:10s-cmp" class="footnote" rel="footnote">3</a></sup> of a negative result. For example, subtracting <code class="language-plaintext highlighter-rouge">1</code> from <code class="language-plaintext highlighter-rouge">0</code> will produce all-nines.</p> <p>You can detect when underflow or overflow occurs when the resulting value is unexpectedly larger or smaller than the prior value in <code class="language-plaintext highlighter-rouge">rr</code>, respectively. (This trick is necessary on architectures that lack a carry flags register, like RISC-V.)</p> <p>Setting <code class="language-plaintext highlighter-rouge">rl</code> will reverse the sign of the operation done on <code class="language-plaintext highlighter-rouge">cr</code> during a turn of the handle. In addition mode, it will cause <code class="language-plaintext highlighter-rouge">cr</code> to be subtracted from, while in subtraction mode, it will cause it to be added to. Some complex algorithms make use of this.</p> <p>Finally, the <em>clearing lever</em> can be used to clear (to zero) <code class="language-plaintext highlighter-rouge">sr</code> or <code class="language-plaintext highlighter-rouge">rr</code>, independently. It is a small ring-shaped lever that, while the carriage is raised, can be wiped past digits to clear them. Registers cannot be partially cleared.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/pturn.jpg" alt=""/></p> <figcaption>The clearing lever.</figcaption> </figure> <h3 id="notation"><a href="#notation">Notation</a></h3> <p>Let’s give names to all the instructions the operator needs to follow, so we can write some assembly:</p> <ul> <li><code class="language-plaintext highlighter-rouge">mr</code>, or <em>Machine Ready!</em>, means to clear/zero every register. All Curta instructions use the term “Machine Ready” to indicate the beginning of a calculation session.</li> <li><code class="language-plaintext highlighter-rouge">pturn</code> is the core addition operation, a “plus turn”.</li> <li><code class="language-plaintext highlighter-rouge">mturn</code> is its subtraction twin, a “minus turn”.</li> <li><code class="language-plaintext highlighter-rouge">set &lt;flag&gt;</code> requests the operator set one of <code class="language-plaintext highlighter-rouge">rl</code> or <code class="language-plaintext highlighter-rouge">sm</code>.</li> <li><code class="language-plaintext highlighter-rouge">clr &lt;flag&gt;</code> is the opposite of <code class="language-plaintext highlighter-rouge">set</code>.</li> <li><code class="language-plaintext highlighter-rouge">zero &lt;reg&gt;</code> request a clear of one of <code class="language-plaintext highlighter-rouge">rr</code> or <code class="language-plaintext highlighter-rouge">cr</code> using the clearing lever.</li> <li><code class="language-plaintext highlighter-rouge">add &lt;reg&gt;, &lt;imm&gt;</code> requests manual addition of an immediate to <code class="language-plaintext highlighter-rouge">sr</code> or <code class="language-plaintext highlighter-rouge">ca</code>. This is limited by what mental math we can ask of the operator.</li> <li><code class="language-plaintext highlighter-rouge">copy &lt;reg&gt;, sr</code> requests a copy of the value in <code class="language-plaintext highlighter-rouge">rr</code> or <code class="language-plaintext highlighter-rouge">cr</code> to <code class="language-plaintext highlighter-rouge">sr</code>.</li> <li><code class="language-plaintext highlighter-rouge">wrnp &lt;reg&gt;, &lt;symbol&gt;</code> indicates we need to write down a value in any register to a handy notepad (hence <code class="language-plaintext highlighter-rouge">wr</code>ite <code class="language-plaintext highlighter-rouge">n</code>ote<code class="language-plaintext highlighter-rouge">p</code>ad), marked with <code class="language-plaintext highlighter-rouge">&lt;symbol&gt;</code>.</li> <li><code class="language-plaintext highlighter-rouge">rdnp &lt;reg&gt;, &lt;symbol&gt;</code> asks the operator to <code class="language-plaintext highlighter-rouge">re</code>ad a value recorded with <code class="language-plaintext highlighter-rouge">wrnp</code>.</li> <li><code class="language-plaintext highlighter-rouge">if &lt;cond&gt;, &lt;label&gt;</code> asks the operator to check a condition (in terms of <code class="language-plaintext highlighter-rouge">cr</code>, <code class="language-plaintext highlighter-rouge">rr</code>, and <code class="language-plaintext highlighter-rouge">sr</code>) and, if true, proceed to the instruction at the given <code class="language-plaintext highlighter-rouge">label:</code>. Here’s some examples of conditions we’ll use: <ul> <li><code class="language-plaintext highlighter-rouge">rr == 42</code>, i.e., <code class="language-plaintext highlighter-rouge">rr</code> equals some constant value.</li> <li><code class="language-plaintext highlighter-rouge">rr.ovflow</code>, i.e., <code class="language-plaintext highlighter-rouge">rr</code> overflowed/underflowed due to the most recent <code class="language-plaintext highlighter-rouge">pturn</code>/<code class="language-plaintext highlighter-rouge">mturn</code>.</li> <li><code class="language-plaintext highlighter-rouge">cr[1] == 9</code>, i.e. <code class="language-plaintext highlighter-rouge">cr</code>’s second digit (zero-indexed, not like the physical device!) equals <code class="language-plaintext highlighter-rouge">9</code>.</li> <li><code class="language-plaintext highlighter-rouge">cr[0..ca] &lt; sr[0..ca]</code>, i.e., <code class="language-plaintext highlighter-rouge">cr</code>, considering only the digits up to the setting of <code class="language-plaintext highlighter-rouge">ca</code>, is less than those same digits in <code class="language-plaintext highlighter-rouge">sr</code>.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">goto &lt;label&gt;</code> is like <code class="language-plaintext highlighter-rouge">if</code> without a condition.</li> <li><code class="language-plaintext highlighter-rouge">done</code> means we’re done and the result can be read off of <code class="language-plaintext highlighter-rouge">rr</code> (or <code class="language-plaintext highlighter-rouge">cr</code>).</li> </ul> <p>Note that there is a lot of mental math in some of the conditions. Algorithms on the Curta are aimed to minimize what work the operator needs to do to compute a result, but remember that it is only an ALU: all of the control flow logic needs to be provided by the human operator.</p> <p>None of this is real code, and it is specifically for the benefit of readers.</p> <h2 id="some-algorithms"><a href="#some-algorithms">Some Algorithms</a></h2> <p>So, addition and subtraction are easy, because there are hardware instructions for those. There is, however, no direct way to do multiplication or division. Let’s take a look at some of our options.</p> <p>Given that a Curta is kinda expensive, you can try out an online simulator if you want to follow along. <a href="https://www.cailliau.org/en/Alphabetical/C/Computing/Curta/Simulator/">This one</a> is pretty simple and runs in your browser.</p> <h3 id="multiplication"><a href="#multiplication">Multiplication</a></h3> <p>The easiest way to do multiplication is by repeated addition; <code class="language-plaintext highlighter-rouge">cr</code> helps us check our work.</p> <p>Given a value like <code class="language-plaintext highlighter-rouge">8364</code>, we can multiply it by <code class="language-plaintext highlighter-rouge">5</code> like so:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">mul_by_5:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">8364</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="mi">5</span><span class="p">,</span> <span class="n">end</span>
    <span class="n">pturn</span>
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Curta "Assembly"</a></div></div> <p>Here, we input the larger factor into <code class="language-plaintext highlighter-rouge">sr</code>, and then keep turning until <code class="language-plaintext highlighter-rouge">cr</code> contains the other factor. The result is <code class="language-plaintext highlighter-rouge">41820</code>:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/mul.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">8364 * 5 == 41820</code></p> </figcaption> </figure> <p>Of course, this does not work well for complex products, such as squaring <code class="language-plaintext highlighter-rouge">41820</code>. You could sit there and turn the handle forty thousand times if you wanted to, or you might decided that you should get a better hobby, since modern silicon can do this in nanoseconds.</p> <p>We can speed this up exponentially by making use of the distributive property and the fact that <code class="language-plaintext highlighter-rouge">turn</code> can incorporate multiplication by a power of <code class="language-plaintext highlighter-rouge">10</code>.</p> <p>Consider:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-text" data-lang="text">41820 * 41820
= 41820 * (40000 + 1000 + 800 + 20)
= 41820 * 40000 + 41820 * 1000 + 41820 * 800 + 41820 * 20</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Plaintext</a></div></div> <p>Each nice round number here can be achieved in <code class="language-plaintext highlighter-rouge">cr</code> by use of <code class="language-plaintext highlighter-rouge">ca</code>. Our algorithm will look a bit like this:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="c1">// Check if we're done.</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="mi">41820</span><span class="p">,</span> <span class="n">end</span>
  <span class="n">inner</span><span class="o">:</span>
      <span class="c1">// Turn until the first `ca` digits of `cr` and the</span>
      <span class="c1">// other factor match.</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="mi">41802</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">ca</span><span class="p">],</span> <span class="n">inner_end</span>
      <span class="n">pturn</span>
      <span class="k">goto</span>  <span class="n">inner</span>
  <span class="n">inner_end</span><span class="o">:</span>
    <span class="c1">// Increment `ca` and repeat until done.</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span> 
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Curta "Assembly"</a></div></div> <p>There are two loops. The inner loop runs as many turns as is necessary to get the next prefix of the factor into <code class="language-plaintext highlighter-rouge">cr</code>, then incrementing <code class="language-plaintext highlighter-rouge">ca</code> to do the next digit, and on and on until <code class="language-plaintext highlighter-rouge">cr</code> contains the entire other factor, at which point we can read off the result.</p> <p>The actual trace of operations (omitting control flow), and the resulting contents of the registers <code class="language-plaintext highlighter-rouge">sr/rr/mr/ca</code> at each step, looks something like this:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="c1">// 00000041820/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000000000/00000000/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000418200/00000010/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000083640/00000020/1</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000083640/00000020/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000005018400/00000120/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000009200400/00000220/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000013382400/00000320/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000017564400/00000420/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000021746400/00000520/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000025928400/00000620/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000030110400/00000720/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000034292400/00000820/2</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000034292400/00000820/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000076112400/00001820/3</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000494312400/00011820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000912512400/00021820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001330712400/00031820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001748912400/00041820/4</span>
<span class="n">pturn</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Curta "Assembly"</a></div></div> <p>The result can be read off from <code class="language-plaintext highlighter-rouge">rr</code>: <code class="language-plaintext highlighter-rouge">1748912400</code>. In the trace, you can see <code class="language-plaintext highlighter-rouge">cr</code> get built up digit by digit, making this operation rather efficient.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/square.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">41820 * 41820 == 1748912400</code></p> </figcaption> </figure> <p>We can do even better, if we use subtraction. For example, note that <code class="language-plaintext highlighter-rouge">18 = 20 - 2</code>; we can build up <code class="language-plaintext highlighter-rouge">18</code> in <code class="language-plaintext highlighter-rouge">cr</code> by doing only 4 turns rather than nine, according to this formula. Here’s the general algorithm for <code class="language-plaintext highlighter-rouge">n * m</code>:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">mul:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="n">n</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="n">m</span><span class="p">,</span> <span class="n">end</span>
    <span class="c1">// Same as before, but if the next digit is large,</span>
    <span class="c1">// go into subtraction mode.</span>
    <span class="k">if</span>    <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_sub</span>
  <span class="n">inner</span><span class="o">:</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">ca</span><span class="p">],</span> <span class="n">inner_end</span>
      <span class="n">pturn</span>
      <span class="k">goto</span>  <span class="n">inner</span>
  <span class="n">by_sub</span><span class="o">:</span>
    <span class="c1">// Store the current `ca` position.</span>
    <span class="n">wrnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">sub_from</span>
    <span class="c1">// Find the next small digit (eg. imagine n * 199, we</span>
    <span class="c1">// want to find the 1).</span>
  <span class="n">find_small</span><span class="o">:</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span>
    <span class="k">if</span>    <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">find_small</span>
    <span class="c1">// Set the digit to one plus the desired value for that</span>
    <span class="c1">// digit.</span>
  <span class="n">outer_turns</span><span class="o">:</span>
    <span class="n">pturn</span>
    <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">outer_turns</span>
    <span class="c1">// Store how far we need to re-advance `ca`.</span>
    <span class="n">wrnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">continue_from</span>
    <span class="c1">// Go back to the original `ca` position and enter</span>
    <span class="c1">// subtraction mode.</span>
    <span class="n">rdnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">sub_from</span>
  <span class="n">subs</span><span class="o">:</span>
  <span class="n">subs_inner</span><span class="o">:</span>
      <span class="c1">// Perform subtractions until we get the value we want.</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">],</span>  <span class="n">subs_end</span>
      <span class="n">mturn</span>
      <span class="k">goto</span>  <span class="n">subs_inner</span>
  <span class="n">subs_end</span><span class="o">:</span>
    <span class="c1">// Advance `ca` and keep going until we're done.</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span>
    <span class="k">if</span>    <span class="n">ca</span> <span class="o">!=</span> <span class="n">continue_from</span><span class="p">,</span> <span class="n">subs</span>
    <span class="k">goto</span>  <span class="n">loop</span>
  <span class="n">inner_end</span><span class="o">:</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span> 
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Curta "Assembly"</a></div></div> <p>Although more complicated, if we execute it step by step, we’ll see we get to our answer in fewer turns:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="c1">// 00000041820/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000000000/00000000/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000418200/00000010/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000835400/00000020/1</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">2</span>
<span class="c1">// 00000041820/000000000835400/00000020/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000042656400/00001020/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000084476400/00002020/3</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000041820/000000084476400/00002020/2</span>
<span class="n">mturn</span>
<span class="c1">// 00000041820/000000080294400/00001920/2</span>
<span class="n">mturn</span>
<span class="c1">// 00000041820/000000076112400/00001820/2</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">2</span>
<span class="c1">// 00000041820/000000494312400/00011820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000912512400/00021820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001330712400/00031820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001748912400/00041820/4</span>
<span class="n">pturn</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Curta "Assembly"</a></div></div> <p>In exchange for a little overhead, the number of turns drops from 15 to 10. This is the fastest <em>general</em> algorithm, but some techniques from <em>Hacker’s Delight</em> can likely be applied here to make it faster for some products.</p> <h4 id="cubes"><a href="#cubes">Cubes</a></h4> <p>As a quick note, computing the cube of a number without taking extra notes is easy, so long as the number is already written down somewhere you can already see it. After computing <code class="language-plaintext highlighter-rouge">n^2</code> by any of the methods above, we can do</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">cube:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span>
  <span class="c1">// Perform a multiplication by `n`, then copy the result</span>
  <span class="c1">// into `sr`.</span>
  <span class="n">copy</span>  <span class="n">sr</span><span class="p">,</span>   <span class="n">rr</span>
  <span class="n">zero</span>  <span class="n">rr</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="c1">// Perform another multiplication by `n`, but now with</span>
  <span class="c1">// its square in `sr`.</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Curta "Assembly"</a></div></div> <p>This sequence can be repeated over and over to produce higher powers, and is only limited by the size of <code class="language-plaintext highlighter-rouge">rr</code>.</p> <h3 id="division"><a href="#division">Division</a></h3> <p>Division is way more interesting, because it can be <em>inexact</em>, and thus produces a <em>remainder</em> in addition to the quotient. There are a few different algorithms, but the simplest one is division by repeated subtraction. Some literature calls this “division by breaking down”.</p> <p>For small numbers, this is quite simple, such as <code class="language-plaintext highlighter-rouge">21 / 4</code>:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">div_by_4:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">21</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">4</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">oflow</span><span class="p">,</span> <span class="n">end</span>
    <span class="n">mturn</span>
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">pturn</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Curta "Assembly"</a></div></div> <p>This works by first getting the dividend into <code class="language-plaintext highlighter-rouge">rr</code> and resetting the rest of the machine. Then, with <code class="language-plaintext highlighter-rouge">rl</code> set, we subtract the divisor from <code class="language-plaintext highlighter-rouge">rr</code> until we get overflow, at which point we add to undo the overflow. The quotient will appear in <code class="language-plaintext highlighter-rouge">cr</code>: we set <code class="language-plaintext highlighter-rouge">rl</code>, so each subtraction <em>increments</em> <code class="language-plaintext highlighter-rouge">cr</code>, giving us a count of <code class="language-plaintext highlighter-rouge">mturn</code>s executed. The remainder appears in <code class="language-plaintext highlighter-rouge">rr</code>.</p> <p>In this case, we get down to <code class="language-plaintext highlighter-rouge">1</code> before the next <code class="language-plaintext highlighter-rouge">mturn</code> underflows; the result of that underflow is to <code class="language-plaintext highlighter-rouge">99...97</code>, the ten’s complement of -3. We then undo the last operation by <code class="language-plaintext highlighter-rouge">pturn</code>ing, getting <code class="language-plaintext highlighter-rouge">5</code> in <code class="language-plaintext highlighter-rouge">cr</code>: this is our quotient. <code class="language-plaintext highlighter-rouge">1</code> in <code class="language-plaintext highlighter-rouge">rr</code> is the remainder.</p> <p>The same tricks from earlier work here, using <code class="language-plaintext highlighter-rouge">ca</code> to make less work, effectively implementing decimal long division of <code class="language-plaintext highlighter-rouge">n/m</code>:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">div:</span>
  <span class="c1">// Set up the registers.</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">m</span>
  <span class="n">set</span>   <span class="n">rl</span>
  <span class="c1">// Move `ca` to be such that the highest digit of</span>
  <span class="c1">// `sr` lines up with the highest digit of `rr`.</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="n">log</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="c1">// Make subtractive turns until we underflow.</span>
  <span class="n">inner</span><span class="o">:</span>
    <span class="n">mturn</span>
    <span class="k">if</span>    <span class="o">!</span><span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span> <span class="n">inner</span>
  <span class="c1">// Undo the turn that underflowed by doing an addition.</span>
  <span class="c1">// Because `rl` is set, this will also conveniently subtract</span>
  <span class="c1">// from `cr`, to remove the extra count from the</span>
  <span class="c1">// underflowing turn.</span>
  <span class="n">pturn</span>
  <span class="c1">// We're done if this is the last digit we can be subtracting.</span>
  <span class="c1">// Otherwise, decrement `ca` and start over.</span>
  <span class="k">if</span>    <span class="n">ca</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
  <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Curta "Assembly"</a></div></div> <p>Let’s execute this on <code class="language-plaintext highlighter-rouge">3141592653 / 137</code>, with an instruction trace as before.</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">3141592653</span>
<span class="c1">// 03141592653/000000000000000/00000000/0</span>
<span class="n">pturn</span>
<span class="c1">// 03141592653/000003141592653/00000001/0</span>
<span class="n">zero</span>  <span class="n">cr</span>
<span class="c1">// 03141592653/000003141592653/00000000/0</span>
<span class="n">zero</span>  <span class="n">sr</span>
<span class="c1">// 00000000000/000003141592653/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">137</span>
<span class="c1">// 00000000137/000003141592653/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">7</span>
<span class="c1">// 00000000137/000003141592653/00000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000001771592653/10000000/7</span>
<span class="n">turn</span>
<span class="c1">// 00000000137/000000401592653/20000000/7</span>
<span class="n">turn</span>
<span class="c1">// 00000000137/999990031592653/30000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00000000137/000000401592653/20000000/7</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000401592653/20000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000000264592653/21000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000000127592653/22000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/999999990592653/23000000/6</span>
<span class="n">pturn</span>
<span class="c1">// 00000000137/000000127592653/22000000/6</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000127592653/22000000/5</span>
<span class="c1">// More turns...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000004292653/22900000/4</span>
<span class="c1">// More turns...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000182653/22930000/3</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000045653/22931000/2</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000004553/22931300/1</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000000443/22931330/0</span>
<span class="c1">// ...</span>
<span class="n">done</span>
<span class="c1">// 00000000137/000000000000032/22931333/0</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Curta "Assembly"</a></div></div> <p>For a quotient this big, you’ll need to work through all eight <code class="language-plaintext highlighter-rouge">cr</code> digits, which is a ton of work. At the end, we get a quotient of <code class="language-plaintext highlighter-rouge">22931333</code> and reminder <code class="language-plaintext highlighter-rouge">32</code>.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/quot.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">3141592653 / 137 == 22931333, rem 32</code></p> </figcaption> </figure> <p>Unfortunately, we can’t as easily “cheat” with subtraction as we did with multiplication, because we don’t know the value that needs to appear in <code class="language-plaintext highlighter-rouge">cr</code>.</p> <h3 id="square-roots"><a href="#square-roots">Square Roots</a></h3> <p>Computing square roots by approximation is one of the premiere operations on the Curta. There’s a number of approaches. Newton’s method is the classic, but requires a prior approximation, access to lookup tables, or a lot of multiplication.</p> <p>A slower, but much more mechanical approach is to use <em>Töpler’s method</em>. This consists of observing that the sum of the first <code class="language-plaintext highlighter-rouge">n</code> odd numbers is the square of <code class="language-plaintext highlighter-rouge">n</code>. Thus, we can use an approach similar to that for division, only that we now subtract off consecutive odd numbers. Let’s take the square root of <code class="language-plaintext highlighter-rouge">92</code>:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">sqrt_of_92:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">92</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="n">mturn</span>
  <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span> <span class="n">end</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>  
  <span class="k">goto</span>  <span class="n">loop</span> 
<span class="n">end</span><span class="o">:</span>
  <span class="n">pturn</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Curta "Assembly"</a></div></div> <p>We get <code class="language-plaintext highlighter-rouge">9</code> as our result, but that’s pretty awful precision. We can improve precision by multiplying <code class="language-plaintext highlighter-rouge">92</code> by a large, even power of ten, and then dividing the result by that power of ten’s square root (half the zeroes).</p> <p>Unfortunately, this runs into the same problem as naive multiplication: we have to turn the handle <em>a lot</em>. Turning this algorithm into something that can be done exponentially faster is a bit fussier.</p> <p>One approach (which I found on <curta.org>) allows us to compute the root by shifting. Several programmers appear to have independently discovered this in the 70s or 80s.</curta.org></p> <p>It is based on the so-called <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation">“digit-by-digit”</a> algorithm, dating back to at least the time of Napier. Wikipedia provides a good explanation of why this method works. However, I have not been able to write down a proof that this specific version works, since it incorporates borrowing to compute intermediate terms with successive odd numbers in a fairly subtle way. I would really appreciate a proof, if anyone knows of one!</p> <p>The algorithm is thus, for a radicand <code class="language-plaintext highlighter-rouge">n</code>:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">sqrt:</span>
  <span class="n">mr</span>
  <span class="c1">// Put `ca` as far as it will go, and then enter</span>
  <span class="c1">// the radicand as far right as it will go, so you</span>
  <span class="c1">// get as many digits as possible to work with.</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">8</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="c1">// Put a 1 under the leftmost pair of digits. This</span>
  <span class="c1">// assumes a number with an even number of digits.</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="n">sqrt_loop</span><span class="o">:</span>
      <span class="c1">// Add an odd number (with a bunch of zeros</span>
      <span class="c1">// after it.)</span>
      <span class="n">mturn</span>
      <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span>  <span class="n">sqrt_end</span>
      <span class="c1">// Increment sr by 2 (again, with a bunch of</span>
      <span class="c1">// zeros after it). This gives us our next odd</span>
      <span class="c1">// number.</span>
      <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">goto</span>  <span class="n">sqrt_loop</span>
  <span class="n">sqrt_end</span><span class="o">:</span>
    <span class="c1">// Note that we do NOT undo the increment of `sr`</span>
    <span class="c1">// that caused overflow, but we do undo the last</span>
    <span class="c1">// mturn.</span>
    <span class="n">pturn</span>
    <span class="c1">// If `ca` is all the way to the right, we're out of</span>
    <span class="c1">// space, so these are all the digits we're getting.</span>
    <span class="c1">// Zeroing out `rr` also means we're done.</span>
    <span class="k">if</span>    <span class="n">ca</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">rr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span>
    <span class="c1">// Subtract ONE from the digit in `sr` we were</span>
    <span class="c1">// incrementing in the loop. This results in an even</span>
    <span class="c1">// number.</span>
    <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1">// Decrement `ca` and keep cranking. </span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
    <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Curta "Assembly"</a></div></div> <p>Let’s compute some digits of <code class="language-plaintext highlighter-rouge">sqrt(2)</code>. Here’s the instruction trace.</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">7</span>
<span class="c1">// 00000000000/000000000000000/00000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="c1">// 00020000000/000000000000000/00000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00020000000/200000000000000/10000000/7</span>
<span class="n">zero</span>  <span class="n">cr</span>
<span class="c1">// 00020000000/200000000000000/00000000/7</span>
<span class="n">zero</span>  <span class="n">sr</span>
<span class="c1">// 00000000000/200000000000000/00000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00010000000/200000000000000/00000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00010000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00030000000/100000000000000/10000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00030000000/800000000000000/10000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00030000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">// 00020000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00020000000/100000000000000/10000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00021000000/100000000000000/10000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00021000000/079000000000000/11000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00023000000/079000000000000/11000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00023000000/056000000000000/12000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00025000000/056000000000000/12000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00025000000/031000000000000/13000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00027000000/031000000000000/13000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00027000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00029000000/004000000000000/14000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00029000000/975000000000000/15000000/6</span>
<span class="n">pturn</span>
<span class="c1">// 00029000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">// 00028000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00028000000/004000000000000/14000000/5</span>
<span class="c1">// More of the same...</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Curta "Assembly"</a></div></div> <p>Over time, the digits <code class="language-plaintext highlighter-rouge">14121356</code> will appear in <code class="language-plaintext highlighter-rouge">cr</code>. This is the square root (although we do need to place the decimal point; the number of digits before it will be half of what we started with, rounded up).</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/sqrt.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">sqrt(2) ~ 1.4121356</code></p> </figcaption> </figure> <h2 id="wrap-up"><a href="#wrap-up">Wrap-up</a></h2> <p>There’s a quite a few other algorithms out there, but most of them boil down to clever use of lookup tables and combinations of the above techniques. For example, the so-called “rule of 3” is simply performing a multiplication to get a product into <code class="language-plaintext highlighter-rouge">rr</code>, and then using it as the dividend to produce a quotient of the form <code class="language-plaintext highlighter-rouge">a * b / c</code> in <code class="language-plaintext highlighter-rouge">cr</code>.</p> <p>I hope that these simple numeric algorithms, presented in a style resembling assembly, helps illustrate that programming at such a low level is not <em>hard</em>, but merely requires learning a different bag of tricks.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:mech-digital" role="doc-endnote"> <p>Although this seems like an oxymoron, it is accurate! The Curta contains no electrical or electronic components, and its registers contain discrete symbols, not continuous values. It is <em>not</em> an analog computer! <a href="#fnref:mech-digital" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:one-index" role="doc-endnote"> <p>The Curta is a one-indexed machine, insofar as the values engraved on <code class="language-plaintext highlighter-rouge">ca</code> are not <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">7</code> but <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">8</code>. However, as we all know, zero-indexing is far more convenient. Any place where I say “set <code class="language-plaintext highlighter-rouge">ca</code> to <code class="language-plaintext highlighter-rouge">n</code>”, I mean the <code class="language-plaintext highlighter-rouge">n + 1</code>th detent.</p> <p>Doing this avoids a lot of otherwise unnecessary <code class="language-plaintext highlighter-rouge">-1</code>s in the prose. <a href="#fnref:one-index" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:10s-cmp" role="doc-endnote"> <p>The <em>ten’s complement</em> of a number <code class="language-plaintext highlighter-rouge">x</code> is analogous to the two’s complement (i.e., the value of <code class="language-plaintext highlighter-rouge">-x</code> when viewed as an unsigned integer on a binary machine). It is equal to <code class="language-plaintext highlighter-rouge">MAX_VALUE - x + 1</code>, where <code class="language-plaintext highlighter-rouge">MAX_VALUE</code> is the largest value that <code class="language-plaintext highlighter-rouge">x</code> could be. For example, this is <code class="language-plaintext highlighter-rouge">999_999_999_999_999_999</code> (fifteen nines) for <code class="language-plaintext highlighter-rouge">rr</code>. <a href="#fnref:10s-cmp" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2022-07-13 • 2429 words • 26 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> • <a href="https://mcyoung.xyz/tags.html#templates">#templates</a> </span> <h1><a href="/2022/07/13/tuples-the-hard-way/"> std::tuple the Hard Way </a></h1> </div> <div class="post"> <p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">tuple</span> <span class="p">{</span>
  <span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoidGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVzPlxuY2xhc3MgdHVwbGUg e1xuICBUeXBlcy4uLiB2YWx1ZXM7XG59OyIsImNvbXBpbGVycyI6W10sImV4 ZWN1dG9ycyI6W3siY29tcGlsZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJP dXRwdXRWaXNpYmxlIjp0cnVlLCJjb21waWxlciI6eyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6IiJ9fV19XX0=">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:1">C++</a></div></div> <p>If you click through to Godbolt, you’ll see it doesn’t: this feature doesn’t exist in C++<sup id="fnref:circle-cxx" role="doc-noteref"><a href="#fn:circle-cxx" class="footnote" rel="footnote">2</a></sup> (normally, you’d do <code class="language-plaintext highlighter-rouge">std::tuple&lt;Types...&gt;</code>, but we need to write down <code class="language-plaintext highlighter-rouge">std::tuple</code> somehow). The usual approach is to use some kind of recursive template, which can tend to generate a lot of code.</p> <p>However, C++ does actually have tuples built into the language, as a C++11 feature… lambdas! As an extra challenge, we’re going to try to minimize the number of templates that the compiler needs to instantiate; <code class="language-plaintext highlighter-rouge">std::tuple</code> is famously bad about this and can lead to very poor build performance.</p> <p>For our tuple library type, we need to solve the following problems:</p> <ul> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple()</code> and <code class="language-plaintext highlighter-rouge">std::tuple(args...)</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::apply</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple_element</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::get</code>?</li> </ul> <h2 id="the-power-of-"><a href="#the-power-of-">The Power of [](){}</a></h2> <p>Alright, let’s back up. In C++11, we got <em>lambdas</em>, which are expressions that expand to anonymous functions. In C++, lambdas are <em>closures</em>, meaning that they capture (“close over”) their environment.</p> <p>This is a lambda in action:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">// 13</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">C++</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">C++</a></div></div> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">C++</a></div></div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">C++</a></div></div> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">C++</a></div></div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">C++</a></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">C++</a></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">3</a></sup>:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">C++</a></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">C++</a></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this</li> </ol> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <ol> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</p> </li> </ol> <p>We can use this type like this:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">C++</a></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">C++</a></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">C++</a></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">4</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">C++</a></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">C++</a></div></div> <p>Now, our constructor looks like this:</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">C++</a></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">C++</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">C++</a></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">C++</a></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">C++</a></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">5</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">C++</a></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">C++</a></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">6</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="codeblock" id="code:26"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:26">C++</a></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="codeblock" id="code:27"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:27">C++</a></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="codeblock" id="code:28"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:28">C++</a></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="codeblock" id="code:29"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:29">C++</a></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="codeblock" id="code:30"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:30">C++</a></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="codeblock" id="code:31"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:31">C++</a></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="codeblock" id="code:32"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:32">C++</a></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="codeblock" id="code:33"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:33">C++</a></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="codeblock" id="code:34"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:34">C++</a></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="codeblock" id="code:35"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:35">C++</a></div></div> <p>Now we can see everything in action:</p> <div class="codeblock" id="code:36"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:36">C++</a></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">7</a></sup>.</p> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="codeblock" id="code:38"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:38">C++</a></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:circle-cxx" role="doc-endnote"> <p>The Circle compiler totally laughs in our faces, though, because it <em>has this exact syntax</em>. <a href="https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple">https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple</a> <a href="#fnref:circle-cxx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">C++</a></div></div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoiXG4jaW5jbHVkZSA8bmV3PiBcbiNpbmNsdWRlIDx1dGlsaXR5PiBcblxu ICAgIHRlbXBsYXRlIDx0eXBlbmFtZSBUPlxuICAgIGNsYXNzIGFsaWduYXMo VCkgU3RvcmFnZUZvciB7XG4gICAgIHB1YmxpYzpcbiAgICAgIFN0b3JhZ2VG b3IoKSA9IGRlZmF1bHQ7XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4g QXJncz5cbiAgICAgIHZvaWQgSW5pdChBcmdzJiYuLi4gYXJncykge1xuICAg ICAgICBuZXcgKHJlaW50ZXJwcmV0X2Nhc3Q8VCo+KCZkYXRhXykpIFQoXG4g ICAgICAgICAgc3RkOjpmb3J3YXJkPEFyZ3M+KGFyZ3MpLi4uKTtcbiAgICAg IH1cblxuICAgICAgY29uc3QgVCogZ2V0KCkgY29uc3QgeyByZXR1cm4gcmVp bnRlcnByZXRfY2FzdDxjb25zdCBUKj4oJmRhdGFfKTsgfVxuICAgICAgVCog Z2V0KCkgeyByZXR1cm4gcmVpbnRlcnByZXRfY2FzdDxUKj4oJmRhdGFfKTsg fVxuICAgICAgY29uc3QgVCYgb3BlcmF0b3IqKCkgY29uc3QgeyByZXR1cm4g KmdldCgpOyB9XG4gICAgICBUJiBvcGVyYXRvciooKSB7IHJldHVybiAqZ2V0 KCk7IH1cbiAgICAgIGNvbnN0IFQqIG9wZXJhdG9yLT4oKSBjb25zdCB7IHJl dHVybiBnZXQoKTsgfVxuICAgICAgVCogb3BlcmF0b3ItPigpIHsgcmV0dXJu IGdldCgpOyB9XG4gICAgIHByaXZhdGU6XG4gICAgICBjaGFyIGRhdGFfW3Np emVvZihUKV07XG4gICAgfTtcblxuICAgIHRlbXBsYXRlIDx0eXBlbmFtZS4u LiBUeXBlcz5cbiAgICBjbGFzcyBUdXBsZSB7XG4gICAgIHB1YmxpYzpcbiAg ICAgIFR1cGxlKCkge1xuICAgICAgICBsYW1iZGFfKFtdIChTdG9yYWdlRm9y PFR5cGVzPiYuLi4gcGxhY2VzKSB7XG4gICAgICAgICAgKHBsYWNlcy5Jbml0 KCksIC4uLik7XG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgdGVt cGxhdGUgPHR5cGVuYW1lLi4uIEFyZ3MsXG4gICAgICAgICAgICAgICAgZGVj bHR5cGUoKG5ldyAobnVsbHB0cikgVHlwZXMoc3RkOjpkZWNsdmFsPEFyZ3M+ KCkpLCAuLi4pKVxuICAgICAgICAgICAgICAgICAgPSBudWxscHRyPlxuICAg ICAgVHVwbGUoQXJncyYmLi4uIGFyZ3MpIHtcbiAgICAgICAgbGFtYmRhXyhb Jl0gKFN0b3JhZ2VGb3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAg ICAocGxhY2VzLkluaXQoc3RkOjpmb3J3YXJkPGRlY2x0eXBlKGFyZ3MpPihh cmdzKSksIC4uLik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBU dXBsZShjb25zdCBUdXBsZSYgdGhhdCkge1xuICAgICAgICBsYW1iZGFfKFsm XSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRoZXNlKSB7XG4gICAgICAgICAg dGhhdC5sYW1iZGFfKFsmXSAoY29uc3QgU3RvcmFnZUZvcjxUeXBlcz4mLi4u IHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVzZS5nZXQoKSkgVHlw ZXMoKnRob3NlKSwgLi4uKTsgICBcbiAgICAgICAgICB9KTtcbiAgICAgICAg fSk7XG4gICAgICB9XG5cbiAgICAgIFR1cGxlKFR1cGxlJiYgdGhhdCkge1xu ICAgICAgICBsYW1iZGFfKFsmXSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRo ZXNlKSB7XG4gICAgICAgICAgdGhhdC5sYW1iZGFfKFsmXSAoU3RvcmFnZUZv cjxUeXBlcz4mLi4uIHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVz ZSkgVHlwZXMoc3RhdGljX2Nhc3Q8VHlwZXMmJj4oKnRob3NlKSksIC4uLik7 ICAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4g ICAgICB+VHVwbGUoKSB7XG4gICAgICAgIGxhbWJkYV8oW10gKFN0b3JhZ2VG b3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAgICAocGxhY2VzLT5+ VHlwZXMoKSwgLi4uKTtcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAg IHByaXZhdGU6XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4gQXJncz5c biAgICAgIHN0YXRpYyBhdXRvIFR1cGxlTGFtYmRhKEFyZ3MuLi4gYXJncykg e1xuICAgICAgICByZXR1cm4gWz1dIChhdXRvIGNhbGxiYWNrKSBtdXRhYmxl IC0+IGRlY2x0eXBlKGF1dG8pIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJh Y2soYXJncy4uLik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG11 dGFibGUgZGVjbHR5cGUoVHVwbGVMYW1iZGEoU3RvcmFnZUZvcjxUeXBlcz57 fS4uLikpIGxhbWJkYV8gPVxuICAgICAgICBUdXBsZUxhbWJkYShTdG9yYWdl Rm9yPFR5cGVzPnt9Li4uKTtcbiAgICB9O1xuXG4gICAgdGVtcGxhdGUgPHR5 cGVuYW1lLi4uIFR5cGVzPlxuICAgIFR1cGxlKFR5cGVzLi4uKSAtPiBUdXBs ZTxUeXBlcy4uLj47XG4gICAgdGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVz PlxuICAgIFR1cGxlKGNvbnN0IFR1cGxlPFR5cGVzLi4uPiYpIC0+IFR1cGxl PFR5cGVzLi4uPjtcblxuICAgIGludCBtYWluKCkge1xuICAgICAgVHVwbGUg dHVwezEsIDIsIFwiZm9vXCIsIFwiYmFyXCJ9O1xuICAgICAgVHVwbGUgdHVw MiA9IHR1cDtcbiAgICB9IiwiY29tcGlsZXJzIjpbeyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6Ii0tc3RkPWMrKzE3In1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:25">C++</a></div></div> <p><a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <div class="codeblock" id="code:37"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="cp">#endif
</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>
  
  <span class="cp">#else // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span>  <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cp">#endif // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tup</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="cp">#if USE_CLANG_INTRINSIC
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="cp">#else
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TupleType</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/z/eYeb9Y6cn">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:37">C++</a></div></div> <p><a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2022-06-07 • 5332 words • 59 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> </span> <h1><a href="/2022/06/07/alkyne-gc/"> The Alkyne GC </a></h1> </div> <div class="post"> <p><a href="https://github.com/mcy/alkyne">Alkyne</a> is a scripting language I built a couple of years ago for generating configuration blobs. Its interpreter is a naive AST walker<sup id="fnref:ast-walker" role="doc-noteref"><a href="#fn:ast-walker" class="footnote" rel="footnote">1</a></sup> that uses ARC<sup id="fnref:arc" role="doc-noteref"><a href="#fn:arc" class="footnote" rel="footnote">2</a></sup> for memory management, so it’s pretty slow, and I’ve been gradually writing a <a href="https://github.com/mcy/alkyne/tree/new-engine">new evaluation engine</a> for it.</p> <p>This post isn’t about Alkyne itself, that’s for another day. For now, I’d like to write down some notes for the GC I wrote<sup id="fnref:src" role="doc-noteref"><a href="#fn:src" class="footnote" rel="footnote">3</a></sup> for it, and more generally provide an introduction to memory allocators (especially those that would want to collude with a GC).</p> <p>This post is intended for people familiar with the basics of low-level programming, such as pointers and syscalls. Alkyne’s GC is intended to be simple while still having reasonable performance. This means that the design contains all the allocator “tropes,” but none of the hairy stuff.</p> <p>My hope is readers new to allocators or GCs will come away with an understanding of these tropes and the roles they play in a modern allocator.</p> <blockquote> <p>Thank you to James Farrell, Manish Goregaokar, Matt Kulukundis, JeanHeyd Meneide, Skye Thompson, and Paul Wankadia for providing feedback on various drafts of this article. This was a tough one to get right. :)</p> </blockquote> <h2 id="trailhead"><a href="#trailhead">Trailhead</a></h2> <p>The Alkyne GC is solving a very specific problem, which allows us to limit what it actually needs to do. Alkyne is an “embeddable” language like JavaScript, so its heap is not intended to be big; in fact, for the benefit of memory usage optimizations, it’s ideal to use 32-bit pointers (a 4 gigabyte address space).</p> <p>The heap needs to be able to manage arbitrarily-large allocations (for lists), and allocations as small as eight bytes (for floats<sup id="fnref:nan-boxing" role="doc-noteref"><a href="#fn:nan-boxing" class="footnote" rel="footnote">4</a></sup>). Allocation should be reasonably quick, but due to the size of the heap, walking the entire heap is totally acceptable.</p> <p>Because we’re managing a fixed-size heap, we can simply ask the operating system for a contiguous block of that size up-front using the <code class="language-plaintext highlighter-rouge">mmap()</code> syscall. An Alkyne pointer is simply a 32-bit offset into this giant allocation, which can be converted to and from a genuine CPU pointer by adding or subtracting the base address of the heap.</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-text" data-lang="text"> 4GB Heap
 +-------------------------------------------------+
 |                x                                |
 +-------------------------------------------------+
 ^                ^
 base             base + ptr_to_x</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Plaintext</a></div></div> <p>The OS won’t actually reserve 4GB of memory for us; it will only allocate one system page (4KB) at a time. If we read or write to a particular page in the heap for the first time, the OS will only then find physical RAM to back it<sup id="fnref:os-allocator" role="doc-noteref"><a href="#fn:os-allocator" class="footnote" rel="footnote">5</a></sup>.</p> <p>Throughout, we’ll be working with this fixed-size heap, and won’t think too hard about where it came from. For our purposes, it is essentially a <code class="language-plaintext highlighter-rouge">Box&lt;[u8]&gt;</code>, but we’ll call it a <code class="language-plaintext highlighter-rouge">Heap&lt;[u8]&gt;</code> to make it clear this memory we got from the operating system (but, to be clear, the entire discussion applies just as well to an ordinary gigantic <code class="language-plaintext highlighter-rouge">Box&lt;[u8]&gt;</code>)</p> <p>The Alkyne language does not have threads, so we can eschew concurrency. This significantly reduces the problems we will need to solve. Most modern allocators and garbage collectors are violently concurrent by nature, and unfortunately, much too advanced for one article. There are links below to fancier GCs you can poke around in.</p> <h2 id="a-heap-of-trouble"><a href="#a-heap-of-trouble">A Heap of Trouble</a></h2> <p>To build a garbage collector, we first need an allocator. We could “just”<sup id="fnref:load-bearing" role="doc-noteref"><a href="#fn:load-bearing" class="footnote" rel="footnote">6</a></sup> use the system heap as a source of pages, but most garbage collectors collude with the allocator, since they will want to use similar data structures. Thus, if we are building a garbage collector, we might as well build the allocator too.</p> <p>An allocator, or “memory heap” (not to be confused with a min-heap, an unrelated but <em>wicked</em> data structure), services requests for <em>allocations</em>: unique leases of space in the managed heap of various sizes, which last for lifetimes not known until runtime. These allocations may also be called <em>objects</em>, and a heap may be viewed as a general-purpose object pool.</p> <p>The most common API for a heap is:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Allocator</span> <span class="p">{</span>
  <span class="c1">// Returns a *unique pointer* managed by this allocator</span>
  <span class="c1">// to memory as large as requested, and as aligned</span>
  <span class="c1">// as we'd like.</span>
  <span class="c1">// </span>
  <span class="c1">// Returns null on failure.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
  <span class="c1">// Frees a pointer returned by `Alloc` may be called at</span>
  <span class="c1">// most once.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>Originally the examples were in C++, which I feel is more accessible (lol) but given that Alkyne itself is written in Rust I felt that would make the story flow better.</p> </blockquote> <p>This is the “malloc” API, which is actually very deficient; ideally, we would do something like Rust’s <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html"><code class="language-plaintext highlighter-rouge">Allocator</code></a>, which requires providing size <em>and</em> alignment to both the allocation <em>and</em> deallocation functions.</p> <p>Unfortunately<sup id="fnref:i-tried" role="doc-noteref"><a href="#fn:i-tried" class="footnote" rel="footnote">7</a></sup>, this means I need to explain alignment.</p> <h3 id="good-pointers-evil-pointers-lawful-pointers-chaotic-pointers"><a href="#good-pointers-evil-pointers-lawful-pointers-chaotic-pointers">Good Pointers, Evil Pointers, Lawful Pointers, Chaotic Pointers</a></h3> <p>“Alignment” is a somewhat annoying property of a pointer. A pointer is aligned to N bytes (always a power of 2) if its address is divisible by N. A pointer is “well-aligned” (or just “aligned”) if its address is aligned to the natural alignment of the thing it points to. For ints, this is <em>usually</em> their size; for structs, it is the maximum alignment among the alignments of the fields of that struct.</p> <p>Performing operations on a pointer requires that it be aligned<sup id="fnref:unaligned" role="doc-noteref"><a href="#fn:unaligned" class="footnote" rel="footnote">8</a></sup>. This is annoying because it requires some math. Specifically we need three functions:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="cd">/// Checks that `ptr` is aligned to an alignment.</span>
<span class="k">fn</span> <span class="nf">is_aligned</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
  <span class="n">ptr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="cd">/// Rounds `ptr` down to a multiple of `align`.</span>
<span class="k">fn</span> <span class="nf">align_down</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="n">ptr</span> <span class="o">&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Rounds `ptr` up to a multiple of `align`.</span>
<span class="k">fn</span> <span class="nf">align_up</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="c1">// (I always look this one up. &gt;_&gt;)</span>
  <span class="nf">align_down</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Computes how much needs to be added to `ptr` to align it.</span>
<span class="k">fn</span> <span class="nf">misalign</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">align_up</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> <span class="o">-</span> <span class="n">ptr</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Rust</a></div></div> <p>(Exercise: prove these formulas.)</p> <p>For the rest of the article I will assume I have these three functions available at any time for whatever type of integer I’d like (including raw pointers which are just boutique<sup id="fnref:provenance" role="doc-noteref"><a href="#fn:provenance" class="footnote" rel="footnote">9</a></sup> integers).</p> <p>Also we will treat the <code class="language-plaintext highlighter-rouge">Heap&lt;[u8]&gt;</code> holding our entire heap as being infinitely aligned; i.e. as a pointer it is aligned to all possible alignments that could matter (i.e. page-aligned, 4KB as always). (For an ordinary <code class="language-plaintext highlighter-rouge">Box&lt;[u8]&gt;</code>, this is not true.)</p> <h3 id="the-trivial-heap"><a href="#the-trivial-heap">The Trivial Heap</a></h3> <p>Allocating memory is actually very easy. <em>Arenas</em> are the leanest and meanest in the allocator food chain; they simply don’t bother to free any memory.</p> <p>This means allocation is just incrementing a cursor indicating where the hitherto-unallocated memory is.</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-text" data-lang="text"> +-------------------------------------------------+
 | Allocated        | Free                         |
 +-------------------------------------------------+
                    ^
                    cursor</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Plaintext</a></div></div> <p>Our allocator is as simple as <code class="language-plaintext highlighter-rouge">return ptr++;</code>.</p> <p>This is straightforward to implement in code:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Arena</span> <span class="p">{</span>
  <span class="n">heap</span><span class="p">:</span> <span class="n">Heap</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">cursor</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Allocator</span> <span class="k">for</span> <span class="n">Arena</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="c1">// To get an aligned pointer, we need to burn some "alignment</span>
    <span class="c1">// padding". This is one of the places where alignment is</span>
    <span class="c1">// annoying.</span>
    <span class="k">let</span> <span class="n">needed</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="nf">misalign</span><span class="p">(</span><span class="k">self</span><span class="py">.heap</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="n">align</span><span class="p">);</span>

    <span class="c1">// Check that we're not out of memory.</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.heap</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="k">self</span><span class="py">.cursor</span> <span class="o">&lt;</span> <span class="n">needed</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Advance the cursor and cut off the end of the allocated</span>
    <span class="c1">// section.</span>
    <span class="k">self</span><span class="py">.cursor</span> <span class="o">+=</span> <span class="n">needed</span><span class="p">;</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.heap</span><span class="p">[</span><span class="k">self</span><span class="py">.cursor</span> <span class="o">-</span> <span class="n">size</span><span class="p">]</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ayy lmao</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>Arenas are very simple, but far from useless! They’re great for holding onto data that exists for the context of a “session”, such as for software that does lots of computations and then exits (a compiler) or software that handles requests from clients, where lots of data lives for the duration of the request and no longer (a webserver).</p> <p>They are not, however, good for long-running systems. Eventually the heap will be exhausted if objects are not recycled.</p> <p>Making this work turns out to be hard<sup>[citation-needed]</sup>. This is the “fundamental theorem” of allocators:</p> <blockquote id="thm:fundamental-theorem-of-allocators" class="thm"> <p><a href="#thm:fundamental-theorem-of-allocators"><span class="chip">theorem</span><span class="title">Fundamental “Theorem” of Allocators</span></a></p> <p>Handing out memory is easy. Handing it out <strong>repeatedly</strong> is hard.</p> </blockquote> <p>Thankfully, over the last fifty years we’ve mostly figured this out. Allocator designs can get pretty gnarly.</p> <h2 id="four-tropes"><a href="#four-tropes">Four Tropes</a></h2> <p>From here, we will gradually augment our allocator with more features to allow it to service all kinds of requests. For this, we will implement four common allocator features:</p> <ol> <li>Blocks and a block cache.</li> <li>Free lists.</li> <li>Block merging and splitting.</li> <li>Slab allocation.</li> </ol> <p>All four of these are present in some form in most modern allocators.</p> <h3 id="blocks"><a href="#blocks">Blocks</a></h3> <p>The first thing we should do is to deal in fixed-size blocks of memory of some minimum size. If you ask <code class="language-plaintext highlighter-rouge">malloc()</code> for a single byte, it will probably give you like 8 bytes on most systems. No one is asking <code class="language-plaintext highlighter-rouge">malloc()</code> for single bytes, so we can quietly round up and not have people care. (Also, Alkyne’s smallest heap objects are eight bytes, anyways.)</p> <p>Blocks are also convenient, because we can keep per-block metadata on each one, as a header before the user’s data:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Block</span> <span class="p">{</span>
  <span class="n">header</span><span class="p">:</span> <span class="n">Header</span><span class="p">,</span>
  <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SIZE</span><span class="p">],</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Rust</a></div></div> <p>To allow blocks to be re-used, we can keep a cache of recently freed blocks. The easiest way to do this is with a stack. Note that the heap is now made of <code class="language-plaintext highlighter-rouge">Block</code>s, not plain bytes.</p> <p>To allocate storage, first we check the stack. If the stack is empty, we revert to being an arena and increment the cursor. To free, we push the block onto the stack, so <code class="language-plaintext highlighter-rouge">alloc()</code> can return it on the next call.</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">BlockCache</span> <span class="p">{</span>
  <span class="n">heap</span><span class="p">:</span> <span class="n">Heap</span><span class="o">&lt;</span><span class="p">[</span><span class="n">Block</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">cursor</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">free_stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">Block</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Allocator</span> <span class="k">for</span> <span class="n">BlockCache</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="c1">// Check that the size isn't too big. We don't need to</span>
    <span class="c1">// bother with alignment, because every block is</span>
    <span class="c1">// infinitely-aligned, just like the heap itself.</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">BLOCK_SIZE</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Try to serve a block from the stack.</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free_stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">block</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Fall back to arena mode.</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.cursor</span> <span class="o">==</span> <span class="k">self</span><span class="py">.heap</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="py">.cursor</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.heap</span><span class="p">[</span><span class="k">self</span><span class="py">.cursor</span><span class="p">]</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Use pointer subtraction to find the start of the block.</span>
    <span class="k">let</span> <span class="n">block</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.sub</span><span class="p">(</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Header</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.free_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p>This allocator has a problem: it relies on the system allocator! <code class="language-plaintext highlighter-rouge">Heap</code> came directly from the OS, but <code class="language-plaintext highlighter-rouge">Vec</code> talks to <code class="language-plaintext highlighter-rouge">malloc()</code> (or something like it). It also adds some pretty big overhead: the <code class="language-plaintext highlighter-rouge">Vec</code> needs to be able to resize, since it grows as more and more things are freed. This can lead to long pauses during <code class="language-plaintext highlighter-rouge">free()</code> as the vector resizes.</p> <p>Cutting out the middleman gives us more control over this overhead.</p> <h3 id="free-lists"><a href="#free-lists">Free Lists</a></h3> <p>Of course, no one has ever heard of a “free stack”; everyone uses free lists! A free list is the cache idea but implemented as an <em>intrusive linked list</em>.</p> <p>A linked list is this data structure:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nb">Nil</span><span class="p">,</span>
  <span class="nf">Cons</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="c1">//   ^~~ oops I allocated again</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>This has the same problem of needing to find an allocator to store the nodes. An intrusive list avoids that by making the nodes <em>part</em> of the elements. The <code class="language-plaintext highlighter-rouge">Header</code> we reserved for ourselves earlier is the perfect place to put it:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Header</span> <span class="p">{</span>
  <span class="cd">/// Pointer to the next and previous blocks in whatever</span>
  <span class="cd">/// list the block is in.</span>
  <span class="n">next</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">,</span>
  <span class="n">prev</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>In particular we want to make sure block are in doubly-linked lists, which have the property that any element can be removed from them without walking the list.</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-text" data-lang="text">   list.root
     |
     v
 +-&gt; Block--------------------------+
 |   | next | null | data data data |
 |   +------------------------------+
 +-----/------+
      /       |
     v        |
 +-&gt; Block--------------------------+
 |   | next | prev | data data data |
 |   +------------------------------+
 +-----/------+
      /       |
     v        |
 +-&gt; Block--------------------------+
 |   | next | prev | data data data |
 |   +------------------------------+
 +-----/------+
      /       |
     v        |
     Block--------------------------+
     | null | prev | data data data |
     +------------------------------+</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Plaintext</a></div></div> <p>We also introduce a <code class="language-plaintext highlighter-rouge">List</code> container type that holds the root node of a list of blocks, to give us a convenient container-like API. This type looks like this:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
  <span class="cd">/// The root is actually a sacrificial block that exists only to</span>
  <span class="cd">/// make it possible to unlink blocks in the middle of a list. This</span>
  <span class="cd">/// needs to exist so that calling unlink() on the "first" element</span>
  <span class="cd">/// of the list has a predecessor to replace itself with.</span>
  <span class="n">root</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">List</span> <span class="p">{</span>
  <span class="cd">/// Pushes a block onto the list.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">block</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">root</span><span class="py">.header.next</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">root</span><span class="py">.header.next</span><span class="p">;</span>
      <span class="n">block</span><span class="py">.header.next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
      <span class="n">first</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">root</span><span class="py">.header.next</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
    <span class="n">block</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cd">/// Gets the first element of the list, if any.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">first</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">Block</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
    <span class="n">root</span><span class="py">.header.next</span><span class="nf">.as_mut</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <p>We should also make it possible to ask a block whether it is in any list, and if so, remove it.</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Block</span> <span class="p">{</span>
  <span class="cd">/// Checks if this block is part of a list.</span>
  <span class="k">fn</span> <span class="nf">is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="c1">// Only the prev link is guaranteed to exist; next is</span>
    <span class="c1">// null for the last element in a list. Sacrificial</span>
    <span class="c1">// nodes will never have prev non-null, and can't be</span>
    <span class="c1">// unlinked.</span>
    <span class="o">!</span><span class="k">self</span><span class="py">.header.prev</span><span class="nf">.is_null</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="cd">/// Unlinks this linked block from whatever list it's in.</span>
  <span class="k">fn</span> <span class="nf">unlink</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_linked</span><span class="p">());</span>
    <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.header.next</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.header.next</span><span class="p">;</span>
      <span class="n">next</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="k">self</span><span class="py">.header.prev</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="c1">// This is why we need the sacrificial node.</span>
    <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.header.prev</span><span class="p">;</span>
    <span class="n">prev</span><span class="py">.header.next</span> <span class="o">=</span> <span class="k">self</span><span class="py">.header.next</span><span class="p">;</span>

    <span class="k">self</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.header.next</span> <span class="o">=</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>Using these abstractions we can upgrade <code class="language-plaintext highlighter-rouge">BlockCache</code> to <code class="language-plaintext highlighter-rouge">FreeList</code>. We only need to rename <code class="language-plaintext highlighter-rouge">free_stack</code> to <code class="language-plaintext highlighter-rouge">free_list</code>, and make a one-line change:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="o">-</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free_stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
<span class="o">+</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free_list</span><span class="nf">.first</span><span class="p">()</span> <span class="p">{</span>
<span class="o">+</span>   <span class="n">block</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">block</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
 <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Rust</a></div></div> <p>Hooray for encapsulation!</p> <p>This is a very early <code class="language-plaintext highlighter-rouge">malloc()</code> design, similar to the one described in the K&amp;R C book. It does have big blind spot: it can only serve up blocks up to a fixed size! It’s also quite wasteful, because all allocations are served the same size blocks: the bigger we make the maximum request, the more wasteful <code class="language-plaintext highlighter-rouge">alloc(8)</code> gets.</p> <h3 id="block-splitting-alkynes-way"><a href="#block-splitting-alkynes-way">Block Splitting (Alkyne’s Way)</a></h3> <p>The next step is to use a block splitting/merging scheme, such as the <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation"><em>buddy system</em></a>. Alkyne does not precisely use a buddy system, but it does something similar.</p> <p>Alkyne does not have fixed-size blocks. Like many allocators, it defines a “page” of memory as the atom that it keeps its data structures. Alkyne defines a page to be 4KB, but other choices are possible: TCMalloc uses 8KB pages.</p> <p>In Alkyne, pages come together to form contiguous, variable-size <em>reams</em> (get it?). These take the place of blocks.</p> <h4 id="page-descriptors"><a href="#page-descriptors">Page Descriptors</a></h4> <p>Merging and splitting makes it hard to keep headers at the start of reams, so Alkyne puts them all in a giant array somewhere else. Each page gets its own “header” called a page descriptor, or <a href="https://github.com/mcy/alkyne/blob/a62ad3b7ee70268625da640c1edeea8ff7116512/src/eval2/gc.rs#L416"><code class="language-plaintext highlighter-rouge">Pd</code></a>.</p> <p>The array of page descriptors lives at the beginning of the heap, and the actual pages follow after that. It turns out that this array has a maximum size, which we can use to pre-compute where the array ends.</p> <p>Currently, each <code class="language-plaintext highlighter-rouge">Pd</code> is 32 bytes, in addition to the 4KB it describes. If we divide 4GB by 32 + 4K, it comes out to around four million pages (4067203 to be precise). Rounded up to the next page boundary, this means that pages begin at the 127102nd 4K boundary after the <code class="language-plaintext highlighter-rouge">Heap&lt;[u8]&gt;</code> base address, or an offset of <code class="language-plaintext highlighter-rouge">0x7c1f400</code> bytes.</p> <p>Having them all in a giant array is also very useful, because it means the GC can trivially find <em>every allocation</em> in the whole heap: just iterate the <code class="language-plaintext highlighter-rouge">Pd</code> array!</p> <p>So! This is our heap:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-text" data-lang="text">+---------------------------------------+  &lt;-- mmap(2)'d region base
| Pd | Pd | Pd | Pd | Pd | Pd | Pd | Pd | \
+---------------------------------------+ |--- Page Descriptors
| Pd | Pd | Pd | Pd | Pd | Pd | Pd | Pd | |    for every page we can
+---------------------------------------+ |    ever allocate.
: ...                                   : |
+---------------------------------------+ |
| Pd | Pd | Pd | Pd | Pd | Pd | Pd | Pd | /
+---------------------------------------+  &lt;-- Heap base address
| Page 0                                | \    = region + 0x7c1f400
|                                       | |
|                                       | |--- 4K pages corresponding
+---------------------------------------+ |    to the Pds above.
| Page 1                                | |    (not to scale)
|                                       | |
|                                       | |
+---------------------------------------+ |
: ...                                   | |
+---------------------------------------+ |
| Page N                                | |
|                                       | |
|                                       | /
+---------------------------------------+
  (not to scale by a factor of about 4)</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Plaintext</a></div></div> <p>Each one of those little <code class="language-plaintext highlighter-rouge">Pd</code>s looks something like this:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Pd</span> <span class="p">{</span>
  <span class="n">gc_bits</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">prev</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
  <span class="n">class</span><span class="p">:</span> <span class="n">SizeClass</span><span class="p">,</span>
  <span class="c1">// More fields...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">prev</code> and <code class="language-plaintext highlighter-rouge">next</code> are the intrusive linked list pointers used for the free lists, but now they are indices into the <code class="language-plaintext highlighter-rouge">Pd</code> array. The other fields will be used for this and the trope that follows.</p> <p>Given a pointer into a page, we can get the corresponding <code class="language-plaintext highlighter-rouge">Pd</code> by <code class="language-plaintext highlighter-rouge">align_down()</code>‘ing to a page boundary, computing the index of the page (relative to the heap base), and then index into the <code class="language-plaintext highlighter-rouge">Pd</code> array. This process can be reversed to convert a pointer to a <code class="language-plaintext highlighter-rouge">Pd</code> into a pointer to a page, so going between the two is very easy.</p> <blockquote id="note:2" class="note"> <p><a href="#note:2"><span class="chip">note</span></a></p> <p>I won’t cover this here, but Alkyne actually wraps <code class="language-plaintext highlighter-rouge">Pd</code> pointers in a special <code class="language-plaintext highlighter-rouge">PdRef</code> type that also carries a reference to the <code class="language-plaintext highlighter-rouge">Heap</code>; this allows implementing functions like <code class="language-plaintext highlighter-rouge">is_linked()</code>, <code class="language-plaintext highlighter-rouge">unlink()</code>, and <code class="language-plaintext highlighter-rouge">data()</code> directly.</p> <p>I won’t show how this is implemented, since it’s mostly boilerplate.</p> </blockquote> <h4 id="reams-of-pages"><a href="#reams-of-pages">Reams of Pages</a></h4> <p>There is one giant free list that contains all of the reams. Reams use their first page’s descriptor to track all of their metadata, including the list pointers for the free list. The <code class="language-plaintext highlighter-rouge">len</code> field additionally tracks how many <em>additional</em> pages are in the ream. <code class="language-plaintext highlighter-rouge">gc_bits</code> is set to 1 if the page is in use and 0 otherwise.</p> <p>To allocate N continuous pages from the free ream list:</p> <ol> <li>We walk through the free ream list, and pick the first one with at least N pages.</li> <li>We “split” it: the first N pages are returned to fulfill the request.</li> <li>The rest of the ream is put back into the free list.</li> <li>If no such ream exists, we allocate a max-sized ream<sup id="fnref:max-size" role="doc-noteref"><a href="#fn:max-size" class="footnote" rel="footnote">10</a></sup> (65536 pages), and split that as above.</li> </ol> <p>In a sense, each ream is an arena that we allocate smaller reams out of; those reams cannot be “freed” back to the ream they came from. Instead, to free a ream, we just stick it back on the main free list.</p> <p>If we ever run out, we turn back into an arena and initialize the next uninitialized <code class="language-plaintext highlighter-rouge">Pd</code> in the big ol’ <code class="language-plaintext highlighter-rouge">Pd</code> array.</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">ReamAlloc</span> <span class="p">{</span>
  <span class="n">heap</span><span class="p">:</span> <span class="n">Heap</span><span class="o">&lt;</span><span class="p">[</span><span class="n">Page</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">cursor</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">free_list</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// The offset to the end of the maximally-large Pd array.</span>
<span class="cd">/// This can be computed ahead of time.</span>
<span class="k">const</span> <span class="n">PAGES_START</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Allocator</span> <span class="k">for</span> <span class="n">ReamAlloc</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="c1">// We don't need to bother with alignment, because every page is</span>
    <span class="c1">// already infinitely aligned; we only allocate at the page</span>
    <span class="c1">// boundary.</span>
    <span class="k">let</span> <span class="n">page_count</span> <span class="o">=</span> <span class="nf">align_up</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4096</span><span class="p">;</span>

    <span class="c1">// Find the first page in the list that's big enough.</span>
    <span class="c1">// (Making `List` iterable is an easy exercise.)</span>
    <span class="k">for</span> <span class="n">pd</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">pd</span><span class="py">.len</span> <span class="o">&lt;</span> <span class="n">page_count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">continue</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="n">pd</span><span class="py">.len</span> <span class="o">==</span> <span class="n">page_count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="c1">// No need to split here.</span>
        <span class="n">pd</span><span class="nf">.unlink</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">pd</span><span class="nf">.data</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="c1">// We can chop off the *end* of the ream to avoid needing</span>
      <span class="c1">// to update any pointers.</span>
      <span class="k">let</span> <span class="n">new_ream</span> <span class="o">=</span> <span class="n">pd</span><span class="nf">.add</span><span class="p">(</span><span class="n">page_count</span><span class="p">);</span>
      <span class="n">new_ream</span><span class="py">.len</span> <span class="o">=</span> <span class="n">page_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">pd</span><span class="py">.len</span> <span class="o">-=</span> <span class="n">page_count</span><span class="p">;</span>

      <span class="k">return</span> <span class="n">new_ream</span><span class="nf">.data</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Allocate a new ream. This is more of the same arena stuff.</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Find the Pd corresponding to this page's pointer. This</span>
    <span class="c1">// will always be a ream's first Pd assuming the user</span>
    <span class="c1">// didn't give us a bad pointer.</span>
    <span class="k">let</span> <span class="n">pd</span> <span class="o">=</span> <span class="nn">Pd</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.free_list</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Rust</a></div></div> <p>This presents a problem: over time, reams will shrink and never grow, and eventually there will be nothing left but single pages.</p> <p>Top fix this, we can merge reams (not yet implemented in Alkyne). Thus:</p> <ol> <li>Find two adjacent, unallocated reams.</li> <li>Unlink the second ream from the free list.</li> <li>Increase the length of the first ream by the number of pages in the second.</li> </ol> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// `reams()` returns an iterator that walks the `Pd` array using</span>
<span class="c1">// the `len` fields to find the next ream each time.</span>
<span class="k">for</span> <span class="n">pd</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.reams</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">pd</span><span class="py">.gc_bits</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
  <span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pd</span><span class="nf">.add</span><span class="p">(</span><span class="n">pd</span><span class="py">.len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">next</span><span class="py">.gc_bits</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
    <span class="n">next</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="n">pd</span><span class="py">.len</span> <span class="o">+=</span> <span class="n">next</span><span class="py">.len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Rust</a></div></div> <p>We don’t need to do anything to the second ream’s <code class="language-plaintext highlighter-rouge">Pd</code>; by becoming part of the first ream, it is subsumed. Walking the heap requires using reams’ lengths to skip over currently-invalid <code class="language-plaintext highlighter-rouge">Pd</code>s, anyways.</p> <p>We have two options for finding mergeable reams. Either we can walk the entire heap, as above, or, when a ream is freed, we can check that the previous and following reams are mergeable (finding the previous ream would require storing the length of a ream at its first <em>and</em> last <code class="language-plaintext highlighter-rouge">Pd</code>).</p> <p>Which merging strategy we use depends on whether we’re implementing an ordinary <code class="language-plaintext highlighter-rouge">malloc</code>-like heap or a garbage collector; in the <code class="language-plaintext highlighter-rouge">malloc</code> case, merging on free makes more sense, but merging in one shot makes more sense for Alkyne’s GC (we’ll see why in a bit).</p> <h3 id="slabs-and-size-classes"><a href="#slabs-and-size-classes">Slabs and Size Classes</a></h3> <p>A <em>slab allocator</em> is a specialized allocator that allocates a single type of object; they are quite popular in kernels as pools of commonly-used object. The crux of a slab allocator is that, because everything is the same size, we <em>don’t</em> need to implement splitting and merging. The <code class="language-plaintext highlighter-rouge">BlockCache</code> above is actually a very primitive slab allocator.</p> <p>Our <code class="language-plaintext highlighter-rouge">Pd</code> array is also kind of like a slab allocator; instead of mixing them in with the variably-sized blocks, they all live together with no gaps in between; entire pages are dedicated just to <code class="language-plaintext highlighter-rouge">Pd</code>s.</p> <p>The Alkyne page allocator cannot allocate pages smaller than 4K, and making them any smaller increases the relative overhead of a <code class="language-plaintext highlighter-rouge">Pd</code>. To cut down on book-keeping, we slab-allocate small objects by defining <em>size classes</em>.</p> <p>A size class is size of smaller-than-a-page object that Alkyne will allocate; other sizes are rounded up to the next size class. Entire pages are dedicated to holding just objects of the same size; these are called small object pages, or simply <em>slabs</em>. The size class is tracked with the <code class="language-plaintext highlighter-rouge">class</code> field of the <code class="language-plaintext highlighter-rouge">Pd</code>.</p> <p>Each size class has its own free list of partially-filled slabs of that size. For slabs, <code class="language-plaintext highlighter-rouge">gc_bits</code> field becomes a bitset that tracks which slots in the page are currently in-use, reducing the overhead for small objects to only a little over a single bit each!</p> <p>In the diagram below, bits set in the 32-bit, little-endian bitset indicate which slots in the slab (no to scale!) are filled with three-letter words. (The user likes cats.)</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-text" data-lang="text">  Pd--------------------------------------------+
  | gc_bits: 0b01010011111010100110000010101011 |
  +---------------------------------------------+

 Page--------------------------------------------+
 | cat | ink |     | hat |     | jug |     | fig |
 +-----------------------------------------------+
 |     |     |     |     |     | zip | net |     |
 +-----------------------------------------------+
 |     | aid |     | yes |     | war | cat | van |
 +-----------------------------------------------+
 | can | cat |     |     | rat |     | urn |     |
 +-----------------------------------------------+</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Plaintext</a></div></div> <p>Allocating an object is a bit more complicated now, but now we have a really, really short fast path for small objects:</p> <ol> <li>Round up to the next highest size class, or else to the next page boundary.</li> <li>If a slab size class… a. Check the pertinent slab list for a partially-filled slab. i. If there isn’t one, allocate a page per the instructions below and initialize it as a slab page. b. Find the next available slot with <code class="language-plaintext highlighter-rouge">(!gc_bits).count_trailing_zeros()</code>, and set that bit. c. Return <code class="language-plaintext highlighter-rouge">page_addr + slab_slot_size * slot</code>.</li> <li>Else, if a single page, allocate from the single-page list. a. If there isn’t one, allocate from the ream list as usual.</li> <li>Else, multiple pages, allocate a ream as usual.</li> </ol> <p>Allocating small objects is very fast, since the slab free lists, if not empty, will always have a spot to fill in <code class="language-plaintext highlighter-rouge">gc_bits</code>. Finding the empty spot in the bitset is a few instructions (a <code class="language-plaintext highlighter-rouge">not</code> plust a <code class="language-plaintext highlighter-rouge">ctz</code> or equivalent on most hardware).</p> <p>Alkyne maintains a separate free list for single free pages to speed up finding such pages to turn into fresh slabs. This also minimizes the need to allocate single pages off of large reams, which limits fragmentation.</p> <p>Alkyne’s size classes are the powers of two from 8 (the smallest possible object) to 2048. For the classes 8, 16, and 32, which would have more than 64 slots in the page, we use up to 56 bytes on the page itself to extend <code class="language-plaintext highlighter-rouge">gc_bits</code>; 8-byte pages can only hold 505 objects, instead of the full 512, a 1% overhead.</p> <p>Directly freeing an object via is now tricky, since we do not a priori know the size.</p> <ol> <li>Round the pointer up to the next page boundary, and obtain that page’s <code class="language-plaintext highlighter-rouge">Pd</code>.</li> <li>If this is a start-of-ream page, stick it into the appropriate free list (single page or ream, depending on the size of the ream).</li> <li>Else, we can look at <code class="language-plaintext highlighter-rouge">class</code> to find the size class, and from that, and the offset of the original pointer into the page, the index of the slot.</li> <li>Clear the slot’s index in <code class="language-plaintext highlighter-rouge">gc_bits</code>.</li> <li>If the page was full before, place it onto the correct slab free list; if it becomes empty, place it into the page free list.</li> </ol> <p>At this point, we know whether the page just became partially full or empty, and can move it to the correct free list.</p> <p>Size classes are an important allocator optimization. TCMalloc takes this to an . These constants are generated by some crazy script based on profiling data.</p> <h2 id="intermission"><a href="#intermission">Intermission</a></h2> <p>Before continuing to the GC part of the article, it’s useful to go over what we learned.</p> <p>A neat thing about this is that most of these tricks are somewhat independent. While giving feedback for an early draft, Matt Kulukundis shared <a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U">this awesome talk</a> that describes how to build complex allocators out of simple ones, and covers many of the same tropes as we did here. This perspective on allocators actually blew my mind.</p> <p>Good allocators don’t just use one strategy; the use many and pick and chose the best one for the job based on expected workloads. For example, Alkyne expects to allocate many small objects; the slab pages were originally only for float objects, but it turned out to simplify a lot of the code to make <em>all</em> small objects be slab-allocated.</p> <p>Even size classes are a deep topic: TCMalloc uses <a href="https://research.google/pubs/pub36575/">GWP telemetry</a> from Google’s fleet to inform its <em>many</em> tuning parameters, including its <a href="https://github.com/google/tcmalloc/blob/master/tcmalloc/size_classes.cc">comically large</a> tables of size classes.</p> <p>At this point, we have a pretty solid allocator. Now, let’s get rid of the free function.</p> <h2 id="throwing-out-the-trash"><a href="#throwing-out-the-trash">Throwing out the Trash</a></h2> <p>Garbage collection is very different from manual memory management in that frees are performed in <em>batches</em> without cue from the user. There are no calls to <code class="language-plaintext highlighter-rouge">free()</code>; instead, we need to figure out which calls to <code class="language-plaintext highlighter-rouge">free()</code> we <em>can</em> make on the user’s behalf that they won’t notice (i.e., without quietly freeing pointers the user can still reach, resulting in a use-after-free bug). We need to do this as fast as we can.</p> <p>Alkyne is a “tracing GC”. Tracing GCs walk the “object graph” from a root set of known-reachable objects. Given an object <code class="language-plaintext highlighter-rouge">a</code>, it will <em>trace</em> through any data in the object that it knows is actually a GC pointer. In the object graph, <code class="language-plaintext highlighter-rouge">b</code> is reachable from <code class="language-plaintext highlighter-rouge">a</code> if one can repeatedly trace through GC pointers to get from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code>.</p> <p>Alkyne uses tracing to implement garbage collection in a two-step process, commonly called “mark-and-sweep”.</p> <p><em>Marking</em> consists of traversing the entire graph from a collection of reachable-by-definition values, such as things on the stack, and recording each object that is visited. Every object <em>not</em> so marked must therefore be definitely unreachable and can be reclaimed; this reclamation is called <em>sweeping</em>.</p> <p>Alkyne reverses the order of operations somewhat: it “sweeps” first and then marks, i.e., it marks every value as dead and then, as it walks the graph, marks every block as alive. It then rebuilds the free lists to reflect the new marks, allowing the blocks to be reallocated. This is sometimes called “mark and don’t sweep”, but fixing up the free lists is effectively a sweeping step.</p> <figure> <img src="https://upload.wikimedia.org/wikipedia/commons/4/4a/Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif"/> <figcaption>Marking and sweeping! (via Wikipedia, CC0)</figcaption> </figure> <p>Alkyne is a “stop-the-world” (STW) GC. It needs to pause all program execution while cleaning out the heap. It is possible to build GCs that do not do this (I believe modern HotSpot GCs very rarely stop the world), but also very difficult. Most GCs are world-stopping to some degree.</p> <p>One thing we do not touch on is <em>when</em> to sweep. This is a more complicated and somewhat hand-wavy tuning topic that I’m going to quietly sweep under the rug by pointing you to <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgcpacer.go">how Go does it</a>.</p> <h3 id="heap-armageddon-and-resurrection"><a href="#heap-armageddon-and-resurrection">Heap Armageddon and Resurrection</a></h3> <p>Delicate freeing of individual objects is quite difficult, but scorching the earth is very easy. To do this, we walk the whole <code class="language-plaintext highlighter-rouge">Pd</code> array (see, I said this would be useful!) and blow away every <code class="language-plaintext highlighter-rouge">gc_bits</code>. This leaves the heap in a broken state where every pointer appears to be dangling. This is “armageddon”.</p> <p>To fix this up, we need to “resurrect” any objects we shouldn’t have killed (oops). The roots are objects in the Alkyne interpreter stack<sup id="fnref:stack-roots" role="doc-noteref"><a href="#fn:stack-roots" class="footnote" rel="footnote">11</a></sup>. To mark an object, we convert a pointer to it into a <code class="language-plaintext highlighter-rouge">Pd</code> via the page-<code class="language-plaintext highlighter-rouge">Pd</code> correspondence, and mark it as alive by “allocating” it.</p> <p>We then use our knowledge<sup id="fnref:interpreter-knowledge" role="doc-noteref"><a href="#fn:interpreter-knowledge" class="footnote" rel="footnote">12</a></sup> of Alkyne objects’ heap layout to find pointers to other objects in the heap (for example, the intepreter <em>knows</em> it’s looking at a list and can <em>just find</em> the list elements within, which are likely pointers themselves). If we trace into an object and find it has been marked as allocated, we don’t recurse; this avoids infinite recursion when encountering cycles.</p> <blockquote id="note:3" class="note"> <p><a href="#note:3"><span class="chip">note</span></a></p> <p>It’s a big hard to give a code example for this, because the “mark” part that’s part of the GC is mixed up with interpreter code, so there isn’t much to show in this case. :(</p> </blockquote> <p>At the end of this process, every reachable object will once again be alive, but anything we couldn’t reach stays dead.</p> <h3 id="instant-apocalypse"><a href="#instant-apocalypse">Instant Apocalypse</a></h3> <p>(Alkyne currently does not make this optimization, but really should.)</p> <p>Rather than flipping every bit, we flip the global <em>convention</em> for whether 0 or 1 means “alive”, implemented by having a global <code class="language-plaintext highlighter-rouge">bool</code> specifying which is which at any given time; this would alternate from sweep to sweep. Thus, killing every living object is now a single operation.</p> <p>This works if the allocated bit of objects in the free lists is never read, and only ever overwritten with the “alive” value when allocated, so that all of the dead objects suddenly becoming alive isn’t noticed. This does not work with slab-allocated small objects: pages may be in a mixed state where they are partially allocated and partially freed.</p> <p>We can still make this optimization by adding a second bit that tracks whether the page contains <em>any</em> living objects, using the same convention. This allows delaying the clear of the allocated bits for small objects to when the page is visited, which also marks the whole page as alive.</p> <p>Pages that were never visited (i.e., still marked as dead) can be reclaimed as usual, ignoring the allocated bits.</p> <h3 id="free-list-reconciliation"><a href="#free-list-reconciliation">Free List Reconciliation</a></h3> <p>At this point, no pointers are dangling, but newly emptied out pages are not in the free lists they should be in. To fix this, we can walk over all <code class="language-plaintext highlighter-rouge">Pd</code>s and put them where they need to go if they’re not full. This is the kinda-but-not-really sweep phase.</p> <p>The code for this is simpler to show than explaining it:</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">for</span> <span class="n">pd</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.reams</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">pd</span><span class="py">.gc_bits</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">pd</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">pd</span><span class="py">.len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="k">self</span><span class="py">.page_free_list</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="k">self</span><span class="py">.ream_free_list</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">pd</span><span class="nf">.is_full</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// GC can't make a not-full-list become full, so we don't</span>
    <span class="c1">// need to move it.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Non-empty, non-full lists cannot be reams.</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">pd</span><span class="py">.class</span> <span class="o">!=</span> <span class="nn">SizeClass</span><span class="p">::</span><span class="n">Ream</span><span class="p">);</span>

    <span class="n">pd</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.slab_free_lists</span><span class="p">[</span><span class="n">pd</span><span class="py">.class</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Rust</a></div></div> <p>Of course, this will also shuffle around all pages that did not become partially empty or empty while marking. If the “instant apocalypse” optimization is used, this step must still inspect every <code class="language-plaintext highlighter-rouge">Pd</code> and modify the free lists.</p> <p>However, it is a completely separate phase: all it does is find pages that did not survive the previous mark phase. This means that user code can run between the phases, reducing latency. If it turns out to be very expensive to sweep the whole heap, it can even be run less often than mark phases<sup id="fnref:if-quick-kill" role="doc-noteref"><a href="#fn:if-quick-kill" class="footnote" rel="footnote">13</a></sup>.</p> <p>This is also a great chance to merge reams, because we’re inspecting every page anyways; this is why the merging strategy depends on wanting to be a GC’s allocator rather than a normal <code class="language-plaintext highlighter-rouge">malloc()</code>/<code class="language-plaintext highlighter-rouge">free()</code> allocator.</p> <p>…and that’s it! That’s garbage collection. The setup of completely owning the layout of blocks in the allocator allows us to cut down significantly on memory needed to track objects in the heap, while keeping the mark and sweep steps short and sweet. A garbage collector is like any other data structure: you pack in a lot of complexity into the invariants to make the actual operations very quick.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Alkyne’s GC is intended to be super simple because I didn’t want to think too hard about it (even though I clearly did lmao). The GC layouts are a whole ‘nother story I have been swirling around in my head for months, which is described <a href="https://github.com/mcy/alkyne/blob/a62ad3b7ee70268625da640c1edeea8ff7116512/src/eval2/value.rs#L78">here</a>. The choices made there influenced the design of the GC itself.</p> <p>There are still many optimizations to make, but it’s a really simple but realistic GC design, and I’m pretty happy with it!</p> <h3 id="a-note-on-finalizers-tools-of-the-devil"><a href="#a-note-on-finalizers-tools-of-the-devil">A Note on Finalizers (Tools of the Devil!)</a></h3> <p>Alkyne also does not provide finalizers. A finalizer is the GC equivalent of a destructor: it gets run after the GC declares an object dead. Finalizers complicate a GC significantly by their very nature; they are called in unspecified orders and can witness broken GC state; they can stall the entire program (if they are implemented to run during the GC pause in a multi-threaded GC) or else need to be called with a zombie argument that either can’t escape the finalizer or, worse, must be resurrected if it does!</p> <p>If finalizers depend on each other, they can’t be run at all, for the same reason an ARC cycle cannot be broken; this weakness of ARC is one of the major benefits of an omniscient GC.</p> <p>Java’s <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()">documentation for <code class="language-plaintext highlighter-rouge">Object.finalize()</code></a> is a wall of text of lies, damned lies, and ghost stories.</p> <p>I learned earlier (the week before I started writing this article) that Go ALSO has finalizers and that they are <a href="https://pkg.go.dev/runtime#SetFinalizer">similarly cursed</a>. Go does behave somewhat more nicely than Java (finalizers are per-value and avoid zombie problems by unconditionally resurrecting objects with a finalizer).</p> <h3 id="further-reading"><a href="#further-reading">Further Reading</a></h3> <p>Here are some other allocators that I find interesting and worth reading about, some of which have inspired elements of Alkyne’s design.</p> <p><a href="https://google.github.io/tcmalloc/design.html">TCMalloc</a> is Google’s crazy thread-caching allocator. It’s really fast and really cool, but I work for Google, so I’m biased. But it uses radix trees! Radix trees are cool!!!</p> <p>Go <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgc.go">has a garbage collector</a> that has well-known performance properties but does not perform any wild optimizations like moving, and is a world-stopping, incremental GC.</p> <p><a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">Oilpan</a> is the Chronimum renderer’s GC (you know, for DOM elements). It’s actually grafted onto C++ and has a very complex API reflective of the subtleties of GCs as a result.</p> <p><a href="https://www.hboehm.info/gc/">libboehm</a> is another C/C++ GC written by Hans Boehm, one of the world’s top experts on concurrency.</p> <p><a href="https://v8.dev/blog/trash-talk">Orinoco</a> is V8’s GC for the JavaScript heap (i.e., Chronimum’s <em>other</em> GC). It is a <em>generational</em> or <em>moving GC</em> that can defragment the heap over time by moving things around (and updating pointers). It also has a separate sub-GC just for short-lived objects.</p> <p><a href="https://arxiv.org/abs/1902.04738">Mesh</a> is a non-GC allocator that can do compacting via clever use of <code class="language-plaintext highlighter-rouge">mmap(2)</code>.</p> <p><a href="https://github.com/protocolbuffers/upb/blob/1cf8214e4daa1d0dd9777c987697e82c2a3c6584/upb/upb.c#L117"><code class="language-plaintext highlighter-rouge">upb_Arena</code></a> is an arena allocator that uses free-lists to allows fusing arenas together. This part of the μpb Protobuf runtime.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:ast-walker" role="doc-endnote"> <p>In other words, it uses recursion along a syntax tree, instead of a more efficient approach that compiles the program down to bytecode. <a href="#fnref:ast-walker" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:arc" role="doc-endnote"> <p><em>A</em>utomatic <em>R</em>eference <em>C</em>ounting is an automatic memory management technique where every heap allocation contains a counter of how many pointers currently point to it; once pointers go out of scope, they decrement the counter; when the counter hits zero the memory is freed.</p> <p>This is used by Python and Swift as the core memory management strategy, and provided by C++ and Rust via the <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> types, respectively. <a href="#fnref:arc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:src" role="doc-endnote"> <p><a href="https://github.com/mcy/alkyne/blob/a62ad3b7ee70268625da640c1edeea8ff7116512/src/eval2/gc.rs">This is the file.</a> It’s got fairly complete comments, but they’re written for an audience familiar with allocators and garbage collectors. <a href="#fnref:src" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:nan-boxing" role="doc-endnote"> <p>This is a tangent, but I should point out that Alkyne does not do <a href="https://leonardschuetz.ch/blog/nan-boxing/">“NaN boxing”</a>. This is a technique used by some JavaScript runtimes, like Spidermonkey, which represent dynamically typed values as either ordinary floats, or pointers hidden in the mantissas of 64-bit IEEE 754 signaling NaNs.</p> <p>Alkyne instead uses something like V8’s <a href="https://v8.dev/blog/pointer-compression">Smi pointer compression</a>, so our heap values are four bytes, not eight. Non-Smi values that aren’t on the stack (which uses a completely different representation) can only exist as elements of lists or objects. Alkyne’s slab allocator design (described below) is focused on trying to minimize the overhead of all floats being in their own little allocations. <a href="#fnref:nan-boxing" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:os-allocator" role="doc-endnote"> <p>The operating system’s own physical page allocator is actually solving the same problem: given a vast range of memory (in this case, physical RAM), allocate it. The algorithms in this article apply to those, too.</p> <p>Operating system allocators can be slightly fussier because they need to deal with virtual memory mappings, but that is a topic for another time. <a href="#fnref:os-allocator" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:load-bearing" role="doc-endnote"> <p>As you might expect, these scare-quotes are load-bearing. <a href="#fnref:load-bearing" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i-tried" role="doc-endnote"> <p>I tried leaving this out of the first draft, and failed. So many things would be simpler without fussing around with alignment. <a href="#fnref:i-tried" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned" role="doc-endnote"> <p>Yes yes most architectures can cope with unaligned loads and stores but compilers rather like to pretend that’s not true. <a href="#fnref:unaligned" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:provenance" role="doc-endnote"> <p>Boutique means <a href="https://llvm.org/docs/LangRef.html#pointer-aliasing-rules">provenance</a> in French. <a href="#fnref:provenance" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:max-size" role="doc-endnote"> <p>Currently Alkyne has a rather small max ream size. A better way to approach this would be to treat the entire heap as one gigantic ream at the start, which is always at the bottom of the free list. <a href="#fnref:max-size" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stack-roots" role="doc-endnote"> <p>In GC terms, these are often called “stack roots”. <a href="#fnref:stack-roots" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:interpreter-knowledge" role="doc-endnote"> <p>The interpreter simply <em>knows</em> this and can instruct the GC appropriately.</p> <p>In any tracing GC, the compiler or interpreter must be keenly aware of the layouts of types so that it can generate the appropriate tracing code for each.</p> <p>This is why grafting GCs to non-GC’d languages is non-trivial, even though people have totally done it: <a href="https://www.hboehm.info/gc/">libboehm</a> and <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">Oilpan</a> are good (albeit sometimes controversial) examples of how this can be done. <a href="#fnref:interpreter-knowledge" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:if-quick-kill" role="doc-endnote"> <p>With “instant apocalypse”, this isn’t quite true; after two mark phases, pages from the first mark phase will appear to be alive, since the global “alive” convention has changed twice. Thus, only pages condemned in every other mark phase will be swept; sweeping is most optimal after an odd number of marks. <a href="#fnref:if-quick-kill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2021-12-19 • 1923 words • 21 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#ffi">#ffi</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2021/12/19/move-ctors-2/"> Move Constructors Revisited<br/> </a></h1> </div> <div class="post"> <p>Almost a year ago I developed the <a href="https://github.com/google/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a> Rust library, which provides primitives for expressing something like C++’s <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> and move constructors while retaining Rust’s so-called “destructive move property”: moving a value transfers ownership, rather than doing a funny copy.</p> <p>In an <a href="https://mcyoung.xyz//2021/04/26/move-ctors">earlier blogpost</a> I described the theory behind this library and some of the motivation, which I feel fairly confident about, especially in how constructors (and their use of pinning) are defined.</p> <p>However, there is a problem.</p> <h2 id="a-not-so-quick-recap"><a href="#a-not-so-quick-recap">A Not-so-Quick Recap</a></h2> <p>The old post is somewhat outdated, since <code class="language-plaintext highlighter-rouge">moveit</code> uses different names for a lot of things that are geared to fit in with the rest of Rust.</p> <p>The core abstraction of <code class="language-plaintext highlighter-rouge">moveit</code> is the constructor, which are types that implement the <code class="language-plaintext highlighter-rouge">New</code> trait:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">New</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The type to construct.</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

  <span class="cd">/// Construct a new value in-place using the arguments stored</span>
  <span class="cd">/// in `self`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">this</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Rust</a></div></div> <p>A <code class="language-plaintext highlighter-rouge">New</code> type is not what is being constructed; rather, it represents a <em>method</em> of construction, resembling a specialized <code class="language-plaintext highlighter-rouge">Fn</code> trait. The constructed type is given by the associated type <code class="language-plaintext highlighter-rouge">Output</code>.</p> <p>Types that can be constructed are constructed <em>in place</em>, unlike most Rust types. This is a property shared by constructors in C++, allowing values to record their own address at the moment of creation. Explaining why this is useful is a bit long-winded, but let’s assume this is a thing we want to be able to do. Crucially, we need the output of a constructor to be pinned, which is why the <code class="language-plaintext highlighter-rouge">this</code> output parameter is pinned.</p> <p>Calling a constructor requires creating the output location in advance so that we can make it available to it in time:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Create storage for the new value.</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>

<span class="c1">// Pin that storage on the stack; by calling this, we may never move</span>
<span class="c1">// `storage` again, even after this goes out of scope.</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Now we can call the constructor. It's only unsafe because it assumes</span>
<span class="c1">// the provided memory is uninitialized.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <p>However, this is not quite right. <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>’s docs are quite clear that we must ensure that, once we create an <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, we must call <code class="language-plaintext highlighter-rouge">T</code>’s destructor before its memory is re-used; since reuse is unavoidable for stack data, and <code class="language-plaintext highlighter-rouge">storage</code> will not do it for us (it’s a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, after all), we must somehow run the destructor separately.</p> <h3 id="an-easy-solution"><a href="#an-easy-solution">An “Easy” Solution</a></h3> <p>One trick we could use is to replace <code class="language-plaintext highlighter-rouge">storage</code> with some kind of wrapper over a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> that calls the destructor for us:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.assume_init_mut</span><span class="p">())</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Rust</a></div></div> <p>This <em>works</em>, but isn’t ideal, because now we can’t write down something like a C++ move constructor without running into the classic C++ problem: all objects must be destroyed unconditionally, so now you can have moved-from state. Giving up Rust’s moves-transfer-ownership (i.e. <em>affine</em>) property is bad, but it turns out to be avoidable!</p> <p>There are also some scary details around panics here that I won’t get into.</p> <h3 id="t-mut-t--move-t"><a href="#t-mut-t--move-t"><code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, … <code class="language-plaintext highlighter-rouge">&amp;move T</code>?</a></h3> <p><code class="language-plaintext highlighter-rouge">moveit</code> instead provides a <a href="https://docs.rs/moveit/latest/moveit/move_ref/struct.MoveRef.html"><code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code></a> type that tries to capture the notion of what an “owning reference” <em>could</em> mean in Rust. An <code class="language-plaintext highlighter-rouge">&amp;move</code> or <code class="language-plaintext highlighter-rouge">&amp;own</code> type has been discussed many times, but implementing it in the full generality it would deserve as a language feature runs into some interesting problems due to how <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, the heap allocated equivalent, <a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">currently behaves.</a></p> <p>We can think of <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code> as wrapping the <em>longest-lived</em> <code class="language-plaintext highlighter-rouge">&amp;mut T</code> reference pointing to a particular location in memory. The longest-lived part is crucial, since it means that <code class="language-plaintext highlighter-rouge">MoveRef</code> is entitled to run its pointee’s destructor:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Notice parallels with EventuallyInit&lt;T&gt; above.</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Rust</a></div></div> <p>No reference to the pointee can ever outlive the <code class="language-plaintext highlighter-rouge">MoveRef</code> itself, by definition, so this is safe. The owner of a value is that which is entitled to destroy it, and therefore a <code class="language-plaintext highlighter-rouge">MoveRef</code> <em>literally</em> owns its pointee. Of course, this means we can move out of it (which was the whole point of the original blogpost).</p> <p>Because of this, we are further entitled to arbitrarily pin a <code class="language-plaintext highlighter-rouge">MoveRef</code> with no consequences: pinning it would consume the unpinned <code class="language-plaintext highlighter-rouge">MoveRef</code> (for obvious reasons, <code class="language-plaintext highlighter-rouge">MoveRefs</code> cannot be reborrowed) so no unpinned reference may outlive the pinning operation.</p> <p>This gives us a very natural solution to the problem above: <code class="language-plaintext highlighter-rouge">result</code> should not be a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, but rather a <code class="language-plaintext highlighter-rouge">Pin&lt;MoveRef&lt;'_, T&gt;&gt;</code>:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pinned</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">())</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>This messy sequence of steps is nicely wrapped up in a macro provided by the library that ensures safe initialization and eventual destruction:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Allocate storage on the stack, emplace `my_new` onto it, and pin it</span>
<span class="c1">// in an owning reference.</span>
<span class="nd">moveit!</span><span class="p">(</span><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">MoveRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">my_new</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Rust</a></div></div> <p>There is also some reasonably complex machinery that allows us to do something like an owning <code class="language-plaintext highlighter-rouge">Deref</code>, which I’ll come back to in a bit.</p> <p>However, there is a small wrinkle that I did not realize when I first designed <code class="language-plaintext highlighter-rouge">MoveRef</code>: what happens if I <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">MoveRef</code>?</p> <h2 id="undefined-behavior-obviously"><a href="#undefined-behavior-obviously">Undefined Behavior, Obviously</a></h2> <p>Quashing destruction isn’t new to Rust: we can <code class="language-plaintext highlighter-rouge">mem::forget</code> just about anything, leaking all kinds of resources. And that’s ok! Destructors alone cannot be used in type design to advert <code class="language-plaintext highlighter-rouge">unsafe</code> catastrophe, a well-understood limitation of the language that we have experience designing libraries around, such as <a href="https://doc.rust-lang.org/nomicon/leaking.html#drain"><code class="language-plaintext highlighter-rouge">Vec::drain()</code></a>.</p> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s design creates a contradiction:</p> <ul> <li><code class="language-plaintext highlighter-rouge">MoveRef</code> is an owning smart pointer, and therefore can be safely pinned, much like <code class="language-plaintext highlighter-rouge">Box::into_pinned()</code> enables. Constructors, in particular, are <em>designed</em> to generate pinned <code class="language-plaintext highlighter-rouge">MoveRef</code>s!</li> <li>Forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code> will cause the pointee destructor to be suppressed, but its storage will still be freed and eventually re-used, a violation of the <code class="language-plaintext highlighter-rouge">Pin</code> drop guarantee.</li> </ul> <p>This would <em>appear</em> to mean that a design like <code class="language-plaintext highlighter-rouge">MoveRef</code> is not viable at all, and that this sort of “stack box” strategy is always unsound.</p> <blockquote id="aside:what-about-box" class="aside"> <p><a href="#aside:what-about-box"><span class="chip">aside</span><span class="title">What About <code class="language-plaintext highlighter-rouge">Box</code>?</span></a></p> <p>What about it? Even though we can trivially create a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;i32&gt;&gt;</code> via <code class="language-plaintext highlighter-rouge">Box::pin()</code>, this is a red herring. When we <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">Box</code>, we also forget about its storage too. Because its storage has been leaked unrecoverably, we are still, <em>technically</em>, within the bounds of the <code class="language-plaintext highlighter-rouge">Pin</code> contract. Only barely, but we’re inside the circle.</p> </blockquote> <p>Interestingly, the Rust language has to deal with a similar problem; perhaps it suggests a way out?</p> <h2 id="drop-flags-and-dynamic-ownership-transfer"><a href="#drop-flags-and-dynamic-ownership-transfer">Drop Flags and Dynamic Ownership Transfer</a></h2> <p>Carefully crafted Rust code emits some very interesting assembly. I’ve annotated the key portion of the output with a play-by-play below.</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[inline(never)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// What goes in here isn't important,it just needs to</span>
  <span class="c1">// be an optimizer black-box.</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">maybe_drop</span><span class="p">(</span><span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
  <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span>
    <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6IiNbaW5saW5lKG5ldmVyKV1cbnB1YiBmbiBzb21lb25lX2Vsc2VzX3By b2JsZW0oXzogQm94PGkzMj4pIHtcbiAgLy8gV2hhdCBnb2VzIGluIGhlcmUg aXNuJ3QgaW1wb3J0YW50LGl0IGp1c3QgbmVlZHMgdG9cbiAgLy8gYmUgYW4g b3B0aW1pemVyIGJsYWNrLWJveC5cbn1cblxucHViIGZuIG1heWJlX2Ryb3Ao ZmxhZzogYm9vbCkge1xuICBsZXQgeCA9IEJveDo6bmV3KDQyKTtcbiAgaWYg ZmxhZyB7XG4gICAgc29tZW9uZV9lbHNlc19wcm9ibGVtKHgpXG4gIH1cbn0i LCJjb21waWxlcnMiOlt7ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiItTyJ9XX1d fQ== ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// See Godbolt widget above for full disassembly.</span>
<span class="n">example</span><span class="o">::</span><span class="n">maybe_drop</span><span class="o">:</span>
  <span class="c1">// ...</span>

  <span class="c1">// Allocate memory.</span>
  <span class="n">call</span>    <span class="n">__rust_alloc</span>

  <span class="c1">// Check if allocation failed; panic if so.</span>
  <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">scream</span>

  <span class="c1">// Write a 42 to the memory.</span>
  <span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>

  <span class="c1">// Check the flag argument (LLVM decided to put it in rbx). If</span>
  <span class="c1">// true, we go free the memory ourselves.</span>
  <span class="n">test</span>    <span class="n">bl</span><span class="p">,</span> <span class="n">bl</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">actually_our_problem</span>

  <span class="c1">// Otherwise, make it someone else's problem; they get to</span>
  <span class="c1">// free the memory for themselves. </span>
  <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">pop</span>     <span class="n">rbx</span>
  <span class="n">jmp</span>     <span class="n">example</span><span class="o">::</span><span class="n">someone_elses_problem</span>

  <span class="c1">// ...</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">x86 Assembly</a></div></div> <p>The upshot is that <code class="language-plaintext highlighter-rouge">maybe_drop</code> conditions the destructor of <code class="language-plaintext highlighter-rouge">x</code> on a <em>flag</em>, which is allocated next to it on the stack. Rust flips this flag when the value is moved into another function, and only runs the destructor when the flag is left alone. In this case, LLVM folded the flag into the <code class="language-plaintext highlighter-rouge">bool</code> argument, so this isn’t actually a meaningful perf hit.</p> <p>These “drop flags” are key to Rust’s ownership model. Since ownership may be transferred dynamically due to reasonably complex control flow, it needs to leave breadcrumbs for itself to figure out whether the value wound up getting moved away or not. This is unique to Rust: in C++, every object is always destroyed, so no such faffing about is necessary.</p> <p>Similarly, <code class="language-plaintext highlighter-rouge">moveit</code> can close this soundness hole by leaving itself breadcrumbs to determine if safe code is trying to undermine its guarantees.</p> <p>In other words: in Rust, it is not sufficient to manage a pointer to manage a memory location; it is necessary to manage an explicit or implicit drop flag as well.</p> <h2 id="a-flagged-moveref"><a href="#a-flagged-moveref">A Flagged <code class="language-plaintext highlighter-rouge">MoveRef</code></a></h2> <p>We can extend <code class="language-plaintext highlighter-rouge">MoveRef</code> to track an explicit drop flag:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>

  <span class="c1">// Set to `false` once the destructor runs.</span>
  <span class="n">drop_flag</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>Wrapping it in a <code class="language-plaintext highlighter-rouge">Cell</code> is convenient and doesn’t cost us anything, since a <code class="language-plaintext highlighter-rouge">MoveRef</code> can never be made <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code> anyways. Inside of its destructor, we can flip the flag, much like Rust flips a drop flag when transferring ownership to another function:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.drop_flag</span><span class="nf">.set</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p>But, how should we use it? The easiest way is to change the definition of <code class="language-plaintext highlighter-rouge">moveit!()</code> to construct a <em>flag trap</em>:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Create a *trapped flag*, which I'll describe below.</span>
<span class="k">let</span> <span class="n">trap</span> <span class="o">=</span> <span class="nn">TrappedFlag</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// Run the constructor as before and construct a MoveRef.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">uninit</span><span class="p">)</span><span class="nf">.assume_init_mut</span><span class="p">(),</span>
  <span class="n">trap</span><span class="nf">.flag</span><span class="p">(),</span>  <span class="c1">// Creating a MoveRef now requires</span>
                <span class="c1">// passing in a flag in addition to </span>
                <span class="c1">// a reference to the owned value itself.</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Rust</a></div></div> <p>The trap is a deterrent against forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code>: because the <code class="language-plaintext highlighter-rouge">MoveRef</code>’s destructor flips the flag, the trap’s destructor will notice if this <em>doesn’t</em> happen, and take action accordingly.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>In <code class="language-plaintext highlighter-rouge">moveit</code>, this is actually implemented by having the <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code> type carry a reference to the trap, created in the <code class="language-plaintext highlighter-rouge">slot!()</code> macro. However, this is not a crucial detail for the design.</p> </blockquote> <h3 id="an-earth-shattering-kaboom"><a href="#an-earth-shattering-kaboom">An Earth-Shattering Kaboom</a></h3> <p>The trap is another RAII type that basically looks like this:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="nf">TrappedFlag</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">TrappedFlag</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">()</span> <span class="p">{</span> <span class="nf">abort</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Rust</a></div></div> <p>The trap is simple: if the contained drop flag is not flipped, it crashes the program. Because <code class="language-plaintext highlighter-rouge">moveit!()</code> allocates it on the stack where uses cannot <code class="language-plaintext highlighter-rouge">mem::forget</code> it, its destructor is guaranteed to run before <code class="language-plaintext highlighter-rouge">storage</code>’s destructor runs (although Rust does not guarantee destructors run, it <em>does</em> guarantee their order).</p> <p>If a <code class="language-plaintext highlighter-rouge">MoveRef</code> is forgotten, it won’t have a chance to flip the flag, which the trap will detect. Once the trap’s destructor notices this, it cannot return, either normally or by panic, since this would cause <code class="language-plaintext highlighter-rouge">storage</code> to be freed. Crashing the program is the only<sup id="fnref:or-we-could-drop-it" role="doc-noteref"><a href="#fn:or-we-could-drop-it" class="footnote" rel="footnote">1</a></sup> acceptable response.</p> <p>Some of <code class="language-plaintext highlighter-rouge">MoveRef</code>’s functions need to be adapted to this new behavior: for example, <code class="language-plaintext highlighter-rouge">MoveRef::into_inner()</code> still needs to flip the flag, since moving out of the <code class="language-plaintext highlighter-rouge">MoveRef</code> is equivalent to running the destructor for the purposes of drop flags.</p> <h2 id="a-safer-derefmove"><a href="#a-safer-derefmove">A Safer <code class="language-plaintext highlighter-rouge">DerefMove</code></a></h2> <p>In order for <code class="language-plaintext highlighter-rouge">MoveRef</code> to be a proper “new” reference type, and not just a funny smart pointer, we also need a <code class="language-plaintext highlighter-rouge">Deref</code> equivalent:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// An "uninitialized" version of `Self`.</span>
  <span class="k">type</span> <span class="n">Uninit</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>
  
  <span class="cd">/// "Deinitializes" `self`, producing an opaque type that will</span>
  <span class="cd">/// destroy the storage of `*self` without calling the pointee</span>
  <span class="cd">/// destructor.</span>
  <span class="k">fn</span> <span class="nf">deinit</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a `MoveRef` that owns its</span>
  <span class="cd">/// contents.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">deref_move</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Rust</a></div></div> <p>This is the <em>original</em> design for <code class="language-plaintext highlighter-rouge">DerefMove</code>, which had a two-phase operation: first <code class="language-plaintext highlighter-rouge">deinit()</code> was used to create a destructor-suppressed version of the smart pointer that would only run the destructor for the storage (e.g., for <code class="language-plaintext highlighter-rouge">Box</code>, only the call to <code class="language-plaintext highlighter-rouge">free()</code>). Then, <code class="language-plaintext highlighter-rouge">deref_move()</code> would extract the “inner pointee” out of it as a <code class="language-plaintext highlighter-rouge">MoveRef</code>. This had the effect of splitting the smart pointer’s destructor, much like we did above on the stack.</p> <p>This has a number of usability problems. Not only does it <em>need</em> to be called through a macro, but <code class="language-plaintext highlighter-rouge">deinit()</code> isn’t actually safe: failing to call <code class="language-plaintext highlighter-rouge">deref_move()</code> is just as bad as calling <code class="language-plaintext highlighter-rouge">mem::forget</code> on the result. Further, it’s not clear where to plumb the drop flags through.</p> <p>After <a href="https://github.com/google/moveit/pull/23#issuecomment-963549869">many attempts</a> to graft drop flags onto this design, I replaced it with a completely new interface:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The "pure storage" form of `Self`, which owns the storage</span>
  <span class="cd">/// but not the pointee.</span>
  <span class="k">type</span> <span class="n">Storage</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a [`MoveRef`] that owns</span>
  <span class="cd">/// its contents.</span>
  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Storage</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">Uninit</code> has been given the clearer name of <code class="language-plaintext highlighter-rouge">Storage</code>: a type that owns <em>just</em> the storage of the moved-from pointer. The two functions were merged into a single, <em>safe</em> function that performs everything in one step, emitting the storage as an out-parameter.</p> <p>The new <code class="language-plaintext highlighter-rouge">DroppingSlot&lt;T&gt;</code> is like a <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code>, but closer to a safe version of the <code class="language-plaintext highlighter-rouge">EventuallyInit&lt;T&gt;</code> type from earlier: its contents are not necessarily initialized, but if they are, it destroys them, and it only does so when its drop flag is set.</p> <p><code class="language-plaintext highlighter-rouge">Box</code> is the most illuminating example of this trait:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// Dismantle the incoming Box into the "storage-only part".</span>
    <span class="k">let</span> <span class="n">this</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span>
    <span class="p">};</span>

    <span class="c1">// Put the Box into the provided storage area. Note that we</span>
    <span class="c1">// don't need to set the drop flag; `DroppingSlot` does</span>
    <span class="c1">// that automatically for us.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="o">=</span> <span class="n">storage</span><span class="nf">.put</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

    <span class="c1">// Construct a new MoveRef, converting `storage` from </span>
    <span class="c1">// `&amp;mut Box&lt;MaybeUninit&lt;T&gt;&gt;` into `&amp;mut T`.</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">storage</span><span class="nf">.assume_init_mut</span><span class="p">(),</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s own implementation illustrates the need for the explicit lifetime bound:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="p">();</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// We can just return directly; this is a mere lifetime narrowing.</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Rust</a></div></div> <p>Since this is fundamentally a lifetime narrowing, this can only compile if we insist that <code class="language-plaintext highlighter-rouge">'a: 'frame</code>, which is implied by <code class="language-plaintext highlighter-rouge">Self: 'frame</code>. Earlier iterations of this design enforced it via a <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, Self&gt;</code> receiver, which turned out to be unnecessary.</p> <h2 id="conclusions"><a href="#conclusions">Conclusions</a></h2> <p>As of writing, I’m still in the process of self-reviewing <a href="https://github.com/google/moveit/pull/25">this change</a>, but at this point I feel <em>reasonably</em> confident that it’s correct; this article is, in part, written to convince myself that I’ve done this correctly.</p> <p>The new design will also enable me to finally complete my implementation of a constructor and pinning-friendly vector type; this issue came up in part because the vector type needs to manipulate drop flags in a complex way. For this reason, the <em>actual</em> implementation of drop flags actually uses a counter, not a single boolean.</p> <p>I doubt this is the last issue I’ll need to chase down in <code class="language-plaintext highlighter-rouge">moveit</code>, but for now, we’re ever-closer to true owning references in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:or-we-could-drop-it" role="doc-endnote"> <p>Arguably, running the skipped destructor is <em>also</em> a valid remediation strategy. However, this is incompatible with what the user requested: they asked for the destructor to be supressed, not for it to be run at a later date. This would be somewhat surprising behavior, which we could warn about for the benefit of <code class="language-plaintext highlighter-rouge">unsafe</code> code, but ultimately the incorrect choice for non-stack storage, such as a <code class="language-plaintext highlighter-rouge">MoveRef</code> referring to the heap. <a href="#fnref:or-we-could-drop-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2021-11-29 • 4697 words • 52 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2021/11/29/assembly-1/"> Understanding Assembly<br/> Part I: RISC-V<br/> </a></h1> </div> <div class="post"> <p>A <a href="https://en.wikipedia.org/wiki/Turing_tarpit">Turing tarpit</a> is a programming language that is Turing-complete but very painful to accomplish anything in. One particularly notable tarpit is <a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a>, which has a reputation among beginner and intermediate programmers as being unapproachable and only accessible to the most elite programmers hence the name, as Wikipedia puts it:</p> <blockquote> <p>The language’s name is a reference to the slang term <em>brainfuck</em>, which refers to things so complicated or unusual that they exceed the limits of one’s understanding.</p> </blockquote> <p>Assembly language, the “lowest-level” programming language on any computer, has a similar reputation: difficult, mysterious, and beyond understanding. A Turing tarpit that no programmer would want to have anything to do with.</p> <p>Although advanced programmers usually stop seeing assembly as mysterious and inaccessible, I feel like it is a valuable topic even for intermediate programmers, and one that can be made approachable and interesting.</p> <p>This series seeks to be that: assuming you have already been using a compiled language like Rust, C++, or Go, how <em>is</em> assembly relevant to you?</p> <blockquote id="tip:1" class="tip"> <p><a href="#tip:1"><span class="chip">tip</span></a></p> <p>If you’re here to just learn assembly and don’t really care for motivation, you can just <a href="#diving-in">skip ahead</a>.</p> <p>This series is about learning to <em>understand</em> assembly, not write it. I do occasionally write assembly for a living, but I’m not an <em>expert</em>, and I don’t particularly relish it. I do read a ton of assembly, though.</p> </blockquote> <h2 id="what-is-it-anyways"><a href="#what-is-it-anyways">What Is It, Anyways?</a></h2> <p>As every programmer knows, computers are very stupid. They are very good at following instructions and little else. In fact, the computer is <em>so</em> stupid, it can only process basic instructions serially<sup id="fnref:superscalar" role="doc-noteref"><a href="#fn:superscalar" class="footnote" rel="footnote">1</a></sup>, one by one. The instructions are very simple: “add these two values”, “copy this value from here to there”, “go run these instructions over here”.</p> <p>A computer processor implements these instructions as electronic circuits. At its most basic level, every computer looks like the following program:</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">size_t</span> <span class="n">program_counter</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">program</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Instruction</span> <span class="n">next</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_counter</span><span class="p">];</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Figure out what you're supposed to be doing and do it.</span>
  <span class="p">}</span>
  <span class="n">program_counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">C</a></div></div> <p>The array <code class="language-plaintext highlighter-rouge">program</code> is a your program encoded as a sequence of these “machine instructions” in some kind of binary format. For example, in RISC-V programs, each instruction is a 32-bit integer. This binary format is called <em>machine code</em>.</p> <p>For example, when a RISC-V processor encounters the value <code class="language-plaintext highlighter-rouge">5407443</code> decoding circuitry decides that it means that it should take the value in the “register” <code class="language-plaintext highlighter-rouge">a0</code>, add <code class="language-plaintext highlighter-rouge">10</code> to it, and place the result in the register <code class="language-plaintext highlighter-rouge">a1</code>.</p> <blockquote id="aside:decoding-instructions" class="aside"> <p><a href="#aside:decoding-instructions"><span class="chip">aside</span><span class="title">Decoding Instructions</span></a></p> <p><code class="language-plaintext highlighter-rouge">5407443</code> seems opaque, but when viewed as binary, we can see how the processor decodes it:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-text" data-lang="text">&gt; 0b 000000000101 00101 000 00110 0010011
    \__________/ \___/ \_/ \___/ \_____/
     |           |     |   |     |
     imm         rs1   fn  rd    opcode</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Plaintext</a></div></div> <p><code class="language-plaintext highlighter-rouge">opcode</code> describes what sort of instruction this is, and what format it’s in; <code class="language-plaintext highlighter-rouge">0b0010011</code> means it’s an “immediate arithmetic” instruction, which uses the “I-type” format, given above. <code class="language-plaintext highlighter-rouge">fn</code> further specifies what the operation does; <code class="language-plaintext highlighter-rouge">0b000</code>, combined with the value of <code class="language-plaintext highlighter-rouge">opcode</code>, means this is an <em>addition</em> instruction.</p> <p><code class="language-plaintext highlighter-rouge">rs1</code> is the source: it gives the name of the source register, <code class="language-plaintext highlighter-rouge">a0</code>, given by it index, <code class="language-plaintext highlighter-rouge">0b00101</code>, i.e., <code class="language-plaintext highlighter-rouge">10</code>. Similarly, <code class="language-plaintext highlighter-rouge">rd</code> specifies the destination <code class="language-plaintext highlighter-rouge">a1</code> by its index <code class="language-plaintext highlighter-rouge">11</code>. Finally, <code class="language-plaintext highlighter-rouge">imm</code> is the value to add, <code class="language-plaintext highlighter-rouge">0b000000000101</code>, or <code class="language-plaintext highlighter-rouge">10</code>. The constant value appears immediately in the instruction itself, so it’s called an <em>immediate</em>.</p> </blockquote> <p>However, if you’re a human programming a computer, writing all of this by hand is… very 60s, and you might prefer to have a textual representation, so you can write this more simply as <code class="language-plaintext highlighter-rouge">addi a1, a0, 10</code>.</p> <p><code class="language-plaintext highlighter-rouge">addi a1, a0, 10</code> is a single line of assembly: it describes a <em>single</em> instruction in text form. Assembly language is “just” a textual representation of the program’s machine code. Your assembler can convert from text into machine instructions, and a <em>dis</em>assembler reverses the process.</p> <p>The simple nature of these instructions is what makes assembly a sort of Turing tarpit: you only get the most basic operations possible: you’re responsible for building <em>everything</em> else.</p> <h3 id="on-architectures"><a href="#on-architectures">On Architectures</a></h3> <p>There isn’t “an” assembly language. Every computer has a different instruction set architecture, or “ISA”; I use the terms “instruction set”, “architecture”, and “ISA” interchangeably. Each ISA has a corresponding assembly language that describes that ISA’s specific instructions, but they all generally have similar overall structure.</p> <p>I’m going to focus on three ISAs for ease of exposition, introduced in this order:</p> <ol> <li>RISC-V, a modern and fairly simple instruction set (specifically, the rv32gc variant). That’s Part I.</li> <li>x86_64, the instruction set of the device you’re reading this on (unless it’s a phone, an Apple M1 laptop, or something like a Nintendo Switch). That’s Part II.</li> <li>MOS 6502, a fairly ancient ISA still popular in very small microcontrollers. That’s Part III.</li> </ol> <p>We’re starting with RISC-V because it’s a particularly elegant ISA (having been developed for academic work originally), while still being representative of the operations most ISAs offer.</p> <p>In the future, I may dig into some other, more specialized ISAs.</p> <h2 id="but-why"><a href="#but-why">But <em>Why</em>?</a></h2> <p>It’s actually very rare to write actual assembly. Thanks to modern (relatively) languages like Rust, C++, and Go, and even things like Haskell and JavaScript, virtually no programmers need to write assembly anymore.</p> <p>But that’s only because it’s the leading language written by <em>computers themselves</em>. A compiler’s job is, fundamentally, to write the the assembly you would have had to write <em>for</em> you. To better understand what a compiler is doing for you, you need to be able to read its output.</p> <p>At this point, it may be worth looking at my <a href="https://mcyoung.xyz/2021/06/01/linker-script/#seriously-whats-a-linker">article on linkers</a> as a refresher on the C compilation model.</p> <p>For example, let’s suppose we have the very simple C program below.</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">square_and_print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYyIsInNvdXJjZSI6 IiNpbmNsdWRlIDxzdGRpby5oPlxuXG5pbnQgc3F1YXJlX2FuZF9wcmludChp bnQgeCkge1xuICAgIHggKj0geDtcbiAgICBwcmludGYoXCIlZFxcblwiLCB4 KTtcbiAgICByZXR1cm4geDtcbn0iLCJjb21waWxlcnMiOlt7ImlkIjoicnYz Mi1jY2xhbmciLCJvcHRpb25zIjoiLU96In1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:3">square.c</a></div></div> <p>Clang, my C compiler of choice, can turn it directly into a library via <code class="language-plaintext highlighter-rouge">clang -c square.c</code>. <code class="language-plaintext highlighter-rouge">-c</code> asks the compiler to stop before the link step, outputting the <em>object file</em> <code class="language-plaintext highlighter-rouge">square.o</code>. We can ask the compiler to stop even sooner than that by writing <code class="language-plaintext highlighter-rouge">clang -S square.c</code>, which will output <code class="language-plaintext highlighter-rouge">square.s</code>, the assembly file the compiler produced! For this example, and virtually all others in this post, I’m using a RISC-V target: <code class="language-plaintext highlighter-rouge">-target riscv32-unknown-elf -march=rv32gc</code>.</p> <p>If you build with <code class="language-plaintext highlighter-rouge">-Oz</code> to make the code as small as possible (this makes it easiest to see what’s going on, too), you get something like this:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="p">.</span><span class="n">text</span>
        <span class="p">.</span><span class="n">file</span>   <span class="s">"square.c"</span>
        <span class="p">.</span><span class="n">globl</span>  <span class="n">square_and_print</span>
<span class="n">square_and_print</span><span class="o">:</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">mul</span>     <span class="n">s0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span>          <span class="c1">// !</span>
        <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">s0</span>
        <span class="n">call</span>    <span class="n">printf</span>              <span class="c1">// !</span>
        <span class="n">mv</span>      <span class="n">a0</span><span class="p">,</span> <span class="n">s0</span>
        <span class="n">lw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        <span class="n">ret</span>

        <span class="p">.</span><span class="n">section</span>        <span class="p">.</span><span class="n">rodata</span>
<span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="o">:</span>
        <span class="p">.</span><span class="n">asciz</span>  <span class="s">"%d</span><span class="se">\n</span><span class="s">"</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">square.s</a></div></div> <p>There’s a lot going on! But pay attention to the two lines with a <code class="language-plaintext highlighter-rouge">// !</code>: the first is <code class="language-plaintext highlighter-rouge">mul s0, a0, a0</code>, which is the multiplication <code class="language-plaintext highlighter-rouge">x *= x;</code>. The second is <code class="language-plaintext highlighter-rouge">call printf</code>, which is our function call to <code class="language-plaintext highlighter-rouge">printf()</code>! I’ll explain what everything else means in short order.</p> <p>Writing assembly isn’t a crucial skill, but being able to read it is. It’s actually so useful, that a website exists for quickly generating the assembly output of a vast library of compilers: the <a href="https://godbolt.org/">Compiler Explorer</a>, frequently just called “godbolt” after its creator, Matt Godbolt. Being able to compare the output of different compilers can help understand what they do! Click on the <code class="language-plaintext highlighter-rouge">godbolt</code> button in the code fences to a godbolt for it.</p> <p>“Low-level” languages like C aren’t the only ones where you can inspect assembly output. Godbolt supports Go: for example, click the <code class="language-plaintext highlighter-rouge">godbolt</code> button below.</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">sq</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">SquareAndPrint</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiZ28iLCJzb3VyY2Ui OiJwYWNrYWdlIHNxXG5cbmltcG9ydCBcImZtdFwiXG5cbmZ1bmMgU3F1YXJl QW5kUHJpbnQoeCBpbnQpIGludCB7XG4gICAgeCAqPSB4XG4gICAgZm10LlBy aW50ZihcIiVkXFxuXCIsIHgpXG4gICAgcmV0dXJuIHhcbn0iLCJjb21waWxl cnMiOlt7ImlkIjoiZ2x0aXAiLCJvcHRpb25zIjoiIn1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:5">Go</a></div></div> <p>Hopefully this is motivation enough to jump into the language proper. It is very useful to have a godbolt tab open to play around with examples!</p> <h2 id="diving-in"><a href="#diving-in">Diving In</a></h2> <p>So, let’s say you <em>do</em> want to read assembly. How do we do that?</p> <p>Let’s revisit our <code class="language-plaintext highlighter-rouge">square.c</code> example above. This time, I’ve added comments explaining what all the salient parts of the code do, including the <em>assembler directives</em>, which are all of the form <code class="language-plaintext highlighter-rouge">.blah</code>. Note that the <em>actual</em> compiler output includes way more directives that would get in the way of exposition.</p> <p>There’s a lot of terms below that I haven’t defined yet. I’ll break down what this code does gradually, so feel free to refer back to it as necessary, using <a href="#big-example">this handy-dandy link.</a></p> <div class="codeblock" id="big-example"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">        <span class="c1">// This tells the assembler to place all code that</span>
        <span class="c1">// follows in the `.text` section, where executable</span>
        <span class="c1">// data goes.</span>
        <span class="p">.</span><span class="n">text</span>

        <span class="c1">// This is just metadata that tools can use to figure out</span>
        <span class="c1">// how the executable was built.</span>
        <span class="p">.</span><span class="n">file</span>   <span class="s">"square.c"</span>

        <span class="c1">// This asks the assembler to mark `square_and_print`</span>
        <span class="c1">// as an externally linkable symbol. Other files that</span>
        <span class="c1">// refer to `square_and_print` will be able to find it</span>
        <span class="c1">// at link time.</span>
        <span class="p">.</span><span class="n">globl</span>  <span class="n">square_and_print</span>

<span class="n">square_and_print</span><span class="o">:</span> <span class="c1">// This is a label, which gives this position</span>
                  <span class="c1">// in the executable a name that can be</span>
                  <span class="c1">// referenced. They're very similar to `goto`</span>
                  <span class="c1">// labels from C.</span>
                  <span class="c1">//</span>
                  <span class="c1">// We'll see more labels later on.</span>


        <span class="c1">// This is the function prologue, which "sets up" the</span>
        <span class="c1">// function: it allocates stack space and saves the</span>
        <span class="c1">// return address, along with other calling-convention</span>
        <span class="c1">// fussiness.</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

        <span class="c1">// This is our `x *= x;` from before! Notice that the</span>
        <span class="c1">// compiler rewrote this to `temp = x * x;` at some</span>
        <span class="c1">// point, since the destination register is `s0`.</span>
        <span class="n">mul</span>     <span class="n">s0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span>

        <span class="c1">// These two instructions load the address of a string</span>
        <span class="c1">// constant; this pattern is specific to RISC-V.</span>
        <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        
        <span class="c1">// This copies the multiplication result into `a1`.</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">s0</span>

        <span class="c1">// Call to printf!</span>
        <span class="n">call</span>    <span class="n">printf</span>

        <span class="c1">// Move `s0` into `a0`, since it's the return value.</span>
        <span class="n">mv</span>      <span class="n">a0</span><span class="p">,</span> <span class="n">s0</span>

        <span class="c1">// This is the function epilogue, which restores state</span>
        <span class="c1">// saved in the prologue and de-allocates the stack</span>
        <span class="c1">// frame.</span>
        <span class="n">lw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        
        <span class="c1">// We're done; return from the function!</span>
        <span class="n">ret</span>

        <span class="c1">// This tells the assembler to place what follows in</span>
        <span class="c1">// the `.rodata` section, for read-only constants like</span>
        <span class="c1">// strings.</span>
        <span class="p">.</span><span class="n">section</span>        <span class="p">.</span><span class="n">rodata</span>

<span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="o">:</span> <span class="c1">// Give our string constant a private name. By convention,</span>
        <span class="c1">// .L labels are "private" names emitted by the compiler.</span>

        <span class="c1">// Emit an ASCII string into `.rodata` with an extra null</span>
        <span class="c1">// terminator at the end: that's what the `z` stands for.</span>
        <span class="p">.</span><span class="n">asciz</span>  <span class="s">"%d</span><span class="se">\n</span><span class="s">"</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">square.s</a></div></div> <h3 id="the-core-syntax"><a href="#the-core-syntax">The Core Syntax</a></h3> <p>All assemblers are different, but the core syntax tends to be the same. There are three main kinds of syntax productions:</p> <ul> <li>Instructions, which consist of a <em>mnemonic</em> followed by some number of <em>operands</em>, such as <code class="language-plaintext highlighter-rouge">addi sp, sp -16</code> and <code class="language-plaintext highlighter-rouge">call printf</code> above. These are the text encoding of machine code.</li> <li>Labels, which consist of a symbol followed by a colon, like <code class="language-plaintext highlighter-rouge">square_and_print:</code> or <code class="language-plaintext highlighter-rouge">.L.str:</code>. These are used to let instruction operands refer to locations in the program.</li> <li>Directives, which vary wildly by assembler. GCC-style assembly like that above uses a <code class="language-plaintext highlighter-rouge">.directive arg, arg</code> syntax, as seen in <code class="language-plaintext highlighter-rouge">.text</code>, <code class="language-plaintext highlighter-rouge">.globl</code>, and <code class="language-plaintext highlighter-rouge">.asciz</code>. They control the behavior of the assembler in various ways.</li> </ul> <p>An assembler’s purpose is to read the <code class="language-plaintext highlighter-rouge">.s</code> file and serialize it as a binary <code class="language-plaintext highlighter-rouge">.o</code> file. It’s kind of like a compiler, but it does virtually no interesting work at all, beyond knowing how to encode instructions.</p> <p>Directives control how this serialization occurs (such as moving around the output cursor); instructions are emitted as-is, and labels refer to locations in the object file. Simple enough, right?</p> <h3 id="anatomy-of-an-instruction"><a href="#anatomy-of-an-instruction">Anatomy of an Instruction</a></h3> <p>Let’s look at the very first instruction in <code class="language-plaintext highlighter-rouge">square_and_print</code>:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">        <span class="n">addi</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="o">----</span> <span class="o">--</span>  <span class="o">--</span>  <span class="o">---</span>
         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>    <span class="o">|</span>
        <span class="n">mnemonic</span> <span class="o">|</span>   <span class="n">immediate</span> <span class="n">operand</span>
             <span class="o">|</span>  <span class="n">input</span> <span class="n">operand</span>
             <span class="o">|</span>
            <span class="n">output</span> <span class="n">operand</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">RISC-V Assembly</a></div></div> <p>The first token is called the <em>mnemonic</em>, which is a painfully terse abbreviation of what the instruction does. In this case, <code class="language-plaintext highlighter-rouge">addi</code> means “add with immediate”.</p> <p><code class="language-plaintext highlighter-rouge">sp</code> is a <em>register</em>. Registers are special variables wired directly into the processor that can be used as operands in instructions. The degree to which only registers are permitted as operands varies by architecture; RISC-V only allows registers, but x86, as we’ll see, does not. Registers come in many flavors, but <code class="language-plaintext highlighter-rouge">sp</code> is a GPR, or “general purpose register”; it holds a machine word-sized integer, which in the case of 32-bit RISC-V is… 32-bit<sup id="fnref:whats-a-word" role="doc-noteref"><a href="#fn:whats-a-word" class="footnote" rel="footnote">2</a></sup>.</p> <blockquote id="aside:risc-v-registers" class="aside"> <p><a href="#aside:risc-v-registers"><span class="chip">aside</span><span class="title">RISC-V Registers</span></a></p> <p>One of my absolute favorite parts of RISC-V is how it names its registers. It has 32 GPRs named <code class="language-plaintext highlighter-rouge">x0</code> through <code class="language-plaintext highlighter-rouge">x31</code>. However, these registers have so-called “ABI names” that specify the <em>role</em> of each register in the ABI.</p> <p>The usefulness of these names will be much more apparent when we discuss <a href="#the-calling-convention">the calling convention</a>, so feel free to come back to this later.</p> <p><code class="language-plaintext highlighter-rouge">x0</code> is called <code class="language-plaintext highlighter-rouge">zero</code>, because of its special property: writes to it are ignored, and reads always produce zero. This is handy for encoding certain common operations: for example, it can be used to quickly get a constant value= into a register: <code class="language-plaintext highlighter-rouge">addi rd, zero, 42</code>.</p> <p><code class="language-plaintext highlighter-rouge">x1</code>, <code class="language-plaintext highlighter-rouge">x2</code>, <code class="language-plaintext highlighter-rouge">x3</code>, and <code class="language-plaintext highlighter-rouge">x4</code> have special roles and generally aren’t used for general computation. The first two are the link register <code class="language-plaintext highlighter-rouge">ra</code>, which holds the <u>r</u>eturn <u>a</u>ddress, and <code class="language-plaintext highlighter-rouge">sp</code>, the <u>s</u>tack <u>p</u>ointer.</p> <p>The latter two are <code class="language-plaintext highlighter-rouge">gp</code> and <code class="language-plaintext highlighter-rouge">tp</code>; the <u>g</u>lobal <u>p</u>pointer and the <u>t</u>hread <u>p</u>pointer; their roles are somewhat complicated, so we won’t discuss them in this post.</p> <p>The remaining registers belong to one of three categories: <em>argument</em> registers, <em>saved</em> registers, and <em>temporary</em> registers, named so for their role in calling a function (as described <a href="#the-calling-convention">below</a>).</p> <p>The argument registers are <code class="language-plaintext highlighter-rouge">x10</code> through <code class="language-plaintext highlighter-rouge">x17</code>, and use the names <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a7</code>. The saved registers are <code class="language-plaintext highlighter-rouge">x8</code>, <code class="language-plaintext highlighter-rouge">x9</code>, and <code class="language-plaintext highlighter-rouge">x18</code> through <code class="language-plaintext highlighter-rouge">x27</code>, called <code class="language-plaintext highlighter-rouge">s0</code>, through <code class="language-plaintext highlighter-rouge">s11</code>. The temporary registers are <code class="language-plaintext highlighter-rouge">x5</code> through <code class="language-plaintext highlighter-rouge">x7</code> and <code class="language-plaintext highlighter-rouge">x28</code> through <code class="language-plaintext highlighter-rouge">x31</code>, called <code class="language-plaintext highlighter-rouge">t0</code> through <code class="language-plaintext highlighter-rouge">t6</code>.</p> <p>As a matter of personal preference, you may notice me reaching for argument registers for most examples.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">-16</code> is an <em>immediate</em>, which is a literal value that is encoded directly into the instruction. The encoding of <code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code> will include the binary representation of <code class="language-plaintext highlighter-rouge">-16</code> (in the case of RISC-V, as a 12-bit integer). [The decoding example above]{#decoding-instructions} shows how immediates are literally encoded <em>immediately</em> in the instruction.</p> <p>Immediates allow for small but fixed integer arguments to be encoded with high locality to the instruction, which is good for code size and performance.</p> <p>The first operand in RISC-V is (almost) always the output. <code class="language-plaintext highlighter-rouge">addi, rd, rs, imm</code> should be read as <code class="language-plaintext highlighter-rouge">rd = rs + imm</code>. Virtually all assembler syntax follows this convention, which is called the <a href="https://en.wikipedia.org/wiki/Three-address_code">three-address code</a>.</p> <p>Other kinds of operands exist: for example, <code class="language-plaintext highlighter-rouge">call printf</code> refers to the <em>symbol</em> <code class="language-plaintext highlighter-rouge">printf</code>. The assembler, which doesn’t actually know where <code class="language-plaintext highlighter-rouge">printf</code> is, will emit a small note in the object file that tells the linker to find <code class="language-plaintext highlighter-rouge">printf</code> and splat it into the assembly according to some instructions in the note. These notes are called <em>relocations</em>.</p> <p>The instructions <code class="language-plaintext highlighter-rouge">lui a0, %hi(.L.str)</code> and <code class="language-plaintext highlighter-rouge">addi a0, a0, %lo(.L.str)</code> use the <code class="language-plaintext highlighter-rouge">%lo</code> and <code class="language-plaintext highlighter-rouge">%hi</code> operand types, which are specific to RISC-V; they load the low 12 bits and high 20 bits of a symbol’s address into the immediate operand. This is a RISC-V-specific pattern for loading an address into a register, which most assemblers provide with the <em>pseudoinstruction</em> <code class="language-plaintext highlighter-rouge">la a0, .L.str</code> (where <code class="language-plaintext highlighter-rouge">la</code> stands for “load address”).</p> <p>Most architectures have their own funny architecture-specific operand types to deal with the architecture’s idiosyncrasy.</p> <h3 id="types-of-instructions"><a href="#types-of-instructions">Types of Instructions</a></h3> <p>Available instructions tend to be motivated by providing one of three classes of functionality:</p> <ol> <li>A Turing-complete <a href="https://en.wikipedia.org/wiki/Register_machine">register machine</a> execution environment. This lends to the Turing tarpit nature of assembly: only the absolute minimum in terms of control flow and memory access is provided.</li> <li>Efficient silicon implementation of common operations on bit strings and integers, ranging from arithmetic to cryptographic algorithms.</li> <li>Building a secure operating system, hosting virtual machines, and actuating hardware external to the processor, like a monitor, a keyboard, or speakers.</li> </ol> <p>Instructions can be broadly classified into four categories: arithmetic, memory, control flow, and “everything else”. In the last thirty years, the bar for general-purpose architectures is usually “this is enough to implement a C runtime.”</p> <h4 id="arithmetic-instructions"><a href="#arithmetic-instructions">Arithmetic Instructions</a></h4> <p>Arithmetic makes up the bulk of the instruction set. This always includes addition, subtraction, and bitwise and, or, and xor, as well as unary not and negation.</p> <p>In RISC-V, these come in two variants: a three-register version and a two-register, one immediate version. For example, <code class="language-plaintext highlighter-rouge">add a0, a1, a2</code> is the three-register version of addition, while <code class="language-plaintext highlighter-rouge">addi a0, a1, 42</code> is the immediate version. There isn’t a <code class="language-plaintext highlighter-rouge">subi</code> though, since you can just use negative immediates with <code class="language-plaintext highlighter-rouge">addi</code>.</p> <p><code class="language-plaintext highlighter-rouge">not</code> and <code class="language-plaintext highlighter-rouge">neg</code> are not actual instructions in RISC-V, but pseudoinstructions: <code class="language-plaintext highlighter-rouge">not a0, a1</code> encodes as <code class="language-plaintext highlighter-rouge">xori a0, a1, -1</code>, while <code class="language-plaintext highlighter-rouge">neg a0, a1</code> becomes <code class="language-plaintext highlighter-rouge">sub a0, zero, a1</code>.</p> <p>Most instruction sets also have bit shifts, usually in three flavors: left shifts, right shifts, and <em>arithmetic</em> right shifts; arithmetic right shift is defined such that it behaves like division by powers of two on signed integers. RISC-V’s names for these instructions are <code class="language-plaintext highlighter-rouge">sll</code>, <code class="language-plaintext highlighter-rouge">srl</code>, and <code class="language-plaintext highlighter-rouge">sra</code>.</p> <p>Multiplication and division are somewhat rarer, because they are expensive to implement in silicon; smaller devices don’t have them<sup id="fnref:mul-polyfill" role="doc-noteref"><a href="#fn:mul-polyfill" class="footnote" rel="footnote">3</a></sup>. Division in particular is very complex to implement in silicon. Instruction sets usually have different behavior around division by zero: some architectures will fault, similar to a memory error, while some, like RISC-V, produce a well-defined trap value.</p> <p>There is usually also a “copy” instruction that moves the value of one register to another, which is kind of like a trivial arithmetic instruction. RISC-V calls this <code class="language-plaintext highlighter-rouge">mv a0, a1</code>, but it’s just a pseudoinstruction that expands to <code class="language-plaintext highlighter-rouge">addi a0, a1, 0</code>.</p> <p>Some architectures also offer more exotic arithmetic. This is just a sampler of what’s sometimes available:</p> <ul> <li>Bit rotation, which is like a shift but bits that get shifted off end up at the other end of the integer. This is useful for a vast array of numeric algorithms, including ARX ciphers like <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha20</a>.</li> <li>Byte reversal, which can be used for changing the endianness of an integer; bit reversal is analogous.</li> <li>Bit extraction, which can be used to form new integers out of bitfields of another.</li> <li>Carry-less multiplication, which is like long multiplication but you don’t bother to carry anything when you add intermediates. This is used to implement <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois/Counter mode encryption</a>.</li> <li>Fused instructions, like <code class="language-plaintext highlighter-rouge">xnor</code> and <code class="language-plaintext highlighter-rouge">nand</code>.</li> <li>Floating point instructions, usually implementing the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> standard.</li> </ul> <p>There is also a special kind of arithmetic instruction called a <em>vector instruction</em>, but I’ll leave those for another time.</p> <h4 id="memory-instructions"><a href="#memory-instructions">Memory Instructions</a></h4> <p>Load instructions fetch memory from RAM into registers, while store instructions write it back. These instructions are what we use to implement pointers.</p> <p>They come in all sorts of different sizes: RISC-V has <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">lh</code>, and <code class="language-plaintext highlighter-rouge">lb</code> for loading 32-, 16-, and 8-bit values from a location; <code class="language-plaintext highlighter-rouge">sw</code>, <code class="language-plaintext highlighter-rouge">sh</code>, and <code class="language-plaintext highlighter-rouge">sb</code> are their store counterparts. 64-bit RISC-V also provides <code class="language-plaintext highlighter-rouge">ld</code> and <code class="language-plaintext highlighter-rouge">sd</code> for 64-bit loads and stores.</p> <p>Load/store instructions frequently take an offset for indexing into memory. <code class="language-plaintext highlighter-rouge">lw a1, 4(a0)</code><sup id="fnref:offset-syntax" role="doc-noteref"><a href="#fn:offset-syntax" class="footnote" rel="footnote">4</a></sup> is effectively <code class="language-plaintext highlighter-rouge">a1 = a0[4]</code>, treating <code class="language-plaintext highlighter-rouge">a0</code> like a pointer.</p> <p>These instructions frequently have an <em>alignment</em> constraint: the pointer value must (or, at least, should) be divisible by the number of bytes being loaded. RISC-V, for example, mandates that <code class="language-plaintext highlighter-rouge">lw</code> only be used on pointers divisible by 4. This constraint simplifies the microarchitecture; even on architectures that don’t mandate it, aligned loads and stores are typically far faster.</p> <p>This category also includes instructions necessary for implementing atomics, such as <code class="language-plaintext highlighter-rouge">lock cmpxchg</code> on x86 and <code class="language-plaintext highlighter-rouge">lr</code>/<code class="language-plaintext highlighter-rouge">sc</code> on RISC-V. Atomics are fundamentally about changing the semantics of reading and writing from RAM, and thus require special processor support.</p> <p>Some architectures, like x86, 65816, and very recently, ARM, provide instructions that implement <code class="language-plaintext highlighter-rouge">memcpy</code> and its ilk in hardware: in x86, for example, this is called <code class="language-plaintext highlighter-rouge">rep movsb</code>.</p> <h4 id="control-flow-instructions"><a href="#control-flow-instructions">Control Flow Instructions</a></h4> <p>Control flow is the secret ingredient that turns our glorified calculator into a Turing tarpit: they allow changing the flow of program execution based on its current state.</p> <p><em>Unconditional jumps</em> implement <code class="language-plaintext highlighter-rouge">goto</code>: given some <code class="language-plaintext highlighter-rouge">label</code>, the <code class="language-plaintext highlighter-rouge">j label</code> instruction jumps directly to it. <code class="language-plaintext highlighter-rouge">j</code> can be thought of as writing to a special <code class="language-plaintext highlighter-rouge">pc</code> register that holds the program counter. RISC-V also provides a <em>dynamic</em> jump, <code class="language-plaintext highlighter-rouge">jr</code>, which will jump to the address in a register. Function calls and returns are a special kind of unconditional jump.</p> <p><em>Conditional jumps</em>, often called <em>branches</em>, implement <code class="language-plaintext highlighter-rouge">if</code>. <code class="language-plaintext highlighter-rouge">beq a0, a1, label</code> will jump to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">a0</code> and <code class="language-plaintext highlighter-rouge">a1</code> contain the same value. RISC-V provides branch instructions for all kinds of comparisons, like <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">blt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>.</p> <p>Conditional and unconditional jumps can be used together to build loops, much like we could in C using <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">goto</code>.</p> <p>For example, to zero a region of memory:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">        <span class="c1">// Assume a0 is the start of the region, and a1 the</span>
        <span class="c1">// number of bytes to zero.</span>

        <span class="c1">// Set a1 to the end of the region.</span>
        <span class="n">addi</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span>
<span class="n">loop_start</span><span class="o">:</span>
        <span class="c1">// If a0 == a1, we're done!</span>
        <span class="n">beq</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">loop_done</span>

        <span class="c1">// Store a zero byte to `a0` and advance the pointer.</span>
        <span class="n">sb</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
        <span class="n">addi</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">1</span>

        <span class="c1">// Take it from the top!</span>
        <span class="n">j</span> <span class="n">loop_start</span>
<span class="n">loop_done</span><span class="o">:</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">RISC-V Assembly</a></div></div> <h4 id="miscellaneous-instructions"><a href="#miscellaneous-instructions">Miscellaneous Instructions</a></h4> <p>“Everything else” is, well… everything else.</p> <p>No-op instructions do nothing: <code class="language-plaintext highlighter-rouge">nop</code>’s only purpose is to take up space in the instruction stream. No-op instructions can be used to pad space in the instruction stream, provide space for the linker to fix things up later, or implement <a href="https://en.wikipedia.org/wiki/NOP_slide"><code class="language-plaintext highlighter-rouge">nop</code> sleds</a>.</p> <p>Instructions for poking processor state, like <code class="language-plaintext highlighter-rouge">csrrw</code> in RISC-V and <code class="language-plaintext highlighter-rouge">wrmsr</code> in <code class="language-plaintext highlighter-rouge">x86</code> also belong in this category, as do “hinting” instructions like memory prefetches.</p> <p>There are also instructions for special control flow: <code class="language-plaintext highlighter-rouge">ecall</code> is RISC-V’s “syscall” instruction, which “traps” to the kernel for it to do something; other architectures have similar instructions.</p> <p>Breakpoint instructions and <a href="https://www.felixcloutier.com/x86/lfence">“fence” instructions</a> belong here, too.</p> <h2 id="the-calling-convention"><a href="#the-calling-convention">The Calling Convention</a></h2> <p>Functions are the core abstraction of all of programming. Assembly is no different: we have functions there, too!</p> <p>Like in any language, functions are <em>passed</em> a list of arguments, perform some work, and <em>return</em> a value. For example, in C:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">identity</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="n">identity</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1">// Returns 5.</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">C</a></div></div> <p>Unfortunately, there isn’t anything like function call syntax in assembly. As with everything else, we need do it instruction by instruction. All we <em>do</em> get in most architectures is a <code class="language-plaintext highlighter-rouge">call</code> instruction, which sets up a return address somewhere, and a <code class="language-plaintext highlighter-rouge">ret</code> instruction, which uses the return address to jump to where the function was called.</p> <p>We need some way to pass arguments, return a computed value, and maintain a call stack, so that each function’s return address is kept intact for its <code class="language-plaintext highlighter-rouge">ret</code> instruction to consume. We also need this to be universal: if I pull in a library, I should be able to call its functions.</p> <p>This mechanism is called the <em>calling convention</em> of the platform’s ABI. It’s a convention, because all libraries must respect it in their exposed API for code to work correctly at runtime.</p> <h3 id="a-function-call-in-slow-mo"><a href="#a-function-call-in-slow-mo">A Function Call in Slow-Mo</a></h3> <p>At the instruction level, function calls look something like this:</p> <ol> <li> <p>Pre-call setup. The caller sets up the function call arguments by placing them in the appointed locations for arguments. These are usually either registers or locations on the stack. a. The caller also saves the <em>caller-saved registers</em> to the stack.</p> </li> <li> <p>Jump to the function. The caller executes a <code class="language-plaintext highlighter-rouge">call</code> instruction (or whatever the function call instruction might be called – virtually all architectures have one). This sets the program counter to the first instruction of the callee.</p> </li> <li> <p>Function prologue. The callee does some setup before executing its code. a. The callee reserves space on the stack in an architecture-dependent manner. b. The callee saves the <em>callee-saved registers</em> to this stack space.</p> </li> <li> <p>Function body. The actual code of the function runs now! This part of the function needs to make sure the return value winds up wherever the <em>return slot</em> for the function is.</p> </li> <li> <p>Function epilogue. The callee undoes whatever work it did in the prologue, such as restoring saved registers, and executes a <code class="language-plaintext highlighter-rouge">ret</code> (or equivalent) instruction to return.</p> </li> <li> <p>Post-call cleanup. The caller is now executing again; it can unspill any saved state that it needs immediately after the function call, and can retrieve the return value from the return slot.</p> <p>In some ABIs, such as C++’s on Linux, this is where the destructors of the arguments get run. (Rust, and C++ on Windows, have <em>callee</em>-destroyed arguments instead.)</p> </li> </ol> <p>When people say that function calls have overhead, this is what they mean. Not only does the <code class="language-plaintext highlighter-rouge">call</code> instruction cause the processor to slam the breaks on its pipeline, causing all kinds of work to get thrown away, but state needs to be delicately saved and restored across the function boundary to maintain the illusion of a callstack.</p> <p>Small functions which don’t need to use as many registers can avoid some of the setup and cleanup, and <em>leaf functions</em> which don’t call any other functions can avoid basically all of it!</p> <p>Almost all registers in RISC-V are caller-saved, except for <code class="language-plaintext highlighter-rouge">ra</code> and the “saved” registers <code class="language-plaintext highlighter-rouge">s0</code> and <code class="language-plaintext highlighter-rouge">s11</code>.</p> <p>Callee-saved registers are convenient, because they won’t be wiped out by function calls. We can actually see the call to <code class="language-plaintext highlighter-rouge">printf</code> use this: even though the compiler could have emitted <code class="language-plaintext highlighter-rouge">mul a1, a0, a0</code> and avoided the <code class="language-plaintext highlighter-rouge">mv</code>, this is actually less optimal. We need to keep the value around to return, and <code class="language-plaintext highlighter-rouge">a1</code> is caller-saved, so we would have had to spill <code class="language-plaintext highlighter-rouge">a1</code> before calling <code class="language-plaintext highlighter-rouge">printf</code>, regardless of whether <code class="language-plaintext highlighter-rouge">printf</code> overwrites <code class="language-plaintext highlighter-rouge">a1</code> or not. We would then have to unspill it into <code class="language-plaintext highlighter-rouge">a0</code> before <code class="language-plaintext highlighter-rouge">ret</code>. This costs us a hit to RAM. However, by emitting <code class="language-plaintext highlighter-rouge">mul s0, a0, a0; mv a1, s0</code>, we speculatively avoid the spill: if <code class="language-plaintext highlighter-rouge">printf</code> is compiled such that it never touches <code class="language-plaintext highlighter-rouge">s0</code>, the value never leaves registers at all!</p> <h3 id="caller-side"><a href="#caller-side">Caller-Side</a></h3> <p>We can see steps 1 and 2 in the call to <code class="language-plaintext highlighter-rouge">printf</code>:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">        <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">s0</span>
        <span class="n">call</span>    <span class="n">printf</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">RISC-V Assembly</a></div></div> <p>Arguments in the usual<sup id="fnref:custom-abis" role="doc-noteref"><a href="#fn:custom-abis" class="footnote" rel="footnote">5</a></sup> RISC-V calling convention, word-sized arguments are passed in the <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a7</code> registers, falling back to passing on the stack if they run out of space. If the argument is too big to fit in a register, it gets passed by reference instead. Arguments that fit into two registers can be split across registers.</p> <p>We can see this in action <a href="#big-example">above</a>. The first argument, a string, is passed by pointer in <code class="language-plaintext highlighter-rouge">a0</code>; <code class="language-plaintext highlighter-rouge">lui</code> and <code class="language-plaintext highlighter-rouge">addi</code> do the work of actually putting that pointer into <code class="language-plaintext highlighter-rouge">a0</code>. The second argument <code class="language-plaintext highlighter-rouge">x</code> is passed in <code class="language-plaintext highlighter-rouge">a1</code>, copied from <code class="language-plaintext highlighter-rouge">s0</code> where it landed from the earlier <code class="language-plaintext highlighter-rouge">mul</code> instruction.</p> <p>Complex function signatures require much more<sup id="fnref:all-args" role="doc-noteref"><a href="#fn:all-args" class="footnote" rel="footnote">6</a></sup> work to set up.</p> <p>Once we’re done getting arguments into place, we <code class="language-plaintext highlighter-rouge">call</code>, which switches execution over to <code class="language-plaintext highlighter-rouge">printf</code>’s first instruction. In addition, it stores the return address, specifically, the address of the instruction immediately after the <code class="language-plaintext highlighter-rouge">call</code>, into an architecture-specific location. On RISC-V, this is the special register <code class="language-plaintext highlighter-rouge">ra</code>.</p> <h3 id="callee-side"><a href="#callee-side">Callee-Side</a></h3> <p>Meanwhile, steps 3 and 4 occur in <code class="language-plaintext highlighter-rouge">square_and_print</code>’s prologue/epilogue itself:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square_and_print:</span> 
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

        <span class="c1">// ...</span>

        <span class="n">lw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">RISC-V Assembly</a></div></div> <p><code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code>, which we stared at so hard above, grows the stack by 16 bytes. <code class="language-plaintext highlighter-rouge">sp</code> holds the <em>stack pointer</em>, which points to the top of the stack at all times. The stack grows downwards (as in most architectures!) and must be aligned to 16-byte boundaries across function calls: even though <code class="language-plaintext highlighter-rouge">square_and_print</code> only uses eight of those bytes, the full 16 bytes must be allocated.</p> <p>The two <code class="language-plaintext highlighter-rouge">sw</code> instructions that follow store (or “spill”) the callee-saved registers <code class="language-plaintext highlighter-rouge">ra</code> and <code class="language-plaintext highlighter-rouge">s0</code> to the stack. Note that <code class="language-plaintext highlighter-rouge">s1</code> through <code class="language-plaintext highlighter-rouge">s11</code> are <em>not</em> spilled, since <code class="language-plaintext highlighter-rouge">square_and_print</code> doesn’t use them!</p> <p>Th this point, the function does its thing, whatever that means. This includes putting the return value in the return slot, which, for a function that returns an <code class="language-plaintext highlighter-rouge">int</code>, is in <code class="language-plaintext highlighter-rouge">a0</code>. In general, the return slot is passed back to the caller much like arguments are: if it fits in registers, <code class="language-plaintext highlighter-rouge">a0</code> and <code class="language-plaintext highlighter-rouge">a1</code> are used; otherwise, the caller allocates space for it and passes a pointer to the return slot as a hidden argument (in e.g. <code class="language-plaintext highlighter-rouge">a0</code>)<sup id="fnref:return-slot" role="doc-noteref"><a href="#fn:return-slot" class="footnote" rel="footnote">7</a></sup>.</p> <p>The epilogue inverts all operations of the prologue in reverse, unspilling registers and shrinking the stack, followed by <code class="language-plaintext highlighter-rouge">ret</code>. On RISC-V, all <code class="language-plaintext highlighter-rouge">ret</code> does is jump to the location referred to by the <code class="language-plaintext highlighter-rouge">ra</code> register.</p> <p>Of course, all this work is only necessary to maintain the illusion of a callstack; if <code class="language-plaintext highlighter-rouge">square_and_print</code> were a leaf function, it would not need to spill anything at all! This results in an almost trivial function:</p> <div class="code-multicol"> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYyIsInNvdXJjZSI6 ImludCBzcXVhcmUoaW50IHgpIHtcbiAgcmV0dXJuIHggKiB4O1xufSIsImNv bXBpbGVycyI6W3siaWQiOiJydjMyLWNjbGFuZyIsIm9wdGlvbnMiOiItT3oi fV19XX0=">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:17">C</a></div></div> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// `x` is already in a0, and the</span>
<span class="c1">// return value needs to wind up</span>
<span class="c1">// in a0. EZ!</span>
<span class="n">square</span><span class="o">:</span>
        <span class="n">mul</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span>
        <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">RISC-V Assembly</a></div></div> </div> <p>Because leaf functions won’t call other functions, they won’t need to save the caller-saved <code class="language-plaintext highlighter-rouge">tX</code> registers, so they can freely use them instead of the <code class="language-plaintext highlighter-rouge">sX</code> registers.</p> <h2 id="the-end-for-now"><a href="#the-end-for-now">The End, for Now</a></h2> <p>Phew! We’re around six thousand words in, so let’s checkpoint what we’ve learned:</p> <ol> <li> <p>Computers are stupid, but can at least follow <em>extremely</em> basic instructions, which are encoded as binary.</p> </li> <li> <p>Assembly language is human-readable version of these basic instructions for a particular computer.</p> </li> <li> <p>Assembly language programs consist of <em>instructions</em>, <em>labels</em>, and <em>directives</em>.</p> </li> <li> <p>Each instruction is a <em>mnemonic</em> followed by zero or more <em>operands</em>.</p> </li> <li> <p><em>Registers</em> hold values the machine is currently operating on.</p> </li> <li> <p>Instructions can be broadly categorized as <em>arithmetic</em>, <em>memory</em>, <em>control flow</em>, and “miscellaneous” (plus <em>vector</em> and <em>float</em> instructions, for another time).</p> </li> <li> <p>The <em>calling convention</em> describes the low-level interface of a general function, consisting of some pre-call setup, and a prologue and epilogue in each function.</p> </li> </ol> <p>That’s all for now. RISC-V is a powerful but reasonably simple ISA. Next time, we’ll dive into the much older, much larger, and much more complex Intel x86.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:superscalar" role="doc-endnote"> <p>This is a hilarious lie that is beyond the scope of this post. See, for example, <a href="https://en.wikipedia.org/wiki/Superscalar_processor">https://en.wikipedia.org/wiki/Superscalar_processor</a>. <a href="#fnref:superscalar" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:whats-a-word" role="doc-endnote"> <p>What’s a machine word, exactly? It really depends on context. Most popular architectures has a straight-forward definition: the size of a GPR <em>or</em> the size of a pointer, which are the same.</p> <p>This is not true of all architectures, so beware. <a href="#fnref:whats-a-word" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:mul-polyfill" role="doc-endnote"> <p>Thankfully, these can be polyfilled using the previous ubiquitous instructions. Hacker’s Delight contains all of the relevant algorithms, so I won’t reproduce them here. The division polyfills are particularly interesting. <a href="#fnref:mul-polyfill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:offset-syntax" role="doc-endnote"> <p>It’s a bit interesting that we don’t write <code class="language-plaintext highlighter-rouge">lw a1, a0[4]</code> in imitation of array syntax. This specific corner of the notation is shockingly diverse across assemblers: in ARM, we write <code class="language-plaintext highlighter-rouge">ldr r0, [r1, #offset]</code>; in x86, <code class="language-plaintext highlighter-rouge">mov rax, [rdx + offset]</code>, or <code class="language-plaintext highlighter-rouge">movq offset(%rdx), %rax</code> for AT&amp;T-flavored assemblers (which is surprisingly similar to the RISC-V syntax!); in 6502, <code class="language-plaintext highlighter-rouge">lda ($1234, X)</code>. <a href="#fnref:offset-syntax" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:custom-abis" role="doc-endnote"> <p>The calling convention isn’t actually determined by the architecture in most cases; that’s why it’s called a <em>convention</em>. The convention on x86 actually differs on Windows and Linux, and is usually also language-dependent; C’s calling convention is usually documented, but C++, Rust, and Go invent their own to handle language-specific fussiness.</p> <p>Of course, if you’re writing assembly, you can do whatever you want (though the silicon may be optimized for a particular recommended calling convention).</p> <p>RISC-V defines a recommended calling convention for ELF-based targets: <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">https://github.com/riscv-non-isa/riscv-elf-psabi-doc</a>. <a href="#fnref:custom-abis" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:all-args" role="doc-endnote"> <p>The following listing shows how all kinds of different arguments are passed. The output isn’t quite what Clang emits, since I’ve cleaned it up for clarity.</p> <div class="code-multicol" style="height: 860px;"> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdnoreturn.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">Pair</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Triple</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Packed</span> <span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// `noreturn` obviates the</span>
<span class="c1">// {pro,epi}logue in `call_it`.</span>
<span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">all_the_args</span><span class="p">(</span>
  <span class="kt">uint32_t</span> <span class="n">a0</span><span class="p">,</span>
  <span class="kt">uint64_t</span> <span class="n">a1a2</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Pair</span> <span class="n">a3a4</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Triple</span> <span class="n">a5_by_ref</span><span class="p">,</span>
  <span class="kt">uint16_t</span> <span class="n">a6</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Packed</span> <span class="n">a7</span><span class="p">,</span>
  <span class="kt">uint32_t</span> <span class="n">on_the_stack</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Triple</span> <span class="n">stack_by_ref</span>
<span class="p">);</span>

<span class="kt">void</span> <span class="nf">call_it</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Pair</span> <span class="n">u</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">Triple</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">Packed</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">};</span>
  <span class="n">all_the_args</span><span class="p">(</span>
    <span class="mi">42</span><span class="p">,</span> <span class="o">-</span><span class="mi">42</span><span class="p">,</span>  <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
     <span class="mi">5</span><span class="p">,</span>   <span class="n">w</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="n">v</span>
  <span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYyIsInNvdXJjZSI6 IlxuI2luY2x1ZGUgPHN0ZGlvLmg+XG4jaW5jbHVkZSA8c3RkaW50Lmg+XG4j aW5jbHVkZSA8c3Rkbm9yZXR1cm4uaD5cblxuICAgIHN0cnVjdCBQYWlyIHtc biAgICAgIHVpbnQzMl90IHgsIHk7XG4gICAgfTtcbiAgICBzdHJ1Y3QgVHJp cGxlIHtcbiAgICAgIHVpbnQzMl90IHgsIHksIHo7XG4gICAgfTtcbiAgICBz dHJ1Y3QgUGFja2VkIHtcbiAgICAgIHVpbnQ4X3QgeCwgeSwgejtcbiAgICB9 O1xuXG4gICAgLy8gYG5vcmV0dXJuYCBvYnZpYXRlcyB0aGVcbiAgICAvLyB7 cHJvLGVwaX1sb2d1ZSBpbiBgY2FsbF9pdGAuXG4gICAgbm9yZXR1cm4gdm9p ZCBhbGxfdGhlX2FyZ3MoXG4gICAgICB1aW50MzJfdCBhMCxcbiAgICAgIHVp bnQ2NF90IGExYTIsXG4gICAgICBzdHJ1Y3QgUGFpciBhM2E0LFxuICAgICAg c3RydWN0IFRyaXBsZSBhNV9ieV9yZWYsXG4gICAgICB1aW50MTZfdCBhNixc biAgICAgIHN0cnVjdCBQYWNrZWQgYTcsXG4gICAgICB1aW50MzJfdCBvbl90 aGVfc3RhY2ssXG4gICAgICBzdHJ1Y3QgVHJpcGxlIHN0YWNrX2J5X3JlZlxu ICAgICk7XG5cbiAgICB2b2lkIGNhbGxfaXQodm9pZCkge1xuICAgICAgc3Ry dWN0IFBhaXIgdSA9IHs3LCA5fTtcbiAgICAgIHN0cnVjdCBUcmlwbGUgdiA9 IHsxMSwgMTMsIDE1fTtcbiAgICAgIHN0cnVjdCBQYWNrZWQgdyA9IHsxNCwg MTYsIDE4fTtcbiAgICAgIGFsbF90aGVfYXJncyhcbiAgICAgICAgNDIsIC00 MiwgIHUsIHYsXG4gICAgICAgICA1LCAgIHcsIDIxLCB2XG4gICAgICApO1xu ICAgIH0iLCJjb21waWxlcnMiOlt7ImlkIjoicnYzMi1jY2xhbmciLCJvcHRp b25zIjoiLU96In1dfV19 ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:11">C</a></div></div> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">call_it:</span>
  <span class="c1">// Reserve stack space.</span>
  <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">48</span>

  <span class="c1">// Get `&amp;call_it.v` into `a3`.</span>
  <span class="n">lui</span>     <span class="n">a3</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(</span><span class="n">call_it</span><span class="p">.</span><span class="n">v</span><span class="p">)</span>
  <span class="n">addi</span>    <span class="n">a3</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(</span><span class="n">call_it</span><span class="p">.</span><span class="n">v</span><span class="p">)</span>

  <span class="c1">// Copy contents of `*a3`</span>
  <span class="c1">// into `a0...a2`.</span>
  <span class="n">lw</span>      <span class="n">a0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
  <span class="n">lw</span>      <span class="n">a1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
  <span class="n">lw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>

  <span class="c1">// Create two copies of `v`</span>
  <span class="c1">// on the stack to pass by</span>
  <span class="c1">// reference.</span>

  <span class="c1">// This is `a5_by_ref`.</span>
  <span class="n">sw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">40</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a1</span><span class="p">,</span> <span class="mi">36</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a0</span><span class="p">,</span> <span class="mi">32</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

  <span class="c1">// This is `stack_by_ref`.</span>
  <span class="n">sw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">20</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a0</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  
  <span class="c1">// Load the argument regs.</span>
  <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">addi</span>    <span class="n">a1</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="o">-</span><span class="mi">42</span>
  <span class="n">addi</span>    <span class="n">a2</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
  <span class="n">addi</span>    <span class="n">a3</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">7</span>
  <span class="n">addi</span>    <span class="n">a4</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">9</span>
  <span class="c1">// A pointer to `a5_by_ref`!</span>
  <span class="n">addi</span>    <span class="n">a5</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">addi</span>    <span class="n">a6</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">5</span>
  <span class="c1">// Note that `a7` is three</span>
  <span class="c1">// packed bytes!</span>
  <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="mi">289</span>
  <span class="n">addi</span>    <span class="n">a7</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">14</span>

  <span class="c1">// Store `21` on the top of</span>
  <span class="c1">// the stack (our "a8")</span>
  <span class="n">addi</span>    <span class="n">t0</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">21</span>
  <span class="n">sw</span>      <span class="n">t0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

  <span class="c1">// Store a pointer to</span>
  <span class="c1">// `stack_by_ref` on the </span>
  <span class="c1">// second spot from the</span>
  <span class="c1">// stack top (our "a9")</span>
  <span class="n">addi</span>    <span class="n">t0</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
  <span class="n">sw</span>      <span class="n">t0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

  <span class="c1">// Call it!</span>
  <span class="n">call</span>    <span class="n">all_the_args</span>

<span class="n">call_it</span><span class="p">.</span><span class="n">v</span><span class="o">:</span>
  <span class="c1">// The constant `{11, 13, 15}`.</span>
  <span class="p">.</span><span class="n">word</span>   <span class="mi">11</span>
  <span class="p">.</span><span class="n">word</span>   <span class="mi">13</span>
  <span class="p">.</span><span class="n">word</span>   <span class="mi">15</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">RISC-V Assembly</a></div></div> </div> <p><a href="#fnref:all-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:return-slot" role="doc-endnote"> <p>LLVM occasionally does somewhat clueless things around this corner of some ABIs. Given</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">p</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="p">}</span> <span class="n">X</span><span class="p">;</span>

<span class="n">X</span> <span class="nf">make_big</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span> </code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYyIsInNvdXJjZSI6 InR5cGVkZWYgc3RydWN0IHsgY2hhciBwWzEwMF07IH0gWDtcblxuICAgIFgg bWFrZV9iaWcoaW50IHgpIHtcbiAgICAgIHJldHVybiAoWCkge3h9O1xuICAg IH0gIiwiY29tcGlsZXJzIjpbeyJpZCI6InJ2MzItY2NsYW5nIiwib3B0aW9u cyI6Ii1PeiJ9XX1dfQ== ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:14">C</a></div></div> <p>we get the following from Clang:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// NOTE: Return slot passed in `a0`, `x` passed in `a1`.</span>
<span class="n">make_big</span><span class="o">:</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">mv</span>      <span class="n">s0</span><span class="p">,</span> <span class="n">a1</span>
        <span class="n">mv</span>      <span class="n">s1</span><span class="p">,</span> <span class="n">a0</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">addi</span>    <span class="n">a2</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">99</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">zero</span>
        <span class="n">call</span>    <span class="n">memset</span>
        <span class="n">sb</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">s1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">RISC-V Assembly</a></div></div> <p>Note that <code class="language-plaintext highlighter-rouge">sb s0, 0(s1)</code> stores the input value <code class="language-plaintext highlighter-rouge">x</code> into the first element of the big array <em>after</em> calling memset. If we move the store to before, we can avoid much silliness, including some unnecessary spills:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">make_big:</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sb</span>      <span class="n">a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">zero</span>
        <span class="n">addi</span>    <span class="n">a2</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">99</span>
        <span class="n">call</span>    <span class="n">memset</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">RISC-V Assembly</a></div></div> <p><a href="#fnref:return-slot" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2021-06-01 • 4898 words • 54 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#linkers">#linkers</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2021/06/01/linker-script/"> Everything You Never Wanted To Know About Linker Script </a></h1> </div> <div class="post"> <p>Low level software usually has lots of <code class="language-plaintext highlighter-rouge">.cc</code> or <code class="language-plaintext highlighter-rouge">.rs</code> files. Even lower-level software, like your cryptography library, probably has <code class="language-plaintext highlighter-rouge">.S</code> containing assembly, my least favorite language for code review.</p> <p>The lowest level software out there, firmware, kernels, and drivers, have one third file type to feed into the toolchain: an <code class="language-plaintext highlighter-rouge">.ld</code> file, a “linker script”. The linker script, provided to Clang as <code class="language-plaintext highlighter-rouge">-Wl,-T,foo.ld</code><sup id="fnref:linker-flag" role="doc-noteref"><a href="#fn:linker-flag" class="footnote" rel="footnote">1</a></sup>, is like a template for the final executable. It tells the linker how to organize code from the input objects. This permits extremely precise control over the toolchain’s output.</p> <p>Very few people know how to write linker script; it’s a bit of an obscure skill. Unfortunately, I’m one of them, so I get called to do it on occasion. Hopefully, this post is a good enough summary of the linker script language that you, too, can build your own binary!</p> <p>Everything in this post can be found in excruciating detail in <a href="https://sourceware.org/binutils/docs/ld/index.html">GNU <code class="language-plaintext highlighter-rouge">ld</code>’s documentation</a>; <code class="language-plaintext highlighter-rouge">lld</code> accepts basically the same syntax. There’s no spec, just what your linker happens to accept. I will, however, do my best to provide a more friendly introduction.</p> <p>No prior knowledge of how toolchains work is necessary! Where possible, I’ve tried to provide historical context on the names of everything. Toolchains are, unfortunately, bound by half a century of tradition. Better to at least know why they’re called that.</p> <blockquote id="aside:wait-an-s-file" class="aside"> <p><a href="#aside:wait-an-s-file"><span class="chip">aside</span><span class="title">Wait, an <code class="language-plaintext highlighter-rouge">.S</code> file?</span></a></p> <p>On Windows, assembly files use the sensible <code class="language-plaintext highlighter-rouge">.asm</code> extension. POSIX we use the <code class="language-plaintext highlighter-rouge">.s</code> extension, or <code class="language-plaintext highlighter-rouge">.S</code> when we’d like Clang to run the C preprocessor on them (virtually all hand-written assembly is of the second kind).</p> <p>I don’t actually have a historical citation<sup id="fnref:etymology-of-s" role="doc-noteref"><a href="#fn:etymology-of-s" class="footnote" rel="footnote">2</a></sup> for <code class="language-plaintext highlighter-rouge">.s</code>, other than that it came from the Unix tradition of obnoxiously terse names. If we are to believe that <code class="language-plaintext highlighter-rouge">.o</code> stands for “object”, and <code class="language-plaintext highlighter-rouge">.a</code> stands for “archive”, then <code class="language-plaintext highlighter-rouge">.s</code> must stand for “source”, up until the B compiler replaced them with <code class="language-plaintext highlighter-rouge">.b</code> files! See <a href="http://man.cat-v.org/unix-1st/1/b">http://man.cat-v.org/unix-1st/1/b</a>.</p> <p>A final bit of trivia: <code class="language-plaintext highlighter-rouge">.C</code> files are obviously different from <code class="language-plaintext highlighter-rouge">.c</code> files… they’re C++ files! (Seriously, try it.)</p> </blockquote> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>This post is specifically about POSIX. I know basically nothing about MSVC and <code class="language-plaintext highlighter-rouge">link.exe</code> other than that they exist. The most I’ve done is helped people debug trivial <code class="language-plaintext highlighter-rouge">__declspec</code> issues.</p> <p>I will also only be covering things specific to linking an executable; linking other outputs, like shared libraries, is beyond this post.</p> </blockquote> <h2 id="seriously-whats-a-linker"><a href="#seriously-whats-a-linker">Seriously, What’s a linker?</a></h2> <p>A linker is but a small part of a <em>toolchain</em>, the low-level programmer’s toolbox: everything you need to go from source code to execution.</p> <p>The crown jewel of any toolchain is the compiler. The LLVM toolchain, for example, includes Clang, a C/C++<sup id="fnref:clang-languages" role="doc-noteref"><a href="#fn:clang-languages" class="footnote" rel="footnote">3</a></sup> compiler. The compiler takes source code, such as <code class="language-plaintext highlighter-rouge">.cc</code>, and lowers it down to a <code class="language-plaintext highlighter-rouge">.s</code> file, an <em>assembly file</em> which textually describes machine code for a specific architecture (you can also write them yourself).</p> <p>Another toolchain program, the assembler, <em>assembles</em> each <code class="language-plaintext highlighter-rouge">.s</code> into a <code class="language-plaintext highlighter-rouge">.o</code> file, an <em>object file</em><sup id="fnref:object-what" role="doc-noteref"><a href="#fn:object-what" class="footnote" rel="footnote">4</a></sup>. An assembly file is merely a textual representation of an object file; assemblers are not particularly interesting programs.</p> <p>A third program, the linker, <em>links</em> all of your object files into a final <em>executable</em> or <em>binary</em>, traditionally given the name <code class="language-plaintext highlighter-rouge">a.out</code><sup id="fnref:aout" role="doc-noteref"><a href="#fn:aout" class="footnote" rel="footnote">5</a></sup>.</p> <p>This three (or two, if you do compile/assemble in one step) phase process is sometimes called the <em>C compilation model</em>. All modern software build infrastructure is built around this model<sup id="fnref:rust-objects" role="doc-noteref"><a href="#fn:rust-objects" class="footnote" rel="footnote">6</a></sup>.</p> <blockquote id="aside:even-more-stages" class="aside"> <p><a href="#aside:even-more-stages"><span class="chip">aside</span><span class="title">Even More Stages!</span></a></p> <p>Clang, being based on LLVM, actually exposes one stage in between the <code class="language-plaintext highlighter-rouge">.cc</code> file and the <code class="language-plaintext highlighter-rouge">.s</code> file. You can ask it to skip doing codegen and emit a <code class="language-plaintext highlighter-rouge">.ll</code> file filled with LLVM IR, an intermediate between human-writable source code and assembly. The magic words to get this file are <code class="language-plaintext highlighter-rouge">clang -S -emit-llvm</code>. (The Rust equivalent is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir</code>.)</p> <p>The LLVM toolchain provides <code class="language-plaintext highlighter-rouge">llc</code>, the LLVM compiler, which performs the <code class="language-plaintext highlighter-rouge">.ll</code> -&gt; <code class="language-plaintext highlighter-rouge">.s</code> step (optionally assembling it, too). <code class="language-plaintext highlighter-rouge">lli</code> is an interpreter for the IR. Studying IR is mostly useful for understanding optimization behavior; topic for another day.</p> </blockquote> <p>The compiler, assembler, and linker are the central components of a toolchain. Other languages, like Rust, usually provide their own toolchain, or just a compiler, reusing the existing C/C++ toolchain. The assembler and linker are language agnostic.</p> <p>The toolchain also provides various debugging tools, including an interactive debugger, and tools for manipulating object files, such as <code class="language-plaintext highlighter-rouge">nm</code>, <code class="language-plaintext highlighter-rouge">objdump</code>, <code class="language-plaintext highlighter-rouge">objcopy</code>, and <code class="language-plaintext highlighter-rouge">ar</code>.</p> <p>These days, most of this stuff is bundled into a single program, the compiler frontend, which knows how to compiler, assemble, and link, in one invocation. You can ask Clang to spit out <code class="language-plaintext highlighter-rouge">.o</code> files with <code class="language-plaintext highlighter-rouge">clang -c</code>, and <code class="language-plaintext highlighter-rouge">.s</code> files with <code class="language-plaintext highlighter-rouge">clang -S</code>.</p> <blockquote id="aside:trs-nms" class="aside"> <p><a href="#aside:trs-nms"><span class="chip">aside</span><span class="title">Trs Nms</span></a></p> <p>The UNIX crowd at Bell Labs was very excited about short, terse names. This tradition survives in Go’s somewhat questionable practice of single-letter variables.</p> <p>Most toolchain program names are cute contractions. <code class="language-plaintext highlighter-rouge">cc</code> is “C compiler”; compilers for almost all other languages follow this convention, like <code class="language-plaintext highlighter-rouge">rustc</code>, <code class="language-plaintext highlighter-rouge">javac</code>, <code class="language-plaintext highlighter-rouge">protoc</code>, and <code class="language-plaintext highlighter-rouge">scalac</code>; Clang is just <code class="language-plaintext highlighter-rouge">clang</code>, but is perfectly ok being called as <code class="language-plaintext highlighter-rouge">cc</code>.</p> <p><code class="language-plaintext highlighter-rouge">as</code> is “assembler”; <code class="language-plaintext highlighter-rouge">ld</code> is “loader” (you’ll learn why sooner). <code class="language-plaintext highlighter-rouge">ar</code> is “archiver”, <code class="language-plaintext highlighter-rouge">nm</code> is “names”. Other names tend to be a bit more sensible.</p> </blockquote> <h3 id="final-link"><a href="#final-link">Final Link</a></h3> <p>Some fifty years ago at Bell Labs, someone really wanted to write a program with more than one <code class="language-plaintext highlighter-rouge">.s</code> file. To solve this, a program that could “link” symbol references across object files was written: the first linker.</p> <p>You can take several <code class="language-plaintext highlighter-rouge">.o</code> files and use <code class="language-plaintext highlighter-rouge">ar</code> (an archaic <code class="language-plaintext highlighter-rouge">tar</code>, basically) to create a library, which always have names like <code class="language-plaintext highlighter-rouge">libfoo.a</code> (the <code class="language-plaintext highlighter-rouge">lib</code> is mandatory). A static library is just a collection of objects, which can be provided on an as-needed basis to the linker.</p> <p>The “final link” incorporates several <code class="language-plaintext highlighter-rouge">.o</code> files and <code class="language-plaintext highlighter-rouge">.a</code> files to produce an executable. It does roughly the following:</p> <ol> <li>Parse all the objects and static libraries and put their <em>symbols</em> into a database. Symbols are named addresses of functions and global variables.</li> <li>Search for all unresolved symbol references in the <code class="language-plaintext highlighter-rouge">.o</code> files and match it up with a symbol from the database, recursively doing this for any code in a <code class="language-plaintext highlighter-rouge">.a</code> referenced during this process. This forms a sort of dependency graph between sections. This step is called <em>symbol resolution</em>.</li> <li>Throw out any code that isn’t referenced by the input files by tracing the dependency graph from the entry-point symbol (e.g., <code class="language-plaintext highlighter-rouge">_start</code> on Linux). This step is called <em>garbage collection</em>.</li> <li>Execute the linker script to figure out how to stitch the final binary together. This includes discovering the offsets at which everything will go.</li> <li>Resolve <em>relocations</em>, “holes” in the binary that require knowing the final runtime address of the section. Relocations are instructions placed in the object file for the linker to execute.</li> <li>Write out the completed binary.</li> </ol> <p>This process is extremely memory-intensive; it is possible for colossal binaries, especially ones with tons of debug information, to “fail to link” because the linker exhausts the system’s memory.</p> <p>We only care about step 4; whole books can be written about the previous steps. Thankfully, Ian Lance Taylor, mad linker scientist and author of <code class="language-plaintext highlighter-rouge">gold</code>, has written several excellent words on this topic: <a href="https://lwn.net/Articles/276782/">https://lwn.net/Articles/276782/</a>.</p> <h2 id="object-files-and-sections"><a href="#object-files-and-sections">Object Files and Sections</a></h2> <p>Linkers, fundamentally, consume object files and produce object files; the output is executable, meaning that all relocations have been resolved and an entry-point address (where the OS/bootloader will jump to to start the binary).</p> <p>It’s useful to be able to peek into object files. The <code class="language-plaintext highlighter-rouge">objdump</code> utility is best for this. <code class="language-plaintext highlighter-rouge">objdump -x my_object.o</code> will show <em>all</em> headers, telling you what exactly is in it.</p> <p>At a high level, an object file describes how a program should be loaded into memory. The object is divided into sections, which are named blocks of data. Sections may have file-like permissions, such as allocatable, loadable, readonly, and executable. <code class="language-plaintext highlighter-rouge">objdump -h</code> can be used to show the list of sections. Some selected lines of output from <code class="language-plaintext highlighter-rouge">objdump</code> on my machine (I’m on a 64-bit machine, but I’ve trimmed leading zeros to make it all fit):</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-terminal" data-lang="terminal"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-h</span> <span class="s2">"</span><span class="si">$(</span>which clang<span class="si">)</span><span class="s2">"</span>
<span class="go">/usr/bin/clang:     file format elf64-x86-64

Sections:
Idx Name    Size      VMA       LMA       File off  Algn
 11 .init   00000017  00691ab8  00691ab8  00291ab8  2**2
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt    00006bb0  00691ad0  00691ad0  00291ad0  2**4
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text   0165e861  00698680  00698680  00298680  2**4
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini   00000009  01cf6ee4  01cf6ee4  018f6ee4  2**2
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata 0018ec68  01cf6ef0  01cf6ef0  018f6ef0  2**4
            CONTENTS, ALLOC, LOAD, READONLY, DATA
 24 .data   000024e8  021cd5d0  021cd5d0  01dcc5d0  2**4
            CONTENTS, ALLOC, LOAD, DATA
 26 .bss    00009d21  021cfac0  021cfac0  01dceab8  2**4
            ALLOC</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">Terminal</a></div></div> <p>Allocateable (<code class="language-plaintext highlighter-rouge">ALLOC</code>) sections must be <em>allocated</em> space by the operating system; if the section is loadable (<code class="language-plaintext highlighter-rouge">LOAD</code>), then the operating system must further fill that space with the contents of the section. This process is called <em>loading</em> and is performed by a <em>loader</em> program<sup id="fnref:bare-metal-loading" role="doc-noteref"><a href="#fn:bare-metal-loading" class="footnote" rel="footnote">7</a></sup>. The loader is sometimes called the “dynamic linker”, and is often the same program as the “program linker”; this is why the linker is called <code class="language-plaintext highlighter-rouge">ld</code>.</p> <p>Loading can also be done beforehand using the <code class="language-plaintext highlighter-rouge">binary</code> output format. This is useful for tiny microcontrollers that are too primitive to perform any loading. <code class="language-plaintext highlighter-rouge">objcopy</code> is useful for this and many other tasks that involve transforming object files.</p> <p>Some common (POSIX) sections include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">.text</code>, where your code lives<sup id="fnref:text-section" role="doc-noteref"><a href="#fn:text-section" class="footnote" rel="footnote">8</a></sup>. It’s usually a loadable, readonly, executable section.</li> <li><code class="language-plaintext highlighter-rouge">.data</code> contains the initial values of global variables. It’s loadable.</li> <li><code class="language-plaintext highlighter-rouge">.rodata</code> contains constants. It’s loadable and readonly.</li> <li><code class="language-plaintext highlighter-rouge">.bss</code> is an empty allocatable section<sup id="fnref:bss-section" role="doc-noteref"><a href="#fn:bss-section" class="footnote" rel="footnote">9</a></sup>. C specifies that uninitialized globals default to zero; this is a convenient way for avoiding storing a huge block of zeros in the executable!</li> <li>Debug sections that are not loaded or allocated; these are usually removed for release builds.</li> </ul> <p>After the linker decides which sections from the <code class="language-plaintext highlighter-rouge">.o</code> and <code class="language-plaintext highlighter-rouge">.a</code> inputs to keep (based on which symbols it decided it needed), it looks to the linker script how to arrange them in the output.</p> <p>Let’s write our first linker script!</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="cm">/* Define an output section ".text". */</span>
  <span class="p">.</span><span class="n">text</span> <span class="o">:</span> <span class="p">{</span>
    <span class="cm">/* Pull in all symbols in input sections named .text */</span>
    <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">)</span>
    <span class="cm">/* Do the same for sections starting with .text.,
       such as .text.foo */</span>
    <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">.</span><span class="o">*</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="cm">/* Do the same for ".bss", ".rodata", and ".data". */</span>
  <span class="p">.</span><span class="n">bss</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">);</span> <span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">data</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">);</span> <span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">rodata</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">rodata</span><span class="p">);</span> <span class="o">*</span><span class="p">(.</span><span class="n">rodata</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Linker Script</a></div></div> <p>This tells the linker to create a <code class="language-plaintext highlighter-rouge">.text</code> section in the output, which contains all sections named <code class="language-plaintext highlighter-rouge">.text</code> from all inputs, plus all sections with names like <code class="language-plaintext highlighter-rouge">.text.foo</code>. The content of the section is laid out in order: the contents of all <code class="language-plaintext highlighter-rouge">.text</code> sections will come before any <code class="language-plaintext highlighter-rouge">.text.*</code> sections; I don’t think the linker makes any promises about the ordering between different objects<sup id="fnref:order-sorting" role="doc-noteref"><a href="#fn:order-sorting" class="footnote" rel="footnote">10</a></sup>.</p> <p>As I mentioned before, parsers for linker script are fussy<sup id="fnref:comment-syntax" role="doc-noteref"><a href="#fn:comment-syntax" class="footnote" rel="footnote">11</a></sup>: the space in <code class="language-plaintext highlighter-rouge">.text :</code> is significant.</p> <p>Note that the two <code class="language-plaintext highlighter-rouge">.text</code> sections are different, and can have different names! The linker generally doesn’t care what a section is named; just its attributes. We could name it <code class="language-plaintext highlighter-rouge">code</code> if we wanted to; even the leading period is mere convention. Some object file formats don’t support arbitrary sections; all the sane ones (ELF, COFF, Mach-O) don’t care, but they don’t all spell it the same way; in Mach-O, you call it <code class="language-plaintext highlighter-rouge">__text</code>.</p> <p>Before continuing, I recommend looking at the <a href="#appendix">appendix</a> so that you have a clear path towards being able to run and test your linker scripts!</p> <blockquote id="aside:input-section-syntax" class="aside"> <p><a href="#aside:input-section-syntax"><span class="chip">aside</span><span class="title">Input Section Syntax</span></a></p> <p>None of this syntax is used in practice but it’s useful to contextualize the syntax for pulling in a section. The full form of the syntax is</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-text" data-lang="text">&gt; archive:object(section1 section2 ...)</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Plaintext</a></div></div> <p>Naturally, all of this is optional, so you can write <code class="language-plaintext highlighter-rouge">foo.o</code> or <code class="language-plaintext highlighter-rouge">libbar.a:(.text)</code> or <code class="language-plaintext highlighter-rouge">:baz.o(.text .data)</code>, where the last one means “not part of a library”. There’s even an <code class="language-plaintext highlighter-rouge">EXCLUDE_FILE</code> syntax for filtering by source object, and a <code class="language-plaintext highlighter-rouge">INPUT_SECTION_FLAGS</code> syntax for filtering by the presence of format-specific flags.</p> <p>Do not use any of this. Just write <code class="language-plaintext highlighter-rouge">*(.text)</code> and don’t think about it too hard. The <code class="language-plaintext highlighter-rouge">*</code> is just a glob for all objects.</p> </blockquote> <p>Each section has an <em>alignment</em>, which is just the maximum of the alignments of all input sections pulled into it. This is important for ensuring that code and globals are aligned the way the architecture expects them to be. The alignment of a section can be set explicitly with</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">super_aligned</span> <span class="o">:</span> <span class="n">ALIGN</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Linker Script</a></div></div> <p>You can also instruct the linker to toss out sections using the special <code class="language-plaintext highlighter-rouge">/DISCARD/</code> output section, which overrides any decisions made at garbage-collection time. I’ve only ever used this to discard debug information that GCC was really excited about keeping around.</p> <p>On the other hand, you can use <code class="language-plaintext highlighter-rouge">KEEP(*(.text.*))</code> to ensure no <code class="language-plaintext highlighter-rouge">.text</code> sections are discarded by garbage-collection. Unfortunately, this doesn’t let you pull in sections from static libraries that weren’t referenced in the input objects.</p> <h3 id="lma-and-vma"><a href="#lma-and-vma">LMA and VMA</a></h3> <p>Every section has three addresses associated with it. The simplest is the file offset: how far from the start of the file to find the section.</p> <p>The <em>virtual memory address</em>, or VMA, is where the program expects to find the section at runtime. This is the address that is used by pointers and the program counter.</p> <p>The <em>load memory address</em>, or LMA, is where the loader (be it a runtime loader or <code class="language-plaintext highlighter-rouge">objcpy</code>) must place the code. This is almost always the same as the VMA. Later on, in <a href="#rom-ram-lma">Using Symbols and LMAs</a>, I’ll explain a place where this is actually useful.</p> <p>When declaring a new section, the VMA and LMA are both set to the value<sup id="fnref:dot-align" role="doc-noteref"><a href="#fn:dot-align" class="footnote" rel="footnote">12</a></sup> of the <em>location counter</em>, which has the <em>extremely</em> descriptive name <code class="language-plaintext highlighter-rouge">.</code><sup id="fnref:dot-in-asm" role="doc-noteref"><a href="#fn:dot-in-asm" class="footnote" rel="footnote">13</a></sup>. This counter is automatically incremented as data is copied from the input</p> <p>We can explicitly specify the VMA of a section by putting an expression before the colon, and the LMA by putting an expression in the <code class="language-plaintext highlighter-rouge">AT(lma)</code> specifier <em>after</em> the colon:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">text</span> <span class="mh">0x10008000</span><span class="o">:</span> <span class="n">AT</span><span class="p">(</span><span class="mh">0x40008000</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Linker Script</a></div></div> <p>This will modify the location counter; you could also write it as</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span> <span class="o">=</span> <span class="mh">0x10008000</span><span class="p">;</span>
  <span class="p">.</span><span class="n">text</span> <span class="o">:</span> <span class="n">AT</span><span class="p">(</span><span class="mh">0x40008000</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Linker Script</a></div></div> <p>Within <code class="language-plaintext highlighter-rouge">SECTIONS</code>, the location counter can be set at any point, even while in the middle of declaring a section (though the linker will probably complain if you do something rude like move it backwards).</p> <p>The location counter is incremented automatically as sections are added, so it’s rarely necessary to fuss with it directly.</p> <h2 id="memory-regions-and-section-allocation"><a href="#memory-regions-and-section-allocation">Memory Regions and Section Allocation</a></h2> <p>By default, the linker will simply allocate sections starting at address <code class="language-plaintext highlighter-rouge">0</code>. The <code class="language-plaintext highlighter-rouge">MEMORY</code> statement can be used to define <em>memory regions</em> for more finely controlling how VMAs and LMAs are allocated without writing them down explicitly.</p> <p>A classic example of a <code class="language-plaintext highlighter-rouge">MEMORY</code> block separates the address space into ROM and RAM:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">MEMORY</span> <span class="p">{</span>
  <span class="n">rom</span> <span class="p">(</span><span class="n">rx</span><span class="p">)</span>   <span class="o">:</span> <span class="n">ORIGIN</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>     <span class="n">LENGTH</span> <span class="o">=</span> <span class="mi">16</span><span class="n">K</span>
  <span class="n">ram</span> <span class="p">(</span><span class="n">rw</span><span class="o">!</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">ORIGIN</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span> <span class="n">LENGTH</span> <span class="o">=</span> <span class="mi">256</span><span class="n">M</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Linker Script</a></div></div> <p>A region is a block of memory with a name and some attributes. The name is irrelevant beyond the scope of the linker script. The attributes in parens are used to specify what sections could conceivably go in that region. A section is compatible if it has any of the attributes before the <code class="language-plaintext highlighter-rouge">!</code>, and none which come after the <code class="language-plaintext highlighter-rouge">!</code>. (This filter mini-language isn’t very expressive.)</p> <p>The attributes are the ones we mentioned earlier: <code class="language-plaintext highlighter-rouge">rwxal</code> are readonly, read/write, executable, allocated, and loadable<sup id="fnref:attrs-in-asm" role="doc-noteref"><a href="#fn:attrs-in-asm" class="footnote" rel="footnote">14</a></sup>.</p> <p>When allocating a section a VMA, the linker will try to pick the best memory region that matches the filter using a heuristic. I don’t really trust the heuristic, but you can instead write <code class="language-plaintext highlighter-rouge">&gt; region</code> to put something into a specific region. Thus,</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTION</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">data</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span> <span class="o">&gt;</span> <span class="n">ram</span> <span class="n">AT</span><span class="o">&gt;</span> <span class="n">rom</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Linker Script</a></div></div> <p><code class="language-plaintext highlighter-rouge">AT&gt;</code> is the “obvious” of <code class="language-plaintext highlighter-rouge">AT()</code> and <code class="language-plaintext highlighter-rouge">&gt;</code>, and sets which region to allocate the LMA from.</p> <p>The origin and length of a region can be obtained with the <code class="language-plaintext highlighter-rouge">ORIGIN(region)</code> and <code class="language-plaintext highlighter-rouge">LENGTH(region)</code> functions.</p> <h2 id="other-stuff-to-put-in-sections"><a href="#other-stuff-to-put-in-sections">Other Stuff to Put In Sections</a></h2> <p>Output sections can hold more than just input sections. Arbitrary data can be placed into sections using the <code class="language-plaintext highlighter-rouge">BYTE</code>, <code class="language-plaintext highlighter-rouge">SHORT</code>, <code class="language-plaintext highlighter-rouge">LONG</code> and <code class="language-plaintext highlighter-rouge">QUAD</code> for placing literal 8, 16, 32, and 64-bit unsigned integers into the section:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">screams_internally</span> <span class="o">:</span> <span class="p">{</span> <span class="n">LONG</span><span class="p">(</span><span class="mh">0xaaaaaaaa</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Linker Script</a></div></div> <p>Numeric literals in linker script may, conveniently, be given the suffixes <code class="language-plaintext highlighter-rouge">K</code> or <code class="language-plaintext highlighter-rouge">M</code> to specify a kilobyte or megabyte quantity. E.g., <code class="language-plaintext highlighter-rouge">4K</code> is sugar for <code class="language-plaintext highlighter-rouge">4096</code>.</p> <h3 id="fill"><a href="#fill">Fill</a></h3> <p>You can fill the unused portions of a section by using the <code class="language-plaintext highlighter-rouge">FILL</code> command, which sets the “fill pattern” from that point onward. For example, we can create four kilobytes of <code class="language-plaintext highlighter-rouge">0xaa</code> using <code class="language-plaintext highlighter-rouge">FILL</code> and the location counter:</p> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">scream_page</span> <span class="o">:</span> <span class="p">{</span>
    <span class="n">FILL</span><span class="p">(</span><span class="mh">0xaa</span><span class="p">)</span>
    <span class="p">.</span> <span class="o">+=</span> <span class="mi">4</span><span class="n">K</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">Linker Script</a></div></div> <p>The “fill pattern” is used to fill any unspecified space, such as alignment padding or jumping around with the location counter. We can use multiple FILLs to vary the fill pattern, such as if we wanted half the page to be <code class="language-plaintext highlighter-rouge">0x0a</code> and half <code class="language-plaintext highlighter-rouge">0xa0</code>:</p> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">scream_page</span> <span class="o">:</span> <span class="p">{</span>
    <span class="n">FILL</span><span class="p">(</span><span class="mh">0x0a</span><span class="p">)</span>
    <span class="p">.</span> <span class="o">+=</span> <span class="mi">2</span><span class="n">K</span><span class="p">;</span>
    <span class="n">FILL</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">)</span>
    <span class="p">.</span> <span class="o">+=</span> <span class="mi">2</span><span class="n">K</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">Linker Script</a></div></div> <p>When using one fill pattern for the whole section, you can just write <code class="language-plaintext highlighter-rouge">= fill;</code> at the end of the section. For example,</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">scream_page</span> <span class="o">:</span> <span class="p">{</span>
    <span class="p">.</span> <span class="o">+=</span> <span class="mi">4</span><span class="n">K</span><span class="p">;</span>
  <span class="p">}</span> <span class="o">=</span> <span class="mh">0xaa</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Linker Script</a></div></div> <h3 id="linker-symbols"><a href="#linker-symbols">Linker Symbols</a></h3> <p>Although the linker needs to resolve all symbols using the input <code class="language-plaintext highlighter-rouge">.o</code> and <code class="language-plaintext highlighter-rouge">.a</code> files, you can also declare symbols directly in linker script; this is the absolute latest that symbols can be provided. For example:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="n">my_cool_symbol</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Linker Script</a></div></div> <p>This will define a new symbol with value <code class="language-plaintext highlighter-rouge">5</code>. If we then wrote <code class="language-plaintext highlighter-rouge">extern char my_cool_symbol;</code>, we can access the value placed by the linker. However, note that the value of a symbol is an <em>address</em>! If you did</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">extern</span> <span class="kt">char</span> <span class="n">my_cool_symbol</span><span class="p">;</span>

<span class="kt">uintptr_t</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">my_cool_symbol</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">C</a></div></div> <p>the processor would be very confused about why you just dereferenced a pointer with address <code class="language-plaintext highlighter-rouge">5</code>. The <em>correct</em> way to extract a linker symbol’s value is to write</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">extern</span> <span class="kt">char</span> <span class="n">my_cool_symbol</span><span class="p">;</span>

<span class="kt">uintptr_t</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">my_cool_symbol</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">C</a></div></div> <p>It seems a bit silly to take the address of the global and use that as some kind of magic value, but that’s just how it works. The exact same mechanism works in Rust, too:</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">get</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="nd">#[link_name</span> <span class="nd">=</span> <span class="s">"my_cool_symbol"</span><span class="nd">]</span>
    <span class="k">static</span> <span class="n">SYM</span><span class="p">:</span> <span class="nb">u8</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">addr_of!</span><span class="p">(</span><span class="n">SYM</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Rust</a></div></div> <p>The most common use of this mechanism is percolating information not known until link time. For example, a common idiom is</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">text</span> <span class="o">:</span> <span class="p">{</span>
    <span class="n">__text_start</span> <span class="o">=</span> <span class="p">.;</span>
    <span class="cm">/* stuff */</span>
    <span class="n">__text_end</span> <span class="o">=</span> <span class="p">.;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">Linker Script</a></div></div> <p>This allows initialization code to find the section’s address and length; in this case, the pointer values are actually meaningful!</p> <blockquote id="aside:wunderbars" class="aside"> <p><a href="#aside:wunderbars"><span class="chip">aside</span><span class="title">Wunderbars</span></a></p> <p>It’s common practice to lead linker symbols with two underscores, because C declares a surprisingly large class of symbols reserved for the implementation, so normal user code won’t call them. These include names like <code class="language-plaintext highlighter-rouge">__text_start</code>, which start with two underscores, and names starting with an underscore and an uppercase letter, like <code class="language-plaintext highlighter-rouge">_Atomic</code>.</p> <p>However, libc and STL headers will totally use the double underscore symbols to make them resistant to tampering by users (which they are entitled to), so beware!</p> </blockquote> <p>Symbol assignments can even go inside of a section, to capture the location counter’s value between input sections:</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">text</span> <span class="o">:</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">)</span>
    <span class="n">text_middle</span> <span class="o">=</span> <span class="p">.;</span>
    <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">.</span><span class="o">*</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Linker Script</a></div></div> <p>Symbol names are not limited to C identifiers, and may contain dashes, periods, dollar signs, and other symbols. They may even be quoted, like <code class="language-plaintext highlighter-rouge">"this symbol has spaces"</code>, which C will never be able to access as an <code class="language-plaintext highlighter-rouge">extern</code>.</p> <p>There is a mini-language of expressions that symbols can be assigned to. This includes:</p> <ul> <li>Numeric literals like <code class="language-plaintext highlighter-rouge">42</code>, <code class="language-plaintext highlighter-rouge">0xaa</code>, and <code class="language-plaintext highlighter-rouge">4K</code>.</li> <li>The location counter, <code class="language-plaintext highlighter-rouge">.</code>.</li> <li>Other symbols.</li> <li>The usual set of C operators, such as arithmetic and bit operations. Xor is curiously missing.</li> <li>A handful of builtin functions, described below.</li> </ul> <p>There are some fairly complicated rules around how symbols may be given relative addresses to the start of a section, which are only relevant when dealing with position-independent code: <a href="https://sourceware.org/binutils/docs/ld/Expression-Section.html">https://sourceware.org/binutils/docs/ld/Expression-Section.html</a></p> <p>Functions belong to one of two board categories: getters for properties of sections, memory regions, and other linker structures; and arithmetic. Useful functions include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">ADDR</code>, <code class="language-plaintext highlighter-rouge">LOADADDR</code>, <code class="language-plaintext highlighter-rouge">SIZEOF</code>, and <code class="language-plaintext highlighter-rouge">ALIGNOF</code>, which produce the VMA, LMA, size, and alignment of a previously defined section.</li> <li><code class="language-plaintext highlighter-rouge">ORIGIN</code> and <code class="language-plaintext highlighter-rouge">LENGTH</code>, which produce the start address and length of a memory region.</li> <li><code class="language-plaintext highlighter-rouge">MAX</code>, <code class="language-plaintext highlighter-rouge">MIN</code> are obvious; <code class="language-plaintext highlighter-rouge">LOG2CEIL</code> computes the base-2 log, rounded up.</li> <li><code class="language-plaintext highlighter-rouge">ALIGN(expr, align)</code> rounds <code class="language-plaintext highlighter-rouge">expr</code> to the next multiple of <code class="language-plaintext highlighter-rouge">align</code>. <code class="language-plaintext highlighter-rouge">ALIGN(align)</code> is roughly equivalent to <code class="language-plaintext highlighter-rouge">ALIGN(., align)</code> with some subtleties around PIC. <code class="language-plaintext highlighter-rouge">. = ALIGN(align);</code> will align the location counter to <code class="language-plaintext highlighter-rouge">align</code>.</li> </ul> <p>Some other builtins can be found at <a href="https://sourceware.org/binutils/docs/ld/Builtin-Functions.html">https://sourceware.org/binutils/docs/ld/Builtin-Functions.html</a>.</p> <p>A symbol definition can be wrapped in the <code class="language-plaintext highlighter-rouge">PROVIDEO()</code> function to make it “weak”, analogous to the “weak symbol” feature found in Clang. This means that the linker will not use the definition if any input object defines it.</p> <h3 id="rom-ram-lma"><a href="#rom-ram-lma">Using Symbols and LMAs</a></h3> <p>As mentioned before, it is extremely rare for the LMA and VMA to be different. The most common situation where this occurs is when you’re running on a system, like a microcontroller, where memory is partitioned into two pieces: ROM and RAM. The ROM has the executable burned into it, and RAM starts out full of random garbage.</p> <p>Most of the contents of the linked executable are read-only, so their VMA can be in ROM. However, the <code class="language-plaintext highlighter-rouge">.data</code> and <code class="language-plaintext highlighter-rouge">.bss</code> sections need to lie in RAM, because they’re writable. For <code class="language-plaintext highlighter-rouge">.bss</code> this is easy, because it doesn’t have loadable content. For <code class="language-plaintext highlighter-rouge">.data</code>, though, we need to separate the VMA and LMA: the VMA must go in RAM, and the LMA in ROM.</p> <p>This distinction is important for the code that initializes the RAM: while for <code class="language-plaintext highlighter-rouge">.bss</code> all it has to do is zero it, for <code class="language-plaintext highlighter-rouge">.data</code>, it has to copy from ROM to RAM! The LMA lets us distinguish the copy source and the copy destination.</p> <p>This has the important property that it tells the loader (usually <code class="language-plaintext highlighter-rouge">objcopy</code> in this case) to use the ROM addresses for actually loading the section to, but to link the code as if it were at a RAM address (which is needed for things like PC-relative loads to work correctly).</p> <p>Here’s how we’d do it in linker script:</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">MEMORY</span> <span class="p">{</span>
  <span class="n">rom</span> <span class="o">:</span> <span class="cm">/* ... */</span>
  <span class="n">ram</span> <span class="o">:</span> <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="cm">/* .text and .rodata just go straight into the ROM. We don't need
     to mutate them ever. */</span>
  <span class="p">.</span><span class="n">text</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">)</span> <span class="p">}</span> <span class="o">&gt;</span> <span class="n">rom</span>
  <span class="p">.</span><span class="n">rodata</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">rodata</span><span class="p">)</span> <span class="p">}</span> <span class="o">&gt;</span> <span class="n">rom</span>

  <span class="cm">/* .bss doesn't have any "loadable" content, so it goes straight
     into RAM. We could include `AT&gt; rom`, but because the sections
     have no content, it doesn't matter. */</span>
  <span class="p">.</span><span class="n">bss</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">)</span> <span class="p">}</span> <span class="o">&gt;</span> <span class="n">ram</span>

  <span class="cm">/* As described above, we need to get a RAM VMA but a ROM LMA;
     the &gt; and AT&gt; operators achieve this. */</span>
  <span class="p">.</span><span class="n">data</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span> <span class="o">&gt;</span> <span class="n">ram</span> <span class="n">AT</span><span class="o">&gt;</span> <span class="n">rom</span>
<span class="p">}</span>

<span class="cm">/* The initialization code will need some symbols to know how to
   zero the .bss and copy the initial .data values. We can use the
   functions from the previous section for this! */</span>

<span class="n">bss_start</span> <span class="o">=</span> <span class="n">ADDR</span><span class="p">(.</span><span class="n">bss</span><span class="p">);</span>
<span class="n">bss_end</span> <span class="o">=</span> <span class="n">bss_start</span> <span class="o">+</span> <span class="n">SIZEOF</span><span class="p">(.</span><span class="n">bss</span><span class="p">);</span>

<span class="n">data_start</span> <span class="o">=</span> <span class="n">ADDR</span><span class="p">(.</span><span class="n">data</span><span class="p">);</span>
<span class="n">data_end</span> <span class="o">=</span> <span class="n">data_start</span> <span class="o">+</span> <span class="n">SIZEOF</span><span class="p">(.</span><span class="n">data</span><span class="p">);</span>

<span class="n">rom_data_start</span> <span class="o">=</span> <span class="n">LOADADDR</span><span class="p">(.</span><span class="n">data</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">Linker Script</a></div></div> <p>Although we would normally write the initialization code in assembly (since it’s undefined behavior to execute C before initializing the <code class="language-plaintext highlighter-rouge">.bss</code> and <code class="language-plaintext highlighter-rouge">.data</code> sections), I’ve written it in C for illustrative purposes:</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">bss_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">bss_end</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">data_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">data_end</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">rom_data_start</span><span class="p">[];</span>

<span class="kt">void</span> <span class="nf">init_sections</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Zero the .bss.</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">bss_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bss_end</span> <span class="o">-</span> <span class="n">bss_start</span><span class="p">);</span>

  <span class="c1">// Copy the .data values from ROM to RAM.</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">data_start</span><span class="p">,</span> <span class="n">rom_data_start</span><span class="p">,</span> <span class="n">data_end</span> <span class="o">-</span> <span class="n">data_start</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">C</a></div></div> <h2 id="misc-linker-script-features"><a href="#misc-linker-script-features">Misc Linker Script Features</a></h2> <p>Linker script includes a bunch of other commands that don’t fit into a specific category:</p> <ul> <li><code class="language-plaintext highlighter-rouge">ENTRY()</code> sets the program entry-point, either as a symbol or a raw address. The <code class="language-plaintext highlighter-rouge">-e</code> flag can be used to override it. The <code class="language-plaintext highlighter-rouge">ld</code> docs assert that there are fallbacks if an entry-point can’t be found, but in my experience you can sometimes get errors here. <code class="language-plaintext highlighter-rouge">ENTRY(_start)</code> would use the <code class="language-plaintext highlighter-rouge">_start</code> symbol, for example<sup id="fnref:not-main" role="doc-noteref"><a href="#fn:not-main" class="footnote" rel="footnote">15</a></sup>.</li> <li><code class="language-plaintext highlighter-rouge">INCLUDE "path/to/file.ld"</code> is <code class="language-plaintext highlighter-rouge">#include</code> but for linker script.</li> <li><code class="language-plaintext highlighter-rouge">INPUT(foo.o)</code> will add <code class="language-plaintext highlighter-rouge">foo.o</code> as a linker input, as if it was passed at the commandline. <code class="language-plaintext highlighter-rouge">GROUP</code> is similar, but with the semantics of <code class="language-plaintext highlighter-rouge">--start-group</code>.</li> <li><code class="language-plaintext highlighter-rouge">OUTPUT()</code> overrides the usual <code class="language-plaintext highlighter-rouge">a.out</code> default output name.</li> <li><code class="language-plaintext highlighter-rouge">ASSERT()</code> provides static assertions.</li> <li><code class="language-plaintext highlighter-rouge">EXTERN(sym)</code> causes the linker to behave as if an undefined reference to <code class="language-plaintext highlighter-rouge">sym</code> existed in an input object.</li> </ul> <p>(Other commands are documented, but I’ve never needed them in practice.)</p> <h2 id="real-linker-scripts"><a href="#real-linker-scripts">Real Linker Scripts</a></h2> <p>It may be useful to look at some real-life linker scripts.</p> <p>If you wanna see what Clang, Rust, and the like all ultimately use, run <code class="language-plaintext highlighter-rouge">ld --verbose</code>. This will print the default linker script for your machine; this is a really intense script that uses basically every feature available in linker script (and, since it’s GNU, is very poorly formatted).</p> <p>The Linux kernel also has linker scripts, which are differently intense, because they use the C preprocessor. For example, the one for amd64: <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S">https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S</a>.</p> <p>Tock OS, a secure operating system written in Rust, has some pretty solid linker scripts, with lots of comments: <a href="https://github.com/tock/tock/blob/master/boards/kernel_layout.ld">https://github.com/tock/tock/blob/master/boards/kernel_layout.ld</a>. I recommend taking a look to see what a “real” but not too wild linker script looks like. There’s a fair bit of toolchain-specific stuff in there, too, that should give you an idea of what to expect.</p> <p>Happy linking!</p> <hr/> <h2 id="appendix"><a href="#appendix">Appendix: A Linker Playground</a></h2> <p>tl;dr: If you don’t wanna try out any examples, skip this section.</p> <p>I want you to be able to try out the examples above, but there’s no Godbolt for linker scripts (yet!). Unlike normal code, you can’t just run linker script through a compiler, you’re gonna need some objects to link, too! Let’s set up a very small C project for testing your linker scripts.</p> <blockquote id="note:2" class="note"> <p><a href="#note:2"><span class="chip">note</span></a></p> <p>I’m assuming you’re on Linux, with x86_64, and using Clang. If you’re on a Mac (even M1), you can probably make <code class="language-plaintext highlighter-rouge">ld64</code> do the right thing, but this is outside of what I’m an expert on.</p> <p>If you’re on Windows, use WSL. I have no idea how MSCV does linker scripts at all.</p> </blockquote> <p>First, we want a very simple static library:</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">lib_call</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Discard `str`, we just want to take any argument.</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">str</span><span class="p">;</span>

  <span class="c1">// This will go in `.bss`.</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYyIsInNvdXJjZSI6 ImludCBsaWJfY2FsbChjb25zdCBjaGFyKiBzdHIpIHtcbiAgLy8gRGlzY2Fy ZCBgc3RyYCwgd2UganVzdCB3YW50IHRvIHRha2UgYW55IGFyZ3VtZW50Llxu ICAodm9pZClzdHI7XG5cbiAgLy8gVGhpcyB3aWxsIGdvIGluIGAuYnNzYC5c biAgc3RhdGljIGludCBjb3VudDtcbiAgcmV0dXJuIGNvdW50Kys7XG59Iiwi Y29tcGlsZXJzIjpbeyJpZCI6ImNjbGFuZ190cnVuayIsIm9wdGlvbnMiOiIi fV19XX0=">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:23">extern.c</a></div></div> <p>Compile <code class="language-plaintext highlighter-rouge">extern.c</code> into a static library like so:</p> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-shell" data-lang="shell">clang <span class="nt">-c</span> extern.c
ar rc libextern.a extern.o</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">Shell</a></div></div> <p>We can check out that we got something reasonable by using <code class="language-plaintext highlighter-rouge">nm</code>. The <code class="language-plaintext highlighter-rouge">nm</code> program shows you all the symbols a library or object defines.</p> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-terminal" data-lang="terminal"><span class="gp">$</span><span class="w"> </span>nm libextern.a
<span class="go">extern.o:
0000000000000000 T lib_call
0000000000000000 b lib_call.count</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:25">Terminal</a></div></div> <p>This shows us the address, section type, and name of each symbol; <code class="language-plaintext highlighter-rouge">man nm</code> tells us that <code class="language-plaintext highlighter-rouge">T</code> means <code class="language-plaintext highlighter-rouge">.text</code> and <code class="language-plaintext highlighter-rouge">b</code> means <code class="language-plaintext highlighter-rouge">.bss</code>. Capital letters mean that the symbol is <em>exported</em>, so the linker can use it to resolve a symbol reference or a relocation. In C/C++, symbols declared <code class="language-plaintext highlighter-rouge">static</code> or in an unnamed namespace are “hidden”, and can’t be referenced outside of the object. This is sometimes called internal vs external linkage.</p> <p>Next, we need a C program that uses the library:</p> <div class="codeblock" id="code:26"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">lib_call</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span>

<span class="c1">// We're gonna use a custom entrypoint. This code will never run anyways, we</span>
<span class="c1">// just care about the linker output.</span>
<span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// This will go in `.data`, because it's initialized to non-zero.</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// The string-constant will go into `.rodata`.</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">lib_call</span><span class="p">(</span><span class="s">"Hello from .rodata!"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYyIsInNvdXJjZSI6 ImV4dGVybiBpbnQgbGliX2NhbGwoY29uc3QgY2hhciogc3RyKTtcblxuLy8g V2UncmUgZ29ubmEgdXNlIGEgY3VzdG9tIGVudHJ5cG9pbnQuIFRoaXMgY29k ZSB3aWxsIG5ldmVyIHJ1biBhbnl3YXlzLCB3ZVxuLy8ganVzdCBjYXJlIGFi b3V0IHRoZSBsaW5rZXIgb3V0cHV0Llxudm9pZCBydW4odm9pZCkge1xuICAv LyBUaGlzIHdpbGwgZ28gaW4gYC5kYXRhYCwgYmVjYXVzZSBpdCdzIGluaXRp YWxpemVkIHRvIG5vbi16ZXJvLlxuICBzdGF0aWMgaW50IGRhdGEgPSA1O1xu XG4gIC8vIFRoZSBzdHJpbmctY29uc3RhbnQgd2lsbCBnbyBpbnRvIGAucm9k YXRhYC5cbiAgZGF0YSA9IGxpYl9jYWxsKFwiSGVsbG8gZnJvbSAucm9kYXRh IVwiKTtcbn0iLCJjb21waWxlcnMiOlt7ImlkIjoiY2NsYW5nX3RydW5rIiwi b3B0aW9ucyI6IiJ9XX1dfQ== ">godbolt</a><a class="codeblock-button codeblock-anchor" href="#code:26">run.c</a></div></div> <p>Compile it with <code class="language-plaintext highlighter-rouge">clang -c run.c</code>. We can inspect the symbol table with <code class="language-plaintext highlighter-rouge">nm</code> as before:</p> <div class="codeblock" id="code:27"><figure class="highlight"><pre><code class="language-terminal" data-lang="terminal"><span class="gp">$</span><span class="w"> </span>nm run.o
<span class="go">                 U lib_call
0000000000000000 T run
0000000000000000 d run.data</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:27">Terminal</a></div></div> <p>As you might guess, <code class="language-plaintext highlighter-rouge">d</code> is just <code class="language-plaintext highlighter-rouge">.data</code>. However, <code class="language-plaintext highlighter-rouge">U</code> is interesting: it’s an undefined symbol, meaning the linker will need to perform a symbol resolution! In fact, if we ask Clang to link this for us (it just shells out to a linker like <code class="language-plaintext highlighter-rouge">ld</code>):</p> <div class="codeblock" id="code:28"><figure class="highlight"><pre><code class="language-terminal" data-lang="terminal"><span class="gp">$</span><span class="w"> </span>clang run.o
<span class="go">/usr/bin/ld: /somewhere/crt1.o: in function `_start':
(.text+0x20): undefined reference to `main'
/usr/bin/ld: run.o: in function `run':
run.c:(.text+0xf): undefined reference to `lib_call'</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:28">Terminal</a></div></div> <p>The linker also complains that there’s no <code class="language-plaintext highlighter-rouge">main()</code> function, and that some object we didn’t provide called <code class="language-plaintext highlighter-rouge">crt1.o</code> wants it. This is the startup code for the C runtime; we can skip linking it with <code class="language-plaintext highlighter-rouge">-nostartfiles</code>. This will result in the linker picking an entry point for us.</p> <p>We can resolve the missing symbol by linking against our library. <code class="language-plaintext highlighter-rouge">-lfoo</code> says to search for the library <code class="language-plaintext highlighter-rouge">libfoo.a</code>; <code class="language-plaintext highlighter-rouge">-L.</code> says to include the current directory for searching for libraries.</p> <div class="codeblock" id="code:29"><figure class="highlight"><pre><code class="language-shell" data-lang="shell">clang run.o <span class="nt">-L</span><span class="nb">.</span> <span class="nt">-lextern</span> <span class="nt">-nostartfiles</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:29">Shell</a></div></div> <p>This gives us our binary, <code class="language-plaintext highlighter-rouge">a.out</code>, which we can now <code class="language-plaintext highlighter-rouge">objdump</code>:</p> <div class="codeblock" id="code:30"><figure class="highlight"><pre><code class="language-terminal" data-lang="terminal"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-d</span> <span class="nt">-Mintel</span> a.out
<span class="go">
a.out:     file format elf64-x86-64


Disassembly of section .text:

</span><span class="gp">0000000000401000 &lt;run&gt;</span>:
<span class="go">  401000:  55                      push   rbp
  401001:  48 89 e5                mov    rbp,rsp
  401004:  48 bf 00 20 40 00 00    movabs rdi,0x402000
  40100b:  00 00 00
</span><span class="gp">  40100e:  e8 0d 00 00 00          call   401020 &lt;lib_call&gt;</span><span class="w">
</span><span class="go">  401013:  89 04 25 00 40 40 00    mov    DWORD PTR ds:0x404000,eax
  40101a:  5d                      pop    rbp
  40101b:  c3                      ret
  40101c:  0f 1f 40 00             nop    DWORD PTR [rax+0x0]

</span><span class="gp">0000000000401020 &lt;lib_call&gt;</span>:
<span class="go">  401020:  55                      push   rbp
  401021:  48 89 e5                mov    rbp,rsp
  401024:  48 89 7d f8             mov    QWORD PTR [rbp-0x8],rdi
  401028:  8b 04 25 04 40 40 00    mov    eax,DWORD PTR ds:0x404004
  40102f:  89 c1                   mov    ecx,eax
  401031:  83 c1 01                add    ecx,0x1
  401034:  89 0c 25 04 40 40 00    mov    DWORD PTR ds:0x404004,ecx
  40103b:  5d                      pop    rbp
  40103c:  c3                      ret</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:30">Terminal</a></div></div> <p>Let’s write up the simplest possible linker script for all this:</p> <div class="codeblock" id="code:31"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">ENTRY</span><span class="p">(</span><span class="n">run</span><span class="p">)</span>
<span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">text</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">);</span> <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">bss</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">);</span> <span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">data</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">);</span> <span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">rodata</span> <span class="o">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">rodata</span><span class="p">);</span> <span class="o">*</span><span class="p">(.</span><span class="n">rodata</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:31">link.ld</a></div></div> <p>Let’s link! We’ll also want to make sure that the system libc doesn’t get in the way, using <code class="language-plaintext highlighter-rouge">-nostdlib</code><sup id="fnref:libgcc_s" role="doc-noteref"><a href="#fn:libgcc_s" class="footnote" rel="footnote">16</a></sup>.</p> <div class="codeblock" id="code:32"><figure class="highlight"><pre><code class="language-shell" data-lang="shell">clang run.o <span class="nt">-L</span><span class="nb">.</span> <span class="nt">-lextern</span> <span class="nt">-nostartfiles</span> <span class="nt">-nostdlib</span> <span class="nt">-Wl</span>,-T,link.ld</code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:32">Shell</a></div></div> <p>At this point, you can use <code class="language-plaintext highlighter-rouge">objdump</code> to inspect <code class="language-plaintext highlighter-rouge">a.out</code> at your leisure! You’ll notice there are a few other sections, like <code class="language-plaintext highlighter-rouge">.eh_frame</code>. Clang adds these by default, but you can throw them out using <code class="language-plaintext highlighter-rouge">/DISCARD/</code>.</p> <p>It’s worth it to run the examples in the post through the linker using this “playground”. You can actually control the sections Clang puts symbols into using the <code class="language-plaintext highlighter-rouge">__attribute__((section("blah")))</code> compiler extension. The Rust equivalent is <code class="language-plaintext highlighter-rouge">#[link_section = "blah"]</code>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:linker-flag" role="doc-endnote"> <p>Blame GCC for this. <code class="language-plaintext highlighter-rouge">-Wl</code> feeds arguments through to the linker, and <code class="language-plaintext highlighter-rouge">-T</code> is <code class="language-plaintext highlighter-rouge">ld</code>’s linker script input flag. Thankfully, rustc is far more sensible here: <code class="language-plaintext highlighter-rouge">-Clink-args=-Wl,-T,foo.ld</code> (when GCC/Clang is your linker frontend). <a href="#fnref:linker-flag" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:etymology-of-s" role="doc-endnote"> <p>Correction, 2022-09-11. I have really been bothered by not knowing if this is actually true, and have periodically asked around about it. I asked Russ Cox, who was actually <em>at</em> Bell Labs back in the day, and he asked Ken Thompson, who confirms: it’s genuinely <code class="language-plaintext highlighter-rouge">.s</code> for source, because it was the only source they had back then.</p> <p>I am glad I got this from the horse’s mouth. :) <a href="#fnref:etymology-of-s" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:clang-languages" role="doc-endnote"> <p>And many other things, like Objective-C. <a href="#fnref:clang-languages" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:object-what" role="doc-endnote"> <p>Completely and utterly unrelated to the objects of object-oriented programming. Best I can tell, the etymology is lost to time. <a href="#fnref:object-what" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:aout" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">a.out</code> is <em>also</em> an object file format, like ELF, but toolchains live and die by tradition, so that’s the name given to the linker’s output by default. <a href="#fnref:aout" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rust-objects" role="doc-endnote"> <p>Rust does not compile each <code class="language-plaintext highlighter-rouge">.rs</code> file into an object, and its “crates” are much larger than the average C++ translation unit. However, the Rust compiler will nonetheless produce many object files for a single crate, precisely for the benefit of this compilation model. <a href="#fnref:rust-objects" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:bare-metal-loading" role="doc-endnote"> <p>Operating systems are loaded by a bootloader. Bootloaders are themselves loaded by other bootloaders, such as the BIOS. At the bottom of the turtles is the mask ROM, which is a tiny bootloader permanently burned into the device. <a href="#fnref:bare-metal-loading" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:text-section" role="doc-endnote"> <p>No idea on the etymology. This isn’t ASCII text! <a href="#fnref:text-section" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:bss-section" role="doc-endnote"> <p>Back in the 50s, this stood for “block started by symbol”. <a href="#fnref:bss-section" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:order-sorting" role="doc-endnote"> <p>Yes, yes, you can write <code class="language-plaintext highlighter-rouge">SORT_BY_NAME(*)(.text)</code> but that’s not really something you ever wind up needing.</p> <p>See <a href="https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html">https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html</a> for more information on this. <a href="#fnref:order-sorting" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:comment-syntax" role="doc-endnote"> <p>You only get <code class="language-plaintext highlighter-rouge">/* */</code> comment syntax because that’s the lowest common denominator. <a href="#fnref:comment-syntax" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:dot-align" role="doc-endnote"> <p>Well, <code class="language-plaintext highlighter-rouge">.</code> actually gets increased to the alignment of the section first. If you insist on an unaligned section, the syntax is, obviously,</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">SECTIONS</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">unaligned</span> <span class="p">.</span><span class="o">:</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Linker Script</a></div></div> <p>(That was sarcasm. It must be stressed that this is not a friendly language.) <a href="#fnref:dot-align" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:dot-in-asm" role="doc-endnote"> <p>This symbol is also available in assembly files. <code class="language-plaintext highlighter-rouge">jmp .</code> is an overly-cute idiom for an infinity busy loop. It is even more terse in ARM and RISC-V, where it’s written <code class="language-plaintext highlighter-rouge">b .</code> and <code class="language-plaintext highlighter-rouge">j .</code>, respectively.</p> <p>Personally, I prefer the obtuse clarity of <code class="language-plaintext highlighter-rouge">loop_forever: j loop_forever</code>. <a href="#fnref:dot-in-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:attrs-in-asm" role="doc-endnote"> <p>These are the same characters used to declare a section in assembly. If I wanted to place my code in a section named <code class="language-plaintext highlighter-rouge">.crt0</code> but wanted it to be placed into a readonly, executable memory block, use the the assembler directive <code class="language-plaintext highlighter-rouge">.section .crt0, rxal</code> <a href="#fnref:attrs-in-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:not-main" role="doc-endnote"> <p>Note that the entry point is almost never a function called <code class="language-plaintext highlighter-rouge">main()</code>. In the default configuration of most toolchains, an object called <code class="language-plaintext highlighter-rouge">crt0.o</code> is provided as part of the libc, which provides a <code class="language-plaintext highlighter-rouge">_start()</code> function that itself calls <code class="language-plaintext highlighter-rouge">main()</code>. CRT stands for “C runtime”; thus, <code class="language-plaintext highlighter-rouge">crt0.o</code> initializes the C runtime.</p> <p>This file contains the moral equivalent of the following C code, which varies according to target:</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
<span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">init_libc</span><span class="p">();</span>    <span class="c1">// Initializes global libc state.</span>
  <span class="n">run_ctors</span><span class="p">();</span>    <span class="c1">// Runs all library constructors.</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">main</span><span class="p">(</span><span class="n">get_argc</span><span class="p">(),</span> <span class="n">get_argv</span><span class="p">());</span>
  <span class="n">run_dtors</span><span class="p">();</span>    <span class="c1">// Runs all library destructors.</span>
  <span class="n">cleanup_libc</span><span class="p">();</span> <span class="c1">// Deinitializes the libc.</span>

  <span class="n">exit</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="c1">// Asks the OS to gracefully destroy the process.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">C</a></div></div> <p>This behavior can be disabled with <code class="language-plaintext highlighter-rouge">-nostartfiles</code> in Clang. The OSDev wiki has some on this topic: <a href="https://wiki.osdev.org/Creating_a_C_Library#Program_Initialization">https://wiki.osdev.org/Creating_a_C_Library#Program_Initialization</a>. <a href="#fnref:not-main" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:libgcc_s" role="doc-endnote"> <p>If you include libc, you will get bizarre errors involving something called “<code class="language-plaintext highlighter-rouge">gcc_s</code>”. <code class="language-plaintext highlighter-rouge">libgcc</code> (and <code class="language-plaintext highlighter-rouge">libgcc_s</code>) is GCC’s <em>compiler runtime</em> library. Where <code class="language-plaintext highlighter-rouge">libc</code> exposes high-level operations on the C runtime and utilities for manipulating common objects, <code class="language-plaintext highlighter-rouge">libgcc</code> provides even lower-level support, including:</p> <ul> <li>Polyfills for arithmetic operations not available on the target. For example, dividing two 64-bit integers on most 32-bit targets will emit a reference to the a symbol like <code class="language-plaintext highlighter-rouge">__udivmoddi4</code> (they all have utterly incomprehensible names like this one).</li> <li>Soft-float implementations, i.e., IEEE floats implemented in software for targets without an FPU.</li> <li>Bits of unwinding (e.g. exceptions and panics) support (the rest is in <code class="language-plaintext highlighter-rouge">libunwind</code>).</li> <li>Miscellaneous runtime support code, such as the code that calls C++ static initializers.</li> </ul> <p>Clang’s version, <code class="language-plaintext highlighter-rouge">libcompiler-rt</code>, is ABI-compatible with <code class="language-plaintext highlighter-rouge">libgcc</code> and provides various support for profiling, sanitizers, and many, many other things the compiler needs available for compiling code. <a href="#fnref:libgcc_s" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2021-05-24 • 2070 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2021/05/24/ptr-taxonomy/"> The Taxonomy of Pointers </a></h1> </div> <div class="post"> <p>Writing <code class="language-plaintext highlighter-rouge">unsafe</code> in Rust usually involves manual management of memory. Although, ideally, we’d like to exclusively use references for this, sometimes the constraints they apply are too strong. This post is a guide on those constraints and how to weaken them for correctness.</p> <p>“Unmanaged” languages, like C++ and Rust, provide <em>pointer</em> types for manipulating memory. These types serve different purposes and provide different guarantees. These guarantees are useful for the optimizer but get in the way of correctness of low-level code. This is especially true in Rust, where these constraints are very tight.</p> <blockquote id="note:1" class="note"> <p><a href="#note:1"><span class="chip">note</span></a></p> <p>This post only surveys <em>data</em> pointers. Function pointers are their own beast, but generally are less fussy, since they all have static lifetime<sup id="fnref:go-nuts" role="doc-noteref"><a href="#fn:go-nuts" class="footnote" rel="footnote">1</a></sup>.</p> </blockquote> <h2 id="basic-c-pointers"><a href="#basic-c-pointers">Basic C++ Pointers</a></h2> <p>First, let’s survey C++. We have three pointer types: the traditional C pointer <code class="language-plaintext highlighter-rouge">T*</code>, C++ references <code class="language-plaintext highlighter-rouge">T&amp;</code>, and rvalue references <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>. These generally have pretty weak guarantees.</p> <p>Pointers provide virtually no guarantees at all: they can be null, point to uninitialized memory, or point to nothing at all! C++ Only requires that they be aligned<sup id="fnref:unaligned" role="doc-noteref"><a href="#fn:unaligned" class="footnote" rel="footnote">2</a></sup>. They are little more than an address (until they are dereferenced, of course).</p> <p>References, on the other hand, are intended to be the “primary” pointer type. A <code class="language-plaintext highlighter-rouge">T&amp;</code> cannot be null, is well-aligned, and is intended to only refer to live memory (although it’s not something C++ can really guarantee for lack of a borrow-checker). References are short-lived.</p> <p>C++ uses non-nullness to its advantage. For example, Clang will absolutely delete code of the form</p> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">x</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">C++</a></div></div> <p>Because references cannot be null, and dereferencing the null pointer is always UB, the compiler may make this fairly strong assumption.</p> <p>Rvalue references, <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>, are not meaningfully different from normal references, beyond their role in overload resolution.</p> <p>Choosing a C++ (primitive) pointer type is well-studied and not the primary purpose of this blog. Rather, we’re interested in how these map to Rust, which has significantly more complicated pointers.</p> <h2 id="basic-rust-pointers"><a href="#basic-rust-pointers">Basic Rust Pointers</a></h2> <p>Like C++, Rust has two broad pointer types: <code class="language-plaintext highlighter-rouge">*const T</code> and <code class="language-plaintext highlighter-rouge">*mut T</code>, the raw pointers, and <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, the references.</p> <p>Rust pointer have even fewer constraints than C++ pointers; they need not even be aligned<sup id="fnref:unaligned-access" role="doc-noteref"><a href="#fn:unaligned-access" class="footnote" rel="footnote">3</a></sup>! The <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">mut</code> specifier is basically irrelevant, but is useful as programmer book-keeping tool. Rust also does not enforce the dreaded strict-aliasing rule<sup id="fnref:strict-aliasing" role="doc-noteref"><a href="#fn:strict-aliasing" class="footnote" rel="footnote">4</a></sup> on its pointers.</p> <p>On the other hand, Rust references are among the most constrained objects in any language that I know of. A shared reference <code class="language-plaintext highlighter-rouge">&amp;'a T</code>, lasting for the lifetime <code class="language-plaintext highlighter-rouge">'a</code>, satisfies:</p> <ul> <li>Non-null, and well-aligned (like in C++).</li> <li>Points to a valid, initialized <code class="language-plaintext highlighter-rouge">T</code> for the duration of <code class="language-plaintext highlighter-rouge">'a</code>.</li> <li><code class="language-plaintext highlighter-rouge">T</code> is never ever mutated for the duration of the reference: the compiler may fold separate reads into one at will. Stronger still, no <code class="language-plaintext highlighter-rouge">&amp;mut T</code> is reachable from any thread while the reference is reachable.</li> </ul> <p>Stronger still are <code class="language-plaintext highlighter-rouge">&amp;'a mut T</code> references, sometimes called <em>unique</em> references, because in addition to being well-aligned and pointing to a valid <code class="language-plaintext highlighter-rouge">T</code> at all times, no other reachable reference ever aliases it in any thread; this is equivalent to a C <code class="language-plaintext highlighter-rouge">T* restrict</code> pointer.</p> <p>Unlike C++, which has two almost-identical pointer types, Rust’s two pointer types provide either no guarantees or <em>all</em> of them. The following <code class="language-plaintext highlighter-rouge">unsafe</code> operations are all UB:</p> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">null</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null</span><span class="p">()</span> <span class="p">};</span>

<span class="c1">// A reference to u8 need not be sufficiently aligned</span>
<span class="c1">// for a reference to u32.</span>
<span class="k">let</span> <span class="n">unaligned</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">};</span>

<span class="c1">// More on this type later...</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">};</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">unsafe</span> <span class="p">{</span>
  <span class="c1">// Not UB in C++ with const_cast!</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="p">(</span><span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span><span class="nf">.write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Two mutable references live at the same time pointing to</span>
<span class="c1">// the same memory. This would also be fine in C++!</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">};</span>
<span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> <h3 id="wide-pointers"><a href="#wide-pointers">Wide Pointers</a></h3> <p>Rust also provides the slice types <code class="language-plaintext highlighter-rouge">&amp;[T]</code><sup id="fnref:std-span" role="doc-noteref"><a href="#fn:std-span" class="footnote" rel="footnote">5</a></sup> (of which you get mutable/immutable reference and pointer varieties) and dynamic trait object types <code class="language-plaintext highlighter-rouge">&amp;dyn Tr</code> (again, all four basic pointer types are available).</p> <p><code class="language-plaintext highlighter-rouge">&amp;[T]</code> is a <code class="language-plaintext highlighter-rouge">usize</code><sup id="fnref:usize" role="doc-noteref"><a href="#fn:usize" class="footnote" rel="footnote">6</a></sup> length plus a pointer to that many <code class="language-plaintext highlighter-rouge">T</code>s. The pointer type of the slice specifies the guarantees on the pointed-to buffer. <code class="language-plaintext highlighter-rouge">*mut [T]</code>, for example, has no meaningful guarantees, but still contains the length<sup id="fnref:ptr-len" role="doc-noteref"><a href="#fn:ptr-len" class="footnote" rel="footnote">7</a></sup>. Note that the length is part of the pointer value, <em>not</em> the pointee.</p> <p><code class="language-plaintext highlighter-rouge">&amp;dyn Tr</code> is a trait object. For our purposes, it consists of a pointer to some data plus a pointer to a static vtable. <code class="language-plaintext highlighter-rouge">*mut dyn Tr</code> is technically a valid type<sup id="fnref:raw-vtable" role="doc-noteref"><a href="#fn:raw-vtable" class="footnote" rel="footnote">8</a></sup>. Overall, trait objects aren’t really relevant to this post; they are rarely used this way in <code class="language-plaintext highlighter-rouge">unsafe</code> settings.</p> <h2 id="weakening-the-guarantees"><a href="#weakening-the-guarantees">Weakening the Guarantees</a></h2> <p>Suppose we’re building some kind of data structure; in Rust, data structures will need some sprinkling of <code class="language-plaintext highlighter-rouge">unsafe</code>, since they will need to shovel around memory directly. Typically this is done using raw pointers, but it is preferable to use the <em>least weakened</em> pointer type to allow the compiler to perform whatever optimizations it can.</p> <p>There are a number of orthogonal guarantees on <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code> we might want to relax:</p> <ul> <li>Non-nullness.</li> <li>Well-aligned-ness.</li> <li>Validity and initialized-ness of the pointee.</li> <li>Allocated-ness of the pointee (implied by initialized-ness).</li> <li>Global uniqueness of an <code class="language-plaintext highlighter-rouge">&amp;mut T</code>.</li> </ul> <h3 id="pointer-to-zst"><a href="#pointer-to-zst">Pointer to ZST</a></h3> <p>The last three of these properties are irrelevant for a zero-sized type. For example, we can generate infinite <code class="language-plaintext highlighter-rouge">&amp;mut ()</code> with no consequences:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">unique_unit</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="mi">0x1</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">())</span> <span class="p">}</span> 
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">Rust</a></div></div> <p>We materialize a non-null, well-aligned pointer and reborrow it into a static reference; because there is no data to point to, none of the usual worries about the pointee itself apply. However, the pointer itself must still be non-null and well-aligned; <code class="language-plaintext highlighter-rouge">0x1</code> is not a valid address for an <code class="language-plaintext highlighter-rouge">&amp;[u32; 0]</code>, but <code class="language-plaintext highlighter-rouge">0x4</code> is<sup id="fnref:but-you-cannot-free-it" role="doc-noteref"><a href="#fn:but-you-cannot-free-it" class="footnote" rel="footnote">9</a></sup>.</p> <p>This also applies to empty slices; in fact, the compiler will happily promote the expression <code class="language-plaintext highlighter-rouge">&amp;mut []</code> to an arbitrary lifetime:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">unique_empty</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
  <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">Rust</a></div></div> <h3 id="null-references"><a href="#null-references">Null References</a></h3> <p>The most well-known manner of weakening is <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code>. Rust guarantees that this is ABI-compatible with a C pointer <code class="language-plaintext highlighter-rouge">const T*</code>, with <code class="language-plaintext highlighter-rouge">Option::&lt;&amp;T&gt;::None</code> being a null pointer on the C side. This “null pointer optimization” applies to any type recursively containing at least one <code class="language-plaintext highlighter-rouge">T&amp;</code>.</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">DoSomething</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_something</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">DoSomething</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>  <span class="c1">// C will see a `NULL` as the argument.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">Rust</a></div></div> <p>The same effect can be achieved for a pointer type using the <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code class="language-plaintext highlighter-rouge">NonNull&lt;T&gt;</code></a> standard library type: <code class="language-plaintext highlighter-rouge">Option&lt;NonNull&lt;T&gt;&gt;</code> is identical to <code class="language-plaintext highlighter-rouge">*mut T</code>. This is most beneficial for types which would otherwise contain a raw pointer:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;</span><span class="p">(),</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;&gt;</span><span class="p">())</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">Rust</a></div></div> <h3 id="uninitialized-pointee"><a href="#uninitialized-pointee">Uninitialized Pointee</a></h3> <p>No matter what, a <code class="language-plaintext highlighter-rouge">&amp;T</code> cannot point to uninitialized memory, since the compiler is free to assume it may read such references at any time with no consequences.</p> <p>The following classic C pattern is verboten:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">initialize_foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">C</a></div></div> <p>Rust doesn’t provide any particularly easy ways to allocate memory without initializing it, too, so this usually isn’t a problem. The <a href="https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_ref"><code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code></a> type can be used for safely allocating memory without initializing it, via <code class="language-plaintext highlighter-rouge">MaybeUninit::uninit()</code>.</p> <p>This type acts as a sort of “optimization barrier” that prevents the compiler from assuming the pointee is initialized. <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> is a pointer to potentially uninitialized but definitely allocated memory. It has the same layout as <code class="language-plaintext highlighter-rouge">&amp;T</code>, and Rust provides functions like <code class="language-plaintext highlighter-rouge">assume_init_ref()</code> for asserting that a <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> is definitely initialized. This assertion is similar in consequence to dereferencing a raw pointer.</p> <p><code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">&amp;mut MaybeUninit&lt;T&gt;</code> should almost be viewed as pointer types in their own right, since they can be converted to/from <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code> under certain circumstances.</p> <p>Because <code class="language-plaintext highlighter-rouge">T</code> is almost a “subtype” of <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, we are entitled<sup id="fnref:requires-transmute" role="doc-noteref"><a href="#fn:requires-transmute" class="footnote" rel="footnote">10</a></sup> to “forget” that the referent of a <code class="language-plaintext highlighter-rouge">&amp;T</code> is initialized converting it to a <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code>. This makes sense because <code class="language-plaintext highlighter-rouge">&amp;T</code> is covariant<sup id="fnref:covariance" role="doc-noteref"><a href="#fn:covariance" class="footnote" rel="footnote">11</a></sup> in <code class="language-plaintext highlighter-rouge">&amp;T</code>. However, this is not true of <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, since it’s not covariant:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">uninit</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">)</span> <span class="p">};</span>
<span class="o">*</span><span class="n">uninit</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>  <span class="c1">// Oops, `x` is now uninit!</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>These types are useful for talking to C++ without giving up too many guarantees. <code class="language-plaintext highlighter-rouge">Option&lt;&amp;MaybeUninit&lt;T&gt;&gt;</code> is an almost perfect model of a <code class="language-plaintext highlighter-rouge">const T*</code>, under the assumption that most pointers in C++ are valid most of the time.</p> <p><code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> also finds use in working with raw blocks of memory, such as in a <code class="language-plaintext highlighter-rouge">Vec</code>-style growable slice:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">SliceVec</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Backing memory. The first `len` elements of it are</span>
  <span class="c1">// known to be initialized, but no more than that.</span>
  <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">],</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SliceVec</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;</span> <span class="n">data</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="k">self</span><span class="py">.len</span><span class="p">]</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <h3 id="aliased-pointee"><a href="#aliased-pointee">Aliased Pointee</a></h3> <p><code class="language-plaintext highlighter-rouge">&amp;mut T</code> can never alias any other pointer, but is also the mechanism by which we perform mutation. It can’t even alias with pointers that Rust can’t see; Rust assumes no one else can touch this memory. Thus, <code class="language-plaintext highlighter-rouge">&amp;mut T</code> is not an appropriate analogue for <code class="language-plaintext highlighter-rouge">T&amp;</code>.</p> <p>Like with uninitialized memory, Rust provides a “barrier” wrapper type, <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code></a>. <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> is the “interior mutability” primitive, which permits us to mutate through an <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> so long as concurrent reads and writes do not occur. We may even convert it to a <code class="language-plaintext highlighter-rouge">&amp;mut T</code> when we’re sure we’re holding the only reference.</p> <p><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> forms the basis of the <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, and <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code> types, each of which performs a sort of “dynamic borrow-checking”:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> only permits direct loads and stores.</li> <li><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> maintains a counter of references into it, which it uses to dynamically determine if a mutable reference would be unique.</li> <li><code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code>, which is like <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> but using concurrency primitives to maintain uniqueness.</li> </ul> <p>Because of this, Rust must treat <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> as always aliasing, but because we can mutate through it, it is a much closer analogue to a C++ <code class="language-plaintext highlighter-rouge">T&amp;</code>. However, because <code class="language-plaintext highlighter-rouge">&amp;T</code> assumes the pointee is never mutated, it cannot coexist with a <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> to the same memory, if mutation is performed through it. The following is explicitly UB:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

<span class="c1">// This is ok; creating the reference to UnsafeCell does not</span>
<span class="c1">// immediately trigger UB.</span>
<span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">};</span>

<span class="c1">// But writing to it does!</span>
<span class="n">q</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">Rust</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> type is useful for non-aliasing references to plain-old-data types, which tend to be <code class="language-plaintext highlighter-rouge">Copy</code>. It allows us to perform mutation without having to utter <code class="language-plaintext highlighter-rouge">unsafe</code>. For example, the correct type for a shared mutable buffer in Rust is <code class="language-plaintext highlighter-rouge">&amp;[Cell&lt;u8&gt;]</code>, which can be freely <code class="language-plaintext highlighter-rouge">memcpy</code>‘d, without worrying about aliasing<sup id="fnref:but-thread-safety" role="doc-noteref"><a href="#fn:but-thread-safety" class="footnote" rel="footnote">12</a></sup>.</p> <p>This is most useful for sharing memory with another language, like C++, which cannot respect Rust’s aliasing rules.</p> <h3 id="combined-barriers"><a href="#combined-barriers">Combined Barriers</a></h3> <p>To recap:</p> <ul> <li>Non-nullness can be disabled with <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code>.</li> <li>Initialized-ness can be disabled with <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code>.</li> <li>Uniqueness can be disabled with <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code>.</li> </ul> <blockquote id="warning:1" class="warning"> <p><a href="#warning:1"><span class="chip">warning</span></a></p> <p>There is no way to disable alignment and validity restrictions: references must always be aligned and have a valid lifetime attached. If these are unachievable, raw pointers are your only option.</p> </blockquote> <p>We can combine these various “weakenings” to produce aligned, lifetime-bound references to data with different properties. For example:</p> <ul> <li><code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> is as close as we can get to a C++ <code class="language-plaintext highlighter-rouge">T&amp;</code>.</li> <li><code class="language-plaintext highlighter-rouge">Option&lt;&amp;UnsafeCell&lt;T&gt;&gt;</code> is a like a raw pointer, but to initialized memory.</li> <li><code class="language-plaintext highlighter-rouge">Option&lt;&amp;mut MaybeUninit&lt;T&gt;&gt;</code> is like a raw pointer, but with alignment, aliasing, and lifetime requirements.</li> <li><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;&amp;[T]&gt;</code> permits us to mutate the pointer to the buffer and its length, but not the values it points to themselves.</li> <li><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;&amp;[UnsafeCell&lt;T&gt;]&gt;</code> lets us mutate both the buffer and its actual pointer/length.</li> </ul> <p>Interestingly, there is no equivalent to a C++ raw pointer: there is no way to create a guaranteed-aligned pointer without a designated lifetime<sup id="fnref:unsafe-lifetime" role="doc-noteref"><a href="#fn:unsafe-lifetime" class="footnote" rel="footnote">13</a></sup>.</p> <h2 id="other-pointers"><a href="#other-pointers">Other Pointers</a></h2> <p>Rust and C++ have many other pointer types, such as smart pointers. However, in both languages, both are built in terms of these basic pointer types. Hopefully this article is a useful reference for anyone writing <code class="language-plaintext highlighter-rouge">unsafe</code> abstraction that wishes to avoid using raw pointers when possible.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:go-nuts" role="doc-endnote"> <p>Except in Go, which synthesizes vtables <em>on the fly</em>. Story for another day. <a href="#fnref:go-nuts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned" role="doc-endnote"> <p>It is, apparently, a little-known fact that constructing unaligned pointers, but then never dereferencing them, is still UB in C++. C++ could, for example, store information in the lower bits of such a pointer. The in-memory representation of a pointer is actually unspecified! <a href="#fnref:unaligned" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned-access" role="doc-endnote"> <p>This is useful when paired with the Rust <code class="language-plaintext highlighter-rouge">&lt;*const T&gt;::read_unaligned()</code> function, which can be compiled down to a normal load on architectures that do not have alignment restrictions, like x86_64 and aarch64. <a href="#fnref:unaligned-access" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:strict-aliasing" role="doc-endnote"> <p>Another story for another time. <a href="#fnref:strict-aliasing" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:std-span" role="doc-endnote"> <p>Comparable to the C++20 <a href="https://en.cppreference.com/w/cpp/container/span"><code class="language-plaintext highlighter-rouge">std::span&lt;T&gt;</code></a> type. <a href="#fnref:std-span" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:usize" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">usize</code> is Rust’s machine word type, compare <code class="language-plaintext highlighter-rouge">std::uintptr_t</code>. <a href="#fnref:usize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptr-len" role="doc-endnote"> <p>The length of a <code class="language-plaintext highlighter-rouge">*mut [T]</code> can be accessed via the unstable <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.len-1"><code class="language-plaintext highlighter-rouge">&lt;*mut [T]&gt;::len()</code></a> method. <a href="#fnref:ptr-len" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:raw-vtable" role="doc-endnote"> <p>It is also not a type I have encountered enough to have much knowledge on. For example, I don’t actually know if the vtable half of a <code class="language-plaintext highlighter-rouge">*mut dyn Tr</code> must always be valid or not; I suspect the answer is “no”, but I couldn’t find a citation for this. <a href="#fnref:raw-vtable" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:but-you-cannot-free-it" role="doc-endnote"> <p>Note that you <em>cannot</em> continue to use a reference to freed, zero-sized memory. This subtle distinction is called out in <a href="https://doc.rust-lang.org/std/ptr/index.html#safety">https://doc.rust-lang.org/std/ptr/index.html#safety</a>. <a href="#fnref:but-you-cannot-free-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-transmute" role="doc-endnote"> <p>Currently, a <code class="language-plaintext highlighter-rouge">transmute</code> must be used to perform this operation, but I see no reason way this would permit us to perform an illegal mutation without uttering <code class="language-plaintext highlighter-rouge">unsafe</code> a second time. In particular, <code class="language-plaintext highlighter-rouge">MaybeUninit::assume_init_read()</code>, which could be used to perform illegal copies, is an <code class="language-plaintext highlighter-rouge">unsafe</code> function. <a href="#fnref:requires-transmute" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:covariance" role="doc-endnote"> <p>A covariant type <code class="language-plaintext highlighter-rouge">Cov&lt;T&gt;</code> is once where, if <code class="language-plaintext highlighter-rouge">T</code> is a subtype of <code class="language-plaintext highlighter-rouge">U</code>, then <code class="language-plaintext highlighter-rouge">Cov&lt;T&gt;</code> is a subtype of <code class="language-plaintext highlighter-rouge">Cov&lt;U&gt;</code>. This isn’t particularly noticeable in Rust, where the only subtyping relationships are <code class="language-plaintext highlighter-rouge">&amp;'a T</code> subtypes <code class="language-plaintext highlighter-rouge">&amp;'b T</code> when <code class="language-plaintext highlighter-rouge">'a</code> outlives <code class="language-plaintext highlighter-rouge">'b</code>, but is nonetheless important for advanced type design. <a href="#fnref:covariance" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:but-thread-safety" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> does not provide synchronization; you still need locks to share it between threads. <a href="#fnref:but-thread-safety" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unsafe-lifetime" role="doc-endnote"> <p>I have previously proposed a sort of <code class="language-plaintext highlighter-rouge">'unsafe</code> or <code class="language-plaintext highlighter-rouge">'!</code> “lifetime” that is intended to be the lifetime of dangling references (a bit of an oxymoron). This would allow us to express this concept, but I need to flesh out the concept more. <a href="#fnref:unsafe-lifetime" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2021-04-26 • 3923 words • 43 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#ffi">#ffi</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2021/04/26/move-ctors/"> Move Constructors in Rust:<br/> Is it possible?<br/> </a></h1> </div> <div class="post"> <p>I’ve been told I need to write this idea down – I figure this one’s a good enough excuse to start one of them programming blogs.</p> <p><em>TL;DR</em> You <em>can</em> move-constructors the Rust! It requires a few macros but isn’t much more outlandish than the <code class="language-plaintext highlighter-rouge">async</code> pinning state of the art. A prototype of this idea is implemented in my <a href="https://crates.io/crates/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a> crate.</p> <h2 id="the-interop-problem"><a href="#the-interop-problem">The Interop Problem</a></h2> <p>Rust is the best contender for a C++ replacement; this is not even a question at this point<sup id="fnref:cc-replacement" role="doc-noteref"><a href="#fn:cc-replacement" class="footnote" rel="footnote">1</a></sup>. It’s a high-level language that provides users with appropriate controls over memory, while also being memory safe. Rust accomplishes by codifying C++ norms and customs around ownership and lifetimes into its type system.</p> <p>Rust has an ok<sup id="fnref:bindgen" role="doc-noteref"><a href="#fn:bindgen" class="footnote" rel="footnote">2</a></sup> FFI story for C:</p> <div class="code-multicol"> <div class="codeblock" id="code:1"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">into_rust</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">into_c</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">into_rust</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:1">C</a></div></div> <div class="codeblock" id="code:2"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">into_c</span><span class="p">();</span>
<span class="p">}</span>

<span class="nd">#[no_mangle]</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">into_rust</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">into_c</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:2">Rust</a></div></div> </div> <p>Calling into either of these functions from the Rust or C side will recurse infinitely across the FFI boundary. The <code class="language-plaintext highlighter-rouge">extern "C" {}</code> item on the Rust side declares C symbols, much like a function prototype in C would; the <code class="language-plaintext highlighter-rouge">extern "C" fn</code> is a Rust function with the C calling convention, and the <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> annotation ensures that <code class="language-plaintext highlighter-rouge">recurse_into_rust</code> is the name that the linker sees for this function. The link works out, we run our program, and the stack overflows. All is well.</p> <p>But this is C. We want to rewrite all of the world’s C++ in Rust, but unfortunately that’s going to take about a decade, so in the meantime new Rust must be able to call existing C++, and vise-versa. C++ has a much crazier ABI, and while Rust gives us the minimum of passing control to C, libraries like <a href="https://cxx.rs/"><code class="language-plaintext highlighter-rouge">cxx</code></a> need to provide a bridge on top of this for Rust and C++ to talk to each other.</p> <p>Unfortunately, the C++ and Rust object models are, a priori, incompatible. In Rust, <em>every object</em> may be “moved” via <code class="language-plaintext highlighter-rouge">memcpy</code>, whereas in C++ this only holds for types satisfying <code class="language-plaintext highlighter-rouge">std::is_trivially_moveable</code><sup id="fnref:relocatable" role="doc-noteref"><a href="#fn:relocatable" class="footnote" rel="footnote">3</a></sup>. Some types require calling a <em>move constructor</em>, or may not be moveable at all!</p> <p>Even more alarming, C++ types are permited to take the address of the location where they are being constructed: the <code class="language-plaintext highlighter-rouge">this</code> pointer is always accessible, allowing easy creation of self-referential types:</p> <div class="codeblock" id="code:3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Cyclic</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Cyclic</span><span class="p">()</span> <span class="p">{}</span>
 
  <span class="c1">// Ensure that copy and move construction respect the self-pointer</span>
  <span class="c1">// invariant:</span>
  <span class="n">Cyclic</span><span class="p">(</span><span class="k">const</span> <span class="n">Cyclic</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="n">Cyclic</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// snip: Analogous for other rule-of-five constructors.</span>

 <span class="nl">private:</span>
  <span class="n">Cyclic</span><span class="o">*</span> <span class="n">ptr_</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:3">C++</a></div></div> <p>The solution <a href="https://cxx.rs/"><code class="language-plaintext highlighter-rouge">cxx</code></a> and other FFI strategies take is to box up complex C++ objects across the FFI boundary; a <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;Cyclic&gt;</code> (perhaps reinterpreted as a <code class="language-plaintext highlighter-rouge">Box</code> on the Rust side) can be passed around without needing to call move constructors. The heap allocation is a performance regression that scares off potential Rust users, so it’s not a viable solution.</p> <p>We can do better.</p> <h3 id="notation-and-terminology"><a href="#notation-and-terminology">Notation and Terminology</a></h3> <p>“Move” is a very, very overloaded concept across Rust and C++, and many people have different names for what this means. So that we don’t get confused, we’ll establish some terminology to use throughout the rest of the article.</p> <p>A <em>destructive move</em> is a Rust-style move, which has the following properties:</p> <ul> <li>It does not create a new object; from the programmer’s perspective, the object has simply changed address.</li> <li>The move is implemented by a call to <code class="language-plaintext highlighter-rouge">memcpy</code>; no user code is run.</li> <li>The moved-from value becomes inaccessible and its destructor does not run.</li> </ul> <p>A destructive move, in effect, is completely invisible to the user<sup id="fnref:swappy" role="doc-noteref"><a href="#fn:swappy" class="footnote" rel="footnote">4</a></sup>, and the Rust compiler can emit as many or as few of them as it likes. We will refer to this as a “destructive move”, a “Rust move”, or a “blind, <code class="language-plaintext highlighter-rouge">memcpy</code> move”.</p> <p>A <em>copying move</em> is a C++-style move, which has the following properties:</p> <ul> <li>It creates a new, distinct object at a new memory location.</li> <li>The move is implemented by calling a user-provided function that initializes the new object.</li> <li>The moved-from value is still accessible but in an “unspecified but valid state”. Its destructor is run once the current scope ends.</li> </ul> <p>A copying move is just a weird copy operation that mutates the copied-from object. C++ compilers <em>may</em> elide calls to the move constructor in certain situations, but calling it usually requires the programmer to explicitly ask for it. From a Rust perspective, this is as if <code class="language-plaintext highlighter-rouge">Clone::clone()</code> took <code class="language-plaintext highlighter-rouge">&amp;mut self</code> as an argument. We will refer to this as a “copying move”, a “nondestructive move”, a “C++ move”, or, metonymically, as a “move constructor”.</p> <h2 id="pinned-pointers"><a href="#pinned-pointers">Pinned Pointers</a></h2> <p>As part of introducing support for stackless coroutines<sup id="fnref:pinned-futures" role="doc-noteref"><a href="#fn:pinned-futures" class="footnote" rel="footnote">5</a></sup> (aka <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>), Rust had to provide some kind of supported for immobile types through <em>pinned pointers</em>.</p> <p>The <a href="https://doc.rust-lang.org/std/pin/index.html"><code class="language-plaintext highlighter-rouge">Pin</code></a> type is a wraper around a pointer type, such as <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut i32&gt;</code> or <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;ComplexObject&gt;&gt;</code>. <code class="language-plaintext highlighter-rouge">Pin</code> provides the following guarantee to unsafe code:</p> <blockquote id="ref:1" class="ref"> <p><a href="#ref:1"><span class="chip">reference</span></a></p> <p>Given <code class="language-plaintext highlighter-rouge">p: Pin&lt;P&gt;</code> for <code class="language-plaintext highlighter-rouge">P: Deref</code>, and <code class="language-plaintext highlighter-rouge">P::Target: !Unpin</code>, the pointee object <code class="language-plaintext highlighter-rouge">*p</code> will always be found at that address, and no other object will use that address until <code class="language-plaintext highlighter-rouge">*p</code>’s destructor is called.</p> </blockquote> <p>In a way, <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code> is a witness to a sort of critical section: once constructed, that memory is <em>pinned</em> until the destructor runs. The <code class="language-plaintext highlighter-rouge">Pin</code> documentation goes into deep detail about when and why this matters, and how unsafe code can take advantage of this guarantee to provide a safe interface.</p> <p>The key benefit is that unsafe code can create self-references behind the pinned pointer, without worrying about them breaking when a destructive move occurs. C++ deals with this kind of type by allowing move/copy constructors to observe the new object’s address and fix up any self references as necessary.</p> <p>Our progress so far: C++ types can be immoveable from Rust’s perspective. They need to be pinned in some memory location: either on the heap as a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code>, or on the stack (somehow; keep reading). Our program is now to reconcile C++ move constructors with this standard library object that explicitly prevents moves. Easy, right;</p> <h2 id="constructors"><a href="#constructors">Constructors</a></h2> <p>C++ constructors are a peculiar thing. Unlike Rust’s <code class="language-plaintext highlighter-rouge">Foo::new()</code>-style factories, or even constructors in dynamic languages like Java, C++ constructors are unique in that they construct a value in a <em>specific location</em>. This concept is best illustraced by the <a href="https://en.cppreference.com/w/cpp/language/new#Placement_new"><em>placement-<code class="language-plaintext highlighter-rouge">new</code></em></a> operation:</p> <div class="codeblock" id="code:4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">MakeString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">new</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"mwahahaha"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:4">C++</a></div></div> <p>Placement-<code class="language-plaintext highlighter-rouge">new</code> is one of those exotic C++ operations you only ever run into deep inside fancy library code. Unlike <code class="language-plaintext highlighter-rouge">new</code>, which triggers a trip into the allocator, placement-<code class="language-plaintext highlighter-rouge">new</code> simply calls the constructor of your type with <code class="language-plaintext highlighter-rouge">this</code> set to the argument in parentheses. This is the “most raw” way you can call a constructor: given a memory location and arguments, construct a new value.</p> <p>In Rust, a method call <code class="language-plaintext highlighter-rouge">foo.bar()</code> is really syntax sugar for <code class="language-plaintext highlighter-rouge">Foo::bar(foo)</code>. This is not the case in C++; a member function has an altogether different type, but some simple template metaprogramming can flatten it back into a regular old free function:</p> <div class="codeblock" id="code:5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="n">FreeBar</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">foo</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">FreeBar</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:5">C++</a></div></div> <p>Placement-<code class="language-plaintext highlighter-rouge">new</code> lets us do the analogous thing for a constructor:</p> <div class="codeblock" id="code:6"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="n">FreeFoo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">)</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">AllocateSomehow</span><span class="p">();</span>
<span class="n">FreeFoo</span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:6">C++</a></div></div> <p>We can lift this “flattening” of a specific constructor into Rust, using the existing vocabulary for pushing fixed-address memory around:</p> <div class="codeblock" id="code:7"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">trait</span> <span class="n">Ctor</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">ctor</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:7">Rust</a></div></div> <p>A <code class="language-plaintext highlighter-rouge">Ctor</code> is a <em>constructing closure</em>. A <code class="language-plaintext highlighter-rouge">Ctor</code> contains the necessary information for constructing a value of type <code class="language-plaintext highlighter-rouge">Output</code> which will live at the location <code class="language-plaintext highlighter-rouge">*dest</code>. The <code class="language-plaintext highlighter-rouge">Ctor::ctor()</code> function performs in-place construction, making <code class="language-plaintext highlighter-rouge">*dest</code> become initialized.</p> <p>A <code class="language-plaintext highlighter-rouge">Ctor</code> is not the constructor itself; rather, it is more like a <code class="language-plaintext highlighter-rouge">Future</code> or an <code class="language-plaintext highlighter-rouge">Iterator</code> which contain the necessary captured values to perform the operation. A Rust type that is constructed using a <code class="language-plaintext highlighter-rouge">Ctor</code> would have functions like this:</p> <div class="codeblock" id="code:8"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">MyType</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Ctor</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:8">Rust</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">unsafe</code> markers serve distinct purposes:</p> <ul> <li>It is an <code class="language-plaintext highlighter-rouge">unsafe trait</code>, because <code class="language-plaintext highlighter-rouge">*dest</code> must be initialized when <code class="language-plaintext highlighter-rouge">ctor()</code> returns.</li> <li>It has an <code class="language-plaintext highlighter-rouge">unsafe fn</code>, because, in order to respect the <a href="https://doc.rust-lang.org/std/pin/index.html#drop-guarantee"><code class="language-plaintext highlighter-rouge">Pin</code> drop guarantees</a>, <code class="language-plaintext highlighter-rouge">*dest</code> must either be freshly allocated or have had its destructor run just prior.</li> </ul> <p>Since we are constructing into <code class="language-plaintext highlighter-rouge">Pin</code>ned memory, the <code class="language-plaintext highlighter-rouge">Ctor</code> implementation can use the address of <code class="language-plaintext highlighter-rouge">*dest</code> as part of the construction procedure and assume that that pointer will not suddenly dangle because of a move. This recovers our C++ behavior of “<code class="language-plaintext highlighter-rouge">this</code>-stability”.</p> <p>Unfortunately, <code class="language-plaintext highlighter-rouge">Ctor</code> is covered in <code class="language-plaintext highlighter-rouge">unsafe</code>, and doesn’t even allocate storage for us. Luckily, it’s not too hard to build our own safe <code class="language-plaintext highlighter-rouge">std::make_unique</code>:</p> <div class="codeblock" id="code:9"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">make_box</span><span class="o">&lt;</span><span class="n">C</span><span class="p">:</span> <span class="n">Ctor</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">C</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="nn">Ctor</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="nn">Ctor</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
    <span class="c1">// First, obtain uninitialized memory on the heap.</span>
    <span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">alloc</span><span class="p">::</span><span class="nf">alloc</span><span class="p">(</span><span class="nn">Layout</span><span class="p">::</span><span class="n">new</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span>
    
    <span class="c1">// Then, pin this memory as a MaybeUninit. This memory</span>
    <span class="c1">// isn't going anywhere, and MaybeUninit's entire purpose</span>
    <span class="c1">// in life is being magicked into existence like this,</span>
    <span class="c1">// so this is safe.</span>
    <span class="k">let</span> <span class="n">pinned</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
      <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">uninit</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="c1">// Now, perform placement-`new`, potentially FFI'ing into</span>
    <span class="c1">// C++.</span>
    <span class="n">c</span><span class="nf">.ctor</span><span class="p">(</span><span class="n">pinned</span><span class="p">);</span>

    <span class="c1">// Because Ctor guarantees it, `uninit` now points to a</span>
    <span class="c1">// valid `T`. We can safely stick this in a `Box`. However,</span>
    <span class="c1">// the `Box` must be pinned, since we pinned `uninit`</span>
    <span class="c1">// earlier.</span>
    <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="n">uninit</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()))</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:9">Rust</a></div></div> <p>Thus, <code class="language-plaintext highlighter-rouge">std::make_unique&lt;MyType&gt;()</code> in C++ becomes <code class="language-plaintext highlighter-rouge">make_box(MyType::new())</code> in Rust. <code class="language-plaintext highlighter-rouge">Ctor::ctor</code> gives us a bridging point to call the C++ constructor from Rust, in a context where its expectations are respected. For example, we might write the following binding code:</p> <div class="codeblock" id="code:10"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Give the constructor an explicit C ABI, using</span>
<span class="c1">// placement-`new` to perform the "rawest" construction</span>
<span class="c1">// possible.</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">FooCtor</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span> <span class="n">thiz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">new</span> <span class="p">(</span><span class="n">thiz</span><span class="p">)</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:10">foo.cc</a></div></div> <div class="codeblock" id="code:11"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Ctor</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// Declare the placement-new bridge.</span>
      <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">FooCtor</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Foo</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// Make a new `Ctor` wrapping a "real" closure.</span>
      <span class="nn">ctor</span><span class="p">::</span><span class="nf">from_placement_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">dest</span><span class="p">|</span> <span class="p">{</span>
        <span class="c1">// Call back into C++.</span>
        <span class="nf">FooCtor</span><span class="p">(</span><span class="n">dest</span><span class="nf">.as_mut_ptr</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:11">foo_bindings.rs</a></div></div> <div class="codeblock" id="code:12"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">foo_bindings</span><span class="p">::</span><span class="n">Foo</span><span class="p">;</span>

<span class="c1">// Lo, behold! A C++ type on the Rust heap!</span>
<span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="nf">make_box</span><span class="p">(</span><span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:12">foo_user.rs</a></div></div> <p>But… we’re still on the heap, so we seem to have made no progress. We could have just called <code class="language-plaintext highlighter-rouge">std::make_unique</code> on the C++ side and shunted it over to Rust. In particular, this is what <a href="https://cxx.rs/"><code class="language-plaintext highlighter-rouge">cxx</code></a> resorts to for complex types.</p> <h2 id="interlude-i-pinning-on-the-stack"><a href="#interlude-i-pinning-on-the-stack">Interlude I: Pinning on the Stack</a></h2> <p>Creating pinned pointers directly requires a sprinkling of <code class="language-plaintext highlighter-rouge">unsafe</code>. <code class="language-plaintext highlighter-rouge">Box::pin()</code> allows us to safely create a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;T&gt;&gt;</code>, since we know it will never move, much like the <code class="language-plaintext highlighter-rouge">make_box()</code> example above. However, it’s not possible to create a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code> to not-necessarilly-<code class="language-plaintext highlighter-rouge">Unpin</code> data as easilly:</p> <div class="codeblock" id="code:13"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">;</span>
<span class="k">let</span> <span class="n">pinned</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
  <span class="c1">// Reborrow `ptr` to create a pointer with a shorter lifetime.</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// Once `pinned` goes out of scope, we can move out of `*ptr`!</span>
<span class="k">let</span> <span class="n">moved</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:13">Rust</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">unsafe</code> block is necessary because of exactly this situation: <code class="language-plaintext highlighter-rouge">&amp;mut T</code> does not own its pointee, and a given mutable reference might not be the “oldest” mutable reference there is. The following <em>is</em> a safe usage of this constructor:</p> <div class="codeblock" id="code:14"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="c1">// Intentionally shadow `data` so that no longer-lived reference than</span>
<span class="c1">// the pinned one can be created.</span>
<span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:14">Rust</a></div></div> <p>This is such a common pattern in futures code that many futures libraries provide a macro for performing this kind of pinning on behalf of the user, such as <a href="https://docs.rs/tokio/1.4.0/tokio/macro.pin.html"><code class="language-plaintext highlighter-rouge">tokio::pin!()</code></a>.</p> <p>With this in hand, we can actually call a constructor on a stack-pinned value:</p> <div class="codeblock" id="code:15"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="nd">pin!</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="k">unsafe</span> <span class="p">{</span> <span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="nf">.ctor</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
<span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
  <span class="n">val</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">x</span><span class="nf">.as_mut_ptr</span><span class="p">())</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:15">Rust</a></div></div> <p>Unfortunately, we <em>still</em> need to utter a little bit more <code class="language-plaintext highlighter-rouge">unsafe</code>, but because of <code class="language-plaintext highlighter-rouge">Ctor</code>’s guarantees, this is all perfectly safe; the compiler just can’t guarantee it on its own. The natural thing to do is to wrap it up in a macro much like <code class="language-plaintext highlighter-rouge">pin!</code>, which we’ll call <code class="language-plaintext highlighter-rouge">emplace!</code>:</p> <div class="codeblock" id="code:16"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">emplace!</span><span class="p">(</span><span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:16">Rust</a></div></div> <p>This is <em>truly</em> analogous to C++ stack initialization, such as <code class="language-plaintext highlighter-rouge">Foo val(args);</code>, although the type of <code class="language-plaintext highlighter-rouge">val</code> is <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut Foo&gt;</code>, whereas in C++ it would merely bee <code class="language-plaintext highlighter-rouge">Foo&amp;</code>. This isn’t much of an obstacle, and just means that <code class="language-plaintext highlighter-rouge">Foo</code>’s API on the Rust side needs to use <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut Self&gt;</code> for its methods.</p> <h2 id="the-return-value-optimization"><a href="#the-return-value-optimization">The Return Value Optimization</a></h2> <p>Now we go to build our Foo-returning function and are immediately hit with a roadblock:</p> <div class="codeblock" id="code:17"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">make_foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="nv">'wat</span> <span class="k">mut</span> <span class="n">Foo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nd">emplace!</span><span class="p">(</span><span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
  <span class="n">foo</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:17">Rust</a></div></div> <p>What is the lifetime <code class="language-plaintext highlighter-rouge">'wat</code>? This is just returning a pointer to the current stack frame, which is no good. In C++ (ignoring fussy defails about move semantics), NRVO would kick in and <code class="language-plaintext highlighter-rouge">val</code> would be constructed “in the return slot”:</p> <div class="codeblock" id="code:18"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span> <span class="nf">MakeFoo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Foo</span> <span class="n">val</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:18">C++</a></div></div> <p><a href="https://en.cppreference.com/w/cpp/language/copy_elision"><em>Return value optimization</em></a> (and the related <em>named return value optimization</em>) allow C++ to elide copies when constructing return values. Instead of constructing <code class="language-plaintext highlighter-rouge">val</code> on <code class="language-plaintext highlighter-rouge">MakeFoo</code>’s stack and then copying it into the ABI’s return location (be that a register like <code class="language-plaintext highlighter-rouge">rax</code> or somewhere in the caller’s stack frame), the value is constructed directly in that location, skipping the copy. Rust itself performs some limited RVO, though its style of move semantics makes this a bit less visible.</p> <p>Rust does not give us a good way of accessing the return slot directly, for good reason: it need not have an address! Rust returns all types that look roughly like a single integer in a register (on modern ABIs), and registers don’t have addresses. C++ ABIs typically solve this by making types which are “sufficiently complicated” (usually when they are not trivially moveable) get passed on the stack unconditionally<sup id="fnref:unique-ptr-inefficiency" role="doc-noteref"><a href="#fn:unique-ptr-inefficiency" class="footnote" rel="footnote">6</a></sup>.</p> <p>Since we can’t get at the return slot, we’ll make our own! We just need to pass the pinned <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> memory that we would pass into <code class="language-plaintext highlighter-rouge">Ctor::ctor</code> as a “fake return slot”:</p> <div class="codeblock" id="code:19"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">make_foo</span><span class="p">(</span><span class="n">return_slot</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">Foo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="nf">.ctor</span><span class="p">(</span><span class="n">return_slot</span><span class="p">);</span>
    <span class="n">val</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">x</span><span class="nf">.as_mut_ptr</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:19">Rust</a></div></div> <p>This is such a common operation that it makes sense to replace <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut MaybeUninit&lt;T&gt;&gt;</code> with a specific type, <code class="language-plaintext highlighter-rouge">Slot&lt;'a, T&gt;</code>:</p> <div class="codeblock" id="code:20"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">emplace</span><span class="o">&lt;</span><span class="n">C</span><span class="p">:</span> <span class="n">Ctor</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">C</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">c</span><span class="nf">.ctor</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="p">);</span>
      <span class="n">val</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">x</span><span class="nf">.as_mut_ptr</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">make_foo</span><span class="p">(</span><span class="n">return_slot</span><span class="p">:</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">Foo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">return_slot</span><span class="nf">.emplace</span><span class="p">(</span><span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:20">Rust</a></div></div> <p>We can provide another macro, <code class="language-plaintext highlighter-rouge">slot!()</code>, which reserves pinned space on the stack much like <code class="language-plaintext highlighter-rouge">emplace!()</code> does, but without the construction step. Calling <code class="language-plaintext highlighter-rouge">make_foo</code> only requires minimal ceremony and no user-level <code class="language-plaintext highlighter-rouge">unsafe</code>.</p> <div class="codeblock" id="code:21"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">slot!</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="nf">make_foo</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:21">Rust</a></div></div> <p>The <code class="language-plaintext highlighter-rouge">slot!()</code> macro is almost identical to <a href="https://docs.rs/tokio/1.4.0/tokio/macro.pin.html"><code class="language-plaintext highlighter-rouge">tokio::pin!()</code></a>, except that it doesn’t initialize the stack space with an existing value.</p> <h2 id="towards-move-constructors-copy-constructors"><a href="#towards-move-constructors-copy-constructors">Towards Move Constructors: Copy Constructors</a></h2> <p>Move constructors involve <a href="https://en.cppreference.com/w/cpp/language/reference#Rvalue_references"><em>rvalue references</em></a>, which Rust has no meaningful equivalent for, so we’ll attack the easier version: copy constructors.</p> <p>A copy constructor is C++’s <code class="language-plaintext highlighter-rouge">Clone</code> equivalent, but, like all constructors, is allowed to inspect the address of <code class="language-plaintext highlighter-rouge">*this</code>. Its sole argument is a <code class="language-plaintext highlighter-rouge">const T&amp;</code>, which has a direct Rust analogue: a <code class="language-plaintext highlighter-rouge">&amp;T</code>. Let’s write up a trait that captures this operation:</p> <div class="codeblock" id="code:22"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">trait</span> <span class="n">CopyCtor</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">copy_ctor</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:22">Rust</a></div></div> <p>Unlike <code class="language-plaintext highlighter-rouge">Ctor</code>, we would implement <code class="language-plaintext highlighter-rouge">CopyCtor</code> on the type with the copy constructor, bridging it to C++ as before. We can then define a helper that builds a <code class="language-plaintext highlighter-rouge">Ctor</code> for us:</p> <div class="codeblock" id="code:23"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">copy</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CopyCtor</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Ctor</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">ctor</span><span class="p">::</span><span class="nf">from_placement_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">dest</span><span class="p">|</span> <span class="p">{</span>
      <span class="nn">T</span><span class="p">::</span><span class="nf">copy_ctor</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">emplace!</span><span class="p">(</span><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nf">copy</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>     <span class="c1">// Calls the copy constructor.</span>
<span class="k">let</span> <span class="n">boxed</span> <span class="o">=</span> <span class="nf">make_box</span><span class="p">(</span><span class="nf">copy</span><span class="p">(</span><span class="n">y</span><span class="p">));</span> <span class="c1">// Copy onto the heap.</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:23">Rust</a></div></div> <p>We can could (modulo orphan rules) even implement <code class="language-plaintext highlighter-rouge">CopyCtor</code> for Rust types that implement <code class="language-plaintext highlighter-rouge">Clone</code> by <code class="language-plaintext highlighter-rouge">clone</code>ing into the destination.</p> <p>It should be straightforward to make a version for move construction… but, what’s a <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> in Rust?</p> <h2 id="interlude-ii-unique-ownership"><a href="#interlude-ii-unique-ownership">Interlude II: Unique Ownership</a></h2> <p><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> is interesting, because unlike <code class="language-plaintext highlighter-rouge">&amp;T</code>, it is possible to <em>move out</em> of a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, since the compiler treats it somewhat magically. There has long been a desire to introduce a <code class="language-plaintext highlighter-rouge">DerefMove</code> trait captures this behavior, but the difficulty is the signature: if <code class="language-plaintext highlighter-rouge">deref</code> returns <code class="language-plaintext highlighter-rouge">&amp;T</code>, and <code class="language-plaintext highlighter-rouge">deref_mut</code> returns <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, should <code class="language-plaintext highlighter-rouge">deref_move</code> return <code class="language-plaintext highlighter-rouge">T</code>? Or something… more exotic? You might not want to dump the value onto the stack; you want <code class="language-plaintext highlighter-rouge">*x = *y</code> to not trigger an expensive intermediate copy, when <code class="language-plaintext highlighter-rouge">*y: [u8; BIG]</code>.</p> <p>Usually, the “something more exotic” is a <code class="language-plaintext highlighter-rouge">&amp;move T</code> or <code class="language-plaintext highlighter-rouge">&amp;own T</code> reference that “owns” the pointee, similar to how a <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> in C++ is taken to mean that the caller wishes to perform ownership transfer.</p> <p>Exotic language features aside, we’d like to be able to implement something like <code class="language-plaintext highlighter-rouge">DerefMove</code> for move constructors, since this is the natural analogue of <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>. To move out of storage, we need a smart pointer to provide us with three things:</p> <ul> <li>It must actually be a smart pointer (duh).</li> <li>It must be possible to destroy the storage without running the destructor of the pointee (in Rust, unlike in C++, destructors do not run on moved-from objects).</li> <li>It must be the <em>unique owner</em> of the pointee. Formally, if, when <code class="language-plaintext highlighter-rouge">p</code> goes out of scope, no thread can access <code class="language-plaintext highlighter-rouge">*p</code>, then <code class="language-plaintext highlighter-rouge">p</code> is the unique owner.</li> </ul> <p><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> trivially satisfies all three of these: it’s a smart pointer, we can destroy the storage using <code class="language-plaintext highlighter-rouge">std::alloc::dealloc</code>, and it satisfies the unique ownership property.</p> <p><code class="language-plaintext highlighter-rouge">&amp;mut T</code> fails both tests: we don’t know how to destory the storage (this is one of the difficulties with a theoretical <code class="language-plaintext highlighter-rouge">&amp;move T</code>) and it is not the unique owner: some <code class="language-plaintext highlighter-rouge">&amp;mut T</code> might outlive it.</p> <p>Interestingly, <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> only fails the unique ownership test, and it can pass it dynamically, if we observe the strong and weak counts to both be 1. This is also true for <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>.</p> <p>Most importantly, however, is that if <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>, then it is sufficient that <code class="language-plaintext highlighter-rouge">P</code> satisfy these conditions. After all, a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;P&gt;&gt;</code> uniquely owns its contents, even if they can’t be moved.</p> <p>It’s useful to introduce some traits that record these requirements:</p> <div class="codeblock" id="code:24"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">trait</span> <span class="n">OuterDrop</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">outer_drop</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="k">Self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="n">OuterDrop</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:24">Rust</a></div></div> <p><code class="language-plaintext highlighter-rouge">OuterDrop</code> is simply the “outer storage destruction” operation. Naturally, it is only safe to perform this operation when the pointee’s own destructor has been separately dropped (there are some subtleties around leaking memory here, but in general it’s not a good idea to destroy storage without destroying the pointee, too).</p> <p><code class="language-plaintext highlighter-rouge">DerefMove</code><sup id="fnref:deref-move-proposals" role="doc-noteref"><a href="#fn:deref-move-proposals" class="footnote" rel="footnote">7</a></sup> is the third requirement, which the compiler cannot check (there’s a lot of these, huh?). Any type which implements <code class="language-plaintext highlighter-rouge">DerefMove</code> can be moved out of by carefully dismantling the pointer:</p> <div class="codeblock" id="code:25"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">move_out_of</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">p</span><span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">P</span><span class="p">::</span><span class="n">Target</span>
<span class="k">where</span>
  <span class="n">P</span><span class="p">:</span> <span class="n">DerefMove</span><span class="p">,</span>
  <span class="nn">P</span><span class="p">::</span><span class="n">Target</span><span class="p">:</span> <span class="nb">Sized</span> <span class="o">+</span> <span class="nb">Unpin</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="c1">// Copy the pointee out of `p` (all Rust moves are</span>
    <span class="c1">// trivial copies). We need `Unpin` for this to be safe.</span>
    <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nn">P</span><span class="p">::</span><span class="n">Target</span><span class="p">)</span><span class="nf">.read</span><span class="p">();</span>
    
    <span class="c1">// Destroy `p`'s storage without running the pointee's</span>
    <span class="c1">// destructor.</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">P</span><span class="p">;</span>
    <span class="c1">// Make sure to suppress the actual "complete" destructor of</span>
    <span class="c1">// `p`.</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="c1">// Actually destroy the storage.</span>
    <span class="nn">P</span><span class="p">::</span><span class="nf">outer_drop</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    
    <span class="c1">// Return the moved pointee, which will be trivially NRVO'ed.</span>
    <span class="n">val</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:25">Rust</a></div></div> <p>Much like pinning, we need to lift this capability to the stack somehow. <code class="language-plaintext highlighter-rouge">&amp;mut T</code> won’t cut it here.</p> <h2 id="owning-the-stack"><a href="#owning-the-stack">Owning the Stack</a></h2> <p>We can already speak of uninitialized but uniquely-owned stack memory with <code class="language-plaintext highlighter-rouge">Slot</code>, but <code class="language-plaintext highlighter-rouge">Slot::emplace()</code> returns a (pinned) <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, which cannot be <code class="language-plaintext highlighter-rouge">DerefMove</code>. This operation actually loses the uniqueness information of <code class="language-plaintext highlighter-rouge">Slot</code>, so instead we make <code class="language-plaintext highlighter-rouge">emplace()</code> return a <code class="language-plaintext highlighter-rouge">StackBox</code>.</p> <p>A <code class="language-plaintext highlighter-rouge">StackBox&lt;'a, T&gt;</code> is like a <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> that’s bound to a stack frame, using a <code class="language-plaintext highlighter-rouge">Slot&lt;'a, T&gt;</code> as underlying storage. Although it’s just a <code class="language-plaintext highlighter-rouge">&amp;mut T</code> on the inside, it augments it with the uniqueness invariant above. In particular, <code class="language-plaintext highlighter-rouge">StackBox::drop()</code> is entitled to call the destructor of its pointee in-place.</p> <p>To the surprise of no one who has read this far, <code class="language-plaintext highlighter-rouge">StackBox: DerefMove</code>. The implementation for <code class="language-plaintext highlighter-rouge">StackBox::outer_drop()</code> is a no-op, since the calling convention takes care of destroying stack frames.</p> <p>It makes sense that, since <code class="language-plaintext highlighter-rouge">Slot::emplace()</code> returns a <code class="language-plaintext highlighter-rouge">Pin&lt;StackBox&lt;T&gt;&gt;</code>, so should <code class="language-plaintext highlighter-rouge">emplace!()</code>.</p> <p>(There’s a crate called <a href="https://crates.io/crates/stackbox"><code class="language-plaintext highlighter-rouge">stackbox</code></a> that provides similar <code class="language-plaintext highlighter-rouge">StackBox</code>/<code class="language-plaintext highlighter-rouge">Slot</code> types, although it is implemented slightly differently and does not provide the pinning guarantees we need.)</p> <h2 id="move-constructors"><a href="#move-constructors">Move Constructors</a></h2> <p>This is it. The moment we’ve all be waiting for. Behold, the definition of a move constructor in Rust:</p> <div class="codeblock" id="code:26"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">trait</span> <span class="n">MoveCtor</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">move_ctor</span><span class="p">(</span>
    <span class="n">src</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">,</span>
    <span class="n">dest</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span>
  <span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:26">Rust</a></div></div> <blockquote> <p>Wait, that’s it?</p> </blockquote> <p>There’s no such thing as <code class="language-plaintext highlighter-rouge">&amp;move Self</code>, so, much like <code class="language-plaintext highlighter-rouge">drop()</code>, we have to use a plain ol’ <code class="language-plaintext highlighter-rouge">&amp;mut</code> instead. Like <code class="language-plaintext highlighter-rouge">Drop</code>, and like <code class="language-plaintext highlighter-rouge">CopyCtor</code>, this function is not called directly by users; instead, we provide an adaptor that takes in a <code class="language-plaintext highlighter-rouge">MoveCtor</code> and spits out a <code class="language-plaintext highlighter-rouge">Ctor</code>.</p> <div class="codeblock" id="code:27"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">mov</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">ptr</span><span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Ctor</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="nn">P</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">P</span><span class="p">:</span> <span class="n">DerefMove</span><span class="p">,</span>
  <span class="nn">P</span><span class="p">::</span><span class="n">Target</span><span class="p">:</span> <span class="n">MoveCtor</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="nf">from_placement_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">dest</span><span class="p">|</span> <span class="p">{</span>
      <span class="nn">MoveCtor</span><span class="p">::</span><span class="nf">move_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>

      <span class="c1">// Destroy `p`'s storage without running the pointee's</span>
      <span class="c1">// destructor.</span>
      <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">ptr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">P</span><span class="p">;</span>
      <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
      <span class="nn">P</span><span class="p">::</span><span class="nf">outer_drop</span><span class="p">(</span><span class="n">inner</span><span class="p">);</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:27">Rust</a></div></div> <p>Notice that we no longer require that <code class="language-plaintext highlighter-rouge">P::Target: Unpin</code>, since the <code class="language-plaintext highlighter-rouge">ptr::read()</code> call from <code class="language-plaintext highlighter-rouge">move_out_of()</code> is now gone. Instead, we need to make a specific requirement of <code class="language-plaintext highlighter-rouge">MoveCtor</code> that I will explain shortly. However, we can now freely call the move constructor just like any other <code class="language-plaintext highlighter-rouge">Ctor</code>:</p> <div class="codeblock" id="code:28"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">emplace!</span><span class="p">(</span><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nf">mov</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>  <span class="c1">// Calls the move constructor.</span>
<span class="k">let</span> <span class="n">boxed</span> <span class="o">=</span> <span class="nf">make_box</span><span class="p">(</span><span class="nf">mov</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>  <span class="c1">// Move onto the heap.</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:28">Rust</a></div></div> <h2 id="the-langauge-lawyering-part"><a href="#the-langauge-lawyering-part">The Langauge-Lawyering Part</a></h2> <p>(If you don’t care for language-lawyering, you can skip this part.)</p> <p>Ok. We need to justify the loss of the <code class="language-plaintext highlighter-rouge">P::Target: Unpin</code> bound on <code class="language-plaintext highlighter-rouge">mov()</code>, which seems almost like a contradiction: <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code> guarantees its pointee won’t be moved, but isn’t the whole point of <code class="language-plaintext highlighter-rouge">MoveCtor</code> to perform moves?</p> <p>At the begining of this article, I called out the difference between destructive Rust move and copying C++ moves. The reason that the above isn’t a contradiction is that the occurences of “move” in that sentence refer to these different senses of “move”.</p> <p>The specific thing that <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code> is protecting unsafe code from is whatever state is behind the pointer being blindly <code class="language-plaintext highlighter-rouge">memcpy</code> moved to another location, leaving any self-references in the new location dangling. However, by invoking a C++-style move constructor, the data never “moves” in the Rust sense; it is merely copied in a way that carefully preserves any address-dependent state.</p> <p>We need to ensure two things:</p> <ul> <li>Implementors of <code class="language-plaintext highlighter-rouge">MoveCtor</code> for their own type must ensure that their type does not rely on any pinning guarantees that the move constructor cannot appropriately “fix up”.</li> <li>No generic code can hold onto a reference to moved-from state, because that way they could witness whatever messed-up post-destruction state the move constructor leaves it in.</li> </ul> <p>The first of these is passed onto the implementor as an <code class="language-plaintext highlighter-rouge">unsafe impl</code> requirement. Designing an <code class="language-plaintext highlighter-rouge">!Unpin</code> type by hand is difficult, and auto-generated C++ bindings using this model would hopefully inherit move-correctness from the C++ code itself.</p> <p>The second is more subtle. In the C++ model, the moved-from value is mutated to mark it as “moved from”, which usually just inhibits the destructor. C++ believes all destructors are run for all objects. For example, <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> sets the moved-from value to <code class="language-plaintext highlighter-rouge">nullptr</code>, so that the destructor can be run at the end of scope and do nothing. Compare with the Rust model, where the compiler inhibits the destructor automatically through the use of drop flags.</p> <p>In order to support move-constructing both Rust and C++ typed through a uniform interface, <code class="language-plaintext highlighter-rouge">move_ctor</code> is a fused destructor/copy operation. In the Rust case, no “destructor” is run, but in the C++ case we are required to run a destructor. Although this changes the semantic ordering of destruction compared to the equivalent C++ program, in practice, no one depends on moved-from objects actually being destroyed (that I know of).</p> <p>After <code class="language-plaintext highlighter-rouge">move_ctor</code> is called, <code class="language-plaintext highlighter-rouge">src</code> must be treated as if it had just been destroyed. This means that the storage for <code class="language-plaintext highlighter-rouge">src</code> must be disposed of immediately, without running any destructors for the pointed-to value. Thus, no one must be able to witness the messed-up pinned state, which is why <code class="language-plaintext highlighter-rouge">mov()</code> requires <code class="language-plaintext highlighter-rouge">P: DerefMove</code>.</p> <p>Thus, no code currently observing <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code> invariants in unsafe code will notice anything untoward going on. No destructive moves happen, and no moved-from state is able to hang around.</p> <hr/> <p>I’m pretty confident this argument is correct, but I’d appreciate some confirmation. In particular, someone involved in the UCG WG or the Async WG will have to point out if there are any holes.</p> <h2 id="the-upshot"><a href="#the-upshot">The Upshot</a></h2> <p>In the end, we don’t <em>just</em> have a move constructors story, but a story for all kinds of construction, C++-style. Not only that, but we have almost natural syntax:</p> <div class="codeblock" id="code:29"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">emplace!</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">ctor</span><span class="p">::</span><span class="nf">mov</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">ctor</span><span class="p">::</span><span class="nf">copy</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// The make_box() example above can be added to `Box` through</span>
<span class="c1">// an extension trait.</span>
<span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">emplace</span><span class="p">(</span><span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:29">Rust</a></div></div> <p>As far as I can tell, having some kind of “magic” around stack emplacement is unavoidable; this is a place where the language is unlikely to give us enough flexibility any time soon, though this concept of constructors is the first step towards such a thing.</p> <p>We can call into C++ from Rust without any heap allocations at all (though maybe wasting an instruction or two shunting pointers across registers for our not-RVO):</p> <div class="codeblock" id="code:30"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="cd">/// Generated Rust type for bridging to C++, like you might get from `cxx`.</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Ctor</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_x</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">make_foo</span><span class="p">(</span><span class="n">out</span><span class="p">:</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">StackBox</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">out</span><span class="nf">.emplace</span><span class="p">(</span><span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
  <span class="n">foo</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.set_x</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">foo</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button codeblock-anchor" href="#code:30">Rust</a></div></div> <p>For when dealing with slots explicitly is too much work, types can just be <code class="language-plaintext highlighter-rouge">ctor::mov</code>ed into a <code class="language-plaintext highlighter-rouge">Box</code> with <code class="language-plaintext highlighter-rouge">Box::emplace</code>.</p> <p>I’ve implemented everything discussed in this post in a crate, <a href="https://crates.io/crates/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a>. Contributions and corrections are welcome.</p> <p>A thanks to Manish Goregaokar, Alyssa Haroldson, and Adrian Taylor for feedback on early versions of this design.</p> <h2 id="future-work"><a href="#future-work">Future Work</a></h2> <p>This is only the beginning: much work needs to be done in type design to have a good story for bridging move-only types from C++ to Rust, preferably automatically. <code class="language-plaintext highlighter-rouge">Ctor</code>s are merely the theoretical foundation for building a more ergonomic FFI; usage patterns will likely determine where to go from here.</p> <p>Open questions such as “how to containers” remain. Much like C++03’s <code class="language-plaintext highlighter-rouge">std::auto_ptr</code>, we have no hope of putting a <code class="language-plaintext highlighter-rouge">StackBox&lt;T&gt;</code> into a <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>, and we’ll need to design a <code class="language-plaintext highlighter-rouge">Vec</code> variant that knows to call move constructors when resizing and copy constructors when cloning. There’s also no support for custom move/copy assignment beyond the trivial <code class="language-plaintext highlighter-rouge">new (this) auto(that)</code> pattern, and it’s unclear whether that’s useful. Do we want to port a constructor-friendly <code class="language-plaintext highlighter-rouge">HashMap</code> (Rust’s swisstable implementation)? Do we want to come up with macros that make dealing with <code class="language-plaintext highlighter-rouge">Slot</code> out-params less cumbersome?</p> <p>Personally, I’m excited. This feels like a real breakthrough in one of the biggest questions for true Rust/C++ interop, and I’d like to see what people wind up building on top of it.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:cc-replacement" role="doc-endnote"> <p>This isn’t exactly a <em>universal</em> opinion <em>glances at Swift</em> but it is if you write kernel code like me. <a href="#fnref:cc-replacement" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:bindgen" role="doc-endnote"> <p>You can’t just have rustc consume a <code class="language-plaintext highlighter-rouge">.h</code> and spit out bindings, like e.g. Go can, but it’s better than the disaster that is JNI. <a href="#fnref:bindgen" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:relocatable" role="doc-endnote"> <p>Some WG21 folks have tried to introduce a weaker type-trait, <code class="language-plaintext highlighter-rouge">std::is_trivially_relocatable</code>, which is a weakening of trivally moveable that permits a Rust-style destructive move. The libc++ implementation of most STL types, like <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>, admit this trait. <a href="#fnref:relocatable" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:swappy" role="doc-endnote"> <p>A lot of unsafe Rust code assumes this is the only kind of move. For example, <a href="https://doc.rust-lang.org/std/mem/fn.swap.html"><code class="language-plaintext highlighter-rouge">mem::swap()</code></a> is implemented using <code class="language-plaintext highlighter-rouge">memcpy</code>. This is unlike the situation in C++, where types will often provide custom <code class="language-plaintext highlighter-rouge">std::swap()</code> implementations that preserve type invariants. <a href="#fnref:swappy" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:pinned-futures" role="doc-endnote"> <p>Because <code class="language-plaintext highlighter-rouge">Future</code> objects collapse their stack state into themselves when yielding, they may have pointers into themselves (as a stack typically does). Thus, <code class="language-plaintext highlighter-rouge">Future</code>s need to be guaranteed to never move once they begin executing, since Rust has no move constructors and no way to fix up the self-pointers. <a href="#fnref:pinned-futures" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unique-ptr-inefficiency" role="doc-endnote"> <p>Among other things, this means that <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>s are passed on the stack, not in a register, which is very wasteful! Rust’s <code class="language-plaintext highlighter-rouge">Box</code> does not have this issue. <a href="#fnref:unique-ptr-inefficiency" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deref-move-proposals" role="doc-endnote"> <p>Rust has attempted to add something like <code class="language-plaintext highlighter-rouge">DerefMove</code> many times. What’s described in this post is nowhere near as powerful as a “real” <code class="language-plaintext highlighter-rouge">DerefMove</code> would be, since such a thing would also allow moving <em>into</em> a memory location. <a href="#fnref:deref-move-proposals" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> &copy; 2025 Miguel Young de la Sota <br> <div style="font-size: 95%;"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> </div> </div> </div> </body> </html>