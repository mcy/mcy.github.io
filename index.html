<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-15 • 804 words • 6 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/15/protobuf-tip-2/"> Protobuf Tip #2: Compress Your Protos! </a></h1> </div> <div class="post"> <p><em>As a matter of fact, when compression technology came along, we thought the future in 1996 was about voice. We got it wrong. It is about voice, video, and data, and that is what we have today on these cell phones. –Steve Buyer</em></p> <p>TL;DR: Compression is everywhere: CDNs, HTTP servers, even in RPC frameworks like Connect. This pervasiveness means that wire size tradeoffs matter less than they used to twenty years ago, when Protobuf was designed.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-2-compress-protos">buf.build blog</a>.</p> </blockquote> <h2 id="varints-from-1998"><a href="#varints-from-1998">Varints from 1998</a></h2> <p>Protobuf’s wire format is intended to be relatively small. It makes use of <em>variable-width integers</em> so that smaller values take up less space on the wire. Fixed width integers might be larger on the wire, but often have faster decoding times.</p> <p>But what if I told you that doesn’t matter?</p> <p>See, most internet traffic is compressed. Bandwidth is precious, and CDN operators don’t want to waste time sending big blobs full of zeros. There are many compression algorithms available, but the state of the art for HTTP requests (which dominates much of global internet traffic) is <a href="https://en.wikipedia.org/wiki/Brotli">Brotli</a>, an algorithm developed at Google in 2013 and standardized in IETF <a href="https://datatracker.ietf.org/doc/html/rfc7932">RFC7932</a> in 2016. There is a very good chance that this article was delivered to your web browser as a Brotli-compressed blob.</p> <h2 id="using-compression"><a href="#using-compression">Using Compression</a></h2> <p>How compression is applied in your case will vary, but both Connect RPC and gRPC support native compression. For example, Connect has an API for injecting compression providers: <a href="https://pkg.go.dev/connectrpc.com/connect#WithCompression">https://pkg.go.dev/connectrpc.com/connect#WithCompression</a>.</p> <p>Connect uses <code class="language-plaintext highlighter-rouge">gzip</code> by default, which uses the DEFLATE compression algorithm. Providing your own compression algorithm (such as Brotli) is pretty simple, as shown by <a href="https://github.com/mattrobenolt/connect-brotli/blob/921ee0236bcd2d66827590c6890bb850e56516ad/connect_brotli.go">this third-party package</a>.</p> <p>Other services may compress for you transparently. Any competent CDN will likely use Brotli (or <code class="language-plaintext highlighter-rouge">gzip</code> or <code class="language-plaintext highlighter-rouge">zlib</code>, but probably Brotli) to compress any files it serves for you. (In fact, JavaScript and HTML minimization can often be rendered irrelevant by HTTP compression, too.)</p> <p>It’s important to remember that Protobuf predates pervasive compression: if it didn’t, it would almost certainly not use variable-width integers for anything. It only uses them because they offer a primitive form of compression in exchange for being slower to decode. If that tradeoff was eliminated, Protobuf would almost certainly only use fixed-width integers on the wire.</p> <h2 id="how-good-is-it-really"><a href="#how-good-is-it-really">How Good Is It Really?</a></h2> <p>Let’s do some apples-to-apples comparisons. Consider the following Protobuf type.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
	<span class="k">repeated</span> <span class="kt">int32</span> <span class="na">varints</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">repeated</span> <span class="kt">sfixed32</span> <span class="na">fixeds</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>There are two fields that contain essentially the same data, which can be encoded in four different ways: as old-style repeated fields, as packed fields, and the integers can be encoded as varints or fixed32 values.</p> <p>Using <a href="https://github.com/protocolbuffers/protoscope">Protoscope</a>, we can create some data that exercises these four cases:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># a.pb, repeated varint
</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">2</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">3</span>
<span class="c1"># ...
</span>
<span class="c1"># b.pb, packed varint
</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
  <span class="c1"># ...
</span><span class="p">}</span>

<span class="c1"># c.pb, repeated fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="n">i32</span>

<span class="c1"># d.pb, packed fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span><span class="n">i32</span> <span class="mi">2</span><span class="n">i32</span> <span class="mi">3</span><span class="n">i32</span>
  <span class="c1"># ...
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protoscope</div></div></div> <p>Each blob contains the integers from 1 to 1000 encoded in different ways. I’ll compress each one using gzip, zlib, and Brotli, using their default compression levels, and arrange their sizes, in bytes, in the table below.</p> <table> <thead> <tr> <th>File</th> <th>Uncompressed</th> <th><code class="language-plaintext highlighter-rouge">gzip</code> (DEFLATE)</th> <th><code class="language-plaintext highlighter-rouge">zlib</code></th> <th>Brotli</th> </tr> </thead> <tbody> <tr> <td>a.pb</td> <td>2875</td> <td>1899</td> <td>1878</td> <td>1094</td> </tr> <tr> <td>b.pb</td> <td>1877</td> <td>1534</td> <td>1524</td> <td>885</td> </tr> <tr> <td>c.pb</td> <td>5005</td> <td>1577</td> <td>1567</td> <td>1140</td> </tr> <tr> <td>d.pb</td> <td>4007</td> <td>1440</td> <td>1916</td> <td>1140</td> </tr> </tbody> </table> <p>Compression achieves incredible results: Brotli manages to get all of the files down to around 1.1 kB, except for the packed varints, which it gets about 250 bytes smaller! Of course, that’s only because most of the values in that repeated field are small. If the values range from 100000 to 101000, b.pb and d.pb are 3006 and 4007 bytes respectively (see that d.pb’s size is unchanged!), but when compressed with brotli, the lead for b.pb starts to disappear: 1039 bytes vs. 1163 bytes. Now it’s only 120 bytes smaller.</p> <h2 id="are-varints-still-better"><a href="#are-varints-still-better">Are Varints Still Better?</a></h2> <p>Applying compression can often have similar results to replacing everything with varints, but not exactly: using a varint will likely always be slightly smaller, at least when using state-of-the-art compression like Brotli. But you can pretty much always assume you <em>will</em> be using compression, such as to compress HTTP headers and other ancillary content in your request. Compression is generic and highly optimized—it applies to all data, regardless of schema, and is often far more optimized than application-level codecs like those in a Protobuf library.</p> <p>Not to mention, you should definitely be compressing any large data blobs you’re storing on disk, too!</p> <p>As a result, you can usually disregard many encoded size concerns when making tradeoffs in designing a Protobuf type. Fixed integer types will decode faster, so if decoding speed is important to you, and you’re worried about the size on the wire, don’t. It’s almost certainly already taken care of at a different layer of the stack.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-14 • 4177 words • 34 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> </span> <h1><a href="/2025/04/14/target-triples/"> What the Hell Is a Target Triple? </a></h1> </div> <div class="post"> <p><em>Cross-compiling</em> is taking a computer program and compiling it for a machine that isn’t the one hosting the compilation. Although historically compilers would only compile for the host machine, this is considered an anachronism: all serious native compilers are now cross-compilers.</p> <p>After all, you don’t want to be building your iPhone app on literal iPhone hardware.</p> <p>Many different compilers have different mechanisms for classifying and identifying <em>targets</em>. A target is a platform that the compiler can produce executable code for. However, due to the runaway popularity of LLVM, virtually all compilers now use <em>target triples</em>. You may have already encountered one, such as the venerable <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code>, or the evil <code class="language-plaintext highlighter-rouge">x86_64-pc-windows</code>. This system is convoluted and <em>almost</em> self-consistent.</p> <p>But what is a target triple, and where did they come from?</p> <h2 id="stupid-gcc-conventions"><a href="#stupid-gcc-conventions">Stupid GCC Conventions</a></h2> <p>So if you go poking around the <a href="https://wiki.osdev.org/Target_Triplet">Target Triplet</a> page on OSDev, you will learn both true and false things about target triples, because this page is about GCC, not native compilers in general.</p> <blockquote> <p>Generally, there is no “ground truth” for what a target triple is. There isn’t some standards body that assigns these names. But as we’ll see, LLVM is the trendsetter.</p> </blockquote> <p>If you run the following command you can learn the target triple for your machine:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>gcc <span class="nt">-dumpmachine</span>
<span class="go">x86_64-linux-gnu</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Now if you’re at all familiar with any system that makes pervasive use of target triples, you will know that this is <em>not a target triple</em>, because this target’s name is <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-gnu</code>, which is what both <code class="language-plaintext highlighter-rouge">clang</code> and <code class="language-plaintext highlighter-rouge">rustc</code> call-</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>clang <span class="nt">-dumpmachine</span>
<span class="go">x86_64-pc-linux-gnu
</span><span class="gp">$</span><span class="w"> </span>rustc <span class="nt">-vV</span> | <span class="nb">grep </span>host
<span class="go">host: x86_64-unknown-linux-gnu</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Oh no.</p> <p>Well, GCC is missing the the <code class="language-plaintext highlighter-rouge">pc</code> or <code class="language-plaintext highlighter-rouge">unknown</code> component, and that’s specifically a GCC thing; it allows omitting parts of the triple in such a way that is unambiguous. And they are a GCC invention, so perhaps it’s best to start by assessing GCC’s beliefs.</p> <p>According to GCC, a target triple is a string of the form <code class="language-plaintext highlighter-rouge">&lt;machine&gt;-&lt;vendor&gt;-&lt;os&gt;</code>. The “machine” part unambiguously identifies the architecture of the system. Practically speaking, this is the assembly language that the compiler will output at the end. The “vendor” part is essentially irrelevant, and mostly is of benefit for sorting related operating systems together. Finally, the “os” part identifies the operating system that this code is being compiled for. The main thing this identifies for a compiler is the executable format: COFF/PE for Windows, Mach-O for Apple’s operating systems, ELF for Linux and friends, and so on (this, however, is an oversimplification).</p> <p>But you may notice that <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-gnu</code> has an extra, fourth entry<sup id="fnref:quad" role="doc-noteref"><a href="#fn:quad" class="footnote" rel="footnote">1</a></sup>, which plays many roles but is most often called the target’s “ABI”. For <code class="language-plaintext highlighter-rouge">linux</code>, it identifies the target’s libc, which has consequences for code generation of some language features, such as thread locals and unwinding. It is optional, since many targets only have one ABI.</p> <h3 id="cross-compiling-with-gcc"><a href="#cross-compiling-with-gcc">Cross Compiling with GCC</a></h3> <p>A critical piece of history here is to understand the really stupid way in which GCC does cross compiling. Traditionally, each GCC binary would be built for <em>one</em> target triple. The full name of a GCC binary would include the triple, so when cross-compiling, you would compile with <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-gcc</code>, link with <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux-ld</code>, and so on (here, <code class="language-plaintext highlighter-rouge">gcc</code> is not the fourth ABI component of a triple; it’s just one of the tools in the <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code> toolchain).</p> <p>Nobody with a brain does this<sup id="fnref:toolchain" role="doc-noteref"><a href="#fn:toolchain" class="footnote" rel="footnote">2</a></sup>. LLVM and all cross compilers that follow it instead put all of the backends in one binary, and use a compiler flag like <code class="language-plaintext highlighter-rouge">--target</code> to select the backend.</p> <p>But regardless, this is where target triples come from, and why they look the way they look: they began as prefixes for the names of binaries in <code class="language-plaintext highlighter-rouge">autoconf</code> scripts.</p> <p>But GCC is ancient technology. In the 21st century, LLVM rules all native compilers.</p> <h2 id="names-in-the-ancient-language"><a href="#names-in-the-ancient-language">Names in the Ancient Language</a></h2> <p>LLVM’s target triple list is the one that should be regarded as “most official”, for a few reasons:</p> <ol> <li> <p>Inertia. Everyone and their mother uses LLVM as a middleend and backend, so its naming conventions bubble up into language frontends like <code class="language-plaintext highlighter-rouge">clang</code>, <code class="language-plaintext highlighter-rouge">rustc</code> <code class="language-plaintext highlighter-rouge">swiftc</code>, <code class="language-plaintext highlighter-rouge">icc</code>, and <code class="language-plaintext highlighter-rouge">nvcc</code>.</p> </li> <li> <p>Upstream work by silicon and operating system vendors. LLVM is what people get hired to work on for the most part, not GCC, so its platform-specific conventions often reflect the preferences of vendors.</p> </li> </ol> <p>These are in no small part because Apple, Google, and Nvidia have armies of compiler engineers contributing to LLVM.</p> <p>The sources for “official” target triples are many. Generally, I would describe a target triple as “official” when:</p> <ol> <li> <p>A major compiler (so, <code class="language-plaintext highlighter-rouge">clang</code> or <code class="language-plaintext highlighter-rouge">rustc</code>) uses it. Rust does a way better job than LLVM of documenting their targets, so I prefer to give it deference. You can find Rust’s official triples <a href="https://doc.rust-lang.org/rustc/platform-support.html">here</a>.</p> </li> <li> <p>A platform developer (e.g., a hardware manufacturer, OS vendor) distributes a toolchain with a target triple in the <code class="language-plaintext highlighter-rouge">arch-vendor-os</code> format.</p> </li> </ol> <p>So, what are the names in class (1)? LLVM does not really go out of its way to provide such a list. But we gotta start somewhere, so source-diving it is.</p> <p>We can dig into <a href="https://llvm.org/doxygen/Triple_8cpp_source.html"><code class="language-plaintext highlighter-rouge">Triple.cpp</code></a> in LLVM’s target triple parser. It lists all of the names LLVM recognizes for each part of a triple. Looking at <code class="language-plaintext highlighter-rouge">Triple::parseArch()</code>, we have the following names, including many, many aliases. The first item on the right column is LLVM’s preferred name for the architecture, as indicated by <code class="language-plaintext highlighter-rouge">Triple::getArchTypeName()</code>.</p> <table> <thead> <tr> <th>Architecture</th> <th>Possible Names</th> </tr> </thead> <tbody> <tr> <td><a href="https://en.wikipedia.org/wiki/X86">Intel x86</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">i386</code>, <code class="language-plaintext highlighter-rouge">i486</code>, <code class="language-plaintext highlighter-rouge">i586</code>, <code class="language-plaintext highlighter-rouge">i686</code>, <code class="language-plaintext highlighter-rouge">i786</code>, <code class="language-plaintext highlighter-rouge">i886</code>, <code class="language-plaintext highlighter-rouge">i986</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/X86">Intel x86</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">x86_64</code>, <code class="language-plaintext highlighter-rouge">amd64</code>, <code class="language-plaintext highlighter-rouge">x86_86h</code><sup id="fnref:x86_86h" role="doc-noteref"><a href="#fn:x86_86h" class="footnote" rel="footnote">3</a></sup></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">arm</code>, <code class="language-plaintext highlighter-rouge">xscale</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (32-bit, big-endian)</td> <td><code class="language-plaintext highlighter-rouge">armeb</code>, <code class="language-plaintext highlighter-rouge">xscaleeb</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">aarch64</code>, <code class="language-plaintext highlighter-rouge">aarch64e</code>, <code class="language-plaintext highlighter-rouge">aarch64ec</code>, <code class="language-plaintext highlighter-rouge">arm64</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (64-bit, big-endian)</td> <td><code class="language-plaintext highlighter-rouge">aarch64_be</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">ARM</a> (64-bit, ILP32<sup id="fnref:ilp32" role="doc-noteref"><a href="#fn:ilp32" class="footnote" rel="footnote">4</a></sup>)</td> <td><code class="language-plaintext highlighter-rouge">aarch64_32</code>, <code class="language-plaintext highlighter-rouge">arm64_32</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Thumb">ARM Thumb</a></td> <td><code class="language-plaintext highlighter-rouge">thumb</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Thumb">ARM Thumb</a> (big-endian)</td> <td><code class="language-plaintext highlighter-rouge">thumbeb</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a><sup id="fnref:power" role="doc-noteref"><a href="#fn:power" class="footnote" rel="footnote">5</a></sup> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">powerpc</code>, <code class="language-plaintext highlighter-rouge">powerpcspe</code>, <code class="language-plaintext highlighter-rouge">ppc</code>, <code class="language-plaintext highlighter-rouge">ppc32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a> (little-endian)</td> <td><code class="language-plaintext highlighter-rouge">powerpcle</code>, <code class="language-plaintext highlighter-rouge">ppcle</code>, <code class="language-plaintext highlighter-rouge">ppc32le</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">powerpc64</code>, <code class="language-plaintext highlighter-rouge">ppu</code>, <code class="language-plaintext highlighter-rouge">ppc64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/PowerPC">IBM PowerPC</a> (64-bit, little-endian)</td> <td><code class="language-plaintext highlighter-rouge">powerpc64le</code>, <code class="language-plaintext highlighter-rouge">ppc64le</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">mips</code>, <code class="language-plaintext highlighter-rouge">mipseb</code>, <code class="language-plaintext highlighter-rouge">mipsallegrex</code>, <code class="language-plaintext highlighter-rouge">mipsisa32r6</code>, <code class="language-plaintext highlighter-rouge">mipsr6</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (32-bit, little-endian)</td> <td><code class="language-plaintext highlighter-rouge">mipsel</code>, <code class="language-plaintext highlighter-rouge">mipsallegrexel</code>, <code class="language-plaintext highlighter-rouge">mipsisa32r6el</code>, <code class="language-plaintext highlighter-rouge">mipsr6el</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">mips64</code>, <code class="language-plaintext highlighter-rouge">mips64eb</code>, <code class="language-plaintext highlighter-rouge">mipsn32</code>, <code class="language-plaintext highlighter-rouge">mipsisa64r6</code>, <code class="language-plaintext highlighter-rouge">mips64r6</code>, <code class="language-plaintext highlighter-rouge">mipsn32r6</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> (64-bit, little-endian)</td> <td><code class="language-plaintext highlighter-rouge">mips64el</code>, <code class="language-plaintext highlighter-rouge">mipsn32el</code>, <code class="language-plaintext highlighter-rouge">mipsisa64r6el</code>, <code class="language-plaintext highlighter-rouge">mips64r6el</code>, <code class="language-plaintext highlighter-rouge">mipsn32r6el</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">riscv32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">riscv64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Z/Architecture">IBM z/Architecture</a></td> <td><code class="language-plaintext highlighter-rouge">s390x</code><sup id="fnref:s390x" role="doc-noteref"><a href="#fn:s390x" class="footnote" rel="footnote">6</a></sup>, <code class="language-plaintext highlighter-rouge">systemz</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a></td> <td><code class="language-plaintext highlighter-rouge">sparc</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a> (little-endian)</td> <td><code class="language-plaintext highlighter-rouge">sparcel</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">sparcv6</code>, <code class="language-plaintext highlighter-rouge">sparc64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">wasm32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">wasm64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Loongson">Loongson</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">loongarch32</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Loongson">Loongson</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">loongarch64</code></td> </tr> </tbody> <tbody> <tr> <td><a href="https://en.wikipedia.org/wiki/Radeon_HD_2000_series">Radeon R600</a></td> <td><code class="language-plaintext highlighter-rouge">r600</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Graphics_Core_Next">AMD GCN</a></td> <td><code class="language-plaintext highlighter-rouge">amdgcn</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Qualcomm_Hexagon">Qualcomm Hexagon</a></td> <td><code class="language-plaintext highlighter-rouge">hexagon</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Parallel_Thread_Execution">Nvidia PTX</a><sup id="fnref:ptx" role="doc-noteref"><a href="#fn:ptx" class="footnote" rel="footnote">7</a></sup> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">nvptx</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Parallel_Thread_Execution">Nvidia PTX</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">nvptx64</code></td> </tr> <tr> <td>AMD IL<sup id="fnref:amdil" role="doc-noteref"><a href="#fn:amdil" class="footnote" rel="footnote">8</a></sup> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">amdil</code></td> </tr> <tr> <td>AMD IL (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">amdil64</code></td> </tr> <tr> <td>Direct-X IL</td> <td><code class="language-plaintext highlighter-rouge">dxil</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Heterogeneous_System_Architecture">HSAIL</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">hsail</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Heterogeneous_System_Architecture">HSAIL</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">hsail64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">spir</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">spir64</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR-V</a></td> <td><code class="language-plaintext highlighter-rouge">spirv</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR-V</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">spirv32</code>, …</td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">Khronos SPIR-V</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">spirv64</code>, …</td> </tr> <tr> <td><a href="https://developer.android.com/guide/topics/renderscript/compute">Android RenderScript</a> (32-bit)</td> <td><code class="language-plaintext highlighter-rouge">renderscript32</code></td> </tr> <tr> <td><a href="https://developer.android.com/guide/topics/renderscript/compute">Android RenderScript</a> (64-bit)</td> <td><code class="language-plaintext highlighter-rouge">renderscript64</code></td> </tr> <tr> <td><a href="https://en.wikichip.org/wiki/movidius/microarchitectures/shave_v2.0">Movidius SHAVE</a></td> <td><code class="language-plaintext highlighter-rouge">shave</code></td> </tr> </tbody> <tbody> <tr> <td><a href="https://en.wikipedia.org/wiki/AVR_microcontrollers">Atmel AVR</a></td> <td><code class="language-plaintext highlighter-rouge">avr</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Motorola_68000_series">Motorola 68k</a></td> <td><code class="language-plaintext highlighter-rouge">m68k</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/ARC_(processor)">Argonaut ARC</a></td> <td><code class="language-plaintext highlighter-rouge">arc</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/TI_MSP430">Texas Instruments MSP430</a></td> <td><code class="language-plaintext highlighter-rouge">msp430</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Tensilica">Tensilica Xtensa</a></td> <td><code class="language-plaintext highlighter-rouge">xtensa</code></td> </tr> <tr> <td><a href="https://c-sky.github.io/">C-SKY</a></td> <td><code class="language-plaintext highlighter-rouge">csky</code></td> </tr> <tr> <td><a href="https://github.com/cpc/openasip">OpenASIP</a></td> <td><code class="language-plaintext highlighter-rouge">tce</code></td> </tr> <tr> <td><a href="https://github.com/cpc/openasip">OpenASIP</a> (little-endian)</td> <td><code class="language-plaintext highlighter-rouge">tcele</code></td> </tr> <tr> <td><a href="https://q3k.org/lanai.html">Myracom Lanai</a></td> <td><code class="language-plaintext highlighter-rouge">lanai</code></td> </tr> <tr> <td>XMOS xCore</td> <td><code class="language-plaintext highlighter-rouge">xcore</code></td> </tr> <tr> <td>Kalimba<sup id="fnref:idk" role="doc-noteref"><a href="#fn:idk" class="footnote" rel="footnote">9</a></sup></td> <td><code class="language-plaintext highlighter-rouge">kalimba</code></td> </tr> <tr> <td>VE<sup id="fnref:idk:1" role="doc-noteref"><a href="#fn:idk" class="footnote" rel="footnote">9</a></sup></td> <td><code class="language-plaintext highlighter-rouge">ve</code></td> </tr> </tbody> </table> <p>Here we begin to see that target triples are not a neat system. They are <em>hell</em>. Where a list of architecture names contains a “…”, it means that LLVM accepts many more names.</p> <p>The problem is that architectures often have <em>versions</em> and <em>features</em>, which subtly change how the compiler generates code. For example, when compiling for an <code class="language-plaintext highlighter-rouge">x86_64</code>, we may want to specify that we want AVX512 instructions to be used. On LLVM, you might do that with <code class="language-plaintext highlighter-rouge">-mattr=+avx512</code>. Every architecture has a subtly-different way of doing this, because every architecture had a <em>different GCC</em>! Each variant of GCC would put different things behind <code class="language-plaintext highlighter-rouge">-mXXX</code> flags (<code class="language-plaintext highlighter-rouge">-m</code> for “machine”), meaning that the interface is not actually that uniform. The meanings of <code class="language-plaintext highlighter-rouge">-march</code>, <code class="language-plaintext highlighter-rouge">-mcpu</code>, <code class="language-plaintext highlighter-rouge">-mtune</code>, and <code class="language-plaintext highlighter-rouge">-mattr</code> thus vary wildly for this reason.</p> <p>Because LLVM is supposed to replace GCC (for the most part), it replicates a lot of this wacky behavior.</p> <p>So uh, we gotta talk about 32-bit ARM architecture names.</p> <h3 id="armtargetparsercpp"><a href="#armtargetparsercpp"><code class="language-plaintext highlighter-rouge">ARMTargetParser.cpp</code></a></h3> <p>There is a hellish file in LLVM dedicated to parsing ARM architecture names. Although members of the ARM family have many configurable features (which you can discover with <code class="language-plaintext highlighter-rouge">llc -march aarch64 -mattr help</code><sup id="fnref:llc" role="doc-noteref"><a href="#fn:llc" class="footnote" rel="footnote">10</a></sup>), the name of the architecture is somewhat meaningful, and can hav many options, mostly relating to the many versions of ARM that exist.</p> <p>How bad is it? Well, we can look at all of the various ARM targets that <code class="language-plaintext highlighter-rouge">rustc</code> supports with <code class="language-plaintext highlighter-rouge">rustc --print target-list</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>rustc <span class="nt">--print</span> target-list | <span class="nb">grep</span> <span class="nt">-P</span> <span class="s1">'arm|aarch|thumb'</span> <span class="se">\</span>
<span class="go">  | cut -d- -f1 | sort | uniq
aarch64
aarch64_be
arm
arm64_32
arm64e
arm64ec
armeb
armebv7r
armv4t
armv5te
armv6
armv6k
armv7
armv7a
armv7k
armv7r
armv7s
armv8r
thumbv4t
thumbv5te
thumbv6m
thumbv7a
thumbv7em
thumbv7m
thumbv7neon
thumbv8m.base
thumbv8m.main</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Most of these are 32-bit ARM versions, with profile information attached. These correspond to the names given <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Cores">here</a>. Why does ARM stick version numbers in the architecture name, instead of using <code class="language-plaintext highlighter-rouge">-mcpu</code> like you would on x86 (e.g. <code class="language-plaintext highlighter-rouge">-mcpu alderlake</code>)? I have no idea, because ARM is not my strong suit. It’s likely because of how early ARM support was added to GCC.</p> <p>Internally, LLVM calls these “subarchitectures”, although ARM gets special handling because there’s so many variants. SPIR-V, Direct X, and MIPS all have subarchitectures, so you might see something like <code class="language-plaintext highlighter-rouge">dxilv1.7</code> if you’re having a bad day.</p> <p>Of course, LLVM’s ARM support also sports some naughty subarchitectures not part of this system, with naughty made up names.</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">arm64e</code> is an Apple thing, which is an enhancement of <code class="language-plaintext highlighter-rouge">aarch64</code> present on some Apple hardware, which adds their own flavor of <a href="https://developer.apple.com/documentation/security/preparing-your-app-to-work-with-pointer-authentication">pointer authentication</a> and some other features.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">arm64ec</code> is a completely unrelated Microsoft invention that is essentially “<code class="language-plaintext highlighter-rouge">aarch64</code> but with an <code class="language-plaintext highlighter-rouge">x86_64</code>-ey ABI” to make <code class="language-plaintext highlighter-rouge">x86_64</code> emulation on what would otherwise be <code class="language-plaintext highlighter-rouge">aarch64-pc-windows-msvc</code> target somewhat more amenable.</p> </li> </ul> <blockquote> <p>Why the Windows people invented a whole other ABI instead of making things clean and simple like Apple did with Rosetta on ARM MacBooks? I have no idea, but <a href="http://www.emulators.com/docs/abc_arm64ec_explained.htm">http://www.emulators.com/docs/abc_arm64ec_explained.htm</a> contains various excuses, none of which I am impressed by. My read is that their compiler org was just worse at life than Apple’s, which is not surprising, since Apple does compilers better than anyone else in the business.</p> </blockquote> <p>Actually, since we’re on the topic of the names of architectures, I have a few things I need to straighten out.</p> <h3 id="made-up-names-of-architectures"><a href="#made-up-names-of-architectures">Made Up Names of Architectures</a></h3> <p>x86 and ARM both seem to attract a lot of people making up nicknames for them, which leads to a lot of confusion in:</p> <ol> <li> <p>What the “real” name is.</p> </li> <li> <p>What name a particular toolchain wants.</p> </li> <li> <p>What name you should use in your own cosmopolitan tooling.</p> </li> </ol> <p>Let’s talk about the incorrect names people like to make up for them. Please consider the following a relatively normative reference on what people call these architectures, based on my own experience with many tools.</p> <p>When we say “x86” unqualified, in 2025, we almost always mean <code class="language-plaintext highlighter-rouge">x86_64</code>, because 32-bit x86 is dead. If you need to talk about 32-bit x86, you should either say “32-bit x86”, “protected mode”<sup id="fnref:x86-modes" role="doc-noteref"><a href="#fn:x86-modes" class="footnote" rel="footnote">11</a></sup>, or “i386” (the first Intel microarchitecture that implemented protected mode)<sup id="fnref:i386" role="doc-noteref"><a href="#fn:i386" class="footnote" rel="footnote">12</a></sup>. You should not call it <code class="language-plaintext highlighter-rouge">x86_32</code> or just <code class="language-plaintext highlighter-rouge">x86</code>.</p> <p>You might also call it IA-32 for Intel Architecture 32, (or <code class="language-plaintext highlighter-rouge">ia32</code>), but nobody calls it that and you risk confusing people with <code class="language-plaintext highlighter-rouge">ia64</code>, or IA-64, the official name of Intel’s failed general-purpose VLIW architecture, <a href="https://en.wikipedia.org/wiki/Itanium">Itanium</a>, which is in no way compatible with x86. <code class="language-plaintext highlighter-rouge">ia64</code> was what GCC and LLVM named Itanium triples with. Itanium support was drowned in a bathtub during the Obama administration, so it’s not really relevant anymore. Rust has never had official Itanium support.</p> <p>32-bit x86 is <em>extremely not</em> called “x32”; this is what Linux used to call its x86 ILP32<sup id="fnref:ilp32:1" role="doc-noteref"><a href="#fn:ilp32" class="footnote" rel="footnote">4</a></sup> variant before it was removed (which, following the ARM names, would have been called <code class="language-plaintext highlighter-rouge">x86_6432</code>).</p> <p>There are also many ficticious names for 64-bit x86, which you should avoid unless you want the younger generation to make fun of you. <code class="language-plaintext highlighter-rouge">amd64</code> refers to AMD’s original implementation of long mode in their K8 microarchitecture, first shipped in their <a href="https://en.wikipedia.org/wiki/Athlon_64">Athlon 64</a> product. AMD still makes the best x86 chips (I am writing this on a machine socketed with a Zen2 Threadripper), sure, but calling it <code class="language-plaintext highlighter-rouge">amd64</code> is silly and also looks a lot like <code class="language-plaintext highlighter-rouge">arm64</code>, and I am honestly kinda annoyed at how much Go code I’ve seen with files named <code class="language-plaintext highlighter-rouge">fast_arm64.s</code> and <code class="language-plaintext highlighter-rouge">fast_amd64.s</code>. Debian also uses <code class="language-plaintext highlighter-rouge">amd64</code>/<code class="language-plaintext highlighter-rouge">arm64</code>, which makes browsing packages kind of annoying.</p> <p>On that topic, you should <em>absolutely not</em> call 64-bit mode <code class="language-plaintext highlighter-rouge">k8</code>, after the AMD K8. Nobody except for weird computer taxonomists like me know what that is. But Bazel calls it that, and it’s really irritating<sup id="fnref:piii" role="doc-noteref"><a href="#fn:piii" class="footnote" rel="footnote">13</a></sup>.</p> <p>You should also not call it <code class="language-plaintext highlighter-rouge">x64</code>. Although LLVM does accept <code class="language-plaintext highlighter-rouge">amd64</code> for historical purposes, no one calls it <code class="language-plaintext highlighter-rouge">x64</code> except for Microsoft. And even though it is fairly prevalent on Windows, I absolutely give my gamedev friends a hard time when they write <code class="language-plaintext highlighter-rouge">x64</code>.</p> <p>On the ARM side, well. Arm<sup id="fnref:arm-holdings" role="doc-noteref"><a href="#fn:arm-holdings" class="footnote" rel="footnote">14</a></sup> has a bad habit of not using consistent naming for 64-bit ARM, since they used both AArch64 and ARM64 for it. However, in compiler land, <code class="language-plaintext highlighter-rouge">aarch64</code> appears to be somewhat more popular.</p> <p>You should also probably stick to the LLVM names for the various architectures, instead of picking your favorite Arm Cortex name (like <code class="language-plaintext highlighter-rouge">cortex_m0</code>).</p> <h2 id="vendors-and-operating-systems"><a href="#vendors-and-operating-systems">Vendors and Operating Systems</a></h2> <p>The worst is over. Let’s now move onto examinining the rest of the triple: the platform vendor, and the operating system.</p> <p>The vendor is intended to identify who is responsible for the ABI definition for that target. Although provides little to no value to the compiler itself, but it does help to sort related targets together. Sort of.</p> <p>Returning to <code class="language-plaintext highlighter-rouge">llvm::Triple</code>, we can examine <code class="language-plaintext highlighter-rouge">Triple::VendorType</code>. Vendors almost always correspond to companies which develop operating systems or other platforms that code runs on, with some exceptions.</p> <p>We can also get the vendors that <code class="language-plaintext highlighter-rouge">rustc</code> knows about with a handy dandy command:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">rustc --print target-list | grep -P '\w+-\w+-' | cut -d- -f2 | sort | uniq</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>The result is this. This is just a representative list; I have left off a few that are not going to be especially recognizeable.</p> <table> <thead> <tr> <th>Vendor</th> <th>Name</th> <th>Example Triple</th> </tr> </thead> <tbody> <tr> <td>Vendor Unknown<sup id="fnref:unknown" role="doc-noteref"><a href="#fn:unknown" class="footnote" rel="footnote">15</a></sup></td> <td><code class="language-plaintext highlighter-rouge">unknown</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code></td> </tr> <tr> <td>“PC”</td> <td><code class="language-plaintext highlighter-rouge">pc</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-pc-windows-msvc</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/AMD">Advanced Micro Devices Inc.</a></td> <td><code class="language-plaintext highlighter-rouge">amd</code></td> <td><code class="language-plaintext highlighter-rouge">amdgcn-amd-gfx906</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Apple_Inc.">Apple Inc.</a></td> <td><code class="language-plaintext highlighter-rouge">apple</code></td> <td><code class="language-plaintext highlighter-rouge">aarch64-apple-ios-sim</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Intel">Intel Corporation</a></td> <td><code class="language-plaintext highlighter-rouge">intel</code></td> <td><code class="language-plaintext highlighter-rouge">i386-intel-elfiamcu</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/IBM">IBM Corporation</a></td> <td><code class="language-plaintext highlighter-rouge">ibm</code></td> <td><code class="language-plaintext highlighter-rouge">powerpc64-ibm-aix</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Mesa_(computer_graphics)">Mesa3D Project</a></td> <td><code class="language-plaintext highlighter-rouge">mesa</code></td> <td><code class="language-plaintext highlighter-rouge">amdgcn-mesa-mesa3d</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/MIPS_Technologies">MIPS Technologies LLC</a></td> <td><code class="language-plaintext highlighter-rouge">mti</code></td> <td><code class="language-plaintext highlighter-rouge">mips-mti-none-elf</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Nintendo">Nintendo</a></td> <td><code class="language-plaintext highlighter-rouge">nintendo</code></td> <td><code class="language-plaintext highlighter-rouge">armv6k-nintendo-3ds</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Nvidia">Nvidia Corporation</a></td> <td><code class="language-plaintext highlighter-rouge">nvidia</code></td> <td><code class="language-plaintext highlighter-rouge">nvptx64-nvidia-cuda</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Sony_Interactive_Entertainment">Sony Interactive Entertainment</a></td> <td><code class="language-plaintext highlighter-rouge">scei</code>, <code class="language-plaintext highlighter-rouge">sie</code>, <code class="language-plaintext highlighter-rouge">sony</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-sie-ps5</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a></td> <td><code class="language-plaintext highlighter-rouge">sun</code></td> <td><code class="language-plaintext highlighter-rouge">sparcv9-sun-solaris</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/SUSE_S.A.">SUSE S. A.</a></td> <td><code class="language-plaintext highlighter-rouge">suse</code></td> <td><code class="language-plaintext highlighter-rouge">aarch64-suse-linux</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Red_Hat">Red Hat, Inc</a></td> <td><code class="language-plaintext highlighter-rouge">redhat</code></td> <td><code class="language-plaintext highlighter-rouge">x86_64-redhat-linux</code></td> </tr> <tr> <td><a href="https://en.wikipedia.org/wiki/Universal_Windows_Platform">Universal Windows Platform</a></td> <td><code class="language-plaintext highlighter-rouge">uwp</code></td> <td><code class="language-plaintext highlighter-rouge">aarch64-uwp-windows-msvc</code></td> </tr> </tbody> </table> <p>Most vendors are the names of organizations that produce hardware or operating systems. For example <code class="language-plaintext highlighter-rouge">suse</code> and <code class="language-plaintext highlighter-rouge">redhat</code> are used for those organizations’ Linux distributions, as a funny branding thing. Some vendors are projects, like the <code class="language-plaintext highlighter-rouge">mesa</code> vendor used with the Mesa3D OpenGL implementation’s triples.</p> <p>The <code class="language-plaintext highlighter-rouge">unknown</code> vendor is used for cases where the vendor is not specified or just not important. For example, the canonical Linux triple is <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code>… although one could argue it should be <code class="language-plaintext highlighter-rouge">x86_64-torvalds-linux</code>. It is not uncommon for companies that sell/distribute Linux distributions to have their own target triples, as do SUSE and sometimes RedHat. Notably, there are no triples with a <code class="language-plaintext highlighter-rouge">google</code> vendor, even though <code class="language-plaintext highlighter-rouge">aarch64-linux-android</code> and <code class="language-plaintext highlighter-rouge">aarch64-unknown-fuchsia</code> should really be called <code class="language-plaintext highlighter-rouge">aarch64-google-linux-android</code> and <code class="language-plaintext highlighter-rouge">aarch64-google-fuchsia</code>. The target triple system begins to show cracks here.</p> <p>The <code class="language-plaintext highlighter-rouge">pc</code> vendor is a bit weirder, and is mostly used by Windows targets. The standard Windows target is <code class="language-plaintext highlighter-rouge">x86_64-pc-windows-msvc</code>, but really it should have been <code class="language-plaintext highlighter-rouge">x86_64-microsoft-windows-msvc</code>. This is likely complicated by the fact that there is also a <code class="language-plaintext highlighter-rouge">x86_64-pc-windows-gnu</code> triple, which is for <a href="https://en.wikipedia.org/wiki/MinGW">MinGW</a> code. This platform, despite running on Windows, is not provided by Microsoft, so it would probably make more sense to be called <code class="language-plaintext highlighter-rouge">x86_64-unknown-windows-gnu</code>.</p> <p>But not all Windows targets are <code class="language-plaintext highlighter-rouge">pc</code>! <a href="https://en.wikipedia.org/wiki/Universal_Windows_Platform">UWP</a> apps use a different triple, that replaces the <code class="language-plaintext highlighter-rouge">pc</code> with <code class="language-plaintext highlighter-rouge">uwp</code>. <code class="language-plaintext highlighter-rouge">rustc</code> provides targets for Windows 7 backports that use a <code class="language-plaintext highlighter-rouge">win7</code> “vendor”.</p> <h3 id="beyond-operating-systems"><a href="#beyond-operating-systems">Beyond Operating Systems</a></h3> <p>The third (or sometimes second, ugh) component of a triple is the operating system, or just “system”, since it’s much more general than that. The main thing that compilers get from this component relates to generating code to interact with the operating system (e.g. SEH on Windows) and various details related to linking, such as object file format and relocations.</p> <p>It’s also used for setting defines like <code class="language-plaintext highlighter-rouge">__linux__</code> in C, which user code can use to determine what to do based on the target.</p> <p>We’ve seen <code class="language-plaintext highlighter-rouge">linux</code> and <code class="language-plaintext highlighter-rouge">windows</code>, but you may have also seen <code class="language-plaintext highlighter-rouge">x86_64-apple-darwin</code>. <em>Darwin?</em></p> <p>The operating system formerly known as Mac OS X (now macOS<sup id="fnref:macos" role="doc-noteref"><a href="#fn:macos" class="footnote" rel="footnote">16</a></sup>) is a POSIX operating system. The POSIX substrate that all the Apple-specific things are built on top of is called Darwin. <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> is a free and open source operating system based on Mach, a research kernel whose name survives in Mach-O, the object file format used by all Apple products.</p> <p>All of the little doodads Apple sells use the actual official names of their OSes, like <code class="language-plaintext highlighter-rouge">aarch64-apple-ios</code>. For, you know, iOS. On your iPhone. Built with Xcode on your iMac.</p> <p><code class="language-plaintext highlighter-rouge">none</code> is a common value for this entry, which usually means a free-standing environment with no operating system. The object file format is usually specified in the fourth entry of the triple, so you might see something like <code class="language-plaintext highlighter-rouge">riscv32imc-unknown-none-elf</code>.</p> <p>Sometimes the triple refers not to an operating system, but to a complete hardware product. This is common with game console triples, which have “operating system” names like <code class="language-plaintext highlighter-rouge">ps4</code>, <code class="language-plaintext highlighter-rouge">psvita</code>, <code class="language-plaintext highlighter-rouge">3ds</code>, and <code class="language-plaintext highlighter-rouge">switch</code>. (Both Sony and Nintendo use LLVM as the basis for their internal toolchains; the Xbox toolchain is just MSVC).</p> <h2 id="abi-abi"><a href="#abi-abi">ABI! ABI!</a></h2> <p>The fourth entry of the triple (and I repeat myself, yes, it’s still a triple) represents the binary interface for the target, when it is ambiguous.</p> <p>For example, Apple targets never have this, because on an Apple platform, you just shut up and use <code class="language-plaintext highlighter-rouge">CoreFoundation.framework</code> as your libc. Except this isn’t true, because of things like <code class="language-plaintext highlighter-rouge">x86_64-apple-ios-sim</code>, the iOS simulator running on an x86 host.</p> <p>On the other hand, Windows targets will usually specify <code class="language-plaintext highlighter-rouge">-msvc</code> or <code class="language-plaintext highlighter-rouge">-gnu</code>, to indicate whether they are built to match MSVC’s ABI or MinGW. Linux targets will usually specify the libc vendor in this position: <code class="language-plaintext highlighter-rouge">-gnu</code> for glibc, <code class="language-plaintext highlighter-rouge">-musl</code> for musl, <code class="language-plaintext highlighter-rouge">-newlib</code> for newlib, and so on.</p> <p>This doesn’t just influence the calling convention; it also influences how language features, such as thread locals and dynamic linking, are handled. This usually requires coordination with the target libc.</p> <p>On ARM free-standing (<code class="language-plaintext highlighter-rouge">armxxx-unknown-none</code>) targets, <code class="language-plaintext highlighter-rouge">-eabi</code> specifies the ARM EABI, which is a standard embeded ABI for ARM. <code class="language-plaintext highlighter-rouge">-eabihf</code> is similar, but indicates that no soft float support is necessary (<code class="language-plaintext highlighter-rouge">hf</code> stands for hardfloat). (Note that Rust does not include a vendor with these architectures, so they’re more like <code class="language-plaintext highlighter-rouge">armv7r-none-eabi</code>).</p> <p>A lot of jankier targets use the ABI portion to specify the object file, such as the aforementioned <code class="language-plaintext highlighter-rouge">riscv32imc-unknown-none-elf</code>.</p> <h2 id="wasm-targets"><a href="#wasm-targets">WASM Targets</a></h2> <p>One last thing to note are the various WebAssembly targets, which completely ignore all of the above conventions. Their triples often only have two components (they are still called triples, hopefully I’ve made that clear by now). Rust is a little bit more on the forefront here than <code class="language-plaintext highlighter-rouge">clang</code> (and anyways I don’t want to get into Emscripten) so I’ll stick to what’s going on in <code class="language-plaintext highlighter-rouge">rustc</code>.</p> <p>There’s a few variants. <code class="language-plaintext highlighter-rouge">wasm32-unknown-unknown</code> (here using <code class="language-plaintext highlighter-rouge">unknown</code> instead of <code class="language-plaintext highlighter-rouge">none</code> as the system, oops) is a completely bare WebAssebly runtime where none of the standard library that needs to interact with the outside world works. This is essentially for building WebAssembly modules to deploy in a browser.</p> <p>There are also the WASI targets, which provide a standard ABI for talking to the host operating system. These are less meant for browsers and more for people who are using WASI as a security boundary. These have names like <code class="language-plaintext highlighter-rouge">wasm32-wasip1</code>, which, unusually, lack a vendor! A “more correct” formulation would have been <code class="language-plaintext highlighter-rouge">wasm32-unknown-wasip1</code>.</p> <h2 id="aside-on-go"><a href="#aside-on-go">Aside on Go</a></h2> <p>Go does the correct thing and distributes a cross compiler. This is well and good.</p> <p>Unfortunately, they decided to be different and special and do not use the target triple system for naming their targets. Instead, you set the <code class="language-plaintext highlighter-rouge">GOARCH</code> and <code class="language-plaintext highlighter-rouge">GOOS</code> environment variables before invoking <code class="language-plaintext highlighter-rouge">gc</code>. This will sometimes be shown printed with a slash between, such as <code class="language-plaintext highlighter-rouge">linux/amd64</code>.</p> <p>Thankfully, they at least provide documentation for a relevant internal package <a href="https://pkg.go.dev/internal/platform">here</a>, which offers the names of various <code class="language-plaintext highlighter-rouge">GOARCH</code> and <code class="language-plaintext highlighter-rouge">GOOS</code> values.</p> <p>They use completely different names from everyone else for a few things, which is guaranteed to trip you up. They use call the 32- and 64-bit variants of x86 <code class="language-plaintext highlighter-rouge">386</code> (note the lack of leading <code class="language-plaintext highlighter-rouge">i</code>) and <code class="language-plaintext highlighter-rouge">amd64</code>. They call 64-bit ARM <code class="language-plaintext highlighter-rouge">arm64</code>, instead of <code class="language-plaintext highlighter-rouge">aarch64</code>. They call little-endian MIPSes <code class="language-plaintext highlighter-rouge">mipsle</code> instead of <code class="language-plaintext highlighter-rouge">mipsel</code>.</p> <p>They also call 32-bit WebAssembly <code class="language-plaintext highlighter-rouge">wasm</code> instead of <code class="language-plaintext highlighter-rouge">wasm32</code>, which is a bit silly, and they use <code class="language-plaintext highlighter-rouge">js/wasm</code> as their equivalent of <code class="language-plaintext highlighter-rouge">wasm32-unknown-unknown</code>, which is <em>very</em> silly.</p> <p>Android is treated as its own operating system, <code class="language-plaintext highlighter-rouge">android</code>, rather than being <code class="language-plaintext highlighter-rouge">linux</code> with a particular ABI; their system also can’t account for ABI variants in general, since Go originally wanted to not have to link any system libraries, something that does not actually work.</p> <p>If you are building a new toolchain, don’t be clever by inventing a cute target triple convention. All you’ll do is annoy people who need to work with a lot of different toolchains by being different and special.</p> <h2 id="inventing-your-own-triples"><a href="#inventing-your-own-triples">Inventing Your Own Triples</a></h2> <p>Realistically, you probably shouldn’t. But if you must, you should probably figure out what you want out of the triple.</p> <p>Odds are there isn’t anything interesting to put in the vendor field, so you will avoid people a lot of pain by picking <code class="language-plaintext highlighter-rouge">unknown</code>. Just include a vendor to avoid pain for people in the future.</p> <p>You should also avoid inventing a new name for an existing architecture. Don’t name your hobby operating system’s triple <code class="language-plaintext highlighter-rouge">amd64-unknown-whatever</code>, please. And you definitely don’t want to have an ABI component. One ABI is enough.</p> <p>If you’re inventing a triple for a free-standing environment, but want to specify something about the hardware configuration, you’re probably gonna want to use <code class="language-plaintext highlighter-rouge">-none-&lt;abi&gt;</code> for your system. For some firmware use-cases, though, the system entry is a better place, such as for the UEFI triples. Although, I have unforunately seen both <code class="language-plaintext highlighter-rouge">x86_64-unknown-uefi</code> and <code class="language-plaintext highlighter-rouge">x86_64-pc-none-uefi</code> in the wild.</p> <p>And most imporantly: this sytem was built up organically. Disabuse yourself now of the idea that the system is consistent and that target triples are easy to parse. Trying to parse them will make you very sad.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:quad" role="doc-endnote"> <p>And no, a “target quadruple” is not a thing and if I catch you saying that I’m gonna bonk you with an Intel optimization manual. <a href="#fnref:quad" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:toolchain" role="doc-endnote"> <p>I’m not sure why GCC does this. I suspect that it’s because computer hard drives used to be small and a GCC with every target would have been too large to cram into every machine. Maybe it has some UNIX philosophy woo mixed into it.</p> <p>Regardless, it’s really annoying and thankfully no one else does this because cross compiling shouldn’t require hunting down a new toolchain for each platform. <a href="#fnref:toolchain" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:x86_86h" role="doc-endnote"> <p>This is for Apple’s later-gen x86 machines, before they went all-in on ARM desktop. <a href="#fnref:x86_86h" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ilp32" role="doc-endnote"> <p>ILP32 means that the <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, and pointer types in C are 32-bit, despite the architecture being 64-bit. This allows writing programs that are small enough top jive in a 32-bit address space, while taking advantage of fast 64-bit operations. It is a bit of a frankentarget. Also existed once as a process mode on <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code> by the name of <code class="language-plaintext highlighter-rouge">x32</code>. <a href="#fnref:ilp32" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:ilp32:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p> </li> <li id="fn:power" role="doc-endnote"> <p>Not to be confused with POWER, an older IBM CPU. <a href="#fnref:power" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:s390x" role="doc-endnote"> <p>This name is Linux’s name for IBM’s z/Architecture. See <a href="https://en.wikipedia.org/wiki/Linux_on_IBM_Z#Hardware">https://en.wikipedia.org/wiki/Linux_on_IBM_Z#Hardware</a>. <a href="#fnref:s390x" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptx" role="doc-endnote"> <p>Not a real chip; refers to Nvidia’s PTX IR, which is what CUDA compiles to. <a href="#fnref:ptx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:amdil" role="doc-endnote"> <p>Similar to PTX; an IR used by AMD for graphics. See <a href="https://openwall.info/wiki/john/development/AMD-IL">https://openwall.info/wiki/john/development/AMD-IL</a>. <a href="#fnref:amdil" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:idk" role="doc-endnote"> <p>No idea what this is, and Google won’t help me. <a href="#fnref:idk" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:idk:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p> </li> <li id="fn:llc" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">llc</code> is the LLVM compiler, which takes LLVM IR as its input. Its interface is much more regular than <code class="language-plaintext highlighter-rouge">clang</code>’s because it’s not intended to be a substitute for GCC the way <code class="language-plaintext highlighter-rouge">clang</code> is. <a href="#fnref:llc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:x86-modes" role="doc-endnote"> <p>Very kernel-hacker-brained name. It references the three processor modes of an x86 machine: real mode, protected mode, long mode, which correspond to 16-, 32-, and 64-bit modes. There is also a secret fourth mode called <a href="https://en.wikipedia.org/wiki/Unreal_mode">unreal mode</a>, which is just what happens when you come down to real mode from protected mode after setting up a protected mode GDT.</p> <p>If you need to refer to real mode, call it “real mode”. Don’t try to be clever by calling it “8086” because you are almost certainly going to be using features that were not in the original Intel 8086. <a href="#fnref:x86-modes" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i386" role="doc-endnote"> <p>I actually don’t like this name, but it’s the one LLVM uses so I don’t really get to complain. <a href="#fnref:i386" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:piii" role="doc-endnote"> <p>Bazel also calls 32-bit x86 <code class="language-plaintext highlighter-rouge">piii</code>, which stands for, you guessed it, “Pentium III”. Extremely unserious. <a href="#fnref:piii" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:arm-holdings" role="doc-endnote"> <p>The intelectual property around ARM, the architecture famility, is owned by the British company Arm Holdings. Yes, the spelling difference is significant.</p> <p>Relatedly, ARM is not an acronym, and is sometimes styled in all-lowercase as arm. The distant predecesor of Arm Holdings is Acorn Computers. Their first compute, the Acorn Archimedes, contained a chip whose target triple name today might have been <code class="language-plaintext highlighter-rouge">armv1</code>. Here, ARM was an acronym, for Acorn RISC Machine. Wikipedia alleges without citation that the name was at once point changed to Advanced RISC Machine at the behest of Apple, but I am unable to find more details. <a href="#fnref:arm-holdings" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unknown" role="doc-endnote"> <p>“You are not cool enough for your company to be on the list.” <a href="#fnref:unknown" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:macos" role="doc-endnote"> <p>Which I pronounce as one word, “macos”, to drive people crazy. <a href="#fnref:macos" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-08 • 742 words • 6 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/08/protobuf-tip-1/"> Protobuf Tip #1: Field Names Are Forever </a></h1> </div> <div class="post"> <p><em>I wake up every morning and grab the morning paper. Then I look at the obituary page. If my name is not on it, I get up. –Ben Franklin</em></p> <p>TL;DR: Don’t rename fields. Even though there are a slim number of cases where you can get away with it, it’s rarely worth doing, and is a potential source of bugs.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-1-field-names">buf.build blog</a>.</p> </blockquote> <h2 id="names-and-tags"><a href="#names-and-tags">Names and Tags</a></h2> <p>Protobuf message fields have <em>field tags</em> that are used in the binary wire format to discriminate fields. This means that the wire format serialization does not actually depend on the <em>names</em> of the fields. For example, the following messages will use the exact same serialization format.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">bar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Foo2</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">bar2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>In fact, the designers of Protobuf intended for it to be feasible to rename an in-use field. However, they were not successful: it can still be a breaking change.</p> <h2 id="schema-consumers-need-to-update"><a href="#schema-consumers-need-to-update">Schema Consumers Need to Update</a></h2> <p>If your schema is public, the generated code will change. For example, renaming a field from <code class="language-plaintext highlighter-rouge">first_name</code> to <code class="language-plaintext highlighter-rouge">given_name</code> will cause the corresponding Go accessor to change from <code class="language-plaintext highlighter-rouge">FirstName</code> to <code class="language-plaintext highlighter-rouge">GivenName</code>, potentially breaking downstream consumers.</p> <p>Renaming a field to a “better” name is almost never a worthwhile change, simply because of this breakage.</p> <h2 id="json-serialization-breaks"><a href="#json-serialization-breaks">JSON Serialization Breaks</a></h2> <p>Wire format serialization doesn’t look at names, but JSON does! This means that <code class="language-plaintext highlighter-rouge">Foo</code> and <code class="language-plaintext highlighter-rouge">Foo2</code> above serialize as <code class="language-plaintext highlighter-rouge">{"bar":"content"}</code> and <code class="language-plaintext highlighter-rouge">{"bar2":"content"}</code> respectively, making them non-interchangeable.</p> <p>This can be partially mitigated by using the <code class="language-plaintext highlighter-rouge">[json_name = "..."]</code> option on a field. However, this doesn’t actually work, because many Protobuf runtimes’ JSON codecs will accept both the name set in <code class="language-plaintext highlighter-rouge">json_name</code>, <em>and</em> the specified field name. So <code class="language-plaintext highlighter-rouge">string given_name = 1 [json_name = "firstName"];</code> will allow deserializing from a key named <code class="language-plaintext highlighter-rouge">given_name</code>, but not <code class="language-plaintext highlighter-rouge">first_name</code> like it used to. This is still a breaking protocol change!</p> <p>This is a place where Protobuf could have done better—if <code class="language-plaintext highlighter-rouge">json_name</code> had been a <code class="language-plaintext highlighter-rouge">repeated string</code>, this wire format breakage would have been avoidable. However, for reasons given below, renames are still a bad idea.</p> <h2 id="reflection"><a href="#reflection">Reflection!</a></h2> <p>Even if you could avoid source and JSON breakages, the names are always visible to reflection. Although it’s <em>very</em> hard to guard against reflection breakages in general (since it can even see the order fields are declared in), this is one part of reflection that can be especially insidious—for example, if callers choose to sort fields by name, or if some middleware is using the name of a field to identify its frequency, or logging/redaction needs.</p> <p>Don’t change the name, because reflection means you can’t know what’ll go wrong!</p> <h2 id="but-i-really-have-to"><a href="#but-i-really-have-to">But I Really Have To!</a></h2> <p>There are valid reasons for wanting to rename a field, such as expanding its scope. For example, <code class="language-plaintext highlighter-rouge">first_name</code> and <code class="language-plaintext highlighter-rouge">given_name</code> are not the same concept: in the Sinosphere, as well as in Hungary, the first name in a person’s full name is their family name, not their given name.</p> <p>Or maybe a field that previously referred to a monetary amount, say <code class="language-plaintext highlighter-rouge">cost_usd</code>, is being updated to not specify the currency:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Before</span> <span class="p">{</span>
  <span class="kt">sint64</span> <span class="na">cost_usd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">After</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">Currency</span> <span class="p">{</span>
    <span class="na">CURRENCY_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">CURRENCY_USD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">CURRENCY_EUR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">CURRENCY_JPY</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="na">CURRENCY_USD_1000TH</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 0.1 cents.</span>
  <span class="p">}</span>

  <span class="kt">sint64</span> <span class="na">cost</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">Currency</span> <span class="na">currency</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>In cases like this, <strong>renaming the field is a terrible idea</strong>. Setting aside source code or JSON breakage, the new field has completely different semantics. If an old consumer, expecting a price in USD, receives a new wire format message serialized from <code class="language-plaintext highlighter-rouge">{"cost":990,"currency":"CURRENCY_USD_1000TH"}</code>, it will incorrectly interpret the price as 990USD, rather than 0.99USD. That’s a disastrous bug!</p> <p>Instead, the right plan is to add <code class="language-plaintext highlighter-rouge">cost</code> and <code class="language-plaintext highlighter-rouge">currency</code> side-by-side <code class="language-plaintext highlighter-rouge">cost_usd</code>. Then, readers should first check for <code class="language-plaintext highlighter-rouge">cost_usd</code> when reading <code class="language-plaintext highlighter-rouge">cost</code>, and take that to imply that <code class="language-plaintext highlighter-rouge">currency</code> is <code class="language-plaintext highlighter-rouge">CURRENCY_USD</code> (it’s also worth generating an error if <code class="language-plaintext highlighter-rouge">cost</code> and <code class="language-plaintext highlighter-rouge">cost_usd</code> are both present).</p> <p><code class="language-plaintext highlighter-rouge">cost_usd</code> can then be marked as <code class="language-plaintext highlighter-rouge">[deprecated = true]</code> . It is possible to even delete <code class="language-plaintext highlighter-rouge">cost_usd</code> in some cases, such as when you control all readers and writers — but if you don’t, the risk is very high. Plus, you kind of need to be able to re-interpret <code class="language-plaintext highlighter-rouge">cost_usd</code> as the value of <code class="language-plaintext highlighter-rouge">cost</code> in perpetuity.</p> <p>If you do wind up deleting them, make sure to reserve the field’s number and name, to avoid accidental re-use.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="n">reserved</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">reserved</span> <span class="s">"cost_usd"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>But try not to. Renaming fields is nothing but tears and pain.</p> </div> </div> </div> <div class="pagination post-footer"> <span class="pagination-item newer">&lt; Prev</span> • <a class="pagination-item older" href="https://mcyoung.xyz/page2">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>