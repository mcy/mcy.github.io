<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-22 • 725 words • 6 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/22/protobuf-tip-3/"> Protobuf Tip #3: Enum Names Need Prefixes </a></h1> </div> <div class="post"> <p><em>Smart people learn from their mistakes. But the real sharp ones learn from the mistakes of others. –Brandon Mull</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">enum</code>s inherit some unfortunate behaviors from C++. Use the Buf lint rules <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a> and <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a>  to avoid this problem (they’re part of the <code class="language-plaintext highlighter-rouge">DEFAULT</code> category).</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-3-enum-names-need-prefixes">buf.build blog</a>.</p> </blockquote> <h2 id="c-style-enums"><a href="#c-style-enums">C++-Style Enums</a></h2> <p>Protobuf’s <code class="language-plaintext highlighter-rouge">enum</code>s define data types that represent a small set of valid values. For example, <code class="language-plaintext highlighter-rouge">google.rpc.Code</code> lists status codes used by various RPC frameworks, such as GRPC. Under the hood, every <code class="language-plaintext highlighter-rouge">enum</code> is just an <code class="language-plaintext highlighter-rouge">int32</code>  on the wire, although codegen backends will generate custom types and constants for the enum to make it easier to use.</p> <p>Unfortunately, <code class="language-plaintext highlighter-rouge">enum</code>s were originally designed to match C++ enums exactly, and they inadvertently replicate many of those behaviors.</p> <p>If you look at the source for <code class="language-plaintext highlighter-rouge">google.rpc.Code</code>, and compare it to, say, <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.Type</code>, you will notice a subtle difference:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="k">rpc</span><span class="p">;</span>
<span class="kd">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="na">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">UNKNOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="n">protobuf</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">FieldDescriptorProto</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// 0 is reserved for errors.</span>
    <span class="na">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">TYPE_INT64</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p><code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> has values starting with <code class="language-plaintext highlighter-rouge">TYPE_</code>, but <code class="language-plaintext highlighter-rouge">Code</code> ‘s values don’t have a <code class="language-plaintext highlighter-rouge">CODE_</code> prefix.  This is because the fully-qualified names (FQN) of an enum value <em>don’t include the name of the enum.</em> That is, <code class="language-plaintext highlighter-rouge">TYPE_DOUBLE</code> actually refers to <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.TYPE_DOUBLE</code>. Thus, <code class="language-plaintext highlighter-rouge">OK</code> is not <code class="language-plaintext highlighter-rouge">google.rpc.Code.OK</code>, but <code class="language-plaintext highlighter-rouge">google.rpc.OK</code>.</p> <p>This is because it matches the behavior of unscoped C++ enums. C++ is the “reference” implementation, so the language often bends for the sake of the C++ backend.</p> <p>When generating code, <code class="language-plaintext highlighter-rouge">protoc</code>’s C++ backend emits the above as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">rpc</span> <span class="p">{</span>
<span class="k">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">FieldDescriptorProto</span> <span class="k">final</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">enum</span> <span class="n">Type</span> <span class="p">{</span>
   <span class="n">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// ...</span>
  <span class="p">};</span>
<span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And in C++, <code class="language-plaintext highlighter-rouge">enum</code>s don’t scope their enumerators: you write <code class="language-plaintext highlighter-rouge">google::rpc::OK</code>, NOT <code class="language-plaintext highlighter-rouge">google::rpc::Code::OK</code>.</p> <p>If you know C++, you might be thinking, “why didn’t they use <code class="language-plaintext highlighter-rouge">enum class</code>?!”? Enums were added in <code class="language-plaintext highlighter-rouge">proto2</code>, which was developed around 2007-2008, but Google didn’t start using C++11, which introduced <code class="language-plaintext highlighter-rouge">enum class</code> , until much, much later.</p> <p>Now, if you’re a Go or Java programmer, you’re probably wondering why you even care about C++. Both Go and Java do scope enum values to the enum type (although Go does it in a somewhat grody way: <code class="language-plaintext highlighter-rouge">rpcpb.Code_OK</code>).</p> <p>Unfortunately, this affects name collision detection in Protobuf. You can’t write the following code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Because the enum name is not part of the FQN for an enum value, both <code class="language-plaintext highlighter-rouge">UNSPECIFIED</code>s here have the FQN <code class="language-plaintext highlighter-rouge">myapi.v1.UNSPECIFIED</code>, so Protobuf complains about duplicate symbols.</p> <p>Thus, the convention we see in <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">STOPLIGHT_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">STOPLIGHT_RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">STOPLIGHT_YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">STOPLIGHT_GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">SPEED_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SPEED_SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">SPEED_FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Buf provides a lint rule to enforce this convention: <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a>. Even though you might think that an enum name will be unique, because top-level enums bleed their names into the containing package, the problem spreads across packages!</p> <h2 id="zero-values"><a href="#zero-values">Zero Values</a></h2> <p><code class="language-plaintext highlighter-rouge">proto3</code> relies heavily on the concept of “zero values” – all non-message fields that are neither <code class="language-plaintext highlighter-rouge">repeated</code> nor <code class="language-plaintext highlighter-rouge">optional</code> are implicitly zero if they are not present. Thus, <code class="language-plaintext highlighter-rouge">proto3</code> requires that enums specify a value equal to zero.</p> <p>By convention, this value shouldn’t be a specific value of the enum, but rather a value representing that no value is specified. <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a> enforces this, with a default of <code class="language-plaintext highlighter-rouge">_UNSPECIFIED</code>. Of course, there are situations where this might not make sense for you, and a suffix like <code class="language-plaintext highlighter-rouge">_ZERO</code> or <code class="language-plaintext highlighter-rouge">_UNKNOWN</code> might make more sense.</p> <p>It may be tempting to have a specific “good default” value for the zero value. Beware though, because that choice is forever. Picking a generic “unknown” as the default reduces the chance you’ll burn yourself.</p> <h2 id="why-dont-all-of-googles-protobuf-files-do-this"><a href="#why-dont-all-of-googles-protobuf-files-do-this">Why Don’t All of Google’s Protobuf Files Do This?</a></h2> <p>Name prefixes and zero values also teach us an important lesson: because Protobuf names are forever, it’s really hard to fix style mistakes, especially as we collectively get better at using Protobuf.</p> <p><code class="language-plaintext highlighter-rouge">google.rpc.Code</code> is intended to be source-compatible with very old existing C++ code, so it throws caution to the wind. <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> doesn’t have a zero value because in <code class="language-plaintext highlighter-rouge">proto2</code> , which doesn’t have zero value footguns in its wire format, you don’t need to worry about that. The lesson isn’t just to use Buf’s linter to try to avoid some of the known pitfalls, but also to remember that even APIs designed by the authors of the language make unfixable mistakes, so unlike other programming languages, imitating “existing practice” isn’t always the best strategy.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-21 • 4282 words • 35 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2025/04/21/go-arenas/"> Cheating the Reaper in Go </a></h1> </div> <div class="post"> <p>Even though I am a C++ programmer at heart, Go fascinates me for none of the reasons you think. Go has made several interesting design decisions:</p> <ol> <li> <p>It has virtually no Undefined Behavior<sup id="fnref:goub" role="doc-noteref"><a href="#fn:goub" class="footnote" rel="footnote">1</a></sup>.</p> </li> <li> <p>It has very simple GC semantics that they’re mostly stuck with due to design decisions in the surface language.</p> </li> </ol> <p>These things mean that despite Go having a GC, it’s possible to do manual memory management in pure Go and in cooperation with the GC (although without any help from the <code class="language-plaintext highlighter-rouge">runtime</code> package). To demonstrate this, we will be building an untyped, garbage-collected arena abstraction in Go which relies on several GC implementation details.</p> <p>I would never play this kind of game in Rust or C++, because LLVM is extremely intelligent and able to find all kinds of ways to break you over the course of frequent compiler upgrades. On the other hand, although Go does not promise any compatibility across versions for code that imports <code class="language-plaintext highlighter-rouge">unsafe</code>, in practice, two forces work against Go doing this:</p> <ol> <li> <p>Go does not attempt to define what is and isn’t allowed: <code class="language-plaintext highlighter-rouge">unsafe</code> lacks any <a href="https://en.wikipedia.org/wiki/Operational_semantics">operational semantics</a>.</p> </li> <li> <p>Go prioritizes not breaking the ecosystem; this allows to assume that <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a> will protect certain observable behaviors of the runtime, from which we may infer what can or cannot break easily.</p> </li> </ol> <p>This is in contrast to a high-performance native compiler like LLVM, which has a carefully defined boundary around all UB, allowing them to arbitrarily break programs that cross it (mostly) without fear of breaking the ecosystem.</p> <p>So, let’s dive in and cheat death.</p> <h2 id="what-are-we-building"><a href="#what-are-we-building">What Are We Building?</a></h2> <p>Our goal is to build an <em>arena</em>, which is a data structure for efficient allocation of memory that has the same lifetime. This reduces pressure on the general-purpose allocator by only requesting memory in large chunks and then freeing it all at once.</p> <p>For a comparison in Go, consider the following program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">s</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="m">1000</span> <span class="p">{</span>
    <span class="n">prev</span> <span class="o">:=</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This program will print successive powers of 2: this is because <code class="language-plaintext highlighter-rouge">append</code> is implemented approximately like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="nb">append</span><span class="p">[</span><span class="n">S</span> <span class="err">~</span><span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">S</span><span class="p">)</span> <span class="n">S</span> <span class="p">{</span>
  <span class="c">// If needed, grow the allocation.</span>
  <span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Either double the size, or allocate just enough if doubling is</span>
    <span class="c">// too little.</span>
    <span class="n">newCap</span> <span class="o">:=</span> <span class="n">max</span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="c">// Grow a.</span>
    <span class="n">a2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">newCap</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a2</span>
  <span class="p">}</span>

  <span class="c">// Increase the length of a to fit b, then write b into the freshly</span>
  <span class="c">// grown region.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span>
  <span class="nb">copy</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>For appending small pieces, <code class="language-plaintext highlighter-rouge">make</code> is only called <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> times, a big improvement over calling it for every call to <code class="language-plaintext highlighter-rouge">append</code>. Virtually every programming language’s dynamic array abstraction makes this optimization.</p> <p>An arena generalizes this concept, but instead of resizing exponentially, it allocates <em>new</em> blocks and vends pointers into them. The interface we want to conform to is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Allocator</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>In go a size and and an alignment, out comes a pointer fresh memory with that layout. Go does not have user-visible uninitialized memory, so we additionally require that the returned region be zeroed. We also require that <code class="language-plaintext highlighter-rouge">align</code> be a power of two.</p> <p>We can give this a type-safe interface by writing a generic <code class="language-plaintext highlighter-rouge">New</code> function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// New allocates a fresh zero value of type T on the given allocator, and</span>
<span class="c">// returns a pointer to it.</span>
<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="n">Allocator</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This all feels very fine and dandy to anyone used to hurting themselves with <code class="language-plaintext highlighter-rouge">malloc</code> or <code class="language-plaintext highlighter-rouge">operator new</code> in C++, but there is a small problem. What happens when we allocate pointer-typed memory into this allocator?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// Allocate a pointer in our custom allocator, and then</span>
<span class="c">// initialize it to a pointer on the Go heap.</span>
<span class="n">p</span> <span class="o">:=</span> <span class="n">New</span><span class="p">[</span><span class="o">*</span><span class="kt">int</span><span class="p">](</span><span class="n">myAlloc</span><span class="p">)</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="n">runtime</span><span class="o">.</span><span class="n">GC</span><span class="p">()</span>
<span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="m">42</span>  <span class="c">// Use after free!</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">Allocator.Alloc</code> takes a size and an alignment, which is sufficient to describe the <em>layout</em> of any type. For example, on 64-bit systems, <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">*int</code> have the same layout: 8 bytes of size, and 8 bytes of alignment.</p> <p>However, the Go GC (and all garbage collectors, generally) require one additional piece of information, which is somewhere between the layout of a value (how it is placed in memory) and the type of a value (rich information on its structure). To understand this, we need a brief overview on what a GC does.</p> <h2 id="mark-and-sweep"><a href="#mark-and-sweep">Mark and Sweep</a></h2> <blockquote> <p>For a complete overview on how to build a simple GC, take a look at a toy GC I designed some time ago: <a href="https://mcyoung.xyz/2022/06/07/alkyne-gc/">The Alkyne GC</a>.</p> </blockquote> <p>A garbage collector’s responsibility is to maintain a memory allocator and an accounting of:</p> <ol> <li>What memory has been allocated.</li> <li>Whether that memory is still in use.</li> </ol> <p>Memory that is not in use can be reclaimed and marked as unallocated, for re-use.</p> <p>The most popular way to accomplish this is via a “mark and sweep” architecture. The GC will periodically walk the entire object graph of the program from certain pre-determined <em>roots</em>; anything it finds is “marked” as alive. After a mark is complete, all other memory is “swept”, which means to mark it is unallocated for future re-use, or to return it to the OS, in the case of significant surplus.</p> <p>The roots are typically entities that are actively being manipulated by the program. In the case of Go, this is anything currently on the stack of some G<sup id="fnref:g" role="doc-noteref"><a href="#fn:g" class="footnote" rel="footnote">2</a></sup>, or anything in a global (of which there is a compile-time-known set).</p> <p>The marking phase begins with <em>stack scanning</em>, which looks at the stack of each G and locates any pointers contained therein. The Go compiler generates metadata for each function that specifies which stack slots in a function’s frame contain pointers. All of these pointers are live by definition.</p> <p>These pointers are placed into a queue, and each pointer is traced to its allocation on the heap. If the GC does not know anything about a particular address, it is discarded as foreign memory that does not need to be marked. If it does, each pointer in that allocation is pushed onto the queue if it has not already been marked as alive. The process continues until the queue is empty.</p> <p>The critical step here is to take the address of some allocation, and convert it into all of the pointer values within. Go has precise garbage collection, which means that it only treats things declared as pointers in the surface language as pointers: an integer that happens to look like an address will not result in sweeping. This results in more efficient memory usage, but trades off some more complexity in the GC.</p> <p>For example, the types <code class="language-plaintext highlighter-rouge">*int</code>, <code class="language-plaintext highlighter-rouge">map[int]byte</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">struct {A int; B *int}</code> all contain at least one pointer, while <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">[1000]byte</code>, <code class="language-plaintext highlighter-rouge">struct {X bool; F uintptr}</code> do not. The latter are called <em>pointer-free</em> types.</p> <p>Go enhances the layout of a type into a <em>shape</em> by adding a bitset that specifies which pointer-aligned, pointer-sized words of the type’s memory region contain a pointer. These are called the <em>pointer bits</em>. For example, here are the shapes of a few Go types on a 64-bit system.</p> <table> <thead> <tr> <th>Type</th> <th>Size/Align</th> <th>Pointer Bits<sup id="fnref:ptr-bits-endian" role="doc-noteref"><a href="#fn:ptr-bits-endian" class="footnote" rel="footnote">3</a></sup></th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">byte</code></td> <td>1/1</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">rune</code></td> <td>4/4</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">*int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">unsafe.Pointer</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">string</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">10</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[]int</code></td> <td>24/8</td> <td><code class="language-plaintext highlighter-rouge">100</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[3]string</code></td> <td>48/8</td> <td><code class="language-plaintext highlighter-rouge">101010</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">map[int]byte</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">map[int]string</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">any</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">01</code><sup id="fnref:itab" role="doc-noteref"><a href="#fn:itab" class="footnote" rel="footnote">4</a></sup></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">error</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">01</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">func(int) int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">runtime.hchan</code><sup id="fnref:hchan" role="doc-noteref"><a href="#fn:hchan" class="footnote" rel="footnote">5</a></sup></td> <td>104/8</td> <td><code class="language-plaintext highlighter-rouge">0010110011110</code></td> </tr> </tbody> </table> <p>In the Go GC, each allocation is tagged with its shape (this is done in a variety of ways in the GC, either through an explicit header on the allocation, itself (a “malloc header”), a runtime type stored in the allocation’s <code class="language-plaintext highlighter-rouge">runtime.mspan</code>, or another mechanism). When scanning a value, it uses this information to determine where the pointers to scan through are.</p> <p>The most obvious problem with our <code class="language-plaintext highlighter-rouge">Allocator.Alloc</code> type is that it does not discriminate shapes, so it cannot allocate memory that contains pointers: the GC will not be able to find the pointers, and will free them prematurely!</p> <p>In our example where we allocated an <code class="language-plaintext highlighter-rouge">*int</code> in our custom allocator, we wind up with a <code class="language-plaintext highlighter-rouge">**int</code> on the stack. You would think that Go would simply trace through the first <code class="language-plaintext highlighter-rouge">*</code> to find an <code class="language-plaintext highlighter-rouge">*int</code> and mark it as being alive, but that is not what happens! Go instead finds a pointer into some chunk that the custom allocator grabbed from the heap, which is missing the pointer bits of its shape!</p> <p>Why does go not look at the type of the pointer it steps through? Two reasons.</p> <ol> <li> <p>All pointers in Go are untyped from the runtime’s perspective; every <code class="language-plaintext highlighter-rouge">*T</code> gets erased into an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>. This allows much of the Go runtime to be “generic” without using actual generics.</p> </li> <li> <p>Pointee metadata can be aggregated, so that each pointer to an object does not have to remember its type at runtime.</p> </li> </ol> <p>The end result for us is that we can’t put pointers on the arena. This makes our <code class="language-plaintext highlighter-rouge">New</code> API unsafe, especially since Go does not provide a standard constraint for marking generic parameters as pointer-free: unsurprisingly, the don’t expect most users to care about such a detail.</p> <p>It <em>is</em> possible to deduce the pointer bits of a type using reflection, but that’s very slow, and the whole point of using arenas is to go fast. As we design our arena, though, it will become clear that there is a safe way to have pointers on it.</p> <h2 id="designing-the-arena"><a href="#designing-the-arena">Designing The Arena</a></h2> <p>Now that we have a pretty good understanding about what the Go GC is doing, we can go about designing a fast arena structure.</p> <p>The ideal case is that a call to <code class="language-plaintext highlighter-rouge">Alloc</code> is very fast: just offsetting a pointer in the common case. One assumption we can make off the bat is that all memory can be forced to have maximum alignment: most objects are a pointer or larger, and Go does have a maximum alignment for ordinary user types, so we can just ignore the <code class="language-plaintext highlighter-rouge">align</code> parameter and always align to say, 8 bytes. This means that the pointer to the next unallocated chunk will always be well-aligned. Thus, we might come up with a structure like this one:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>
<span class="p">}</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="c">// Power of two size of the minimum allocation granularity.</span>
  <span class="n">wordBytes</span> <span class="o">=</span> <span class="m">8</span>  <span class="c">// Depends on target, this is for 64-bit.</span>
  <span class="n">minWords</span>  <span class="o">=</span> <span class="m">8</span>
<span class="p">)</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// First, round the size up to the alignment of every object in</span>
  <span class="c">// the arena.</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="c">// Then, replace the size with the size in pointer-sized words.</span>
  <span class="c">// This does not result in any loss of size, since size is now</span>
  <span class="c">// a multiple of the uintptr size.</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">wordBytes</span>

  <span class="c">// Next, check if we have enough space left for this chunk. If</span>
  <span class="c">// there isn't, we need to grow.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size,</span>
    <span class="c">// twice the last allocation, or the next power of two</span>
    <span class="c">// after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
  <span class="p">}</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// Beware, offsetting to one-past-the-end is one of the few</span>
    <span class="c">// things explicitly not allowed by Go.</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="c">// nextPow2 returns the smallest power of two greater than n.</span>
<span class="k">func</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="o">.</span><span class="n">Len</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>How fast is this really? Here’s a simple benchmark for it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">BenchmarkArena</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bench</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">64</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">1024</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">runs</span> <span class="o">=</span> <span class="m">100000</span>

<span class="k">var</span> <span class="n">sink</span> <span class="n">any</span>

<span class="k">func</span> <span class="n">bench</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">z</span> <span class="n">T</span>
  <span class="n">n</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">runs</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
  <span class="n">name</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%v"</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">T</span><span class="p">]())</span>

  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"arena"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">Arena</span><span class="p">)</span>
        <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
          <span class="n">sink</span> <span class="o">=</span> <span class="n">arena</span><span class="o">.</span><span class="n">New</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">a</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})</span>

    <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"new"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
          <span class="n">sink</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The focus of this benchmark is to measure the cost of allocating many objects of the same size. The number of times the <code class="language-plaintext highlighter-rouge">for b.Loop()</code> loop will execute is unknown, and determined by the benchmarking framework to try to reduce statistical anomaly. This means that if we instead just benchmark a single allocation, the result will be <em>very</em> sensitive to the number of runs.</p> <p>We also use <code class="language-plaintext highlighter-rouge">b.SetBytes</code> to get a throughput measurement on the benchmark. This is a bit easier to interpret than the gross <code class="language-plaintext highlighter-rouge">ns/op</code>, the benchmark would otherwise produce. It tells us how much memory each allocator can allocate per unit time.</p> <p>We want to compare against <code class="language-plaintext highlighter-rouge">new</code>, but just writing <code class="language-plaintext highlighter-rouge">_ = new(T)</code> will get optimized out, since the resulting pointer does not escape. Writing it to a global is sufficient to convince Go that it escapes.</p> <p>Here’s the results, abbreviated to show only the bytes per second. All benchmarks were performed on my AMD Ryzen Threadripper 3960X. Larger is better.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         794.84 MB/s
BenchmarkArena/int/new-48           390.59 MB/s
BenchmarkArena/[2]int/arena-48      1263.58 MB/s
BenchmarkArena/[2]int/new-48        528.06 MB/s
BenchmarkArena/[64]int/arena-48     7370.08 MB/s
BenchmarkArena/[64]int/new-48       2865.24 MB/s
BenchmarkArena/[1024]int/arena-48   9889.20 MB/s
BenchmarkArena/[1024]int/new-48     2875.75 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>This is quite nice, and certainly worth pursuing! The performance increase seems to scale up with the amount of memory allocated, for a 2x-4x improvement across different cases.</p> <p>Now we need to contend with the fact that our implementation is completely broken if we want to have pointers in it.</p> <h3 id="not-dropping-memory-on-the-ground"><a href="#not-dropping-memory-on-the-ground">Not Dropping Memory on the Ground</a></h3> <p>In <code class="language-plaintext highlighter-rouge">(*Arena).Alloc</code>, when we assign a freshly-allocated chunk, we overwrite <code class="language-plaintext highlighter-rouge">a.next</code>, which means the GC can reclaim it. But this is fine: as long as pointers into that arena chunk are alive, the GC will not free it, independent of the arena. So it seems like we don’t need to worry about it?</p> <p>However, the whole point of an arena is to allocate lots of memory that has the same lifetime. This is common for graph data structures, such as an AST or a compiler IR, which performs a lot of work that allocates a lot and then throws the result away.</p> <p>We are not allowed to put pointers in the arena, because they would disappear from the view of the GC and become freed too soon. But, if a pointer wants to go on an arena, it necessarily outlive the whole arena, since it outlives part of the arena, and the arena is meant to have the same lifetime.</p> <p>In particular, if we could make it so that holding any pointer returned by <code class="language-plaintext highlighter-rouge">Alloc</code> prevents the <em>entire arena</em> from being swept by the GC, the arena can safely contain pointers into itself! Consider this:</p> <ol> <li> <p>We have a pointer <code class="language-plaintext highlighter-rouge">p **int</code>. It is allocated on some arena <code class="language-plaintext highlighter-rouge">a</code>.</p> </li> <li> <p>The GC sees our pointer (as a type-erased <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>) and marks its allocation as live.</p> </li> <li> <p>Somehow, the GC also marks <code class="language-plaintext highlighter-rouge">a</code> as alive as a consequence.</p> </li> <li> <p>Somehow, the GC then marks every chunk <code class="language-plaintext highlighter-rouge">a</code> has allocated as alive.</p> </li> <li> <p>Therefore he chunk that <code class="language-plaintext highlighter-rouge">*p</code> points to is also alive, so <code class="language-plaintext highlighter-rouge">*p</code> does not need to be marked directly, and will not be freed early.</p> </li> </ol> <p>The step (3) is crucial. By forcing the whole arena to be marked, any pointers stored in the arena into itself will be kept alive automatically, without the GC needing to know how to scan for them.</p> <p>So, even though <code class="language-plaintext highlighter-rouge">*New[*int](a) = new(int)</code> is still going to result in a use-after-free, <code class="language-plaintext highlighter-rouge">*New[*int](a) = New[int](a)</code> would not! This small improvement does not make arenas themselves safe, but a data structure with an internal arena can be completely safe, so long as the only pointers that go into the arena are from the arena itself.</p> <p>How can we make this work? The easy part is (4), which we can implement by adding a <code class="language-plaintext highlighter-rouge">[]unsafe.Pointer</code> to the arena, and sticking every pointer we allocate into it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>

  <span class="n">chunks</span> <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>  <span class="c">// New field.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip ...</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size,</span>
    <span class="c">// twice the last allocation, or the next power of two</span>
    <span class="c">// after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// ... snip ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The cost of the <code class="language-plaintext highlighter-rouge">append</code> is amortized: to allocate <code class="language-plaintext highlighter-rouge">n</code> bytes, we wind up allocating an additional <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> times. But what does this do to our benchmarks?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         800.08 MB/s
BenchmarkArena/int/new-48           386.81 MB/s
BenchmarkArena/[2]int/arena-48      1236.00 MB/s
BenchmarkArena/[2]int/new-48        520.84 MB/s
BenchmarkArena/[64]int/arena-48     7999.71 MB/s
BenchmarkArena/[64]int/new-48       2706.68 MB/s
BenchmarkArena/[1024]int/arena-48   9998.00 MB/s
BenchmarkArena/[1024]int/new-48     2816.28 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Seems pretty much the same, which is a good sign.</p> <h3 id="back-pointers"><a href="#back-pointers">Back Pointers</a></h3> <p>Now that the arena does not discard any allocated memory, we can focus on condition (3): making it so that if any pointer returned by <code class="language-plaintext highlighter-rouge">Alloc</code> is alive, then so is the whole arena.</p> <p>Here we can make use of an important property of how Go’s GC works: any pointer into an allocation will keep it alive, as well as <em>anything reachable from that pointer</em>. But the chunks we’re allocating are <code class="language-plaintext highlighter-rouge">[]uintptr</code>s, which will not be scanned. If there could <em>somehow</em> be a single pointer in this slice that was scanned, we would be able to stick the pointer <code class="language-plaintext highlighter-rouge">a *Arena</code> there, and so when anything that <code class="language-plaintext highlighter-rouge">Alloc</code> returns is scanned, it would cause <code class="language-plaintext highlighter-rouge">a</code> to be marked as alive.</p> <p>So far, we have been allocating <code class="language-plaintext highlighter-rouge">[N]uintptr</code> using <code class="language-plaintext highlighter-rouge">make([]T)</code>, but we would actually like to allocate <code class="language-plaintext highlighter-rouge">struct { A [N]uintptr; P unsafe.Pointer }</code>, where <code class="language-plaintext highlighter-rouge">N</code> is some dynamic value.</p> <p>In its infintie wisdom, the Go standard library actually gives us a dedicated mechanism to do this: <code class="language-plaintext highlighter-rouge">reflect.StructOf</code>. This can be used to construct arbitrary anonymous <code class="language-plaintext highlighter-rouge">struct</code> types at runtime, which we can then allocate on the heap.</p> <p>So, instead of calling <code class="language-plaintext highlighter-rouge">make</code>, we might call this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
    <span class="p">{</span>
      <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
      <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">words</span><span class="p">),</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()},</span>
  <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This appears to have a minor but noticeable effect on performance<sup id="fnref:type-cache" role="doc-noteref"><a href="#fn:type-cache" class="footnote" rel="footnote">6</a></sup>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         763.91 MB/s
BenchmarkArena/int/new-48           385.49 MB/s
BenchmarkArena/[2]int/arena-48      1174.00 MB/s
BenchmarkArena/[2]int/new-48        524.32 MB/s
BenchmarkArena/[64]int/arena-48     7563.54 MB/s
BenchmarkArena/[64]int/new-48       2649.63 MB/s
BenchmarkArena/[1024]int/arena-48   8668.02 MB/s
BenchmarkArena/[1024]int/new-48     2648.10 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <h2 id="more-optimizations"><a href="#more-optimizations">More Optimizations</a></h2> <p>Looking back at <code class="language-plaintext highlighter-rouge">Arena.Alloc</code>, the end of this function has a branch:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip...</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// Beware, offsetting to one-past-the-end is one of the few</span>
    <span class="c">// things explicitly not allowed by Go.</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is the absolute hottest part of allocation, since it is executed every time we call this function. The branch is a bit unfortunate, but it’s necessary, as noted by the comment.</p> <p>In C++, if we have an array of <code class="language-plaintext highlighter-rouge">int</code> with <code class="language-plaintext highlighter-rouge">n</code> elements in it, and <code class="language-plaintext highlighter-rouge">int* p</code> is a pointer to the start of the array, <code class="language-plaintext highlighter-rouge">p + n</code> is a valid pointer, even though it can’t be dereferenced; it points “one past the end” of the array. This is a useful construction, since, for example, you can use it to eliminate a loop induction variable:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Naive for loop, has an induction variable i.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// Faster: avoids the extra variable increment in the loop</span>
<span class="c1">// body for doing p[i].</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Go, however, gets very upset if you do this, because it confuses the garbage collector. The GC can’t tell the difference between a one-past-the-end pointer for allocation A, and for the start of allocation B immediately after it. At best this causes memory to stay alive for longer, and at worst it triggers safety interlocks in the GC. The GC will panic if it happens to scan a pointer for an address that it knows has been freed.</p> <p>But in our code above, every chunk now has an extra element at the very end that is not used for allocation, so we <em>can</em> have a pointer that <em>is</em> one-past-the-end of the <code class="language-plaintext highlighter-rouge">[N]uintptr</code> that we are vending memory from.</p> <p>The updated allocation function would look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip ...</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Notably, we do not replace <code class="language-plaintext highlighter-rouge">a.left</code> with an end pointer, because of the <code class="language-plaintext highlighter-rouge">if a.left &lt; words</code> comparison. We can’t actually avoid the subtraction <code class="language-plaintext highlighter-rouge">a.left -= words</code> because we would have to do it to make this comparison work if we got rid of <code class="language-plaintext highlighter-rouge">a.left</code>.</p> <p>So how much better is this?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         780.07 MB/s
BenchmarkArena/int/new-48           383.16 MB/s
BenchmarkArena/[2]int/arena-48      1245.73 MB/s
BenchmarkArena/[2]int/new-48        530.39 MB/s
BenchmarkArena/[64]int/arena-48     7684.39 MB/s
BenchmarkArena/[64]int/new-48       2679.94 MB/s
BenchmarkArena/[1024]int/arena-48   8859.99 MB/s
BenchmarkArena/[1024]int/new-48     2611.33 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Remarkably, not very! This is an improvement on the order of magnitude of one or two percentage points. This is because the branch we deleted is extremely predictable. Because Go’s codegen is relatively mediocre, the effect of highly predictable branches (assuming Go actually schedules the branches correctly 🙄) is quite minor.</p> <p>Turns out there’s a bigger improvement we can make.</p> <h3 id="write-barriers"><a href="#write-barriers">Write Barriers</a></h3> <p>Here’s the assembly Go generated for this function, heavily abridged, and annotated with the corresponding Go source code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">(*</span><span class="err">Arena</span><span class="p">).</span><span class="err">Alloc</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JBE</span>     <span class="err">moreStack</span>  <span class="c1">; Stack growth prologue.</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">0x58</span><span class="p">,</span> <span class="err">SP</span>

  <span class="c1">; size = (size + mask) &amp;^ mask</span>
  <span class="err">LEAQ</span>    <span class="m">0x7</span><span class="p">(</span><span class="err">BX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">ANDQ</span>    <span class="err">$</span><span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">,</span> <span class="err">DX</span>
  <span class="c1">; words := size / wordBytes</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">SI</span>
  <span class="err">SHRQ</span>    <span class="err">$</span><span class="m">0x3</span><span class="p">,</span> <span class="err">DX</span>

  <span class="c1">; if a.left &lt; words</span>
  <span class="err">CMPQ</span>    <span class="m">0x8</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">JAE</span>     <span class="err">alloc</span>

  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">SI</span><span class="p">,</span> <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>

  <span class="c1">; nextPow2(words)</span>
  <span class="err">MOVZX</span>   <span class="err">runtime</span><span class="p">.x</span><span class="m">86</span><span class="err">HasPOPCNT</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">DI</span>
  <span class="err">TESTL</span>   <span class="err">DI</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">XORL</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">POPCNTQ</span> <span class="err">DX</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">JMP</span>     <span class="m">2</span><span class="err">f</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">CALL</span>    <span class="err">math/bits</span><span class="p">.</span><span class="err">OnesCount</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">CMPQ</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">$</span><span class="m">0x1</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">BSRQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">$</span><span class="m">-0</span><span class="p">x</span><span class="m">1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">CMOVE</span>   <span class="err">DI</span><span class="p">,</span> <span class="err">CX</span>
  <span class="err">INCQ</span>    <span class="err">CX</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">SHLQ</span>    <span class="err">CL</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">$</span><span class="m">0x40</span>
  <span class="err">SBBQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">R8</span>
  <span class="err">ANDQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">MOVQ</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">DX</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="m">0x10</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">SHLQ</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">CX</span>

  <span class="c1">; a.cap = max(minWords, a.cap*2, nextPow2(words))</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">$</span><span class="m">0x8</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMOVA</span>   <span class="err">CX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMPQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMOVA</span>   <span class="err">DX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; a.next = a.allocChunk(a.cap)</span>
  <span class="err">CALL</span>    <span class="err">github</span><span class="p">.</span><span class="err">com/mcy/go-arena</span><span class="p">.(*</span><span class="err">Arena</span><span class="p">).</span><span class="err">allocChunk</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JNE</span>     <span class="m">1</span><span class="err">f</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">JMP</span>     <span class="m">2</span><span class="err">f</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>

  <span class="c1">; a.left = a.cap</span>
  <span class="err">MOVQ</span>    <span class="m">0x10</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x28</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="m">0x20</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">INCQ</span>    <span class="err">BX</span>
  <span class="err">MOVQ</span>    <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">JAE</span>     <span class="m">2</span><span class="err">f</span>

  <span class="c1">; a.chunks = append(a.chunks, a.next)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x50</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">LEAQ</span>    <span class="m">0x28f70</span><span class="p">(</span><span class="err">IP</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">growslice</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x28</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="m">0x50</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0x20</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">(</span><span class="err">R8</span><span class="p">)(</span><span class="err">BX</span><span class="p">*</span><span class="m">8</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">(</span><span class="err">R8</span><span class="p">)(</span><span class="err">BX</span><span class="p">*</span><span class="m">8</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">MOVQ</span>    <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">SI</span>

<span class="nl">alloc:</span>
  <span class="c1">; p := a.next</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">CX</span>

  <span class="c1">; a.next = unsafe.Add(a.next, size)</span>
  <span class="err">LEAQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">CX</span><span class="p">)(</span><span class="err">SI</span><span class="p">*</span><span class="m">1</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">MOVQ</span>    <span class="err">SI</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; a.left -= words</span>
  <span class="err">LEAQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">CX</span><span class="p">)(</span><span class="err">SI</span><span class="p">*</span><span class="m">1</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">SUBQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; return p</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">0x58</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>There’s a lot going on in this function, but most of it is a mix of Go not being great at register allocation, and lots of <em>write barriers</em>.</p> <p>A write barrier is a mechanism for synchronizing ordinary user code with the GC. Go generates code for one any time a non-pointer-free type is stored. For example, writing to a <code class="language-plaintext highlighter-rouge">**int</code>, <code class="language-plaintext highlighter-rouge">*string</code>, or <code class="language-plaintext highlighter-rouge">*[]int</code> requires a write barrier.</p> <p>Write barriers are implemented as follows:</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">runtime.writeBarrier</code> is checked, which determines whether the write barrier is necessary, which is only when the GC is in the mark phase. Otherwise the branch is taken to skip the write barrier.</p> </li> <li> <p>A call to one of the <code class="language-plaintext highlighter-rouge">runtime.gcWriteBarrierN</code> functions happens. <code class="language-plaintext highlighter-rouge">N</code> is the number of pointers that the GC needs to be informed of.</p> </li> <li> <p>This function calls <code class="language-plaintext highlighter-rouge">runtime.gcWriteBarrier</code>, which returns a buffer onto which pointers the GC needs to now trace through should be written to.</p> </li> <li> <p>The actual store happens.</p> </li> </ol> <p>A write barrier is required for a case like the following. Consider the following code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">alloc</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This function will call <code class="language-plaintext highlighter-rouge">runtime.newobject</code> to allocate eight bytes of memory. The resulting pointer will be returned in <code class="language-plaintext highlighter-rouge">rax</code>. This function then stores <code class="language-plaintext highlighter-rouge">rax</code> into <code class="language-plaintext highlighter-rouge">n</code> and returns. If we Godbolt this function, we’ll find that it does, in fact, generate a write barrier:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">x.</span><span class="err">alloc</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JLS</span>     <span class="err">growStack</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>

  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">main</span><span class="p">.</span><span class="err">n+</span><span class="m">32</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>

  <span class="c1">; new(int)</span>
  <span class="err">LEAQ</span>    <span class="nl">type:</span><span class="err">int</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">newobject</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>

  <span class="err">MOVQ</span>    <span class="err">main</span><span class="p">.</span><span class="err">n+</span><span class="m">32</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">TESTB</span>   <span class="err">AL</span><span class="p">,</span> <span class="p">(</span><span class="err">CX</span><span class="p">)</span>

  <span class="c1">; This is the write barrier.</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0</span>
  <span class="err">JEQ</span>     <span class="err">skip</span>
  <span class="err">MOVQ</span>    <span class="p">(</span><span class="err">CX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="nl">skip:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="p">(</span><span class="err">CX</span><span class="p">)</span>  <span class="c1">; The actual store.</span>

  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span>

<span class="nl">growStack:</span>
  <span class="err">NOP</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">JMP</span>     <span class="p">x.</span><span class="err">alloc</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>Note that two pointers get written: the pointer returned by <code class="language-plaintext highlighter-rouge">new(int)</code>, and the old value of <code class="language-plaintext highlighter-rouge">*n</code>. This ensures that regardless of where in this function the GC happens to be scanning through <code class="language-plaintext highlighter-rouge">*n</code>, it sees both values during the mark phase.</p> <p>Now, this isn’t necessary if the relevant pointers are already reachable in some other way… which is exactly the case in our arena (thanks to the <code class="language-plaintext highlighter-rouge">chunks</code> slice). So the write barrier in the fast path is redundant.</p> <p>But, how do we get rid of it? There is <code class="language-plaintext highlighter-rouge">//go:nowritebarrier</code>, but that’s not allowed outside of a list of packages allowlisted in the compiler. It also doens’t disable write barriers; it simply generates a diagnostic if any are emitted.</p> <p>But remember, write barriers only occur when storing pointer-typed memory… so we can just replace <code class="language-plaintext highlighter-rouge">next unsafe.Pointer</code> with <code class="language-plaintext highlighter-rouge">next uintptr</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="kt">uintptr</span> <span class="c">// A real pointer!</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>

  <span class="n">chunks</span> <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">wordBytes</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>

    <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">allocChunk</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">+=</span> <span class="n">size</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">go vet</code> hates this, because it doesn’t know that we’re smarter than it is. Does This make the code faster? To make it a little bit more realistic, I’ve written a separate variant of the benchmarks that hammers the GC really hard in a separate G:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GC</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}()</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The result indicates that this is a worthwhile optimization for churn-heavy contexts. Performance is much worse overall, but that’s because the GC is pre-empting everyone. The improvement seems to be on the order of 20% for very small allocations.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">#</span><span class="w"> </span>Before
<span class="go">BenchmarkArena/int/arena-48         169.09 MB/s
BenchmarkArena/int/new-48           84.73 MB/s
BenchmarkArena/[2]int/arena-48      309.40 MB/s
BenchmarkArena/[2]int/new-48        120.23 MB/s
BenchmarkArena/[64]int/arena-48     1954.16 MB/s
BenchmarkArena/[64]int/new-48       950.48 MB/s
BenchmarkArena/[1024]int/arena-48   3341.13 MB/s
BenchmarkArena/[1024]int/new-48     1413.26 MB/s

</span><span class="gp">#</span><span class="w"> </span>After
<span class="go">BenchmarkArena/int/arena-48         195.58 MB/s
BenchmarkArena/int/new-48           83.67 MB/s
BenchmarkArena/[2]int/arena-48      352.49 MB/s
BenchmarkArena/[2]int/new-48        120.13 MB/s
BenchmarkArena/[64]int/arena-48     1987.22 MB/s
BenchmarkArena/[64]int/new-48       903.78 MB/s
BenchmarkArena/[1024]int/arena-48   3342.67 MB/s
BenchmarkArena/[1024]int/new-48     1439.99 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <h3 id="cutting-out-the-heap-entirely"><a href="#cutting-out-the-heap-entirely">Cutting Out The Heap Entirely</a></h3> <p>Another source of slowdown is the fact that any time we allocate from the heap, it’s forced to eagerly clear the huge allocated chunk every time, because it contains pointers. If you profile this code, a ton of time is spent in <code class="language-plaintext highlighter-rouge">runtime.memclrNoHeapPointers</code>. Because the chunks of memory we allocate are always of a specific size, we can use an array of <code class="language-plaintext highlighter-rouge">sync.Pool</code>s to amortize the cost of allocating and clearing chunks.</p> <p>First, we need an entry in this array of pools, one for each size of memory we allocate. Then, we need to set a finalizer on the arena to reclaim its memory once we’re done. Finally, we can change the contract of <code class="language-plaintext highlighter-rouge">Alloc</code> to require the caller to clear the value for us, and change <code class="language-plaintext highlighter-rouge">New</code> take a value as its argument:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="n">Allocator</span><span class="p">,</span> <span class="n">v</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>What’s nice about this is that it avoids having to clear the value if a non-zero value would be allocated to it instead.</p> <p>Putting this all together, it would look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">pools</span> <span class="p">[</span><span class="m">64</span><span class="p">]</span><span class="n">sync</span><span class="o">.</span><span class="n">Pool</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">pools</span> <span class="p">{</span>
    <span class="n">pools</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">New</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="n">any</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
        <span class="p">{</span>
          <span class="n">Name</span><span class="o">:</span> <span class="s">"A"</span><span class="p">,</span>
          <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
        <span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"P"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()},</span>
      <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="c">// If this is the first chunk allocated, set a finalizer.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">SetFinalizer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">Arena</span><span class="p">)</span><span class="o">.</span><span class="n">finalize</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Place the returned chunk at the offset in a.chunks that</span>
  <span class="c">// corresponds to its log, so we can identify its size easily</span>
  <span class="c">// in the loop above.</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">log</span><span class="o">+</span><span class="m">1</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">finalize</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">log</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="n">words</span> <span class="o">:=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">log</span>
    <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// Make sure that we don't leak the arena.</span>

    <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>How does this perform?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48        1260.73 MB/s
BenchmarkArena/int/new-48          712.94 MB/s
BenchmarkArena/[2]int/arena-48     2457.27 MB/s
BenchmarkArena/[2]int/new-48       1167.57 MB/s
BenchmarkArena/[64]int/arena-48    4491.49 MB/s
BenchmarkArena/[64]int/new-48      6800.76 MB/s
BenchmarkArena/[1024]int/arena-48  3992.32 MB/s
BenchmarkArena/[1024]int/new-48    4320.65 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Well. That’s a surprise. It does much better for small allocations, but it made really big allocations worse! It’s not immediately clear to me why this is, but note that <code class="language-plaintext highlighter-rouge">new</code> also got <em>much</em> faster, which tells me that because the allocations from the arena are longer-lived, the GC behaves somewhat differently, causing some of the cost from allocating really large things with <code class="language-plaintext highlighter-rouge">new</code> to be amortized.</p> <p>Whether this optimization makes sense would require some profiling. An alternative is to manually manage arena re-use, by adding a very unsafe <code class="language-plaintext highlighter-rouge">Reset()</code> function that causes the arena to behave as if it was just constructed, but <em>keeping all of its allocated chunks</em>. This is analogous to reslicing to zero: <code class="language-plaintext highlighter-rouge">x = x[:0]</code>.</p> <p>This is very unsafe because it can lead to the same memory being allocated twice: this is <em>only</em> ok if the memory is not re-used.</p> <p>Implementing this is very simple.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">log</span> <span class="p">{</span>
    <span class="c">// If we've already allocated a chunk of this size in a previous arena</span>
    <span class="c">// generation, return it.</span>
    <span class="c">//</span>
    <span class="c">// This relies on the fact that an arena never tries to allocate the same</span>
    <span class="c">// size of chunk twice between calls to Reset().</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="c">// ... snip ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Then, if we modify our arena benchmark to take advantage of this…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"arena"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">Arena</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>  <span class="c">// Important!</span>
    <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
      <span class="n">sink</span> <span class="o">=</span> <span class="n">arena</span><span class="o">.</span><span class="n">New</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">a</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>What does the performance look like now?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         2376.01 MB/s
BenchmarkArena/int/new-48           377.64 MB/s
BenchmarkArena/[2]int/arena-48      4314.98 MB/s
BenchmarkArena/[2]int/new-48        530.62 MB/s
BenchmarkArena/[64]int/arena-48     10496.49 MB/s
BenchmarkArena/[64]int/new-48       3959.85 MB/s
BenchmarkArena/[1024]int/arena-48   9735.19 MB/s
BenchmarkArena/[1024]int/new-48     6160.73 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>That’s a massive improvement! There’s a couple of reasons this is faster. First, it doesn’t require waiting for the GC to collect old arenas to make their memory get reused. Second, the fast path is <em>very</em> fast with no synchronization.</p> <p>On the flipside, this is very dangerous: arena re-use needs to be carefully managed, because you can wind up with unique pointers that aren’t.</p> <h3 id="realloc"><a href="#realloc">Realloc</a></h3> <p>Go does not offer an easy mechanism to “reallocate” an allocation, as with <code class="language-plaintext highlighter-rouge">realloc()</code> in C. This is because it has no mechanism for freeing pointers explicitly, which is necessary for a reallocation abstraction.</p> <p>But we already don’t care about safety, so we can offer reallocation on our arena. Now, the reallocation we can offer is quite primitive: if a chunk happens to be the most recent one allocated, we can grow it. Otherwise we just allocate a new chunk and don’t free the old one.</p> <p>This makes it possible to implement “arena slices” that can be constructed by appending, which will not trigger reallocation on slice growth as long as nothing else gets put on the arena.</p> <p><code class="language-plaintext highlighter-rouge">Realloc</code> would look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Realloc</span><span class="p">(</span>
  <span class="n">ptr</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span>
  <span class="n">oldSize</span><span class="p">,</span> <span class="n">newSize</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">,</span>
<span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">oldSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldSize</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="n">newSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">newSize</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>

  <span class="k">if</span> <span class="n">newSize</span> <span class="o">&lt;=</span> <span class="n">oldSize</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ptr</span>
  <span class="p">}</span>

  <span class="c">// Check if this is the most recent allocation. If it is,</span>
  <span class="c">// we can grow in-place.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">-</span> <span class="n">oldSize</span> <span class="o">==</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Check if we have enough space available for the</span>
    <span class="c">// requisite extra space.</span>
    <span class="n">need</span> <span class="o">:=</span> <span class="p">(</span><span class="n">newSize</span> <span class="o">-</span> <span class="n">oldSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">wordBytes</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">need</span> <span class="p">{</span>
      <span class="c">// Grow in-place.</span>
      <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">need</span>
      <span class="k">return</span> <span class="n">ptr</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c">// Can't grow in place, allocate new memory and copy to it.</span>
  <span class="nb">new</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
  <span class="nb">copy</span><span class="p">(</span>
    <span class="n">unsafe</span><span class="o">.</span><span class="n">Slice</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nb">new</span><span class="p">),</span> <span class="n">newSize</span><span class="p">),</span>
    <span class="n">unsafe</span><span class="o">.</span><span class="n">Slice</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">oldSize</span><span class="p">),</span>
  <span class="p">)</span>

  <span class="k">return</span> <span class="nb">new</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Then, whenever we append to our arena slice, we can call <code class="language-plaintext highlighter-rouge">a.Realloc()</code> to grow it. However, this does not work if the slice’s base pointer is not the original address returned by <code class="language-plaintext highlighter-rouge">Alloc</code> or <code class="language-plaintext highlighter-rouge">Realloc</code>. It is an exercise for the reader to:</p> <ol> <li> <p>Implement a <code class="language-plaintext highlighter-rouge">Slice[T]</code> type that uses an arena for allocation.</p> </li> <li> <p>Make this work for any value of <code class="language-plaintext highlighter-rouge">ptr</code> within the most recent allocation, not just the base offset. This requires extra book-keeping.</p> </li> </ol> <h2 id="all-together"><a href="#all-together">All Together</a></h2> <p>Here is the entirety of the code that we have developed, not including the reallocation function above.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">arena</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"math/bits"</span>
  <span class="s">"reflect"</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">,</span> <span class="n">v</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>
  <span class="n">chunks</span>    <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="n">maxAlign</span> <span class="kt">uintptr</span> <span class="o">=</span> <span class="m">8</span> <span class="c">// Depends on target, this is for 64-bit.</span>
  <span class="n">minWords</span> <span class="kt">uintptr</span> <span class="o">=</span> <span class="m">8</span>
<span class="p">)</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// First, round the size up to the alignment of every object in the arena.</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">maxAlign</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="c">// Then, replace the size with the size in pointer-sized words. This does not</span>
  <span class="c">// result in any loss of size, since size is now a multiple of the uintptr</span>
  <span class="c">// size.</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">maxAlign</span>

  <span class="c">// Next, check if we have enough space left for this chunk. If there isn't,</span>
  <span class="c">// we need to grow.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size, twice the last</span>
    <span class="c">// allocation, or the next power of two after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">allocChunk</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>

    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">pools</span> <span class="p">[</span><span class="m">64</span><span class="p">]</span><span class="n">sync</span><span class="o">.</span><span class="n">Pool</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">pools</span> <span class="p">{</span>
    <span class="n">pools</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">New</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="n">any</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
        <span class="p">{</span>
          <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
          <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
        <span class="p">},</span>
        <span class="p">{</span> <span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()</span> <span class="p">},</span>
      <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">log</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="c">// If this is the first chunk allocated, set a finalizer.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">SetFinalizer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">Arena</span><span class="p">)</span><span class="o">.</span><span class="n">finalize</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Place the returned chunk at the offset in a.chunks that</span>
  <span class="c">// corresponds to its log, so we can identify its size easily</span>
  <span class="c">// in the loop above.</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">log</span><span class="o">+</span><span class="m">1</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">finalize</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">log</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="n">words</span> <span class="o">:=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">log</span>
    <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// Make sure that we don't leak the arena.</span>

    <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="o">.</span><span class="n">Len</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>There are other optimizations that we could make here that I haven’t discussed. For example, arenas could be re-used; once an arena is done, it could be “reset” and placed into a <code class="language-plaintext highlighter-rouge">sync.Pool</code>. This arena would not need to go into the GC to request new chunks, re-using the ones previously allocated (and potentially saving on the cost of zeroing memory over and over again).</p> <p>I did say that this relies very heavily on Go’s internal implementation details. Whats the odds that they get broken in the future? Well, the requirement that allocations know their shape is forced by the existence of <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>, and the requirement that a pointer into any part of an allocation keeps the whole thing alive essentially comes from slices being both sliceable and mutable; once a slice escapes to the heap (and thus multiple goroutines) coordinating copies for shrinking a slice would require much more complexity than the current write barrier implementation.</p> <p>And in my opinion, it’s pretty safe to say that Hyrum’s Law has us covered here. ;)</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:goub" role="doc-endnote"> <p>Go <em>does</em> have some UB. For example, Go assumes that a G’s stack is never read or written to by any other G, except by the GC across a write barrier.</p> <p>That said, what UB does exist is very, very difficult to trip on purpose. <a href="#fnref:goub" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:g" role="doc-endnote"> <p>I almost exclusively refer to goroutines as Gs here, since it makes it easy to refer to Ps and Ms as needed. See <a href="https://go.dev/src/runtime/HACKING#scheduler-structures">https://go.dev/src/runtime/HACKING#scheduler-structures</a>. <a href="#fnref:g" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptr-bits-endian" role="doc-endnote"> <p>The pointer bits are in big endian order, so the first bit in left-to-right order corresponds to the first word. <a href="#fnref:ptr-bits-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:itab" role="doc-endnote"> <p>The “itab”, or interface table part of an interface value is not managed by the GC; it is allocated in persistent memory, so even though it is a pointer, it is not a pointer the GC needs to care about. <a href="#fnref:itab" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:hchan" role="doc-endnote"> <p>Internal implementation of the <code class="language-plaintext highlighter-rouge">chan T</code> type, which is implemented as a <code class="language-plaintext highlighter-rouge">*runtime.hchan</code>. See <a href="https://cs.opensource.google/go/go/+/master:src/runtime/chan.go;l=34;drc=a204ed53d907c3b325e3c2bdd6f847a8f97e90d9">https://cs.opensource.google/go/go/+/master:src/runtime/chan.go;l=34;drc=a204ed53d907c3b325e3c2bdd6f847a8f97e90d9</a>. <a href="#fnref:hchan" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:type-cache" role="doc-endnote"> <p>This can be made better by caching the <code class="language-plaintext highlighter-rouge">reflect.Type</code>s, but that is only a very slight improvement on the order of 1% speedup. Most of the slowdown is because Go is a bit more eager about zeroing allocations of values that contain pointers.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">types</span> <span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Pre-allocate the whole array. There aren't that many powers</span>
  <span class="c">// of two. Don't need to go beyond 1&lt;&lt;61, since that's about as</span>
  <span class="c">// large of an allocation as Go will service (trying to create</span>
  <span class="c">// a larger array will panic).</span>
  <span class="n">types</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span> <span class="m">61</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">types</span> <span class="p">{</span>
    <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
      <span class="p">{</span>
        <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
        <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
      <span class="p">},</span>
      <span class="p">{</span> <span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()</span> <span class="p">},</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">log</span><span class="p">])</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>However, with this in place, we can be assured that property (3) now holds, so it’s perfectly safe to place arena pointers into arena-allocated memory, so long as it’s across the same arena. <a href="#fnref:type-cache" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-15 • 804 words • 6 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/15/protobuf-tip-2/"> Protobuf Tip #2: Compress Your Protos! </a></h1> </div> <div class="post"> <p><em>As a matter of fact, when compression technology came along, we thought the future in 1996 was about voice. We got it wrong. It is about voice, video, and data, and that is what we have today on these cell phones. –Steve Buyer</em></p> <p>TL;DR: Compression is everywhere: CDNs, HTTP servers, even in RPC frameworks like Connect. This pervasiveness means that wire size tradeoffs matter less than they used to twenty years ago, when Protobuf was designed.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-2-compress-protos">buf.build blog</a>.</p> </blockquote> <h2 id="varints-from-1998"><a href="#varints-from-1998">Varints from 1998</a></h2> <p>Protobuf’s wire format is intended to be relatively small. It makes use of <em>variable-width integers</em> so that smaller values take up less space on the wire. Fixed width integers might be larger on the wire, but often have faster decoding times.</p> <p>But what if I told you that doesn’t matter?</p> <p>See, most internet traffic is compressed. Bandwidth is precious, and CDN operators don’t want to waste time sending big blobs full of zeros. There are many compression algorithms available, but the state of the art for HTTP requests (which dominates much of global internet traffic) is <a href="https://en.wikipedia.org/wiki/Brotli">Brotli</a>, an algorithm developed at Google in 2013 and standardized in IETF <a href="https://datatracker.ietf.org/doc/html/rfc7932">RFC7932</a> in 2016. There is a very good chance that this article was delivered to your web browser as a Brotli-compressed blob.</p> <h2 id="using-compression"><a href="#using-compression">Using Compression</a></h2> <p>How compression is applied in your case will vary, but both Connect RPC and gRPC support native compression. For example, Connect has an API for injecting compression providers: <a href="https://pkg.go.dev/connectrpc.com/connect#WithCompression">https://pkg.go.dev/connectrpc.com/connect#WithCompression</a>.</p> <p>Connect uses <code class="language-plaintext highlighter-rouge">gzip</code> by default, which uses the DEFLATE compression algorithm. Providing your own compression algorithm (such as Brotli) is pretty simple, as shown by <a href="https://github.com/mattrobenolt/connect-brotli/blob/921ee0236bcd2d66827590c6890bb850e56516ad/connect_brotli.go">this third-party package</a>.</p> <p>Other services may compress for you transparently. Any competent CDN will likely use Brotli (or <code class="language-plaintext highlighter-rouge">gzip</code> or <code class="language-plaintext highlighter-rouge">zlib</code>, but probably Brotli) to compress any files it serves for you. (In fact, JavaScript and HTML minimization can often be rendered irrelevant by HTTP compression, too.)</p> <p>It’s important to remember that Protobuf predates pervasive compression: if it didn’t, it would almost certainly not use variable-width integers for anything. It only uses them because they offer a primitive form of compression in exchange for being slower to decode. If that tradeoff was eliminated, Protobuf would almost certainly only use fixed-width integers on the wire.</p> <h2 id="how-good-is-it-really"><a href="#how-good-is-it-really">How Good Is It Really?</a></h2> <p>Let’s do some apples-to-apples comparisons. Consider the following Protobuf type.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
	<span class="k">repeated</span> <span class="kt">int32</span> <span class="na">varints</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">repeated</span> <span class="kt">sfixed32</span> <span class="na">fixeds</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>There are two fields that contain essentially the same data, which can be encoded in four different ways: as old-style repeated fields, as packed fields, and the integers can be encoded as varints or fixed32 values.</p> <p>Using <a href="https://github.com/protocolbuffers/protoscope">Protoscope</a>, we can create some data that exercises these four cases:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># a.pb, repeated varint
</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">2</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">3</span>
<span class="c1"># ...
</span>
<span class="c1"># b.pb, packed varint
</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
  <span class="c1"># ...
</span><span class="p">}</span>

<span class="c1"># c.pb, repeated fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="n">i32</span>

<span class="c1"># d.pb, packed fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span><span class="n">i32</span> <span class="mi">2</span><span class="n">i32</span> <span class="mi">3</span><span class="n">i32</span>
  <span class="c1"># ...
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protoscope</div></div></div> <p>Each blob contains the integers from 1 to 1000 encoded in different ways. I’ll compress each one using gzip, zlib, and Brotli, using their default compression levels, and arrange their sizes, in bytes, in the table below.</p> <table> <thead> <tr> <th>File</th> <th>Uncompressed</th> <th><code class="language-plaintext highlighter-rouge">gzip</code> (DEFLATE)</th> <th><code class="language-plaintext highlighter-rouge">zlib</code></th> <th>Brotli</th> </tr> </thead> <tbody> <tr> <td>a.pb</td> <td>2875</td> <td>1899</td> <td>1878</td> <td>1094</td> </tr> <tr> <td>b.pb</td> <td>1877</td> <td>1534</td> <td>1524</td> <td>885</td> </tr> <tr> <td>c.pb</td> <td>5005</td> <td>1577</td> <td>1567</td> <td>1140</td> </tr> <tr> <td>d.pb</td> <td>4007</td> <td>1440</td> <td>1916</td> <td>1140</td> </tr> </tbody> </table> <p>Compression achieves incredible results: Brotli manages to get all of the files down to around 1.1 kB, except for the packed varints, which it gets about 250 bytes smaller! Of course, that’s only because most of the values in that repeated field are small. If the values range from 100000 to 101000, b.pb and d.pb are 3006 and 4007 bytes respectively (see that d.pb’s size is unchanged!), but when compressed with brotli, the lead for b.pb starts to disappear: 1039 bytes vs. 1163 bytes. Now it’s only 120 bytes smaller.</p> <h2 id="are-varints-still-better"><a href="#are-varints-still-better">Are Varints Still Better?</a></h2> <p>Applying compression can often have similar results to replacing everything with varints, but not exactly: using a varint will likely always be slightly smaller, at least when using state-of-the-art compression like Brotli. But you can pretty much always assume you <em>will</em> be using compression, such as to compress HTTP headers and other ancillary content in your request. Compression is generic and highly optimized—it applies to all data, regardless of schema, and is often far more optimized than application-level codecs like those in a Protobuf library.</p> <p>Not to mention, you should definitely be compressing any large data blobs you’re storing on disk, too!</p> <p>As a result, you can usually disregard many encoded size concerns when making tradeoffs in designing a Protobuf type. Fixed integer types will decode faster, so if decoding speed is important to you, and you’re worried about the size on the wire, don’t. It’s almost certainly already taken care of at a different layer of the stack.</p> </div> </div> </div> <div class="pagination post-footer"> <span class="pagination-item newer">&lt; Prev</span> • <a class="pagination-item older" href="https://mcyoung.xyz/page2">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>