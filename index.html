<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-06-03 • 874 words • 7 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/06/03/protobuf-tip-7/"> Protobuf Tip #7: Scoping It Out </a></h1> </div> <div class="post"> <p><em>You’d need a very specialized electron microscope to get down to the level to actually see a single strand of DNA. – Craig Venter</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">buf convert</code> is a powerful tool for examining wire format dumps, by converting them to JSON and using existing JSON analysis tooling. <code class="language-plaintext highlighter-rouge">protoscope</code> can be used for lower-level analysis, such debugging messages that have been corrupted.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-7-scoping-it-out">buf.build blog</a>.</p> </blockquote> <h2 id="json-from-protobuf"><a href="#json-from-protobuf">JSON from Protobuf?</a></h2> <p>JSON’s human-readable syntax is a big reason why it’s so popular, possibly second only to built-in support in browsers and many languages. It’s easy to examine any JSON document using tools like online prettifiers and the inimitable <code class="language-plaintext highlighter-rouge">jq</code>.</p> <p>But Protobuf is a binary format! This means that you can’t easily use <code class="language-plaintext highlighter-rouge">jq</code> -like tools with it…or can you?</p> <h2 id="transcoding-with-buf-convert"><a href="#transcoding-with-buf-convert">Transcoding with <code class="language-plaintext highlighter-rouge">buf convert</code></a></h2> <p>The Buf CLI offers a utility for transcoding messages between the three Protobuf encoding formats: the wire format, JSON, and textproto; it also supports YAML. This is <code class="language-plaintext highlighter-rouge">buf convert</code>, and it’s very powerful.</p> <p>To perform a conversion, we need four inputs:</p> <ol> <li>A Protobuf source to get types out of. This can be a local <code class="language-plaintext highlighter-rouge">.proto</code> file, an encoded <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> , or a remote BSR module. <ul> <li>If not provided, but run in a directory that is within a local Buf module, that module will be used as the Protobuf type source.</li> </ul> </li> <li>The name of the top-level type for the message we want to transcode, via the <code class="language-plaintext highlighter-rouge">--type</code> flag.</li> <li>The input message, via the <code class="language-plaintext highlighter-rouge">--from</code> flag.</li> <li>A location to output to, via the <code class="language-plaintext highlighter-rouge">--to</code> flag.</li> </ol> <p><code class="language-plaintext highlighter-rouge">buf convert</code> supports input and output redirection, making it usable as part of a shell pipeline. For example, consider the following Protobuf code in our local Buf module:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// my_api.proto</span>
<span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>
<span class="kn">package</span> <span class="nn">my</span><span class="o">.</span><span class="n">api.v1</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Cart</span> <span class="p">{</span>
  <span class="kt">int32</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">repeated</span> <span class="n">Order</span> <span class="na">orders</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Order</span> <span class="p">{</span>
  <span class="kt">fixed64</span> <span class="na">sku</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">sku_name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int64</span> <span class="na">count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Then, let’s say we’ve dumped a message of type <code class="language-plaintext highlighter-rouge">my.api.v1.Cart</code> from a service to debug it. And let’s say…well—you can’t just <code class="language-plaintext highlighter-rouge">cat</code> it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>dump.pb | xxd <span class="nt">-ps</span>
<span class="go">08a946121b097ac8e80400000000120e76616375756d20636c65616e6572
18011220096709b519000000001213686570612066696c7465722c203220
7061636b1806122c093aa8188900000000121f69736f70726f70796c2061
6c636f686f6c203730252c20312067616c6c6f6e1802</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>However, we can use <code class="language-plaintext highlighter-rouge">buf convert</code> to turn it into some nice JSON. We can then pipe it into <code class="language-plaintext highlighter-rouge">jq</code> to format it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf convert <span class="nt">--type</span> my.api.v1.Cart <span class="nt">--from</span> dump.pb <span class="nt">--to</span> -#format<span class="o">=</span>json | jq
<span class="go">{
  "userId": 9001,
  "orders": [
    {
      "sku": "82364538",
      "skuName": "vacuum cleaner",
      "count": "1"
    },
    {
      "sku": "431294823",
      "skuName": "hepa filter, 2 pack",
      "count": "6"
    },
    {
	    "sku": "2300094522",
      "skuName": "isopropyl alcohol 70%, 1 gallon",
      "count": "2"
    }
  ]
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Now you have the full expressivity of <code class="language-plaintext highlighter-rouge">jq</code> at your disposal. For example, we could pull out the user ID for the cart:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="k">function </span>buf-jq<span class="o">()</span> <span class="o">{</span> buf convert <span class="nt">--type</span> <span class="nv">$1</span> <span class="nt">--from</span> <span class="nv">$2</span> <span class="nt">--to</span> -#format<span class="o">=</span>json | jq <span class="nv">$3</span> <span class="o">}</span>
<span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'.userId'</span>
<span class="go">9001</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Or we can extract all of the SKUs that appear in the cart:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].sku]'</span>
<span class="go">[
  "82364538",
  "431294823",
  "2300094522"
]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Or we could try calculating how many items are in the cart, total:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count] | add'</span>
<span class="go">"162"</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Wait. That’s wrong. The answer should be <code class="language-plaintext highlighter-rouge">9</code>. This illustrates one pitfall to keep in mind when using <code class="language-plaintext highlighter-rouge">jq</code> with Protobuf. Protobuf will <em>sometimes</em> serialize numbers as quoted strings (the C++ reference implementation only does this when they’re integers outside of the IEEE754 representable range, but Go is somewhat lazier, and does it for all 64-bit values).</p> <blockquote> <p>You can test if an <code class="language-plaintext highlighter-rouge">x int64</code> is in the representable float range with this very simple check: <code class="language-plaintext highlighter-rouge">int64(float64(x)) == x)</code>. See <a href="https://go.dev/play/p/T81SbbFg3br">https://go.dev/play/p/T81SbbFg3br</a>. The <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/json/internal/unparser.cc#L96">equivalent version in C++</a> is much more complicated.</p> </blockquote> <p>This means we need to use the <code class="language-plaintext highlighter-rouge">tonumber</code> conversion function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count | tonumber] | add'</span>
<span class="go">9</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p><code class="language-plaintext highlighter-rouge">jq</code> ’s whole deal is JSON, so it brings with it all of JSON’s pitfalls. This is notable for Protobuf when trying to do arithmetic on 64-bit values. As we saw above, Protobuf serializes integers outside of the 64-bit float representable range (and in some runtimes, some integers inside it).</p> <p>For example, if you have a <code class="language-plaintext highlighter-rouge">repeated int64</code> that you want to sum over, it may produce incorrect answers due to floating-point rounding. For notes on conversions in <code class="language-plaintext highlighter-rouge">jq</code>, see <a href="https://jqlang.org/manual/#identity">https://jqlang.org/manual/#identity</a>.</p> <h2 id="disassembling-with-protoscope"><a href="#disassembling-with-protoscope">Disassembling with <code class="language-plaintext highlighter-rouge">protoscope</code></a></h2> <p><a href="https://github.com/protocolbuffers/protoscope"><code class="language-plaintext highlighter-rouge">protoscope</code></a> is a tool provided by the Protobuf team (which I originally wrote!) for decoding arbitrary data as if it were encoded in the Protobuf wire format. This process is called <em>disassembly</em>. It’s designed to work without a schema available, although it doesn’t produce especially clean output.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>go <span class="nb">install </span>github.com/protocolbuffers/protoscope/cmd/protoscope...@latest
<span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {
  1: 82364538i64
  2: {"vacuum cleaner"}
  3: 1
}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>The field names are gone; only field numbers are shown. This example also reveals an especially glaring limitation of <code class="language-plaintext highlighter-rouge">protoscope</code>, which is that it can’t tell the difference between string and message fields, so it guesses according to some heuristics. For the first and third elements it was able to grok them as strings, but for <code class="language-plaintext highlighter-rouge">orders[1].sku_name</code>, it incorrectly guessed it was a message and produced garbage.</p> <p>The tradeoff is that not only does <code class="language-plaintext highlighter-rouge">protoscope</code> not need a schema, it also tolerates almost any error, making it possible to analyze messages that have been partly corrupted. If we flip a random bit somewhere in <code class="language-plaintext highlighter-rouge">orders[0]</code>, disassembling the message still succeeds:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {`0f7ac8e80400000000120e76616375756d20636c65616e65721801`}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Although <code class="language-plaintext highlighter-rouge">protoscope</code> did give up on disassembling the corrupted submessage, it still made it through the rest of the dump.</p> <p>Like <code class="language-plaintext highlighter-rouge">buf convert</code>, we can give <code class="language-plaintext highlighter-rouge">protoscope</code> a <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> to make its heuristic a little smarter.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope <span class="se">\</span>
<span class="go">  --descriptor-set &lt;(buf build -o -) \
  --message-type my.api.v1.Cart \
  --print-field-names \
  dump.pb
</span><span class="gp">1: 9001                   #</span><span class="w"> </span>user_id
<span class="gp">2: {                      #</span><span class="w"> </span>orders
<span class="gp">  1: 82364538i64          #</span><span class="w"> </span>sku
<span class="gp">  2: {"vacuum cleaner"}   #</span><span class="w"> </span>sku_name
<span class="gp">  3: 1                    #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                          #</span><span class="w"> </span>orders
<span class="gp">  1: 431294823i64             #</span><span class="w"> </span>sku
<span class="gp">  2: {"hepa filter, 2 pack"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 6                        #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                                      #</span><span class="w"> </span>orders
<span class="gp">  1: 2300094522i64                        #</span><span class="w"> </span>sku
<span class="gp">  2: {"isopropyl alcohol 70%, 1 gallon"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 2                                    #</span><span class="w"> </span>count
<span class="go">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Not only is the second order decoded correctly now, but <code class="language-plaintext highlighter-rouge">protoscope</code> shows the name of each field (via <code class="language-plaintext highlighter-rouge">--print-field-names</code> ). In this mode, <code class="language-plaintext highlighter-rouge">protoscope</code> still decodes partially-valid messages.</p> <p><code class="language-plaintext highlighter-rouge">protoscope</code> also provides a number of other flags for customizing its heuristic in the absence of a <code class="language-plaintext highlighter-rouge">FileDescriporSet</code>. This enables it to be used as a forensic tool for debugging messy data corruption bugs.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-05-20 • 550 words • 4 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/05/20/protobuf-tip-6/"> Protobuf Tip #6: The Subtle Dangers of Enum Aliases </a></h1> </div> <div class="post"> <p><em>I’ve been very fortunate to dodge a nickname throughout my entire career. I’ve never had one. – Jimmie Johnson</em></p> <p>TL;DR: Enum values can have aliases. This feature is poorly designed and shouldn’t be used. The <a href="https://buf.build/docs/lint/rules/#enum_no_allow_alias"><code class="language-plaintext highlighter-rouge">ENUM_NO_ALLOW_ALIAS</code></a> Buf lint rule prevents you from using them by default.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-5-avoid-import-public-weak">buf.build blog</a>.</p> </blockquote> <h2 id="confusion-and-breakage"><a href="#confusion-and-breakage">Confusion and Breakage</a></h2> <p>Protobuf permits multiple enum values to have the same number. Such enum values are said to be <em>aliases</em> of each other. Protobuf used to allow this by default, but now you have to set a special option, <code class="language-plaintext highlighter-rouge">allow_alias</code>, for the compiler to not reject it.</p> <p>This can be used to effectively rename values without breaking existing code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">MyEnum</span> <span class="p">{</span>
  <span class="k">option</span> <span class="na">allow_alias</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="na">MY_ENUM_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">MY_ENUM_BAD</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[</span><span class="na">deprecated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">];</span>
  <span class="na">MY_ENUM_MORE_SPECIFIC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>This works perfectly fine, and is fully wire-compatible! And unlike renaming a field (see <a href="https://mcyoung.xyz//2025/05/08/protobuf-tip-1">TotW #1</a>), it won’t result in source code breakages.</p> <p>But if you use either reflection or JSON, or a runtime like Java that doesn’t cleanly allow enums with multiple names, you’ll be in for a nasty surprise.</p> <p>For example, if you request an enum value from an enum using reflection, such as with <code class="language-plaintext highlighter-rouge">protoreflect.EnumValueDescriptors.ByNumber()</code>, the value you’ll get is the one that appears in the file lexically. In fact, both <code class="language-plaintext highlighter-rouge">myapipb.MyEnum_MY_ENUM_BAD.String()</code> and <code class="language-plaintext highlighter-rouge">myapipb.MyEnum_MY_ENUM_MORE_SPECIFIC.String()</code> return the same value, leading to potential confusion, as the old “bad” value will be used in printed output like logs.</p> <p>You might think, “oh, I’ll switch the order of the aliases”. But that would be an <em>actual</em> wire format break. Not for the binary format, but for JSON. That’s because JSON preferentially stringifies enum values by using their declared name (if the value is in range). So, reordering the values means that what once serialized as <code class="language-plaintext highlighter-rouge">{"my_field": "MY_ENUM_BAD"}</code> now serializes as <code class="language-plaintext highlighter-rouge">{"my_field": "MY_ENUM_MORE_SPECIFIC"}</code> .</p> <p>If an old binary that hasn’t had the new enum value added sees this JSON document, it won’t parse correctly, and you’ll be in for a bad time.</p> <p>You can argue that this is a language bug, and it kind of is. Protobuf should include an equivalent of <code class="language-plaintext highlighter-rouge">json_name</code> for enum values, or mandate that JSON should serialize enum values with multiple names as a number, rather than an arbitrarily chosen enum name. The feature is intended to allow renaming of enum values, but unfortunately Protobuf hobbled it enough that it’s pretty dangerous.</p> <h1 id="what-to-do"><a href="#what-to-do">What To Do</a></h1> <p>Instead, if you <em>really</em> need to rename an enum value for usability or compliance reasons (ideally, not just aesthetics) you’re better off making a new enum type in a new version of your API. As long as the enum value numbers are the same, it’ll be binary-compatible, but it will <em>somewhat</em> reduce the risk of the above JSON confusion.</p> <p>Buf provides a lint rule against this feature, <a href="https://buf.build/docs/lint/rules/#enum_no_allow_alias"><code class="language-plaintext highlighter-rouge">ENUM_NO_ALLOW_ALIAS</code></a> , and Protobuf requires that you specify a magic option to enable this behavior, so in practice you don’t need to worry about this. But remember, the consequences of enum aliases go much further than JSON—they affect anything that uses reflection. So even if you don’t use JSON, you can still get burned.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-05-13 • 851 words • 7 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/05/13/protobuf-tip-5/"> Protobuf Tip #5: Avoid import public/weak </a></h1> </div> <div class="post"> <p><em>My dad had a guitar but it was acoustic, so I smashed a mirror and glued broken glass to it to make it look more metal. It looked ridiculous! –Max Cavalera</em></p> <p>TL;DR: Avoid <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf lint rules <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> and <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> enforce this for you by default.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-5-avoid-import-public-weak">buf.build blog</a>.</p> </blockquote> <p>Protobuf <code class="language-plaintext highlighter-rouge">import</code>s allow you to specify two special modes: <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf CLI lints against these by default, but you might be tempted to try using them anyway, especially because <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19">some GCP APIs use <code class="language-plaintext highlighter-rouge">import public</code></a>. What are these modes, and why do they exist?</p> <h2 id="import-visibility"><a href="#import-visibility">Import Visibility</a></h2> <p>Protobuf imports are by file path, a fact that is very strongly baked into the language and its reflection model.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">"my/other/api.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Importing a file dumps all of its symbols into the current file. For the purposes of name resolution, it’s as if all if the declarations in that file have been pasted into the current file. However, this isn’t transitive. If:</p> <ul> <li><code class="language-plaintext highlighter-rouge">a.proto</code> imports <code class="language-plaintext highlighter-rouge">b.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">b.proto</code> imports <code class="language-plaintext highlighter-rouge">c.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">c.proto</code> defines <code class="language-plaintext highlighter-rouge">foo.Bar</code>…</li> <li>then, <code class="language-plaintext highlighter-rouge">a.proto</code> must import <code class="language-plaintext highlighter-rouge">c.proto</code> to refer to <code class="language-plaintext highlighter-rouge">foo.Bar</code>, even though <code class="language-plaintext highlighter-rouge">b.proto</code> imports it.</li> </ul> <p>This is similar to how importing a package as <code class="language-plaintext highlighter-rouge">.</code> works in Go. When you write <code class="language-plaintext highlighter-rouge">import . "strings"</code>, it dumps all of the declarations from the <code class="language-plaintext highlighter-rouge">strings</code> package into the current file, but not those of any files that <code class="language-plaintext highlighter-rouge">"strings"</code> imports.</p> <p>Now, what’s nice about Go is that packages can be broken up into files in a way that is transparent to users; users of a package import <em>the package</em>, not the files of that package. Unfortunately, Protobuf is not like that, so the file structure of a package leaks to its callers.</p> <p><code class="language-plaintext highlighter-rouge">import public</code> was intended as a mechanism for allowing API writers to break up files that were getting out of control. You can define a new file <code class="language-plaintext highlighter-rouge">new.proto</code> for some of the definitions in <code class="language-plaintext highlighter-rouge">big.proto</code>, move them to the new file, and then add <code class="language-plaintext highlighter-rouge">import public "new.proto";</code> to <code class="language-plaintext highlighter-rouge">big.proto</code>. Existing imports of <code class="language-plaintext highlighter-rouge">big.proto</code> won’t be broken, hooray!</p> <p>Except this feature was designed for C++. In C++, each <code class="language-plaintext highlighter-rouge">.proto</code> file maps to a <code class="language-plaintext highlighter-rouge">.proto.h</code> header, which you <code class="language-plaintext highlighter-rouge">#include</code> in your application code. In C++, <code class="language-plaintext highlighter-rouge">#include</code> behaves like <code class="language-plaintext highlighter-rouge">import public</code>, so marking an import as <code class="language-plaintext highlighter-rouge">public</code> only changes name resolution in Protobuf—the C++ backend doesn’t have to do anything to maintain source compatibility when an import is changed to <code class="language-plaintext highlighter-rouge">public</code>.</p> <p>But other backends, like Go, do not work this way: <code class="language-plaintext highlighter-rouge">import</code> in Go <em>doesn’t</em> pull in symbols transitively, so Go would need to explicitly add aliases for all of the symbols that come in through a public import. That is, if you had:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// foo.proto</span>
<span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// bar.proto</span>
<span class="kn">package</span> <span class="nn">myotherapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="k">import</span> <span class="n">public</span> <span class="s">"foo.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Then the Go backend has to generate a <code class="language-plaintext highlighter-rouge">type Foo = foopb.Foo</code> in <code class="language-plaintext highlighter-rouge">bar.pb.go</code> to emulate this behavior (in fact, I was surprised to learn Go Protobuf implements this at all). Go <em>happens</em> to implement public imports correctly, but not all backends are as careful, because this feature is obscure.</p> <p>The <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19"><code class="language-plaintext highlighter-rouge">spanner.proto</code></a> example of an <code class="language-plaintext highlighter-rouge">import public</code> isn’t even used for breaking up an existing file; instead, it’s used to not make a huge file bigger and avoid making callers have to add an additional import. This is a <em>bad use</em> of a <em>bad feature!</em></p> <p>Using <code class="language-plaintext highlighter-rouge">import public</code> to effectively “hide” imports makes it harder to understand what a <code class="language-plaintext highlighter-rouge">.proto</code> file is pulling in. If Protobuf imports were at the package/symbol level, like Go or Java, this feature would not need to exist. Unfortunately, Protobuf is closely tailored for C++, and this is one of the consequences.</p> <p>Instead of using <code class="language-plaintext highlighter-rouge">import public</code> to break up a file, simply plan to break up the file in the next version of the API.</p> <p>The <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> Buf lint rule enforces that no one uses this feature by default. It’s tempting, but the footguns aren’t worth it.</p> <h2 id="weak-imports"><a href="#weak-imports">Weak Imports</a></h2> <p>Public imports have a good, if flawed, reason to exist. Their implementation details are the main thing that kneecaps them.</p> <p>Weak imports, however, simply should not exist. They were added to the language to make it easier for some of Google’s enormous binaries to avoid running out of linker memory, by making it so that message types could be dropped if they weren’t accessed. This means that weak imports are “optional”—if the corresponding descriptors are missing at runtime, the C++ runtime can handle it gracefully.</p> <p>This leads to all kinds of implementation complexity and subtle behavior differences across runtimes. Most runtimes implement (or implemented, in the case of those that removed support) <code class="language-plaintext highlighter-rouge">import weak</code> in a buggy or inconsistent way. It’s unlikely the feature will ever be truly removed, even though Google has tried.</p> <p>Don’t use <code class="language-plaintext highlighter-rouge">import weak</code>. It should be treated as completely non-functional. The <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> Buf lint rule takes care of this for you.</p> </div> </div> </div> <div class="pagination post-footer"> <span class="pagination-item newer">&lt; Prev</span> • <a class="pagination-item older" href="https://mcyoung.xyz/page2">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>