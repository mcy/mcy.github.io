<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-05-13 • 851 words • 7 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/05/13/protobuf-tip-5/"> Protobuf Tip #5: Avoid import public/weak </a></h1> </div> <div class="post"> <p><em>My dad had a guitar but it was acoustic, so I smashed a mirror and glued broken glass to it to make it look more metal. It looked ridiculous! –Max Cavalera</em></p> <p>TL;DR: Avoid <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf lint rules <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> and <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> enforce this for you by default.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-5-avoid-import-public-weak">buf.build blog</a>.</p> </blockquote> <p>Protobuf <code class="language-plaintext highlighter-rouge">import</code>s allow you to specify two special modes: <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf CLI lints against these by default, but you might be tempted to try using them anyway, especially because <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19">some GCP APIs use <code class="language-plaintext highlighter-rouge">import public</code></a>. What are these modes, and why do they exist?</p> <h2 id="import-visibility"><a href="#import-visibility">Import Visibility</a></h2> <p>Protobuf imports are by file path, a fact that is very strongly baked into the language and its reflection model.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">"my/other/api.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Importing a file dumps all of its symbols into the current file. For the purposes of name resolution, it’s as if all if the declarations in that file have been pasted into the current file. However, this isn’t transitive. If:</p> <ul> <li><code class="language-plaintext highlighter-rouge">a.proto</code> imports <code class="language-plaintext highlighter-rouge">b.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">b.proto</code> imports <code class="language-plaintext highlighter-rouge">c.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">c.proto</code> defines <code class="language-plaintext highlighter-rouge">foo.Bar</code>…</li> <li>then, <code class="language-plaintext highlighter-rouge">a.proto</code> must import <code class="language-plaintext highlighter-rouge">c.proto</code> to refer to <code class="language-plaintext highlighter-rouge">foo.Bar</code>, even though <code class="language-plaintext highlighter-rouge">b.proto</code> imports it.</li> </ul> <p>This is similar to how importing a package as <code class="language-plaintext highlighter-rouge">.</code> works in Go. When you write <code class="language-plaintext highlighter-rouge">import . "strings"</code>, it dumps all of the declarations from the <code class="language-plaintext highlighter-rouge">strings</code> package into the current file, but not those of any files that <code class="language-plaintext highlighter-rouge">"strings"</code> imports.</p> <p>Now, what’s nice about Go is that packages can be broken up into files in a way that is transparent to users; users of a package import <em>the package</em>, not the files of that package. Unfortunately, Protobuf is not like that, so the file structure of a package leaks to its callers.</p> <p><code class="language-plaintext highlighter-rouge">import public</code> was intended as a mechanism for allowing API writers to break up files that were getting out of control. You can define a new file <code class="language-plaintext highlighter-rouge">new.proto</code> for some of the definitions in <code class="language-plaintext highlighter-rouge">big.proto</code>, move them to the new file, and then add <code class="language-plaintext highlighter-rouge">import public "new.proto";</code> to <code class="language-plaintext highlighter-rouge">big.proto</code>. Existing imports of <code class="language-plaintext highlighter-rouge">big.proto</code> won’t be broken, hooray!</p> <p>Except this feature was designed for C++. In C++, each <code class="language-plaintext highlighter-rouge">.proto</code> file maps to a <code class="language-plaintext highlighter-rouge">.proto.h</code> header, which you <code class="language-plaintext highlighter-rouge">#include</code> in your application code. In C++, <code class="language-plaintext highlighter-rouge">#include</code> behaves like <code class="language-plaintext highlighter-rouge">import public</code>, so marking an import as <code class="language-plaintext highlighter-rouge">public</code> only changes name resolution in Protobuf—the C++ backend doesn’t have to do anything to maintain source compatibility when an import is changed to <code class="language-plaintext highlighter-rouge">public</code>.</p> <p>But other backends, like Go, do not work this way: <code class="language-plaintext highlighter-rouge">import</code> in Go <em>doesn’t</em> pull in symbols transitively, so Go would need to explicitly add aliases for all of the symbols that come in through a public import. That is, if you had:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// foo.proto</span>
<span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// bar.proto</span>
<span class="kn">package</span> <span class="nn">myotherapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="k">import</span> <span class="n">public</span> <span class="s">"foo.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Then the Go backend has to generate a <code class="language-plaintext highlighter-rouge">type Foo = foopb.Foo</code> in <code class="language-plaintext highlighter-rouge">bar.pb.go</code> to emulate this behavior (in fact, I was surprised to learn Go Protobuf implements this at all). Go <em>happens</em> to implement public imports correctly, but not all backends are as careful, because this feature is obscure.</p> <p>The <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19"><code class="language-plaintext highlighter-rouge">spanner.proto</code></a> example of an <code class="language-plaintext highlighter-rouge">import public</code> isn’t even used for breaking up an existing file; instead, it’s used to not make a huge file bigger and avoid making callers have to add an additional import. This is a <em>bad use</em> of a <em>bad feature!</em></p> <p>Using <code class="language-plaintext highlighter-rouge">import public</code> to effectively “hide” imports makes it harder to understand what a <code class="language-plaintext highlighter-rouge">.proto</code> file is pulling in. If Protobuf imports were at the package/symbol level, like Go or Java, this feature would not need to exist. Unfortunately, Protobuf is closely tailored for C++, and this is one of the consequences.</p> <p>Instead of using <code class="language-plaintext highlighter-rouge">import public</code> to break up a file, simply plan to break up the file in the next version of the API.</p> <p>The <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> Buf lint rule enforces that no one uses this feature by default. It’s tempting, but the footguns aren’t worth it.</p> <h2 id="weak-imports"><a href="#weak-imports">Weak Imports</a></h2> <p>Public imports have a good, if flawed, reason to exist. Their implementation details are the main thing that kneecaps them.</p> <p>Weak imports, however, simply should not exist. They were added to the language to make it easier for some of Google’s enormous binaries to avoid running out of linker memory, by making it so that message types could be dropped if they weren’t accessed. This means that weak imports are “optional”—if the corresponding descriptors are missing at runtime, the C++ runtime can handle it gracefully.</p> <p>This leads to all kinds of implementation complexity and subtle behavior differences across runtimes. Most runtimes implement (or implemented, in the case of those that removed support) <code class="language-plaintext highlighter-rouge">import weak</code> in a buggy or inconsistent way. It’s unlikely the feature will ever be truly removed, even though Google has tried.</p> <p>Don’t use <code class="language-plaintext highlighter-rouge">import weak</code>. It should be treated as completely non-functional. The <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> Buf lint rule takes care of this for you.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-29 • 836 words • 6 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/29/protobuf-tip-4/"> Protobuf Tip #4: Accepting Mistakes We Can't Fix </a></h1> </div> <div class="post"> <p><em>Bad humor is an evasion of reality; good humor is an acceptance of it. –Malcolm Muggeridge</em></p> <p>TL;DR: Protobuf’s distributed nature introduces evolution risks that make it hard to fix some types of mistakes. Sometimes the best thing to do is to just let it be.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-4-accepting-mistakes">buf.build blog</a>.</p> </blockquote> <h2 id="a-different-mindset"><a href="#a-different-mindset">A Different Mindset</a></h2> <p>Often, you’ll design and implement a feature for the software you work on, and despite your best efforts to test it, something terrible happens in production. We have a playbook for this, though: fix the bug in your program and ship or deploy the new, fixed version to your users. It might mean working late for big emergencies, but turnaround for most organizations is a day to a week.</p> <p>Most bugs aren’t emergencies, though. Sometimes a function has a confusing name, or an integer type is just a bit too small for real-world data, or an API conflates “zero” and “null”. You fix the API, refactor all usages in your API in one commit, merge, and the fix rolls out gradually.</p> <p>Unless, of course, it’s a bug in a communication API, like a serialization format: your Protobuf types, or your JSON schema, or the not-too-pretty code that parses fields out of dict built from a YAML file. Here, you can’t <em>just</em> atomically fix the world. Fixing bugs in your APIs (from here on, “APIs” means “Protobuf definitions”) requires a different mindset than fixing bugs in ordinary code.</p> <h2 id="what-are-the-risks"><a href="#what-are-the-risks">What Are the Risks?</a></h2> <p>Protobuf’s wire format is designed so that you can safely add new fields to a type, or values to an enum, without needing to perform an atomic upgrade. But other changes, like renaming fields or changing their type, are very dangerous.</p> <p>This is because Protobuf types exist on a temporal axis: different versions of the same type exist simultaneously among programs in the field that are actively talking to each other. This means that <em>writers from the future</em> (that is, new serialization code) must be careful to not confuse the many <em>readers from the past</em> (old versions of the deserialization code). Conversely, future readers must tolerate anything past writers produce.</p> <p>In a modern distributed deployment, the number of versions that exist at once can be quite large. This is true even in self-hosted clusters, but becomes much more fraught whenever user-upgradable software is involved. This can include mobile applications that talk to your servers, or appliance software managed by a third-party administrator, or even just browser-service communication.</p> <p>The most important principle: you can’t easily control when old versions of a type or service are no longer relevant. As soon as a type escapes out of the scope of even a single team, upgrading types becomes a departmental effort.</p> <h2 id="learning-to-love-the-bomb"><a href="#learning-to-love-the-bomb">Learning to Love the Bomb</a></h2> <p>There are many places where Protobuf could have made schema evolution easier, but didn’t. For example, changing <code class="language-plaintext highlighter-rouge">int32 foo = 1;</code> to <code class="language-plaintext highlighter-rouge">sfixed32 foo = 1;</code> is a breakage, even though at the wire format level, it is <em>possible</em> for a parser to distinguish and accept both forms of <code class="language-plaintext highlighter-rouge">foo</code> correctly. There too many other examples to list, but it’s important to understand that the language is not always working in our favor.</p> <p>For example, if we notice a <code class="language-plaintext highlighter-rouge">int32</code> value is too small, and should have been 64-bit, you can’t upgrade it without readers from the past potentially truncating it. But we really have to upgrade it! What are our options?</p> <ol> <li>Issue a new version of the message and all of its dependencies. This is the main reason why sticking a version number in the package name, as enforced by Buf’s <a href="https://buf.build/docs/lint/rules/#package_version_suffix"><code class="language-plaintext highlighter-rouge">PACKAGE_VERSION_SUFFIX</code></a> lint rule, is so important.</li> <li>Do the upgrade anyway and hope nothing breaks. This <em>can</em> work for certain kinds of upgrades, if the underlying format is compatible, but it can have <strong>disastrous consequences</strong> if you don’t know what you’re doing, especially if it’s a type that’s not completely internal to a team’s project. <a href="https://buf.build/docs/breaking/overview/">Buf breaking change detection</a> helps you avoid changes with potential for breakage.</li> </ol> <p>Of course, there is a third option, which is to accept that some things aren’t worth fixing. When the cost of a fix is so high, fixes just aren’t worth it, especially when the language is working against us.</p> <p>This means that even in Buf’s own APIs, we sometimes do things in a way that isn’t quite ideal, or is inconsistent with our own best practices. Sometimes, the ecosystem changes in a way that changes best practice, but we can’t upgrade to it without breaking our users. In the same way, you shouldn’t rush to use new, better language features if they would cause protocol breaks: sometimes, the right thing is to do nothing, because not breaking your users is more important. <br/></p> <p> </p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-04-22 • 725 words • 6 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/04/22/protobuf-tip-3/"> Protobuf Tip #3: Enum Names Need Prefixes </a></h1> </div> <div class="post"> <p><em>Smart people learn from their mistakes. But the real sharp ones learn from the mistakes of others. –Brandon Mull</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">enum</code>s inherit some unfortunate behaviors from C++. Use the Buf lint rules <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a> and <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a>  to avoid this problem (they’re part of the <code class="language-plaintext highlighter-rouge">DEFAULT</code> category).</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-3-enum-names-need-prefixes">buf.build blog</a>.</p> </blockquote> <h2 id="c-style-enums"><a href="#c-style-enums">C++-Style Enums</a></h2> <p>Protobuf’s <code class="language-plaintext highlighter-rouge">enum</code>s define data types that represent a small set of valid values. For example, <code class="language-plaintext highlighter-rouge">google.rpc.Code</code> lists status codes used by various RPC frameworks, such as GRPC. Under the hood, every <code class="language-plaintext highlighter-rouge">enum</code> is just an <code class="language-plaintext highlighter-rouge">int32</code>  on the wire, although codegen backends will generate custom types and constants for the enum to make it easier to use.</p> <p>Unfortunately, <code class="language-plaintext highlighter-rouge">enum</code>s were originally designed to match C++ enums exactly, and they inadvertently replicate many of those behaviors.</p> <p>If you look at the source for <code class="language-plaintext highlighter-rouge">google.rpc.Code</code>, and compare it to, say, <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.Type</code>, you will notice a subtle difference:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="k">rpc</span><span class="p">;</span>
<span class="kd">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="na">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">UNKNOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="n">protobuf</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">FieldDescriptorProto</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// 0 is reserved for errors.</span>
    <span class="na">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">TYPE_INT64</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p><code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> has values starting with <code class="language-plaintext highlighter-rouge">TYPE_</code>, but <code class="language-plaintext highlighter-rouge">Code</code> ‘s values don’t have a <code class="language-plaintext highlighter-rouge">CODE_</code> prefix.  This is because the fully-qualified names (FQN) of an enum value <em>don’t include the name of the enum.</em> That is, <code class="language-plaintext highlighter-rouge">TYPE_DOUBLE</code> actually refers to <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.TYPE_DOUBLE</code>. Thus, <code class="language-plaintext highlighter-rouge">OK</code> is not <code class="language-plaintext highlighter-rouge">google.rpc.Code.OK</code>, but <code class="language-plaintext highlighter-rouge">google.rpc.OK</code>.</p> <p>This is because it matches the behavior of unscoped C++ enums. C++ is the “reference” implementation, so the language often bends for the sake of the C++ backend.</p> <p>When generating code, <code class="language-plaintext highlighter-rouge">protoc</code>’s C++ backend emits the above as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">rpc</span> <span class="p">{</span>
<span class="k">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">FieldDescriptorProto</span> <span class="k">final</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">enum</span> <span class="n">Type</span> <span class="p">{</span>
   <span class="n">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// ...</span>
  <span class="p">};</span>
<span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And in C++, <code class="language-plaintext highlighter-rouge">enum</code>s don’t scope their enumerators: you write <code class="language-plaintext highlighter-rouge">google::rpc::OK</code>, NOT <code class="language-plaintext highlighter-rouge">google::rpc::Code::OK</code>.</p> <p>If you know C++, you might be thinking, “why didn’t they use <code class="language-plaintext highlighter-rouge">enum class</code>?!”? Enums were added in <code class="language-plaintext highlighter-rouge">proto2</code>, which was developed around 2007-2008, but Google didn’t start using C++11, which introduced <code class="language-plaintext highlighter-rouge">enum class</code> , until much, much later.</p> <p>Now, if you’re a Go or Java programmer, you’re probably wondering why you even care about C++. Both Go and Java do scope enum values to the enum type (although Go does it in a somewhat grody way: <code class="language-plaintext highlighter-rouge">rpcpb.Code_OK</code>).</p> <p>Unfortunately, this affects name collision detection in Protobuf. You can’t write the following code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Because the enum name is not part of the FQN for an enum value, both <code class="language-plaintext highlighter-rouge">UNSPECIFIED</code>s here have the FQN <code class="language-plaintext highlighter-rouge">myapi.v1.UNSPECIFIED</code>, so Protobuf complains about duplicate symbols.</p> <p>Thus, the convention we see in <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">STOPLIGHT_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">STOPLIGHT_RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">STOPLIGHT_YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">STOPLIGHT_GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">SPEED_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SPEED_SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">SPEED_FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Buf provides a lint rule to enforce this convention: <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a>. Even though you might think that an enum name will be unique, because top-level enums bleed their names into the containing package, the problem spreads across packages!</p> <h2 id="zero-values"><a href="#zero-values">Zero Values</a></h2> <p><code class="language-plaintext highlighter-rouge">proto3</code> relies heavily on the concept of “zero values” – all non-message fields that are neither <code class="language-plaintext highlighter-rouge">repeated</code> nor <code class="language-plaintext highlighter-rouge">optional</code> are implicitly zero if they are not present. Thus, <code class="language-plaintext highlighter-rouge">proto3</code> requires that enums specify a value equal to zero.</p> <p>By convention, this value shouldn’t be a specific value of the enum, but rather a value representing that no value is specified. <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a> enforces this, with a default of <code class="language-plaintext highlighter-rouge">_UNSPECIFIED</code>. Of course, there are situations where this might not make sense for you, and a suffix like <code class="language-plaintext highlighter-rouge">_ZERO</code> or <code class="language-plaintext highlighter-rouge">_UNKNOWN</code> might make more sense.</p> <p>It may be tempting to have a specific “good default” value for the zero value. Beware though, because that choice is forever. Picking a generic “unknown” as the default reduces the chance you’ll burn yourself.</p> <h2 id="why-dont-all-of-googles-protobuf-files-do-this"><a href="#why-dont-all-of-googles-protobuf-files-do-this">Why Don’t All of Google’s Protobuf Files Do This?</a></h2> <p>Name prefixes and zero values also teach us an important lesson: because Protobuf names are forever, it’s really hard to fix style mistakes, especially as we collectively get better at using Protobuf.</p> <p><code class="language-plaintext highlighter-rouge">google.rpc.Code</code> is intended to be source-compatible with very old existing C++ code, so it throws caution to the wind. <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> doesn’t have a zero value because in <code class="language-plaintext highlighter-rouge">proto2</code> , which doesn’t have zero value footguns in its wire format, you don’t need to worry about that. The lesson isn’t just to use Buf’s linter to try to avoid some of the known pitfalls, but also to remember that even APIs designed by the authors of the language make unfixable mistakes, so unlike other programming languages, imitating “existing practice” isn’t always the best strategy.</p> </div> </div> </div> <div class="pagination post-footer"> <span class="pagination-item newer">&lt; Prev</span> • <a class="pagination-item older" href="https://mcyoung.xyz/page2">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>