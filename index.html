<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> • <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/feed"> <img style="height: 0.8em; transform: translate(0.07em, 0.15em);" src="https://mcyoung.xyz/public/images/rss.svg"></a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-07-14 • 4003 words • 44 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <h1><a href="/2025/07/14/best/"> The Best C++ Library </a></h1> </div> <div class="post"> <p>It’s no secret that my taste in programming languages is very weird for a programming language <del>enthusiast</del> professional. Several of my <a href="https://mcyoung.xyz/2025/07/07/nosplit/">last</a> <a href="https://mcyoung.xyz/2025/04/21/go-arenas/">few</a> <a href="https://mcyoung.xyz/2024/12/16/rangefuncs/">posts</a> are about Go, broadly regarded as the programming language equivalent of eating plain oatmeal for breakfast.</p> <p>To make up for that, I’m going to write about the programming language equivalent of diluting your morning coffee with <a href="https://en.wikipedia.org/wiki/Everclear">Everclear</a>. I am, of course, talking about C++.</p> <p>If you’ve ever had the misfortune of doing C++ professionally, you’ll know that the C++ standard library is really bad. Where to begin?</p> <p>Well, the associative containers are terrible. Due to bone-headed API decisions, <a href="https://en.cppreference.com/w/cpp/container/unordered_map.html"><code class="language-plaintext highlighter-rouge">std::unordered_map</code></a> MUST be a closed-addressing, array-of-linked-lists map, not a Swisstable, despite closed-addressing being an outdated technology. <a href="https://www.cppreference.com/w/cpp/container/map.html"><code class="language-plaintext highlighter-rouge">std::map</code></a>, which is not what you usually want, <em>must</em> be a red-black tree. It can’t be a b-tree, like every sensible language provides for the ordered map.</p> <p><a href="https://en.cppreference.com/w/cpp/utility/optional.html"><code class="language-plaintext highlighter-rouge">std::optional</code></a> is a massive pain in the ass to use, and is full of footguns, like <code class="language-plaintext highlighter-rouge">operator*</code>. <code class="language-plaintext highlighter-rouge">std::variant</code> is also really annoying to use. <a href="https://en.cppreference.com/w/cpp/filesystem.html"><code class="language-plaintext highlighter-rouge">std::filesystem</code></a> is full of sharp edges. And where are the APIs for signals?</p> <p>Everything is extremely wordy. <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size.html"><code class="language-plaintext highlighter-rouge">std::hardware_destructive_interference_size</code></a> could have been called <code class="language-plaintext highlighter-rouge">std::cache_line</code>. <a href="https://en.cppreference.com/w/cpp/container/span/subspan"><code class="language-plaintext highlighter-rouge">std::span::subspan</code></a> could have used <code class="language-plaintext highlighter-rouge">opeartor[]</code>. The standard algorithms are super wordy, because they deal with iterator pairs. Oh my god, iterator pairs. They added <a href="https://en.cppreference.com/w/cpp/ranges.html"><code class="language-plaintext highlighter-rouge">std::ranges</code></a>, which do not measure up to Rust’s <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code class="language-plaintext highlighter-rouge">Iterator</code></a> at all!</p> <p>I’m so mad about all this! The people in charge of C++ clearly, actively hate their users!<sup id="fnref:terrible-people" role="doc-noteref"><a href="#fn:terrible-people" class="footnote" rel="footnote">1</a></sup> They want C++ to be as hard and unpleasant as possible to use. Many brilliant people that I am lucky to consider friends and colleagues, including Titus Winters, JeanHeyd Meneide, Matt Fowles-Kulukundis, and Andy Soffer, have tried and mostly failed<sup id="fnref:jh" role="doc-noteref"><a href="#fn:jh" class="footnote" rel="footnote">2</a></sup> to improve the language.</p> <p>This is much to say that I believe C++ in its current form is unfixable. But that’s only due to the small-mindedness of a small cabal based out of Redmond. What if we could do whatever we wanted? What if we used C++’s incredible library-building language features to build a brand-new language?</p> <p>For the last year-or-so I’ve been playing with a wild idea: what would C++ look like if we did it over again? Starting from an empty C++20 file with no access to the standard library, what can we build in its place?</p> <h2 id="starting-over"><a href="#starting-over">Starting Over</a></h2> <p>Titus started Abseil while at Google, whose namespace, <code class="language-plaintext highlighter-rouge">absl</code>, is sometimes said to stand for “a better standard library”<sup id="fnref:abcl" role="doc-noteref"><a href="#fn:abcl" class="footnote" rel="footnote">3</a></sup>. To me, Abseil is important because it was an attempt to work with the existing standard library and make it better, while retaining a high level of implementation quality that a C++ shop’s home-grown utility library won’t have, and a uniformity of vision that <a href="https://www.boost.org/">Boost</a> is too all-over-the-place to achieve.</p> <p>Rather than trying to coexist with the standard library, I want to surpass it. As a form of performance art, I want to discover what the standard library would look like if we designed it <em>today</em>, in 2025.</p> <p>In this sense, I want to build something that isn’t just <em>better</em>. It should be the C++ standard library from the best possible world. It is the best possible library. This is why my library’s namespace is <code class="language-plaintext highlighter-rouge">best</code>.</p> <p>In general, I am trying not to directly copy either what C++, or Abseil, or Rust, or Go did. However, each of them has really interesting ideas, and the best library probably lies in some middle-ground somewhere.</p> <p>The rest of this post will be about what I have achieved with <code class="language-plaintext highlighter-rouge">best</code> so far, and where I want to take it. You can look at the code <a href="https://github.com/mcy/best">here</a>.</p> <h3 id="building-a-foundation"><a href="#building-a-foundation">Building a Foundation</a></h3> <p>We’re throwing out everything, and that includes <code class="language-plaintext highlighter-rouge">&lt;type_traits&gt;</code>. This is a header which shows its age: alias templates were’t added until C++14, and variable templates were added in C++17. As a result, many things that really aught to be concepts have names like <code class="language-plaintext highlighter-rouge">best::is_same_v</code>. All of these now have concept equivalents in <code class="language-plaintext highlighter-rouge">&lt;concepts&gt;</code>.</p> <p>I have opted to try to classify type traits into separate headers to make them easier to find. They all live under <code class="language-plaintext highlighter-rouge">//best/meta/traits</code>, and they form the leaves of the dependency graph.</p> <p>For example, <code class="language-plaintext highlighter-rouge">arrays.h</code> contains all of the array traits, such as <code class="language-plaintext highlighter-rouge">best::is_array</code>, <code class="language-plaintext highlighter-rouge">best::un_array</code> (to remove an array extent), and <code class="language-plaintext highlighter-rouge">best::as_array</code>, which applies an extent to a type T, such that <code class="language-plaintext highlighter-rouge">best::as_array&lt;T, 0&gt;</code> is not an error.</p> <p><code class="language-plaintext highlighter-rouge">types.h</code> contains very low-level metaprogramming helpers, such as:</p> <ul> <li><code class="language-plaintext highlighter-rouge">best::id</code> and <code class="language-plaintext highlighter-rouge">best::val</code>, the identity traits for type- and value-kinded traits.</li> <li><code class="language-plaintext highlighter-rouge">best::same&lt;...&gt;</code>, which returns whether an entire <em>pack</em> of types is all equal.</li> <li><code class="language-plaintext highlighter-rouge">best::lie</code>, our version of <code class="language-plaintext highlighter-rouge">std::declval</code>.</li> <li><code class="language-plaintext highlighter-rouge">best::select</code>, our <code class="language-plaintext highlighter-rouge">std::conditional_t</code>.</li> <li><code class="language-plaintext highlighter-rouge">best::abridge</code>, a “symbol compression” mechanism for shortening the names of otherwise huge symbols.</li> </ul> <p><code class="language-plaintext highlighter-rouge">funcs.h</code> provides <code class="language-plaintext highlighter-rouge">best::tame</code>, which removes the qualifiers from an <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html">abominable function type</a>. <code class="language-plaintext highlighter-rouge">quals.h</code> provides <code class="language-plaintext highlighter-rouge">best::qualifies_to</code>, necessary for determining if a type is “more const” than another. <code class="language-plaintext highlighter-rouge">empty.h</code> provides a standard empty type that interoperates cleanly with <code class="language-plaintext highlighter-rouge">void</code>.</p> <p>On top of the type traits is the metaprogramming library <code class="language-plaintext highlighter-rouge">//best/meta</code>, which includes generalized constructibility traits in <code class="language-plaintext highlighter-rouge">init.h</code> (e.g., to check that you can, in fact, initialize a <code class="language-plaintext highlighter-rouge">T&amp;</code> from a <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>, for example). <code class="language-plaintext highlighter-rouge">tlist.h</code> provides a very general type-level heterogenous list abstraction; a parameter pack as-a-type.</p> <p>The other part of “the foundation” is <code class="language-plaintext highlighter-rouge">//best/base</code>, which mostly provides access to intrinsics, portability helpers, macros, and “tag types” such as our versions of <code class="language-plaintext highlighter-rouge">std::in_place</code>. For example, <code class="language-plaintext highlighter-rouge">macro.h</code> provides <code class="language-plaintext highlighter-rouge">BEST_STRINGIFY()</code>, <code class="language-plaintext highlighter-rouge">port.h</code> provides <code class="language-plaintext highlighter-rouge">BEST_HAS_INCLUDE()</code>, and <code class="language-plaintext highlighter-rouge">hint.h</code> provides <code class="language-plaintext highlighter-rouge">best::unreachable()</code>.</p> <p><code class="language-plaintext highlighter-rouge">guard.h</code> provides our version of the Rust <code class="language-plaintext highlighter-rouge">?</code> operator, which is not an expression because statement expressions are broken in Clang.</p> <p>Finally, within <code class="language-plaintext highlighter-rouge">//best/container</code> we find <code class="language-plaintext highlighter-rouge">best::object</code>, a special type for turning any C++ type into an object (i.e., a type that you can form a reference to). This is useful for manipulating any type generically, without tripping over the assign-through semantics of references. For example, <code class="language-plaintext highlighter-rouge">best::object&lt;T&amp;&gt;</code> is essentially a pointer.</p> <h3 id="adt-containers"><a href="#adt-containers">“ADT” Containers</a></h3> <p>On top of this foundation we build the basic algebraic data types of <code class="language-plaintext highlighter-rouge">best</code>: <code class="language-plaintext highlighter-rouge">best::row</code> and <code class="language-plaintext highlighter-rouge">best::choice</code>, which replace <code class="language-plaintext highlighter-rouge">std::tuple</code> and <code class="language-plaintext highlighter-rouge">std::variant</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::row&lt;A, B, C&gt;</code> is a heterogenous collection of values, stored inside of <code class="language-plaintext highlighter-rouge">best::object</code>s. This means that <code class="language-plaintext highlighter-rouge">best::row&lt;int&amp;&gt;</code> has natural rebinding, rather than assign-through, semantics.</p> <p>Accessing elements is done with <code class="language-plaintext highlighter-rouge">at()</code>: <code class="language-plaintext highlighter-rouge">my_row.at&lt;0&gt;()</code> returns a reference to the first element. Getting the first element is so common that you can also use <code class="language-plaintext highlighter-rouge">my_row.first()</code>. Using <code class="language-plaintext highlighter-rouge">my_row.object&lt;0&gt;()</code> will return a reference to a <code class="language-plaintext highlighter-rouge">best::object</code> instead, which can be used for rebinding references. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">best</span><span class="o">::</span><span class="n">row</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="n">a</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>     <span class="c1">// Writes to x.</span>
<span class="n">a</span><span class="p">.</span><span class="n">object</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// Rebinds a.0 to y.</span>
<span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>    <span class="c1">// Writes to y.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>There is also <code class="language-plaintext highlighter-rouge">second()</code> and <code class="language-plaintext highlighter-rouge">last()</code>, for the other two most common elements to access.</p> <p><code class="language-plaintext highlighter-rouge">best::row</code> is named so in reference to database rows: it provides many operations for slicing and dicing that <code class="language-plaintext highlighter-rouge">std::tuple</code> does not.</p> <p>For example, in addition to extracting single elements, it’s also possible to access contiguous subsequences, using <code class="language-plaintext highlighter-rouge">best::bounds</code>: <code class="language-plaintext highlighter-rouge">a.at&lt;best::bounds{.start = 1, .end = 10}&gt;()</code>! There are also a plethora of mutation operations:</p> <ul> <li><code class="language-plaintext highlighter-rouge">a + b</code> concatenates tuples, copying or moving as appropriate (<code class="language-plaintext highlighter-rouge">a + BEST_MOVE(b)</code> will move out of the elements of <code class="language-plaintext highlighter-rouge">b</code>, for example).</li> <li><code class="language-plaintext highlighter-rouge">a.push(x)</code> returns a copy of <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">x</code> appended, while <code class="language-plaintext highlighter-rouge">a.insert&lt;n&gt;(x)</code> does the same at an arbitrary index.</li> <li><code class="language-plaintext highlighter-rouge">a.update&lt;n&gt;(x)</code> <em>replaces</em> the <code class="language-plaintext highlighter-rouge">n</code>th element with <code class="language-plaintext highlighter-rouge">x</code>, potentially of a different type.</li> <li><code class="language-plaintext highlighter-rouge">a.remove&lt;n&gt;()</code> deletes the <code class="language-plaintext highlighter-rouge">n</code>th element, while <code class="language-plaintext highlighter-rouge">a.erase&lt;...&gt;()</code> deletes a contiguous range.</li> <li><code class="language-plaintext highlighter-rouge">a.splice&lt;best::bounds{...}&gt;(...)</code> splices a row into another row, offering a general replace/delete operation that all of the above operations are implemented in terms of.</li> <li><code class="language-plaintext highlighter-rouge">gather()</code> and <code class="language-plaintext highlighter-rouge">scatter()</code> are even more general, allowing for non-contiguous indexing.</li> </ul> <p>Meanwhile, <code class="language-plaintext highlighter-rouge">std::apply</code> is a method now: <code class="language-plaintext highlighter-rouge">a.apply(f)</code> calls <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">a</code>’s elements as its arguments. <code class="language-plaintext highlighter-rouge">a.each(f)</code> is similar, but instead expands to <code class="language-plaintext highlighter-rouge">n</code> unary calls of <code class="language-plaintext highlighter-rouge">f</code>, one with each element.</p> <p>And <em>of course</em>, <code class="language-plaintext highlighter-rouge">best::row</code> supports structured bindings.</p> <p>Meanwhile, <code class="language-plaintext highlighter-rouge">best::choice&lt;A, B, C&gt;</code> contains precisely one value from various types. There is an underlying <code class="language-plaintext highlighter-rouge">best::pun&lt;A, B, C&gt;</code> type that implements a variadic untagged union that works around many of C++’s bugs relating to unions with members of non-trivial type.</p> <p>The most common way to operate on a choice is to <code class="language-plaintext highlighter-rouge">match</code> on it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">choice</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="o">*</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">match</span><span class="p">(</span>
  <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Which case gets called here is chosen by overload resolution, allowing us to write a default case as <code class="language-plaintext highlighter-rouge">[](auto&amp;&amp;) { ... }</code>.</p> <p>Which variant is currently selected can be checked with <code class="language-plaintext highlighter-rouge">z.which()</code>, while specific variants can be accessed with <code class="language-plaintext highlighter-rouge">z.at()</code>, just like a <code class="language-plaintext highlighter-rouge">best::row</code>, except that it returns a <code class="language-plaintext highlighter-rouge">best::option&lt;T&amp;&gt;</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::choice</code> is what all of the other sum types, like <code class="language-plaintext highlighter-rouge">best::option</code> and <code class="language-plaintext highlighter-rouge">best::result</code>, are built out of. All of the clever layout optimizations live here.</p> <p>Speaking of <code class="language-plaintext highlighter-rouge">best::option&lt;T&gt;</code>, that’s our option type. It’s close in spirit to what <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code></a> is in Rust. <code class="language-plaintext highlighter-rouge">best</code> has a generic niche mechanism that user types can opt into, allowing <code class="language-plaintext highlighter-rouge">best::option&lt;T&amp;&gt;</code> to be the same size as a pointer, using <code class="language-plaintext highlighter-rouge">nullptr</code> for the <code class="language-plaintext highlighter-rouge">best::none</code> variant.</p> <p><code class="language-plaintext highlighter-rouge">best::option</code> provides the usual transformation operations: <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">filter</code>. Emptiness can be checked with <code class="language-plaintext highlighter-rouge">is_empty()</code> or <code class="language-plaintext highlighter-rouge">has_value()</code>. You can even pass a predicate to <code class="language-plaintext highlighter-rouge">has_value()</code> to check the value with, if it’s present: <code class="language-plaintext highlighter-rouge">x.has_value([](auto&amp; x) { return x == 42; })</code>.</p> <p>The value can be accessed using <code class="language-plaintext highlighter-rouge">operator*</code> and <code class="language-plaintext highlighter-rouge">operator-&gt;</code>, like <code class="language-plaintext highlighter-rouge">std::optional</code>; however, this operation is checked, instead of causing UB if the option is empty. <code class="language-plaintext highlighter-rouge">value_or()</code> can be used to unwrap with a default; the default can be any number of arguments, which are used to construct the default, or even a callback. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">option</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>

<span class="c1">// Pass arguments to the constructor.</span>
<span class="n">do_something</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value_or</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">));</span>

<span class="c1">// Execute arbitrary logic if the value is missing.</span>
<span class="n">do_something</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value_or</span><span class="p">([]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Foo</span><span class="p">(...);</span>
<span class="p">}))</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::option&lt;void&gt;</code> also Just Works (in fact, <code class="language-plaintext highlighter-rouge">best::option&lt;T&gt;</code> is a <code class="language-plaintext highlighter-rouge">best::choice&lt;void, T&gt;</code> internally), allowing for truly generic manipulation of optional results.</p> <p><code class="language-plaintext highlighter-rouge">best::result&lt;T, E&gt;</code> is, unsurprisingly, the analogue of Rust’s <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code></a>. Because it’s a <code class="language-plaintext highlighter-rouge">best::choice</code> internally, <code class="language-plaintext highlighter-rouge">best::result&lt;void, E&gt;</code> works as you might expect, and is a common return value for I/O operations.</p> <p>It’s very similar to <code class="language-plaintext highlighter-rouge">best::option</code>, including offering <code class="language-plaintext highlighter-rouge">operator-&gt;</code> for accessing the “ok” variant. This enables succinct idioms:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fallible</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">r</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">best</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">err</span><span class="p">());</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">r.ok()</code> and <code class="language-plaintext highlighter-rouge">r.err()</code> return <code class="language-plaintext highlighter-rouge">best::option</code>s containing references to the ok and error variants, depending on which is actually present; meanwhile, a <code class="language-plaintext highlighter-rouge">best::option</code> can be converted into a <code class="language-plaintext highlighter-rouge">best::result</code> using <code class="language-plaintext highlighter-rouge">ok_or()</code> or <code class="language-plaintext highlighter-rouge">err_or()</code>, just like in Rust.</p> <p><code class="language-plaintext highlighter-rouge">best::result</code>s are constructed using <code class="language-plaintext highlighter-rouge">best::ok</code> and <code class="language-plaintext highlighter-rouge">best::err</code>. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>These internally use <code class="language-plaintext highlighter-rouge">best::args</code>, a wrapper over <code class="language-plaintext highlighter-rouge">best::row</code> that represents a “delayed initialization” that can be stored in a value. It will implicitly convert into any type that can be constructed from its elements. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span>  <span class="c1">// Calls Foo::Foo(args, to, foo).</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Also, every one of the above types is a structural type, meaning it can be used for non-type template parameters!</p> <h3 id="memory-and-pointers"><a href="#memory-and-pointers">Memory and Pointers</a></h3> <p>Of course, all of these ADTs need to be built on top of pointer operations, which is where <code class="language-plaintext highlighter-rouge">//best/memory</code> comes in. <code class="language-plaintext highlighter-rouge">best::ptr&lt;T&gt;</code> is a generalized pointer type that provides many of the same operations as Rust’s raw pointers, including offsetting, copying, and indexing. Like Rust pointers, <code class="language-plaintext highlighter-rouge">best::ptr&lt;T&gt;</code> can be a fat pointer, i.e., it can carry additional metadata on top of the pointer. For example, <code class="language-plaintext highlighter-rouge">best::ptr&lt;int[]&gt;</code> remembers the size of the array.</p> <p>Providing metadata for a <code class="language-plaintext highlighter-rouge">best::ptr</code> is done through a member alias called <code class="language-plaintext highlighter-rouge">BestPtrMetadata</code>. This alias should be private, which <code class="language-plaintext highlighter-rouge">best</code> is given access to by befriending <code class="language-plaintext highlighter-rouge">best::access</code>. Types with custom metadata will usually not be directly constructible (because they are of variable size), and must be manipulated exclusively through types like <code class="language-plaintext highlighter-rouge">best::ptr</code>.</p> <p>Specifying custom metadata allows specifying what the pointer dereferences to. For example, <code class="language-plaintext highlighter-rouge">best::ptr&lt;int[]&gt;</code> dereferences to a <code class="language-plaintext highlighter-rouge">best::span&lt;int&gt;</code>, meaning that all the span operations are accessible through <code class="language-plaintext highlighter-rouge">operator-&gt;</code>: for example, <code class="language-plaintext highlighter-rouge">my_array_ptr-&gt;first()</code>.</p> <p>Most of this may seem a bit over-complicated, since ordinary C++ raw pointers and references are fine for most uses. However, <code class="language-plaintext highlighter-rouge">best::ptr</code> is the foundation upon which <code class="language-plaintext highlighter-rouge">best::box&lt;T&gt;</code> is built on. <code class="language-plaintext highlighter-rouge">best::box&lt;T&gt;</code> is a replacement for <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr.html"><code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code></a> that fixes its const correctness and adds Rust <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code class="language-plaintext highlighter-rouge">Box</code></a>-like helpers. <code class="language-plaintext highlighter-rouge">best::box&lt;T[]&gt;</code> also works, but unlike <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T[]&gt;</code>, it remembers its size, just like <code class="language-plaintext highlighter-rouge">best::ptr&lt;T[]&gt;</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::box</code> is parameterized by its allocator, which must satisfy <code class="language-plaintext highlighter-rouge">best::allocator</code>, a much less insane API than what <a href="https://en.cppreference.com/w/cpp/memory/allocator.html"><code class="language-plaintext highlighter-rouge">std::allocator</code></a> offers. <code class="language-plaintext highlighter-rouge">best::malloc</code> is a singleton allocator representing the system allocator.</p> <p><code class="language-plaintext highlighter-rouge">best::span&lt;T&gt;</code>, mentioned before, is the contiguous memory abstraction, replacing <a href="https://en.cppreference.com/w/cpp/container/span.html"><code class="language-plaintext highlighter-rouge">std::span</code></a>. Like <code class="language-plaintext highlighter-rouge">std::span</code>, <code class="language-plaintext highlighter-rouge">best::span&lt;T, n&gt;</code> is a fixed-length span of <code class="language-plaintext highlighter-rouge">n</code> elements. Unlike <code class="language-plaintext highlighter-rouge">std::span</code>, the second parameter is a <code class="language-plaintext highlighter-rouge">best::option&lt;size_t&gt;</code>, not a <code class="language-plaintext highlighter-rouge">size_t</code> that uses <code class="language-plaintext highlighter-rouge">-1</code> as a sentinel.</p> <p><code class="language-plaintext highlighter-rouge">best::span&lt;T&gt;</code> tries to approximate the API of <a href="https://doc.rust-lang.org/std/primitive.slice.html">Rust slices</a>, providing indexing, slicing, splicing, search, sort, and more. Naturally, it’s also iterable, both forwards and backwards, and provides splitting iterators, just like Rust.</p> <p>Slicing and indexing is always bounds-checked. Indexing can be done with <code class="language-plaintext highlighter-rouge">size_t</code> values, while slicing uses a <code class="language-plaintext highlighter-rouge">best::bounds</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[{.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="mi">6</span><span class="p">}];</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::bounds</code> is a generic mechanism for specifying slicing bounds, similar to Rust’s <a href="https://doc.rust-lang.org/std/ops/struct.Range.html">range types</a>. You can specify the start and end (exclusive), like <code class="language-plaintext highlighter-rouge">x..y</code> in Rust. You can also specify an inclusive end using <code class="language-plaintext highlighter-rouge">.inclusive_end = 5</code>, equivalent to Rust’s <code class="language-plaintext highlighter-rouge">x..=y</code>. And you can specify a count, like C++’s slicing operations prefer: <code class="language-plaintext highlighter-rouge">{.start = 1, .count = 5}</code>. <code class="language-plaintext highlighter-rouge">best::bounds</code> itself provides all of the necessary helpers for performing bounds checks and crashing with a nice error message. <code class="language-plaintext highlighter-rouge">best::bounds</code> is also iterable, as we’ll see shortly.</p> <p><code class="language-plaintext highlighter-rouge">best::layout</code> is a copy of Rust’s <a href="https://doc.rust-lang.org/std/alloc/struct.Layout.html"><code class="language-plaintext highlighter-rouge">Layout</code></a> type, providing similar helpers for performing C++-specific size and address calculations.</p> <h3 id="iterators"><a href="#iterators">Iterators</a></h3> <p>C++ iterator pairs suck. C++ ranges suck. <code class="language-plaintext highlighter-rouge">best</code> provides a new paradigm for iteration that is essentially just Rust <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code class="language-plaintext highlighter-rouge">Iterator</code>s</a> hammered into a C++ shape. This library lives in <code class="language-plaintext highlighter-rouge">//best/iter</code>.</p> <p>To define an iterator, you define an <em>iterator implementation type</em>, which must define a member function named <code class="language-plaintext highlighter-rouge">next()</code> that returns a <code class="language-plaintext highlighter-rouge">best::option</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">my_iter_impl</span> <span class="k">final</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">best</span><span class="o">::</span><span class="n">option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This type is an implementation detail; the actual iterator type is <code class="language-plaintext highlighter-rouge">best::iter&lt;my_iter_impl&gt;</code>. <code class="language-plaintext highlighter-rouge">best::iter</code> provides all kinds of helpers, just like <code class="language-plaintext highlighter-rouge">Iterator</code>, for adapting the iterator or consuming items out of it.</p> <p>Iterators can override the behavior of some of these adaptors to be more efficient, such as for making <code class="language-plaintext highlighter-rouge">count()</code> constant-time rather than linear. Iterators can also offer extra methods if they define the member alias <code class="language-plaintext highlighter-rouge">BestIterArrow</code>; for example, the iterators for <code class="language-plaintext highlighter-rouge">best::span</code> have a <code class="language-plaintext highlighter-rouge">-&gt;rest()</code> method for returning the part of the slice that has not been yielded by <code class="language-plaintext highlighter-rouge">next()</code> yet.</p> <p>One of the most important extension points is <code class="language-plaintext highlighter-rouge">size_hint()</code>, analogous to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint"><code class="language-plaintext highlighter-rouge">Iterator::size_hint()</code></a>, for right-sizing containers that the iterator is converted to, such as a <code class="language-plaintext highlighter-rouge">best::vec</code>.</p> <p>And of course, <code class="language-plaintext highlighter-rouge">best::iter</code> provides <code class="language-plaintext highlighter-rouge">begin/end</code> so that it can be used in a C++ range-for loop, just like C++20 ranges do. <code class="language-plaintext highlighter-rouge">best::int_range&lt;I&gt;</code><sup id="fnref:interval" role="doc-noteref"><a href="#fn:interval" class="footnote" rel="footnote">4</a></sup>, which <code class="language-plaintext highlighter-rouge">best::bounds</code> is an instantiation of, is also an iterator, and can be used much like Rust ranges would:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">best</span><span class="o">::</span><span class="n">int_range</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">200</span><span class="p">})</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::int_range</code> will carefully handle all of the awkward corner cases around overflow, such as <code class="language-plaintext highlighter-rouge">best::int_range&lt;uint8_t&gt;{.end_inclusive = 255}</code>.</p> <h3 id="heap-containers"><a href="#heap-containers">Heap Containers</a></h3> <p>Iterators brings us to the most complex container type that’s checked in right now, <code class="language-plaintext highlighter-rouge">best::vec</code>. Not only can you customize its allocator type, but you can customize its small vector optimization type.</p> <p>In <code class="language-plaintext highlighter-rouge">libc++</code>, <code class="language-plaintext highlighter-rouge">std::string</code>s of at most 23 bytes are stored <em>inline</em>, meaning that the strings’s own storage, rather than heap storage, is used to hold them. <code class="language-plaintext highlighter-rouge">best::vec</code> generalizes this, by allowing any trivially copyable type to be inlined. Thus, a <code class="language-plaintext highlighter-rouge">best::vec&lt;int&gt;</code> will hold at most five <code class="language-plaintext highlighter-rouge">int</code>s inline, on 64-bit targets.</p> <p><code class="language-plaintext highlighter-rouge">best::vec</code> mostly copies the APIs of <code class="language-plaintext highlighter-rouge">std::vector</code> and Rust’s <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code class="language-plaintext highlighter-rouge">Vec</code></a>. Indexing and slicing works the same as with <code class="language-plaintext highlighter-rouge">best::span</code>, and all of the <code class="language-plaintext highlighter-rouge">best::span</code> operations can be accessed through <code class="language-plaintext highlighter-rouge">-&gt;</code>, allowing for things like <code class="language-plaintext highlighter-rouge">my_vec-&gt;sort(...)</code>.</p> <p>I have an active (failing) PR which adds <code class="language-plaintext highlighter-rouge">best::table&lt;K, V&gt;</code>, a general hash table implementation that can be used as either a map or a set. Internally it’s backed by a Swisstable<sup id="fnref:swisstable" role="doc-noteref"><a href="#fn:swisstable" class="footnote" rel="footnote">5</a></sup> implementation. Its API resembles neither <code class="language-plaintext highlighter-rouge">std::unordered_map</code>, <code class="language-plaintext highlighter-rouge">absl::flat_hash_map</code>, or Rust’s <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code class="language-plaintext highlighter-rouge">HashMap</code></a>. Instead, everything is done through a general entry API, similar to that of Rust, but optimized for clarity and minimizing hash lookups. I want to get it merged soonish.</p> <p>Beyond <code class="language-plaintext highlighter-rouge">best::table</code>, I plan to add <em>at least</em> the following containers:</p> <ul> <li><code class="language-plaintext highlighter-rouge">best::tree</code>, a btree map/set with a similar API.</li> <li><code class="language-plaintext highlighter-rouge">best::heap</code>, a simple min-heap implementation.</li> <li><code class="language-plaintext highlighter-rouge">best::lru</code>, a <code class="language-plaintext highlighter-rouge">best::table</code> with a linked list running through it for in-order iteration and oldest-member eviction.</li> <li><code class="language-plaintext highlighter-rouge">best::ring</code>, a ring buffer like <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code class="language-plaintext highlighter-rouge">VecDeque</code></a>.</li> <li><code class="language-plaintext highlighter-rouge">best::trie</code>, a port of my <a href="https://docs.rs/twie/latest/twie/"><code class="language-plaintext highlighter-rouge">twie</code> crate</a>.</li> </ul> <p>Possible other ideas: <a href="https://research.swtch.com/sparse">Russ’s sparse array</a>, splay trees, something like Java’s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html"><code class="language-plaintext highlighter-rouge">EnumMap</code></a>, bitset types, and so on.</p> <h3 id="text-handling"><a href="#text-handling">Text Handling</a></h3> <p><code class="language-plaintext highlighter-rouge">best</code>’s string handling is intended to resemble Rust’s as much as possible; it lives within <code class="language-plaintext highlighter-rouge">//best/text</code>. <code class="language-plaintext highlighter-rouge">best::rune</code> is the Unicode scalar type, which is such that it is <em>always</em> within the valid range for a Unicode scalar, but including the unpaired surrogates. It offers a number of relatively simple character operations, but I plan to extend it to all kinds of character classes in the future.</p> <p><code class="language-plaintext highlighter-rouge">best::str</code> is our replacement for <a href="https://en.cppreference.com/w/cpp/string/basic_string_view.html"><code class="language-plaintext highlighter-rouge">best::string_view</code></a>, close to Rust’s <a href="https://doc.rust-lang.org/std/primitive.str.html"><code class="language-plaintext highlighter-rouge">str</code></a>: a sequence of valid UTF-8 bytes, with all kinds of string manipulation operations, such as rune search, splitting, indexing, and so on.</p> <p><code class="language-plaintext highlighter-rouge">best::rune</code> and <code class="language-plaintext highlighter-rouge">best::str</code> use compiler extensions to ensure that when constructed from literals, they’re constructed from <em>valid</em> literals. This means that the following won’t compile!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">str</span> <span class="n">invalid</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xFF</span><span class="s">"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::str</code> is a <code class="language-plaintext highlighter-rouge">best::span</code> under the hood, which can be accessed and manipulated the same way as the underlying <code class="language-plaintext highlighter-rouge">&amp;[u8]</code> to <code class="language-plaintext highlighter-rouge">&amp;str</code> is.</p> <p><code class="language-plaintext highlighter-rouge">best::strbuf</code> is our <a href="https://en.cppreference.com/w/cpp/string/basic_string.html"><code class="language-plaintext highlighter-rouge">std::string</code></a> equivalent. There isn’t very much to say about it, because it works just like you’d expect, and provides a Rust <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code class="language-plaintext highlighter-rouge">String</code></a>-like API.</p> <p>Where this library really shines is that everything is parametrized over encodings. <code class="language-plaintext highlighter-rouge">best::str</code> is actually a <code class="language-plaintext highlighter-rouge">best::text&lt;best::utf8&gt;</code>; <code class="language-plaintext highlighter-rouge">best::str16</code> is then <code class="language-plaintext highlighter-rouge">best::text&lt;best::utf16&gt;</code>. You can write your own text encodings, too, so long as they are relatively tame and you provide rune encode/decode for them. <code class="language-plaintext highlighter-rouge">best::encoding</code> is the concept</p> <p><code class="language-plaintext highlighter-rouge">best::text</code> is always validly encoded; however, sometimes, that’s not possible. For this reason we have <code class="language-plaintext highlighter-rouge">best::pretext</code>, which is “presumed validly encoded”; its operations can fail or produce replacement characters if invalid code units are found. There is no <code class="language-plaintext highlighter-rouge">best::pretextbuf</code>; instead, you would generally use something like a <code class="language-plaintext highlighter-rouge">best::vec&lt;uint8_t&gt;</code> instead.</p> <p>Unlike C++, the fact that a <code class="language-plaintext highlighter-rouge">best::textbuf</code> is a <code class="language-plaintext highlighter-rouge">best::vec</code> under the hood is part of the public interface, allowing for cheap conversions and, of course, we get <code class="language-plaintext highlighter-rouge">best::vec</code>’s small vector optimization for free.</p> <p><code class="language-plaintext highlighter-rouge">best</code> provides the following encodings out of the box: <code class="language-plaintext highlighter-rouge">best::utf8</code>, <code class="language-plaintext highlighter-rouge">best::utf16</code>, <code class="language-plaintext highlighter-rouge">best::utf32</code>, <code class="language-plaintext highlighter-rouge">best::wtf8</code>, <code class="language-plaintext highlighter-rouge">best::ascii</code>, and <code class="language-plaintext highlighter-rouge">best::latin1</code>.</p> <h3 id="formatting"><a href="#formatting">Formatting</a></h3> <p><code class="language-plaintext highlighter-rouge">//best/text:format</code> provides a Rust <code class="language-plaintext highlighter-rouge">format!()</code>-style text formatting library. It’s as easy as:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"my number: 0x{:08x}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Through the power of compiler extensions and <code class="language-plaintext highlighter-rouge">constexpr</code>, the format is actually checked at compile time!</p> <p>The available formats are the same as Rust’s, including the <code class="language-plaintext highlighter-rouge">{}</code> vs <code class="language-plaintext highlighter-rouge">{:?}</code> distinction. But it’s actually way more flexible. You can use any ASCII letter, and types can provide multiple custom formatting schemes using letters. By convention, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">X</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">o</code> all mean numeric bases. <code class="language-plaintext highlighter-rouge">q</code> will quote strings, runes, and other text objects; <code class="language-plaintext highlighter-rouge">p</code> will print pointer addresses.</p> <p>The special format <code class="language-plaintext highlighter-rouge">{:!}</code> “forwards from above”; when used in a formatting implementation, it uses the format specifier the caller used. This is useful for causing formats to be “passed through”, such as when printing lists or <code class="language-plaintext highlighter-rouge">best::option</code>.</p> <p>Any type can be made formattable by providing a friend template ADL extension (FTADLE) called <code class="language-plaintext highlighter-rouge">BestFmt</code>. This is analogous to implementing a trait like <code class="language-plaintext highlighter-rouge">fmt::Debug</code> in Rust, however, all formatting operations use the same function; this is similar to <a href="https://pkg.go.dev/fmt#Formatter"><code class="language-plaintext highlighter-rouge">fmt.Formatter</code></a> in Go.</p> <p>The <code class="language-plaintext highlighter-rouge">best::formatter</code> type, which gets passed into <code class="language-plaintext highlighter-rouge">BestFmt</code>, is similar to Rust’s <a href="https://doc.rust-lang.org/std/fmt/struct.Formatter.html"><code class="language-plaintext highlighter-rouge">Formatter</code></a>. Beyond being a sink, it also exposes information on the specifier for the formatting operation via <code class="language-plaintext highlighter-rouge">current_spec()</code>, and helpers for printing indented lists and blocks.</p> <p><code class="language-plaintext highlighter-rouge">BestFmtQuery</code> is a related FTADLE that is called to determine what the valid format specifiers for this type are. This allows the format validator to reject formats that a type does not support, such as formatting a <code class="language-plaintext highlighter-rouge">best::str</code> with <code class="language-plaintext highlighter-rouge">{:x}</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::format</code> returns (or appends to) a <code class="language-plaintext highlighter-rouge">best::strbuf</code>; <code class="language-plaintext highlighter-rouge">best::println</code> and <code class="language-plaintext highlighter-rouge">best::eprintln</code> can be used to write to stdout and stderr.</p> <h3 id="reflection"><a href="#reflection">Reflection</a></h3> <p>Within the metaprogramming library, <code class="language-plaintext highlighter-rouge">//best/meta:reflect</code> offers a basic form of reflection. It’s not C++26 reflection, because that’s wholely overkill. Instead, it provides a method for introspecting the members of structs and enums.</p> <p>For example, suppose that we want to have a default way of formatting arbitrary <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization.html">aggregate</a> structs. The code for doing this is actually devilishly simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">BestFmt</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">best</span><span class="o">::</span><span class="n">is_reflected_struct</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Reflect the type of the struct.</span>
  <span class="k">auto</span> <span class="n">refl</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">reflect</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// Start formatting a "record" (key-value pairs).</span>
  <span class="k">auto</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">.</span><span class="n">record</span><span class="p">(</span><span class="n">refl</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

  <span class="c1">// For each field in the struct...</span>
  <span class="n">refl</span><span class="p">.</span><span class="n">each</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">field</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Add a field to the formatting record...</span>
    <span class="n">rec</span><span class="p">.</span><span class="n">field</span><span class="p">(</span>
      <span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span>   <span class="c1">// ...whose name is the field...</span>
      <span class="n">value</span><span class="o">-&gt;*</span><span class="n">field</span><span class="p">,</span>  <span class="c1">// ...and with the appropriate value.</span>
    <span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::reflect</code> provides access to the fields (or enum variants) of a user-defined type that opts itself in by providing the <code class="language-plaintext highlighter-rouge">BestReflect</code> FTADLE, which tells the reflection framework what the fields are. The simplest version of this FTADLE looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">friend</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">BestReflect</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">mirror</span><span class="p">,</span> <span class="n">MyStruct</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">mirror</span><span class="p">.</span><span class="n">infer</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::mirror</code> is essentially a “reflection builder” that offers fine-grained control over what reflection actually shows of a struct. This allows for hiding fields, or attaching <em>tags</em> to specific fields, which generic functions can then introspect using <code class="language-plaintext highlighter-rouge">best::reflected_field::tags()</code>.</p> <p>The functions on <code class="language-plaintext highlighter-rouge">best::reflected_type</code> allow iterating over and searching for specific fields (or enum variants); these <code class="language-plaintext highlighter-rouge">best::reflected_field</code>s provide metadata about a field (such as its name) and allow accessing it, with the same syntax as a pointer-to-member: <code class="language-plaintext highlighter-rouge">value-&gt;*field</code>.</p> <p>Explaining the full breadth (and implementation tricks) of <code class="language-plaintext highlighter-rouge">best::reflect</code> would be a post of its own, so I’ll leave it at that.</p> <h3 id="unit-tests-and-apps"><a href="#unit-tests-and-apps">Unit Tests and Apps</a></h3> <p><code class="language-plaintext highlighter-rouge">best</code> provides a unit testing framework under <code class="language-plaintext highlighter-rouge">//best/test</code>, like any good standard library should. To define a test, you define a special kind of global variable:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">test</span> <span class="n">MyTest</span> <span class="o">=</span> <span class="p">[](</span><span class="n">best</span><span class="o">::</span><span class="n">test</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Test code.</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This is very similar to a Go unit test, which defines a function that starts with <code class="language-plaintext highlighter-rouge">Test</code> and takes a <code class="language-plaintext highlighter-rouge">*testing.T</code> as its argument. The <code class="language-plaintext highlighter-rouge">best::test&amp;</code> value offers test assertions and test failures. Through the power of looking at debuginfo, we can extract the name <code class="language-plaintext highlighter-rouge">MyTest</code> from the binary, and use that as the name of the test directly.</p> <p>That’s right, this is a C++ test framework with <em>no macros at all</em>!</p> <p>Meanwhile, at <code class="language-plaintext highlighter-rouge">//best/cli</code> we can find a robust CLI parsing library, in the spirit of <a href="https://docs.rs/clap/latest/clap/_derive/index.html"><code class="language-plaintext highlighter-rouge">#[derive(clap::Parser)]</code></a> and other similar Rust libraries. The way it works is you first define a reflectable struct, whose fields correspond to CLI flags. A very basic example of this can be found in <code class="language-plaintext highlighter-rouge">test.h</code>, since test binaries define their own flags:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">test</span><span class="o">::</span><span class="n">flags</span> <span class="k">final</span> <span class="p">{</span>
  <span class="n">best</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">best</span><span class="o">::</span><span class="n">strbuf</span><span class="o">&gt;</span> <span class="n">skip</span><span class="p">;</span>
  <span class="n">best</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">best</span><span class="o">::</span><span class="n">strbuf</span><span class="o">&gt;</span> <span class="n">filters</span><span class="p">;</span>

  <span class="k">constexpr</span> <span class="k">friend</span> <span class="k">auto</span> <span class="n">BestReflect</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">flags</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">infer</span><span class="p">()</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">app</span><span class="p">{.</span><span class="n">about</span> <span class="o">=</span> <span class="s">"a best unit test binary"</span><span class="p">})</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="o">::</span><span class="n">skip</span><span class="p">,</span>
            <span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">flag</span><span class="p">{</span>
              <span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="s">"FILTER"</span><span class="p">,</span>
              <span class="p">.</span><span class="n">help</span> <span class="o">=</span> <span class="s">"Skip tests whose names contain FILTER"</span><span class="p">,</span>
            <span class="p">})</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="o">::</span><span class="n">filters</span><span class="p">,</span>
            <span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">positional</span><span class="p">{</span>
              <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FILTERS"</span><span class="p">,</span>
              <span class="p">.</span><span class="n">help</span> <span class="o">=</span> <span class="s">"Include only tests whose names contain FILTER"</span><span class="p">,</span>
            <span class="p">});</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Using <code class="language-plaintext highlighter-rouge">best::mirror::with</code>, we can apply tags to the individual fields that describe how they should be parsed and displayed as CLI flags. A more complicated, full-featured example can be found at <a href="https://github.com/mcy/best/blob/main/best/cli/toy_flags.h"><code class="language-plaintext highlighter-rouge">toy_flags.h</code></a>, which exercises most of the CLI parser’s features.</p> <p><code class="language-plaintext highlighter-rouge">best::parse_flags&lt;MyFlags&gt;(...)</code> can be used to parse a particular flag struct from program inputs, independent of the actual <code class="language-plaintext highlighter-rouge">argv</code> of the program. A <code class="language-plaintext highlighter-rouge">best::cli</code> contains the actual parser metadata, but this is not generally user-accessible; it is constructed automatically using reflection.</p> <p>Streamlining top-level app execution can be done using <code class="language-plaintext highlighter-rouge">best::app</code>, which fully replaces the <code class="language-plaintext highlighter-rouge">main()</code> function. Defining an app is very similar to defining a test:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">app</span> <span class="n">MyApp</span> <span class="o">=</span> <span class="p">[](</span><span class="n">MyFlags</span><span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do something cool!</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This will automatically record the program inputs, run the flag parser for <code class="language-plaintext highlighter-rouge">MyFlags</code> (printing <code class="language-plaintext highlighter-rouge">--help</code> and existing, when requested), and then call the body of the lambda.</p> <p>The lambda can either return <code class="language-plaintext highlighter-rouge">void</code>, an <code class="language-plaintext highlighter-rouge">int</code> (as an exit code) or even a <code class="language-plaintext highlighter-rouge">best::result</code>, like Rust. <code class="language-plaintext highlighter-rouge">best::app</code> is also where the <code class="language-plaintext highlighter-rouge">argv</code> of the program can be requested by other parts of the program.</p> <h2 id="whats-next"><a href="#whats-next">What’s Next?</a></h2> <p>There’s still a lot of stuff I want to add to <code class="language-plaintext highlighter-rouge">best</code>. There’s no synchronization primitives, neither atomics nor locks or channels. There’s no I/O; I have a work-in-progress PR to add <code class="language-plaintext highlighter-rouge">best::path</code> and <code class="language-plaintext highlighter-rouge">best::file</code>. I’d like to write my own math library, <code class="language-plaintext highlighter-rouge">best::rc</code> (reference-counting), and portable SIMD. There’s also some other OS APIs I want to build, such as signals and subprocesses. I want to add a robust PRNG, time APIs, networking, and stack symbolization.</p> <p>Building the best C++ library is a lot of work, not the least because C++ is a very tricky language and writing exhaustive tests is tedious. But it manages to make C++ fun for me again!</p> <p>I would love to see contributions some day. I don’t expect anyone to actually use this, but to me, it proves C++ could be so much better.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:terrible-people" role="doc-endnote"> <p>They are also <a href="https://patricia.no/2022/03/08/cppcon.html">terrible people</a>. <a href="#fnref:terrible-people" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:jh" role="doc-endnote"> <p>I will grant that JeanHeyd has made significant process where many people believed was impossible. He appears to have the indomitable willpower of a shōnen protagonist. <a href="#fnref:jh" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:abcl" role="doc-endnote"> <p>I have heard an apocryphal story that the namespace was going to be <code class="language-plaintext highlighter-rouge">abc</code> or <code class="language-plaintext highlighter-rouge">abcl</code>, because it was “Alphabet’s library”. This name was ultimately shot down by the office of the CEO, or so the legend goes. <a href="#fnref:abcl" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:interval" role="doc-endnote"> <p>This may get renamed to <code class="language-plaintext highlighter-rouge">best::interval</code> or even <code class="language-plaintext highlighter-rouge">best::range</code> We’ll see! <a href="#fnref:interval" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:swisstable" role="doc-endnote"> <p>The fourth time I’ve written one in my career, lmao. I also wrote a <a href="https://github.com/google/cwisstable">C implementation</a> at one point. My friend Matt has an <a href="https://www.youtube.com/watch?v=ncHmEUmJZf4">excellent introduction</a> to the Swisstable data structure. <a href="#fnref:swisstable" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-07-07 • 1880 words • 20 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#go">#go</a> • <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> </span> <h1><a href="/2025/07/07/nosplit/"> What's //go:nosplit for? </a></h1> </div> <div class="post"> <p>Most people don’t know that Go has special syntax for directives. Unfortunately, it’s not real syntax, it’s just a comment. For example, <code class="language-plaintext highlighter-rouge">//go:noinline</code> causes the next function declaration to never get inlined, which is useful for changing the inlining cost of functions that call it.</p> <p>There are three types of directives:</p> <ol> <li> <p>The ones documented in <a href="https://pkg.go.dev/cmd/compile#hdr-Function_Directives"><code class="language-plaintext highlighter-rouge">gc</code>’s doc comment</a>. This includes <code class="language-plaintext highlighter-rouge">//go:noinline</code> and <code class="language-plaintext highlighter-rouge">//line</code>.</p> </li> <li> <p>The ones documented elsewhere, such as <code class="language-plaintext highlighter-rouge">//go:build</code> and <code class="language-plaintext highlighter-rouge">//go:generate</code>.</p> </li> <li> <p>The ones documented in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.24.4:src/runtime/HACKING.md">runtime/HACKING.md</a>, which can only be used if the <code class="language-plaintext highlighter-rouge">-+</code> flag is passed to <code class="language-plaintext highlighter-rouge">gc</code>. This includes <code class="language-plaintext highlighter-rouge">//go:nowritebarrier</code>.</p> </li> <li> <p>The ones not documented at all, whose existence can be discovered by searching the compiler’s tests. These include <code class="language-plaintext highlighter-rouge">//go:nocheckptr</code>, <code class="language-plaintext highlighter-rouge">//go:nointerface</code>, and <code class="language-plaintext highlighter-rouge">//go:debug</code>.</p> </li> </ol> <p>We are most interested in a directive of the first type, <code class="language-plaintext highlighter-rouge">//go:nosplit</code>. According to the documentation:</p> <blockquote> <p>The <code class="language-plaintext highlighter-rouge">//go:nosplit</code> directive must be followed by a function declaration. It specifies that the function must omit its usual stack overflow check. This is most commonly used by low-level runtime code invoked at times when it is unsafe for the calling goroutine to be preempted.</p> </blockquote> <p>What does this even mean? Normal program code can use this annotation, but its behavior is poorly specified. Let’s dig in.</p> <h2 id="go-stack-growth"><a href="#go-stack-growth">Go Stack Growth</a></h2> <p>Go allocates very small stacks for new goroutines, which grow their stack dynamically. This allows a program to spawn a large number of short-lived goroutines without spending a lot of memory on their stacks.</p> <p>This means that it’s very easy to overflow the stack. Every function knows how large its stack is, and <code class="language-plaintext highlighter-rouge">runtime.g</code>, the goroutine struct, contains the end position of the stack; if the stack pointer is less than it (the stack grows up) control passes to <code class="language-plaintext highlighter-rouge">runtime.morestack</code>, which effectively preempts the goroutine while its stack is resized.</p> <p>In effect, every Go function has the following code around it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span>    <span class="p">.</span><span class="err">f</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="m">24-16</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JLS</span>     <span class="err">grow</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">//</span> <span class="err">Function</span> <span class="err">body</span><span class="p">...</span>
  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span>
<span class="nl">grow:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">MOVQ</span>    <span class="m">16</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">JMP</span>     <span class="p">.</span><span class="err">f</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>Note that <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the current <code class="language-plaintext highlighter-rouge">runtime.g</code>, and the stack limit is the third word-sized field (<code class="language-plaintext highlighter-rouge">runtime.g.stackguard0</code>) in that struct, hence the offset of 16. If the stack is about to be exhausted, it jumps to a special block at the end of the function that spills all of the argument registers, traps into the runtime, and, once that’s done, unspills the arguments and re-starts the function.</p> <p>Note that arguments are spilled <em>before</em> adjusting <code class="language-plaintext highlighter-rouge">rsp</code>, which means that the arguments are written to the <em>caller’s</em> stack frame. This is part of Go’s ABI; callers must allocate space at the top of their stack frames for any function that they call to spill all of its registers for preemption<sup id="fnref:unused-spill" role="doc-noteref"><a href="#fn:unused-spill" class="footnote" rel="footnote">1</a></sup>.</p> <p>Preemption is not reentrant, which means that functions that are running in the context of a preempted G or with no G at all must not be preempted by this check.</p> <h2 id="nosplit-functions"><a href="#nosplit-functions">Nosplit Functions</a></h2> <p>The <code class="language-plaintext highlighter-rouge">//go:nosplit</code> directive marks a function as “nosplit”, or a “non-splitting function”. “Splitting” has nothing to do with what this directive does.</p> <blockquote> <h4 id="segmented-stacks"><a href="#segmented-stacks">Segmented Stacks</a></h4> <p>In the bad old days, Go’s stacks were <em>split</em> up into <em>segments</em>, where each segment ended with a pointer to the next, effectively replacing the stack’s single array with a linked list of such arrays.</p> <p>Segmented stacks were terrible. Instead of triggering a resize, these prologues were responsible for updating <code class="language-plaintext highlighter-rouge">rsp</code> to the next (or previous) block by following this pointer, whenever the current segment bottomed out. This meant that if a function call happened to be on a segment boundary, it would be <em>extremely slow</em> in comparison to other function calls, due to the significant work required to update <code class="language-plaintext highlighter-rouge">rsp</code> correctly.</p> <p>This meant that unlucky sizing of stack frames meant sudden performance cliffs. Fun!</p> <p>Go has since figured out that segmented stacks are a terrible idea. In the process of implementing a correct GC stack scanning algorithm (which it did not have for many stable releases), it also gained the ability to copy the contents of a stack from one location to another, updating pointers in such a way that user code wouldn’t notice.</p> <p>This stack splitting code is where the name “nosplit” comes from.</p> </blockquote> <p>A nosplit function does not load and branch on <code class="language-plaintext highlighter-rouge">runtime.g.stackguard0</code>, and simply assumes it has enough stack. This means that nosplit functions will not preempt themselves, and, as a result, are noticeably faster to call in a hot loop. Don’t believe me?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">//go:noinline</span>
<span class="k">func</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">nosplit</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">yessplit</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkCall</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"nosplit"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span> <span class="n">nosplit</span><span class="p">(</span><span class="m">42</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">})</span>
  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"yessplit"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span> <span class="n">yessplit</span><span class="p">(</span><span class="m">42</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If we profile this and pull up the timings for each function, here’s what we get:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="m">390</span><span class="err">ms</span>      <span class="m">390</span><span class="err">ms</span>           <span class="err">func</span> <span class="err">nosplit</span><span class="p">(x</span> <span class="err">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">noinline</span><span class="p">(x)</span> <span class="p">}</span>
 <span class="m">60</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd80:</span>     <span class="err">PUSHQ</span> <span class="err">BP</span>
 <span class="m">10</span><span class="err">ms</span>       <span class="m">10</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd81:</span>     <span class="err">MOVQ</span> <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fd84:</span>     <span class="err">SUBQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
 <span class="m">60</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd88:</span>     <span class="err">CALL</span> <span class="p">.</span><span class="k">noinline</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
<span class="m">190</span><span class="err">ms</span>      <span class="m">190</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd8d:</span>     <span class="err">ADDQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fd91:</span>     <span class="err">POPQ</span> <span class="err">BP</span>
 <span class="m">70</span><span class="err">ms</span>       <span class="m">70</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd92:</span>     <span class="err">RET</span>

<span class="m">440</span><span class="err">ms</span>      <span class="m">490</span><span class="err">ms</span>           <span class="err">func</span> <span class="err">yessplit</span><span class="p">(x</span> <span class="err">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">noinline</span><span class="p">(x)</span> <span class="p">}</span>
 <span class="m">50</span><span class="err">ms</span>       <span class="m">50</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda0:</span>     <span class="err">CMPQ</span> <span class="err">SP</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
 <span class="m">20</span><span class="err">ms</span>       <span class="m">20</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda4:</span>     <span class="err">JBE</span> <span class="m">0x51fdb9</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fda6:</span>     <span class="err">PUSHQ</span> <span class="err">BP</span>
 <span class="m">20</span><span class="err">ms</span>       <span class="m">20</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda7:</span>     <span class="err">MOVQ</span> <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdaa:</span>     <span class="err">SUBQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
 <span class="m">10</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdae:</span>     <span class="err">CALL</span> <span class="p">.</span><span class="k">noinline</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
<span class="m">200</span><span class="err">ms</span>      <span class="m">200</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdb3:</span>     <span class="err">ADDQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdb7:</span>     <span class="err">POPQ</span> <span class="err">BP</span>
<span class="m">140</span><span class="err">ms</span>      <span class="m">140</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdb8:</span>     <span class="err">RET</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdb9:</span>     <span class="err">MOVQ</span> <span class="err">AX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdbe:</span>     <span class="err">NOPW</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdc0:</span>     <span class="err">CALL</span> <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">.</span><span class="err">abi0</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdc5:</span>     <span class="err">MOVQ</span> <span class="m">0x8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdca:</span>     <span class="err">JMP</span> <span class="p">.</span><span class="err">yessplit</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>The time spent at each instruction (for the whole benchmark, where I made sure equal time was spent on each test case with <code class="language-plaintext highlighter-rouge">-benchtime Nx</code>) is comparable for all of the instructions these functions share, but an additional ~2% cost is incurred for the stack check.</p> <p>This is a very artificial setup, because the <code class="language-plaintext highlighter-rouge">g</code> struct is always in L1 in the <code class="language-plaintext highlighter-rouge">yessplit</code> benchmark due to the fact that no other memory operations occur in the loop. However, for very hot code that needs to saturate the cache, this can have an outsized effect due to cache misses. We can enhance this benchmark by adding an assembly function that executes <code class="language-plaintext highlighter-rouge">clflush [r14]</code>, which causes the <code class="language-plaintext highlighter-rouge">g</code> struct to be ejected from all caches.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">.</span><span class="err">clflush</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CLFLUSH</span> <span class="p">(</span><span class="err">R14</span><span class="p">)</span>  <span class="err">//</span> <span class="err">Eject</span> <span class="err">the</span> <span class="err">pointee</span> <span class="err">of</span> <span class="err">r14</span> <span class="k">from</span> <span class="err">all</span> <span class="err">caches</span><span class="p">.</span>
  <span class="err">RET</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>If we add a call to this function to both benchmark loops, we see the staggering cost of a cold fetch from RAM show up in every function call: 120.1 nanosecods for <code class="language-plaintext highlighter-rouge">BenchmarkCall/nosplit</code>, versus 332.1 nanoseconds for <code class="language-plaintext highlighter-rouge">BenchmarkCall/yessplit</code>. The 200 nanosecond difference is a fetch from main memory. An L1 miss is about 15 times less expensive, so if the <code class="language-plaintext highlighter-rouge">g</code> struct manages to get kicked out of L1, you’re paying about 15 or so nanoseconds, or about two map lookups!</p> <p>Despite the language resisting adding an inlining heuristic, which programmers would place everywhere without knowing what it does, they <em>did</em> provide something worse that makes code noticeably faster: nosplit.</p> <h2 id="but-its-harmless"><a href="#but-its-harmless">But It’s Harmless…?</a></h2> <p>Consider the following program<sup id="fnref:consider" role="doc-noteref"><a href="#fn:consider" class="footnote" rel="footnote">2</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Naturally, this will instantly overflow the stack. Instead, we get a really scary linker error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">x.x: nosplit stack over 792 byte limit
</span><span class="gp">x.x&lt;1&gt;</span><span class="w">
</span><span class="gp">    grows 24 bytes, calls x.x&lt;1&gt;</span><span class="w">
</span><span class="go">    infinite cycle</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>The Go linker contains a check to verify that any chain of nosplit functions which call nosplit functions do not overflow a small window of extra stack, which is where the stack frames of nosplit functions live if they go past <code class="language-plaintext highlighter-rouge">stackguard0</code>.</p> <p>Every stack frame contributes some stack use (for the return address, at minimum), so the number of functions you can call before you get this error is limited. And because every function needs to allocate space for all of its callees to spill their arguments if necessary, you can hit this limit every fast if every one of these functions uses every available argument register (ask me how I know).</p> <p>Also, turning on fuzzing instruments the code by inserting nosplit calls into the fuzzer runtime around branches, meaning that turning on fuzzing can <em>previously fine code to no longer link</em>. Stack usage also varies slightly by architecture, meaning that code which builds in one architecture fails to link in others (most visible when going from 32-bit to 64-bit).</p> <p>There is no easy way to control directives using build tags (two poorly-designed features collide), so you cannot just “turn off” performance-sensitive nosplits for debugging, either.</p> <p>For this reason, you must be <em>very very careful</em> about using nosplit for performance.</p> <h3 id="virtual-nosplit-functions"><a href="#virtual-nosplit-functions">Virtual Nosplit Functions</a></h3> <p>Excitingly, nosplit functions whose addresses are taken do not have special codegen, allowing us to defeat the linker stack check by using virtual function calls.</p> <p>Consider the following program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">var</span> <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">x</span>
  <span class="n">f</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This will quickly exhaust the main G’s tiny stack and segfault in the most violent way imaginable, preventing the runtime from printing a debug trace. All this program outputs is <code class="language-plaintext highlighter-rouge">signal: segmentation fault</code>.</p> <p>This is <a href="https://github.com/golang/go/issues/74478">probably a bug</a>.</p> <h2 id="other-side-effects"><a href="#other-side-effects">Other Side Effects</a></h2> <p>It turns out that nosplit has various other fun side-effects that are not documented anywhere. The main thing it does is it contributes to whether a function is considered “unsafe” by the runtime.</p> <p>Consider the following program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"os"</span>
  <span class="s">"runtime"</span>
  <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="k">range</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">{}</span>
    <span class="p">}()</span>
  <span class="p">}</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Wait for all the other Gs to start.</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This program will make sure that every P becomes bound to a G that loops forever, meaning they will never trap into the runtime. Thus, this program will hang forever, never printing its result and exiting. But that’s not what happens.</p> <p>Thanks to asynchronous preemption, the scheduler will detect Gs that have been running for too long, and preempt its M by sending a signal to it (<a href="https://cs.opensource.google/go/go/+/master:src/runtime/signal_unix.go;l=43">due to happenstance</a>, this is <code class="language-plaintext highlighter-rouge">SIGURG</code> of all things.)</p> <p>However, asynchronous preemption is only possible when the M stops due to the signal at a safe point, as determined by <code class="language-plaintext highlighter-rouge">runtime.isAsyncSafePoint</code>. It includes the following block of code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go">	<span class="n">up</span><span class="p">,</span> <span class="n">startpc</span> <span class="o">:=</span> <span class="n">pcdatavalue2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">abi</span><span class="o">.</span><span class="n">PCDATA_UnsafePoint</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">up</span> <span class="o">==</span> <span class="n">abi</span><span class="o">.</span><span class="n">UnsafePointUnsafe</span> <span class="p">{</span>
		<span class="c">// Unsafe-point marked by compiler. This includes</span>
		<span class="c">// atomic sequences (e.g., write barrier) and nosplit</span>
		<span class="c">// functions (except at calls).</span>
		<span class="k">return</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span>
	<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If we chase down where this value is set, we’ll find that it is set explicitly for write barrier sequences, for any function that is “part of the runtime” (as defined by being built with the <code class="language-plaintext highlighter-rouge">-+</code> flag) and <em>for any nosplit function</em>.</p> <p>With a small modification of hoisting the <code class="language-plaintext highlighter-rouge">go</code> body into a nosplit function, the following program will run forever: it will never wake up from <code class="language-plaintext highlighter-rouge">time.Sleep</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"os"</span>
  <span class="s">"runtime"</span>
  <span class="s">"time"</span>
<span class="p">)</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">forever</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="k">range</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="n">forever</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Wait for all the other Gs to start.</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Even though there is work to do, every P is bound to a G that will never reach a safe point, so there will never be a P available to run the main goroutine.</p> <p>This represents another potential danger of using nosplit functions: those that do not call preemptable functions must terminate promptly, or risk livelocking the whole runtime.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>I use nosplit <em>a lot</em>, because I write high-performance, low-latency Go. This is a very insane thing to do, which has caused me to slowly generate bug reports whenever I hit strange corner cases.</p> <p>For example, there are many cases where spill regions are allocated for functions that never use them, for example, functions which only call nosplit functions allocate space for them to spill their arguments, which they don’t do.<sup id="fnref:spill-area" role="doc-noteref"><a href="#fn:spill-area" class="footnote" rel="footnote">3</a></sup></p> <p>This is a documented Go language feature which:</p> <ol> <li>Isn’t very well-documented (the async preemption behavior certainly isn’t)!</li> <li>Has very scary optimization-dependent build failures.</li> <li>Can cause livelock and mysterious segfaults.</li> <li>Can be used in user programs that don’t <code class="language-plaintext highlighter-rouge">import "unsafe"</code>!</li> <li>And it makes code faster!</li> </ol> <p>I’m surprised such a massive footgun exists at all, buuuut it’s a measureable benchmark improvement for me, so it’s impossible to tell if it’s bad or not.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:unused-spill" role="doc-endnote"> <p>The astute reader will observe that because preemption is not reentrant, only one of these spill regions will be in use at at time in a G. This is a known bug in the ABI, and is essentially a bodge to enable easy adoption of passing arguments by register, without needing all of the parts of the runtime that expect arguments to be spilled to the stack, as was the case in the slow old days when Go’s ABI on every platform was “<code class="language-plaintext highlighter-rouge">i386-unknown-linux</code> but worse”, i.e., arguments went on the stack and made the CPU’s store queue sad.</p> <p>I recently filed <a href="https://github.com/golang/go/issues/74413">a bug about this</a> that boils down to “add a field to <code class="language-plaintext highlighter-rouge">runtime.g</code> to use a spill space”, which seems to me to be simpler than the alternatives described in the <code class="language-plaintext highlighter-rouge">ABIInternal</code> spec. <a href="#fnref:unused-spill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:consider" role="doc-endnote"> <p>Basically every bug report I write starts with these four words and it means you’re about to see the worst program ever written. <a href="#fnref:consider" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:spill-area" role="doc-endnote"> <p>The spill area is also used for spilling arguments across calls, but in this case, it is not necessary for the caller to allocate it for a nosplit function. <a href="#fnref:spill-area" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-06-03 • 874 words • 9 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#protobuf-tips">#protobuf-tips</a> </span> <h1><a href="/2025/06/03/protobuf-tip-7/"> Protobuf Tip #7: Scoping It Out </a></h1> </div> <div class="post"> <p><em>You’d need a very specialized electron microscope to get down to the level to actually see a single strand of DNA. – Craig Venter</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">buf convert</code> is a powerful tool for examining wire format dumps, by converting them to JSON and using existing JSON analysis tooling. <code class="language-plaintext highlighter-rouge">protoscope</code> can be used for lower-level analysis, such debugging messages that have been corrupted.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-7-scoping-it-out">buf.build blog</a>.</p> </blockquote> <h2 id="json-from-protobuf"><a href="#json-from-protobuf">JSON from Protobuf?</a></h2> <p>JSON’s human-readable syntax is a big reason why it’s so popular, possibly second only to built-in support in browsers and many languages. It’s easy to examine any JSON document using tools like online prettifiers and the inimitable <code class="language-plaintext highlighter-rouge">jq</code>.</p> <p>But Protobuf is a binary format! This means that you can’t easily use <code class="language-plaintext highlighter-rouge">jq</code> -like tools with it…or can you?</p> <h2 id="transcoding-with-buf-convert"><a href="#transcoding-with-buf-convert">Transcoding with <code class="language-plaintext highlighter-rouge">buf convert</code></a></h2> <p>The Buf CLI offers a utility for transcoding messages between the three Protobuf encoding formats: the wire format, JSON, and textproto; it also supports YAML. This is <code class="language-plaintext highlighter-rouge">buf convert</code>, and it’s very powerful.</p> <p>To perform a conversion, we need four inputs:</p> <ol> <li>A Protobuf source to get types out of. This can be a local <code class="language-plaintext highlighter-rouge">.proto</code> file, an encoded <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> , or a remote BSR module. <ul> <li>If not provided, but run in a directory that is within a local Buf module, that module will be used as the Protobuf type source.</li> </ul> </li> <li>The name of the top-level type for the message we want to transcode, via the <code class="language-plaintext highlighter-rouge">--type</code> flag.</li> <li>The input message, via the <code class="language-plaintext highlighter-rouge">--from</code> flag.</li> <li>A location to output to, via the <code class="language-plaintext highlighter-rouge">--to</code> flag.</li> </ol> <p><code class="language-plaintext highlighter-rouge">buf convert</code> supports input and output redirection, making it usable as part of a shell pipeline. For example, consider the following Protobuf code in our local Buf module:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// my_api.proto</span>
<span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>
<span class="kn">package</span> <span class="nn">my</span><span class="o">.</span><span class="n">api.v1</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Cart</span> <span class="p">{</span>
  <span class="kt">int32</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">repeated</span> <span class="n">Order</span> <span class="na">orders</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Order</span> <span class="p">{</span>
  <span class="kt">fixed64</span> <span class="na">sku</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">sku_name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int64</span> <span class="na">count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Then, let’s say we’ve dumped a message of type <code class="language-plaintext highlighter-rouge">my.api.v1.Cart</code> from a service to debug it. And let’s say…well—you can’t just <code class="language-plaintext highlighter-rouge">cat</code> it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>dump.pb | xxd <span class="nt">-ps</span>
<span class="go">08a946121b097ac8e80400000000120e76616375756d20636c65616e6572
18011220096709b519000000001213686570612066696c7465722c203220
7061636b1806122c093aa8188900000000121f69736f70726f70796c2061
6c636f686f6c203730252c20312067616c6c6f6e1802</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>However, we can use <code class="language-plaintext highlighter-rouge">buf convert</code> to turn it into some nice JSON. We can then pipe it into <code class="language-plaintext highlighter-rouge">jq</code> to format it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf convert <span class="nt">--type</span> my.api.v1.Cart <span class="nt">--from</span> dump.pb <span class="nt">--to</span> -#format<span class="o">=</span>json | jq
<span class="go">{
  "userId": 9001,
  "orders": [
    {
      "sku": "82364538",
      "skuName": "vacuum cleaner",
      "count": "1"
    },
    {
      "sku": "431294823",
      "skuName": "hepa filter, 2 pack",
      "count": "6"
    },
    {
	    "sku": "2300094522",
      "skuName": "isopropyl alcohol 70%, 1 gallon",
      "count": "2"
    }
  ]
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Now you have the full expressivity of <code class="language-plaintext highlighter-rouge">jq</code> at your disposal. For example, we could pull out the user ID for the cart:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="k">function </span>buf-jq<span class="o">()</span> <span class="o">{</span> buf convert <span class="nt">--type</span> <span class="nv">$1</span> <span class="nt">--from</span> <span class="nv">$2</span> <span class="nt">--to</span> -#format<span class="o">=</span>json | jq <span class="nv">$3</span> <span class="o">}</span>
<span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'.userId'</span>
<span class="go">9001</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Or we can extract all of the SKUs that appear in the cart:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].sku]'</span>
<span class="go">[
  "82364538",
  "431294823",
  "2300094522"
]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Or we could try calculating how many items are in the cart, total:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count] | add'</span>
<span class="go">"162"</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Wait. That’s wrong. The answer should be <code class="language-plaintext highlighter-rouge">9</code>. This illustrates one pitfall to keep in mind when using <code class="language-plaintext highlighter-rouge">jq</code> with Protobuf. Protobuf will <em>sometimes</em> serialize numbers as quoted strings (the C++ reference implementation only does this when they’re integers outside of the IEEE754 representable range, but Go is somewhat lazier, and does it for all 64-bit values).</p> <blockquote> <p>You can test if an <code class="language-plaintext highlighter-rouge">x int64</code> is in the representable float range with this very simple check: <code class="language-plaintext highlighter-rouge">int64(float64(x)) == x)</code>. See <a href="https://go.dev/play/p/T81SbbFg3br">https://go.dev/play/p/T81SbbFg3br</a>. The <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/json/internal/unparser.cc#L96">equivalent version in C++</a> is much more complicated.</p> </blockquote> <p>This means we need to use the <code class="language-plaintext highlighter-rouge">tonumber</code> conversion function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count | tonumber] | add'</span>
<span class="go">9</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p><code class="language-plaintext highlighter-rouge">jq</code> ’s whole deal is JSON, so it brings with it all of JSON’s pitfalls. This is notable for Protobuf when trying to do arithmetic on 64-bit values. As we saw above, Protobuf serializes integers outside of the 64-bit float representable range (and in some runtimes, some integers inside it).</p> <p>For example, if you have a <code class="language-plaintext highlighter-rouge">repeated int64</code> that you want to sum over, it may produce incorrect answers due to floating-point rounding. For notes on conversions in <code class="language-plaintext highlighter-rouge">jq</code>, see <a href="https://jqlang.org/manual/#identity">https://jqlang.org/manual/#identity</a>.</p> <h2 id="disassembling-with-protoscope"><a href="#disassembling-with-protoscope">Disassembling with <code class="language-plaintext highlighter-rouge">protoscope</code></a></h2> <p><a href="https://github.com/protocolbuffers/protoscope"><code class="language-plaintext highlighter-rouge">protoscope</code></a> is a tool provided by the Protobuf team (which I originally wrote!) for decoding arbitrary data as if it were encoded in the Protobuf wire format. This process is called <em>disassembly</em>. It’s designed to work without a schema available, although it doesn’t produce especially clean output.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>go <span class="nb">install </span>github.com/protocolbuffers/protoscope/cmd/protoscope...@latest
<span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {
  1: 82364538i64
  2: {"vacuum cleaner"}
  3: 1
}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>The field names are gone; only field numbers are shown. This example also reveals an especially glaring limitation of <code class="language-plaintext highlighter-rouge">protoscope</code>, which is that it can’t tell the difference between string and message fields, so it guesses according to some heuristics. For the first and third elements it was able to grok them as strings, but for <code class="language-plaintext highlighter-rouge">orders[1].sku_name</code>, it incorrectly guessed it was a message and produced garbage.</p> <p>The tradeoff is that not only does <code class="language-plaintext highlighter-rouge">protoscope</code> not need a schema, it also tolerates almost any error, making it possible to analyze messages that have been partly corrupted. If we flip a random bit somewhere in <code class="language-plaintext highlighter-rouge">orders[0]</code>, disassembling the message still succeeds:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {`0f7ac8e80400000000120e76616375756d20636c65616e65721801`}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Although <code class="language-plaintext highlighter-rouge">protoscope</code> did give up on disassembling the corrupted submessage, it still made it through the rest of the dump.</p> <p>Like <code class="language-plaintext highlighter-rouge">buf convert</code>, we can give <code class="language-plaintext highlighter-rouge">protoscope</code> a <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> to make its heuristic a little smarter.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope <span class="se">\</span>
<span class="go">  --descriptor-set &lt;(buf build -o -) \
  --message-type my.api.v1.Cart \
  --print-field-names \
  dump.pb
</span><span class="gp">1: 9001                   #</span><span class="w"> </span>user_id
<span class="gp">2: {                      #</span><span class="w"> </span>orders
<span class="gp">  1: 82364538i64          #</span><span class="w"> </span>sku
<span class="gp">  2: {"vacuum cleaner"}   #</span><span class="w"> </span>sku_name
<span class="gp">  3: 1                    #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                          #</span><span class="w"> </span>orders
<span class="gp">  1: 431294823i64             #</span><span class="w"> </span>sku
<span class="gp">  2: {"hepa filter, 2 pack"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 6                        #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                                      #</span><span class="w"> </span>orders
<span class="gp">  1: 2300094522i64                        #</span><span class="w"> </span>sku
<span class="gp">  2: {"isopropyl alcohol 70%, 1 gallon"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 2                                    #</span><span class="w"> </span>count
<span class="go">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Not only is the second order decoded correctly now, but <code class="language-plaintext highlighter-rouge">protoscope</code> shows the name of each field (via <code class="language-plaintext highlighter-rouge">--print-field-names</code> ). In this mode, <code class="language-plaintext highlighter-rouge">protoscope</code> still decodes partially-valid messages.</p> <p><code class="language-plaintext highlighter-rouge">protoscope</code> also provides a number of other flags for customizing its heuristic in the absence of a <code class="language-plaintext highlighter-rouge">FileDescriporSet</code>. This enables it to be used as a forensic tool for debugging messy data corruption bugs.</p> </div> </div> </div> <div class="pagination post-footer"> <span class="pagination-item newer">&lt; Prev</span> • <a class="pagination-item older" href="https://mcyoung.xyz/page2">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>