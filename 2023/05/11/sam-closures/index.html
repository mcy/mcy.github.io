<!DOCTYPE html> <html lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Single Abstract Method Traits &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Single Abstract Method Traits &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/sam-closures-6bb66f1557541fbfc13f58dd19f43831fdb676ed.png"> <meta property="og:title" content="Single Abstract Method Traits &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/sam-closures-6bb66f1557541fbfc13f58dd19f43831fdb676ed.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2023/05/11/sam-closures/"> </head> <body> <div class="sidebar"> <a href="https://mcyoung.xyz/"> <img src="https://mcyoung.xyz/public/avatar.png" alt="Yeah, I drew this. Check out my art blog." class="hide-if-mobile"/> </a> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/">Home</a> • <a class="sidebar-nav-item" href="/about.html">About</a> • <a class="sidebar-nav-item" href="/posts.html">Posts</a> • <a class="sidebar-nav-item" href="/tags.html">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://art.mcyoung.xyz/">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> </nav> <br class="hide-if-mobile"/> <p class="hide-if-mobile"><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota</p> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2023-05-11 • <em> 2075 words • 11 minutes </em> <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/2023/05/11/sam-closures/"> Single Abstract Method Traits </a></h1> </div> <div class="post"> <p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Java gets a bad rap but the core language does have some interesting features in it. A very handy one is an <em>anonymous class</em>.</p> <p>Let’s suppose I want to pass a callback into something. In Java 6, which I grew up on, you did it like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Interface() {...}</code> syntax mints a new class on the spot that implements <code class="language-plaintext highlighter-rouge">Interface</code>. You provide a standard class body between the braces, after the name of the type. You can also do this with a class type too.</p> <p>Now, this is a bit tedious: I need to re-type the signature of the one method. This is fine if I need to implement a bunch of methods, but it’s a little annoying in the one-method case.</p> <p>In Java 8 we got lambdas (syntax: <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>). Java made the interesting choice of not adding a <code class="language-plaintext highlighter-rouge">Function</code> type to be “the type of lambdas”. For a long time I thought this was a weird cop-out but I have since come to regard it as a masterclass in language design.</p> <p>Instead, Java’s lambdas are a sort of syntax sugar over this anonymous class syntax.<sup id="fnref:invokedynamic" role="doc-noteref"><a href="#fn:invokedynamic" class="footnote" rel="footnote">1</a></sup> Instead, you need to assign a lambda to an interface type with a single abstract method, and it will use the body of the lambda to implement that one method.</p> <p>Interfaces compatible with lambdas are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation, which must satisfy the following constraints:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the aforementioned <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts and no GATs.</li> <li>All of its supertraits are <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, or <code class="language-plaintext highlighter-rouge">Sync</code>.</li> </ol> <p>These restrictions are chosen so that we have a shot at actually implementing the entire trait.</p> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, ordinary closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate.</p> <p>None of these traits are SAM, so we can safely allow them to be automatically derived for SAM closures to, under the same rules as for ordinary closures.</p> </blockquote> <p>To request a SAM closure, I will use the tentative syntax of <code class="language-plaintext highlighter-rouge">impl Trait |args| expr</code>. This syntax is unambiguously an expression rather than an <code class="language-plaintext highlighter-rouge">impl</code> item, because a <code class="language-plaintext highlighter-rouge">|</code> cannot appear in a path-in-type, and <code class="language-plaintext highlighter-rouge">impl $path</code> must be followed by <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">where</code>. The precise syntax is unimportant.</p> <p>Applied to the <code class="language-plaintext highlighter-rouge">call_many</code> example above, we get this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="n">Callback</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compiler rewrites this into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">CallbackImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CallbackImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CallbackImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This rewrite can happen relatively early, before we need to infer a type for <code class="language-plaintext highlighter-rouge">x</code>. We also need to verify that this trait’s captures are compatible with an <code class="language-plaintext highlighter-rouge">&amp;self</code> receiver The same rules for when a trait implements <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code> would decide which of the three receiver types the closure is compatible with.</p> <p>Note that SAM closures WOULD NOT implement any <code class="language-plaintext highlighter-rouge">Fn</code> traits.</p> <h3 id="more-complicated-examples"><a href="#more-complicated-examples">More Complicated Examples</a></h3> <p>We are required to name the trait we want but its type parameters can be left up in the air. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Out</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Display</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Out</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// We can infer `T = i32` and `Tr::Out = String`.</span>
<span class="k">let</span> <span class="n">tr</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In general, unspecified parameters and associated types result in inference variables, which are resolved in the same way as the parameters of the <code class="language-plaintext highlighter-rouge">Fn</code> closures are.</p> <p>In fact, we can emulate ordinary closures using SAM closures.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.map</span><span class="p">(</span><span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">_</span> <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that because <code class="language-plaintext highlighter-rouge">Fn</code> and <code class="language-plaintext highlighter-rouge">FnMut</code> have non-trival supertraits we can’t make them out of SAM closures.</p> <p>One application is to completely obsolete <code class="language-plaintext highlighter-rouge">std::iter::from_fn</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">u64</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Copy</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Or, if you need a quick helper implementation of <code class="language-plaintext highlighter-rouge">Debug</code>…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="n">f</span><span class="nf">.debug_list</span><span class="p">()</span>
    <span class="nf">.entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">impl</span> <span class="n">Debug</span> <span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"something something {}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.next_thingy</span><span class="p">())</span>
    <span class="p">})</span>
    <span class="nf">.finish</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are probably additional restrictions we will want to place on the SAM trait, but it’s not immediately clear what the breadth of those are. For example, we probably shouldn’t try to make this work:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">UniversalFactory</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">make</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">UniversalFactory</span> <span class="p">||</span> <span class="p">{</span>
  <span class="c1">// How do I name T so that I can pass it to size_of?</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are definitely clever tricks you <em>can</em> play to make this work, but the benefit seems slim.</p> <h2 id="future-work"><a href="#future-work">Future Work</a></h2> <p>There’s two avenues for how we could extend this concept. The first is straightforward and desireable; the second is probably unimplementable.</p> <h3 id="anonymous-trait-impls"><a href="#anonymous-trait-impls">Anonymous Trait Impls</a></h3> <p>Backing up from the Java equivalent of lambdas, it seems not unreasonable to have a full-fledged expression version of <code class="language-plaintext highlighter-rouge">impl</code> that can make captures.</p> <p>Syntactically, I will use <code class="language-plaintext highlighter-rouge">impl Trait for { ... }</code>. This is currently unambiguous, although I think that making it so that <code class="language-plaintext highlighter-rouge">{</code> cannot start a type is probably a non-starter.</p> <p>Let’s pick something mildly complicated… like <code class="language-plaintext highlighter-rouge">Iterator</code> with an overriden method. Then we might write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">[</span><span class="o">...</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iterator</span> <span class="o">=</span> <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="o">*</span><span class="n">my_list</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">my_list</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The contents of the braces after <code class="language-plaintext highlighter-rouge">for</code> is an item list, except that variables from the outside are available, having the semantics of captures; they are, in effect, accesses of <code class="language-plaintext highlighter-rouge">self</code> without the <code class="language-plaintext highlighter-rouge">self.</code> prefix.</p> <p>Hammering out precisely how this would interact with the self types of the functions in the body seems… complicated. Pretty doable, just fussy. There are also awkward questions about what <code class="language-plaintext highlighter-rouge">Self</code> is here and to what degree you’re allowed to interact with it.</p> <h3 id="trait-inference"><a href="#trait-inference">Trait Inference</a></h3> <p>Suppose that we could instead “just” write <code class="language-plaintext highlighter-rouge">impl |x| x * x</code> and have the compiler figure out what trait we want (to say nothing of making this the default behavior and dropping the leading <code class="language-plaintext highlighter-rouge">impl</code> keyword).</p> <p>This means that I could just write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We get into trouble fast.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <p>Currently, rustc does not have to produce impls “on demand”; the trait solver has a finite set of impls to look at. What we are asking the trait solver to do is to, for certain types, attempt to reify impls based on <em>usage</em>. I.e., I have my opaque closure type <code class="language-plaintext highlighter-rouge">T</code> and I the compiler decided it needed to prove a <code class="language-plaintext highlighter-rouge">T: Foo</code> bound so now it gets to perform type checking to validate whether it has an <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>This seems unimplementable with how the solver currently works. It is not insurmountable! But it would be very hard.</p> <p>It is possible that there are relaxations of this that are not insane to implement, e.g. the <code class="language-plaintext highlighter-rouge">impl ||</code> expression is used to initialize an argument to a function that happens to be generic, so we can steal the bounds off of that type variable and hope it’s SAM. But realistically, this direction is more trouble than its worth.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:invokedynamic" role="doc-endnote"> <p>Except for the part where they are extremely not. Where <code class="language-plaintext highlighter-rouge">new T() {}</code> mints a brand new class and accompanying <code class="language-plaintext highlighter-rouge">.class</code> file, Java lambdas use this complicated machinery from Java 7 to generate method handles on the fly, via the <code class="language-plaintext highlighter-rouge">invokedynamic</code> JVM instruction. This, I’m told, makes them much easier to optimize. <a href="#fnref:invokedynamic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <a href="/2023/11/27/simd-base64/"> <small class="post-meta-flat">2023-11-27</small> Designing a SIMD Algorithm from Scratch </a> <li> <a href="/2023/09/29/what-is-a-matrix/"> <small class="post-meta-flat">2023-09-29</small> What is a Matrix? A Miserable Pile of Coefficients! </a> <li> <a href="/2023/08/09/yarns/"> <small class="post-meta-flat">2023-08-09</small> I Wrote A String Type </a> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2023-05-11 • <em> 2075 words • 11 minutes </em> <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/2023/05/11/sam-closures/"> Single Abstract Method Traits </a></h1> </div> <div class="post"> <p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Java gets a bad rap but the core language does have some interesting features in it. A very handy one is an <em>anonymous class</em>.</p> <p>Let’s suppose I want to pass a callback into something. In Java 6, which I grew up on, you did it like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Interface() {...}</code> syntax mints a new class on the spot that implements <code class="language-plaintext highlighter-rouge">Interface</code>. You provide a standard class body between the braces, after the name of the type. You can also do this with a class type too.</p> <p>Now, this is a bit tedious: I need to re-type the signature of the one method. This is fine if I need to implement a bunch of methods, but it’s a little annoying in the one-method case.</p> <p>In Java 8 we got lambdas (syntax: <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>). Java made the interesting choice of not adding a <code class="language-plaintext highlighter-rouge">Function</code> type to be “the type of lambdas”. For a long time I thought this was a weird cop-out but I have since come to regard it as a masterclass in language design.</p> <p>Instead, Java’s lambdas are a sort of syntax sugar over this anonymous class syntax.<sup id="fnref:invokedynamic" role="doc-noteref"><a href="#fn:invokedynamic" class="footnote" rel="footnote">1</a></sup> Instead, you need to assign a lambda to an interface type with a single abstract method, and it will use the body of the lambda to implement that one method.</p> <p>Interfaces compatible with lambdas are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation, which must satisfy the following constraints:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the aforementioned <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts and no GATs.</li> <li>All of its supertraits are <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, or <code class="language-plaintext highlighter-rouge">Sync</code>.</li> </ol> <p>These restrictions are chosen so that we have a shot at actually implementing the entire trait.</p> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, ordinary closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate.</p> <p>None of these traits are SAM, so we can safely allow them to be automatically derived for SAM closures to, under the same rules as for ordinary closures.</p> </blockquote> <p>To request a SAM closure, I will use the tentative syntax of <code class="language-plaintext highlighter-rouge">impl Trait |args| expr</code>. This syntax is unambiguously an expression rather than an <code class="language-plaintext highlighter-rouge">impl</code> item, because a <code class="language-plaintext highlighter-rouge">|</code> cannot appear in a path-in-type, and <code class="language-plaintext highlighter-rouge">impl $path</code> must be followed by <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">where</code>. The precise syntax is unimportant.</p> <p>Applied to the <code class="language-plaintext highlighter-rouge">call_many</code> example above, we get this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="n">Callback</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compiler rewrites this into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">CallbackImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CallbackImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CallbackImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This rewrite can happen relatively early, before we need to infer a type for <code class="language-plaintext highlighter-rouge">x</code>. We also need to verify that this trait’s captures are compatible with an <code class="language-plaintext highlighter-rouge">&amp;self</code> receiver The same rules for when a trait implements <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code> would decide which of the three receiver types the closure is compatible with.</p> <p>Note that SAM closures WOULD NOT implement any <code class="language-plaintext highlighter-rouge">Fn</code> traits.</p> <h3 id="more-complicated-examples"><a href="#more-complicated-examples">More Complicated Examples</a></h3> <p>We are required to name the trait we want but its type parameters can be left up in the air. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Out</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Display</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Out</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// We can infer `T = i32` and `Tr::Out = String`.</span>
<span class="k">let</span> <span class="n">tr</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In general, unspecified parameters and associated types result in inference variables, which are resolved in the same way as the parameters of the <code class="language-plaintext highlighter-rouge">Fn</code> closures are.</p> <p>In fact, we can emulate ordinary closures using SAM closures.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.map</span><span class="p">(</span><span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">_</span> <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that because <code class="language-plaintext highlighter-rouge">Fn</code> and <code class="language-plaintext highlighter-rouge">FnMut</code> have non-trival supertraits we can’t make them out of SAM closures.</p> <p>One application is to completely obsolete <code class="language-plaintext highlighter-rouge">std::iter::from_fn</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">u64</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Copy</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Or, if you need a quick helper implementation of <code class="language-plaintext highlighter-rouge">Debug</code>…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="n">f</span><span class="nf">.debug_list</span><span class="p">()</span>
    <span class="nf">.entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">impl</span> <span class="n">Debug</span> <span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"something something {}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.next_thingy</span><span class="p">())</span>
    <span class="p">})</span>
    <span class="nf">.finish</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are probably additional restrictions we will want to place on the SAM trait, but it’s not immediately clear what the breadth of those are. For example, we probably shouldn’t try to make this work:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">UniversalFactory</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">make</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">UniversalFactory</span> <span class="p">||</span> <span class="p">{</span>
  <span class="c1">// How do I name T so that I can pass it to size_of?</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are definitely clever tricks you <em>can</em> play to make this work, but the benefit seems slim.</p> <h2 id="future-work"><a href="#future-work">Future Work</a></h2> <p>There’s two avenues for how we could extend this concept. The first is straightforward and desireable; the second is probably unimplementable.</p> <h3 id="anonymous-trait-impls"><a href="#anonymous-trait-impls">Anonymous Trait Impls</a></h3> <p>Backing up from the Java equivalent of lambdas, it seems not unreasonable to have a full-fledged expression version of <code class="language-plaintext highlighter-rouge">impl</code> that can make captures.</p> <p>Syntactically, I will use <code class="language-plaintext highlighter-rouge">impl Trait for { ... }</code>. This is currently unambiguous, although I think that making it so that <code class="language-plaintext highlighter-rouge">{</code> cannot start a type is probably a non-starter.</p> <p>Let’s pick something mildly complicated… like <code class="language-plaintext highlighter-rouge">Iterator</code> with an overriden method. Then we might write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">[</span><span class="o">...</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iterator</span> <span class="o">=</span> <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="o">*</span><span class="n">my_list</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">my_list</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The contents of the braces after <code class="language-plaintext highlighter-rouge">for</code> is an item list, except that variables from the outside are available, having the semantics of captures; they are, in effect, accesses of <code class="language-plaintext highlighter-rouge">self</code> without the <code class="language-plaintext highlighter-rouge">self.</code> prefix.</p> <p>Hammering out precisely how this would interact with the self types of the functions in the body seems… complicated. Pretty doable, just fussy. There are also awkward questions about what <code class="language-plaintext highlighter-rouge">Self</code> is here and to what degree you’re allowed to interact with it.</p> <h3 id="trait-inference"><a href="#trait-inference">Trait Inference</a></h3> <p>Suppose that we could instead “just” write <code class="language-plaintext highlighter-rouge">impl |x| x * x</code> and have the compiler figure out what trait we want (to say nothing of making this the default behavior and dropping the leading <code class="language-plaintext highlighter-rouge">impl</code> keyword).</p> <p>This means that I could just write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We get into trouble fast.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <p>Currently, rustc does not have to produce impls “on demand”; the trait solver has a finite set of impls to look at. What we are asking the trait solver to do is to, for certain types, attempt to reify impls based on <em>usage</em>. I.e., I have my opaque closure type <code class="language-plaintext highlighter-rouge">T</code> and I the compiler decided it needed to prove a <code class="language-plaintext highlighter-rouge">T: Foo</code> bound so now it gets to perform type checking to validate whether it has an <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>This seems unimplementable with how the solver currently works. It is not insurmountable! But it would be very hard.</p> <p>It is possible that there are relaxations of this that are not insane to implement, e.g. the <code class="language-plaintext highlighter-rouge">impl ||</code> expression is used to initialize an argument to a function that happens to be generic, so we can steal the bounds off of that type variable and hope it’s SAM. But realistically, this direction is more trouble than its worth.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:invokedynamic" role="doc-endnote"> <p>Except for the part where they are extremely not. Where <code class="language-plaintext highlighter-rouge">new T() {}</code> mints a brand new class and accompanying <code class="language-plaintext highlighter-rouge">.class</code> file, Java lambdas use this complicated machinery from Java 7 to generate method handles on the fly, via the <code class="language-plaintext highlighter-rouge">invokedynamic</code> JVM instruction. This, I’m told, makes them much easier to optimize. <a href="#fnref:invokedynamic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <a href="/2023/11/27/simd-base64/"> <small class="post-meta-flat">2023-11-27</small> Designing a SIMD Algorithm from Scratch </a> <li> <a href="/2023/09/29/what-is-a-matrix/"> <small class="post-meta-flat">2023-09-29</small> What is a Matrix? A Miserable Pile of Coefficients! </a> <li> <a href="/2023/08/09/yarns/"> <small class="post-meta-flat">2023-08-09</small> I Wrote A String Type </a> </ul> </div> </div> </div> </div></div> </body> <div class="sidebar show-if-mobile"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota </div> </div> </html>