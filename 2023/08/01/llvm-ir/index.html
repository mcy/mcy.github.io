<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> A Gentle Introduction to LLVM IR &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="A Gentle Introduction to LLVM IR &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/llvm-ir-17e5485eba866fa20f439e0c9f78d20c4ea118e0.png"> <meta property="og:title" content="A Gentle Introduction to LLVM IR &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/llvm-ir-17e5485eba866fa20f439e0c9f78d20c4ea118e0.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2023/08/01/llvm-ir/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pok√©mon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> ‚Ä¢ <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> ‚Ä¢ <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> ‚Ä¢ <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> ‚Ä¢ <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> ‚Ä¢ <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resum√©</a> ‚Ä¢ <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> ‚Ä¢ <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2023-08-01 ‚Ä¢ 5263 words ‚Ä¢ 43 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">‚Ä¢</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> ‚Ä¢ <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> ‚Ä¢ <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2023/08/01/llvm-ir/"> A Gentle Introduction to LLVM IR<br/> </a></h1> </div> <div class="post"> <p>The other day, I saw <a href="https://twitter.com/burntsushi5/status/1684204136571478021?s=20">this tweet</a>. In it, Andrew Gallant argues that reaching for LLVM IR, instead of assembly, is a useful tool for someone working on performance. Unfortunately, learning material on LLVM is usually aimed at compiler engineers, not generalist working programmers.</p> <p>Now, <em>I‚Äôm</em> a compiler engineer, so my answer is <em>of course</em> you should know your optimizer‚Äôs IR. But I do think there‚Äôs a legitimate reason to be able to read it, in the same way that being able to read assembly to understand what your processor is doing is a powerful tool. I wrote an <a href="https://mcyoung.xyz//2021/11/29/assembly-1">introduction to assembly</a> over a year ago (still have to finish the followups‚Ä¶ üíÄ), which I recommend reading first.</p> <p>Learning LLVM IR is similar, but it helps you understand what your <em>compiler</em> is doing to create highly optimized code. LLVM IR is very popular, and as such well-documented and reasonably well-specified, to the point that we can just treat it as a slightly weird programming language.</p> <p>In this article, I want to dig into what LLVM IR <em>is</em> and how to read it.</p> <h2 id="whats-llvm-ir"><a href="#whats-llvm-ir">What‚Äôs LLVM IR?</a></h2> <p>‚ÄúLLVM‚Äù is an umbrella name for a number of software components that can be used to build compilers. If you write performance-critical code, you‚Äôve probably heard of it.</p> <p>Its flagship product is Clang, a high-end C/C++/Objective-C compiler. Clang follows the orthodox compiler architecture: a frontend that parses source code into an AST and lowers it into an <em>intermediate representation</em>, an ‚ÄúIR‚Äù; an optimizer (or ‚Äúmiddle-end‚Äù) that transforms IR into better IR, and a backend that converts IR into machine code for a particular platform.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">                               optimizer (opt)
                                    ___
                                   |   v
          .c file  --&gt;  AST  --&gt;  LLVM IR  --&gt;  assembly
                    ^         ^             ^
                 parser    lowering    backend (llc)

         \____________________/  \_____________________/
             Clang Frontend                LLVM</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button"></div></div></div> <p>LLVM often also refers to just the optimizer and backend parts of Clang; this is can be thought of as a compiler for the ‚ÄúLLVM language‚Äù or ‚ÄúLLVM assembly‚Äù. Clang, and other language frontends like Rust, essentially compile to LLVM IR, which LLVM then compiles to machine code.</p> <p>LLVM IR is well documented and‚Ä¶ <em>somewhat</em> stable, which makes it a very good compilation target, since language implementers can re-use the thousands of engineer hours poured into LLVM already. The source of truth for ‚Äúwhat is LLVM IR?‚Äù is the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>.</p> <p>LLVM IR is also binary format (sometimes called ‚Äúbitcode‚Äù), although we will be working exclusively with its text format (which uses the <code class="language-plaintext highlighter-rouge">.ll</code> extension).</p> <p>LLVM-targeting compilers will have debugging flags to make them emit IR instead of their final output. For Clang, this is e.g. <code class="language-plaintext highlighter-rouge">clang++ -S -emit-llvm foo.cc</code>, while for Rust this is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir foo.rs</code>. Godbolt will also respect these options and correctly display LLVM IR output.</p> <h2 id="back-to-basic-blocks"><a href="#back-to-basic-blocks">Back to Basic Blocks</a></h2> <p>LLVM IR can be quite intimidating to read, since it contains much more ancillary information than an assembly dump. Consider this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>If you click on the ‚ÄúGodbolt‚Äù widget, it will take you to a Godbolt that lowers it to LLVM IR. Most of that code is just metadata, but it‚Äôs really intimidating!</p> <p>Starting from compiler output will have a steep difficulty curve, because we have to face the full complexity of LLVM IR. For Rust, this will likely mean encountering exception-handling, which is how panics are implemented, and function attributes that forward Rust‚Äôs guarantees (e.g. non-null pointers) to LLVM.</p> <p>Instead, we‚Äôll start by introducing the basic syntax of LLVM IR, and <em>then</em> we‚Äôll tackle reading compiler output.</p> <h3 id="a-trivial-function"><a href="#a-trivial-function">A Trivial Function</a></h3> <p>The meat of LLVM IR is function definitions, introduced with a <code class="language-plaintext highlighter-rouge">define</code>. There is also <code class="language-plaintext highlighter-rouge">declare</code>, which has exactly the same purpose as a function without a body in C: it brings an external symbol into scope.</p> <p>For example, the following function takes no arguments and returns immediately:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_nothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The return type of the function (<code class="language-plaintext highlighter-rouge">void</code>) immediately follows the <code class="language-plaintext highlighter-rouge">define</code> keyword; the name of the function starts with an <code class="language-plaintext highlighter-rouge">@</code>, which introduces us to the concept of <em>sigils</em>: every user-defined symbol starts with a sigil, indicating what kind of symbol it is. <code class="language-plaintext highlighter-rouge">@</code> is used for global and functions: things you can take the address of (when used as a value, they are always <code class="language-plaintext highlighter-rouge">ptr</code>-typed).</p> <p>The body of a function resembles assembly: a list of labels and instructions. Unlike ordinary assembly, however, there are significant restrictions on the structure of these instructions.</p> <p>In this case, there is only one instruction: a <code class="language-plaintext highlighter-rouge">void</code>-typed return. Unlike most assembly languages, LLVM IR is strongly typed, and requires explicit type annotations almost everywhere.</p> <p>Here is another trivial function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_not_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">unreachable</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function will trigger undefined behavior upon being called: the <code class="language-plaintext highlighter-rouge">unreachable</code> instruction represents a codepath that the compiler can assume is never executed; this is unlike e.g. the unimplemented <code class="language-plaintext highlighter-rouge">ud2</code> instruction in x86, which is guaranteed to issue a fault.</p> <p>This is an important distinction between LLVM IR and an assembly language: some operations are explicitly left undefined to leave room for potential optimizations. For example, LLVM can reason that, because <code class="language-plaintext highlighter-rouge">@do_not_call</code> immediately triggers undefined behavior, all calls to <code class="language-plaintext highlighter-rouge">@do_not_call</code> are also unreachable (and propagate unreachability from there).</p> <h3 id="purely-scalar-code"><a href="#purely-scalar-code">Purely Scalar Code</a></h3> <p>Let‚Äôs start with basic functions that only operate on integers. Consider the following function, that squares a 32-bit integer:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function takes arguments and has multiple instructions.</p> <p>The argument is specified as <code class="language-plaintext highlighter-rouge">i32 %x</code>. Names a <code class="language-plaintext highlighter-rouge">%</code> sigil are sort of like local variables, but with some restrictions that make them more optimization-friendly; as we‚Äôll see later, they‚Äôre not really ‚Äúvariable‚Äù at all. LLVM sometimes calls them <em>registers</em>; in a sense, LLVM IR is assembly for an abstract machine with an infinite number of registers. I‚Äôll be calling <code class="language-plaintext highlighter-rouge">%</code>-prefixed names ‚Äúregisters‚Äù throughout this article.</p> <p><code class="language-plaintext highlighter-rouge">i32</code> is a primitive integer types. All integer types in LLVM are of the form <code class="language-plaintext highlighter-rouge">iN</code>, for any <code class="language-plaintext highlighter-rouge">N</code> (even non-multiples of eight). There are no signed or unsigned types; instead, instructions that care about signedness will specify which semantic they use.</p> <p>The first instruction is a <code class="language-plaintext highlighter-rouge">mul i32</code>, which multiples the two <code class="language-plaintext highlighter-rouge">i32</code> operands together, and returns a value; we assign this to the new register <code class="language-plaintext highlighter-rouge">%1</code><sup id="fnref:numeric-names" role="doc-noteref"><a href="#fn:numeric-names" class="footnote" rel="footnote">1</a></sup>. The next instruction returns this value.</p> <p>The other arithmetic operations have the names you expect: <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">shl</code> (shift left). There are two division and remainder instructions, signed (<code class="language-plaintext highlighter-rouge">sdiv</code>, <code class="language-plaintext highlighter-rouge">srem</code>) and unsigned (<code class="language-plaintext highlighter-rouge">udiv</code>, <code class="language-plaintext highlighter-rouge">urem</code>). There two shift right instructions, again signed (<code class="language-plaintext highlighter-rouge">ashr</code>) and unsigned (<code class="language-plaintext highlighter-rouge">lshr</code>).</p> <blockquote> <p>Exercise for the reader: why are <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">%</code>, and <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> the only operations with signed and unsigned versions?</p> </blockquote> <p>We can also convert from one integer type to another using <code class="language-plaintext highlighter-rouge">trunc</code>, <code class="language-plaintext highlighter-rouge">zext</code>, and <code class="language-plaintext highlighter-rouge">sext</code>, which truncate, zero-extend, and sign-extend, respectively (<code class="language-plaintext highlighter-rouge">sext</code> and <code class="language-plaintext highlighter-rouge">zext</code> are another signed/unsigned pair). For example, if we wanted the <code class="language-plaintext highlighter-rouge">square</code> function to never overflow, we could write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">sext</span> <span class="kt">i32</span> <span class="nv">%x</span> <span class="k">to</span> <span class="kt">i64</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%1</span><span class="p">,</span> <span class="nv">%1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we cast <code class="language-plaintext highlighter-rouge">%x</code> to <code class="language-plaintext highlighter-rouge">i64</code> by sign-extension (since we‚Äôve decided we‚Äôre squaring signed integers) and then square the result. <code class="language-plaintext highlighter-rouge">trunc</code> and <code class="language-plaintext highlighter-rouge">zext</code> both have the same syntax as <code class="language-plaintext highlighter-rouge">sext</code>.</p> <h3 id="ill-be-back"><a href="#ill-be-back">‚ÄúI‚Äôll Be Back‚Äù</a></h3> <p>Of course, interesting functions have <em>control flow</em>. Suppose we want a safe division function: division by zero is UB, so we need to handle it explicitly. Perhaps something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try doing this using <code class="language-plaintext highlighter-rouge">select</code>, LLVM‚Äôs ‚Äúternary‚Äù operation.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">select</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">-1</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%2</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>However, this has a problem: division by zero is UB<sup id="fnref:divz" role="doc-noteref"><a href="#fn:divz" class="footnote" rel="footnote">2</a></sup>, and <code class="language-plaintext highlighter-rouge">select</code> is not short-circuiting: its semantics are closer to that of <code class="language-plaintext highlighter-rouge">cmov</code> in x86.</p> <p>To compile this correctly, need to use the <code class="language-plaintext highlighter-rouge">br</code> instruction, which represents a general branch operation<sup id="fnref:br-on-real-machines" role="doc-noteref"><a href="#fn:br-on-real-machines" class="footnote" rel="footnote">3</a></sup>. In C terms, a <code class="language-plaintext highlighter-rouge">br i1 %cond, label %a, label %b</code> is equivalent to <code class="language-plaintext highlighter-rouge">if (cond) goto a; else goto b;</code>.</p> <p>This is how we might write that:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%iszero</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%nonzero</span>

<span class="nl">iszero:</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="m">-1</span>

<span class="nl">nonzero:</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function has labels, which are used by the <code class="language-plaintext highlighter-rouge">br</code> instruction as jump targets.</p> <p>In the first block, we do the <code class="language-plaintext highlighter-rouge">d == 0</code> check, implemented by an <code class="language-plaintext highlighter-rouge">icmp eq</code> instruction. This returns an <code class="language-plaintext highlighter-rouge">i1</code> (the type LLVM uses for booleans). We then pass the result into a <code class="language-plaintext highlighter-rouge">br</code> instruction, which jumps to the first label if it‚Äôs zero, otherwise to the second if it isn‚Äôt.</p> <p>The second block is the early-return; it returns the ‚Äúsentinel‚Äù value; the third block is self-explanatory.</p> <p>Each of these blocks is a ‚Äúbasic block‚Äù: a sequence of non-control flow operations, plus an instruction that moves control flow away from the block. These blocks form the control flow graph (CFG) of the function.</p> <p>There are a few other ‚Äúblock terminator‚Äù instructions. The one-argument form of <code class="language-plaintext highlighter-rouge">br</code> takes a single label, and is a simple unconditional <code class="language-plaintext highlighter-rouge">goto</code>. There‚Äôs also <code class="language-plaintext highlighter-rouge">switch</code>, which is similar to a C <code class="language-plaintext highlighter-rouge">switch</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">switch</span> <span class="kt">i32</span> <span class="nv">%value</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%default</span> <span class="p">[</span>
  <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_zero</span>
  <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_one</span><span class="p">,</span>
  <span class="c1">; etc</span>
<span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The type of the <code class="language-plaintext highlighter-rouge">switch</code> must be an integer type. Although you could represent this operation with a chain of <code class="language-plaintext highlighter-rouge">br</code>s, a separate <code class="language-plaintext highlighter-rouge">switch</code> instruction makes it easier for LLVM to generate jump tables.</p> <p><code class="language-plaintext highlighter-rouge">unreachable</code>, which we saw before, is a special terminator that does not trigger control flow per se, but which can terminate a block because reaching it is undefined behavior; it is equivalent to e.g. <code class="language-plaintext highlighter-rouge">std::unreachable()</code> in C++.</p> <blockquote> <h4 id="llvm-deleted-my-code"><a href="#llvm-deleted-my-code">LLVM Deleted My Code!</a></h4> <p>The <code class="language-plaintext highlighter-rouge">unreachable</code> instruction provides a good example of why LLVM uses a basic block CFG: a naive dead code elimination (DCE) optimization pass can be implemented as follows:</p> <ol> <li>Fill a set with every block that ends in <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>For every block, if its terminator references a block in the unreachable set, delete that label from the terminator. For example, if we have <code class="language-plaintext highlighter-rouge">br i1 %c, label %a, label %b</code>, and the unreachable set contains <code class="language-plaintext highlighter-rouge">%a</code>, we can replace this with a <code class="language-plaintext highlighter-rouge">br label %b</code>.</li> <li>If every outgoing edge from a block is deleted in (2), replace the terminator with <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>Delete all blocks in the unreachable set.</li> <li>Repeat from (1) as many times as desired.</li> </ol> <p>Intuitively, <code class="language-plaintext highlighter-rouge">unreachable</code>s bubble <em>upwards</em> in the CFG, dissolving parts of the CFG among them. Other passes can generate <code class="language-plaintext highlighter-rouge">unreachable</code>s to represent UB: interplay between this and DCE results in the ‚Äúthe compiler <em>will</em> delete your code‚Äù outcome from UB.</p> <p>The actual DCE pass is much more complicated, since function calls make it harder to decide if a block is ‚Äúpure‚Äù and thus transparently deletable.</p> </blockquote> <p>But, what if we want to implement something more complicated, like <code class="language-plaintext highlighter-rouge">a / b + 1</code>? This expression needs the intermediate result, so we can‚Äôt use two return statements as before.</p> <p>Working around this is not so straightforward: if we try to assign the same register in different blocks, the IR verifier will complain. This brings us to the concept of static single assignment.</p> <h3 id="phony-phony"><a href="#phony-phony">Phony! Phony!</a></h3> <p>LLVM IR is a <em>static single assignment form</em> (SSA) IR. LLVM was actually started at the turn of the century to create a modern SSA optimizer as an academic project. These days, SSA is extremely fashionable for optimizing imperative code.</p> <p>SSA form means that every register is assigned by at most one instruction per function. Different executions of the same block in the same function may produce different values for particular registers, but we cannot <em>mutate</em> already-assigned registers.</p> <p>In other words:</p> <ol> <li>Every register is guaranteed to be initialized by a single expression.</li> <li>Every register depends only on the values of registers assigned before its definition.</li> </ol> <p>This has many useful properties for writing optimizations: for example, within a basic block, every use of a particular register <code class="language-plaintext highlighter-rouge">%x</code> always refers to the same value, which makes optimizations like <a href="https://en.wikipedia.org/wiki/Value_numbering">global value numbering</a> and constant-folding much simpler to write, since the state of a register throughout a block doesn‚Äôt need to be tracked separately.</p> <p>In SSA, we reinterpret mutation as many <em>versions</em> of a single variable. Thus, we might lower <code class="language-plaintext highlighter-rouge">x += y</code> as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x.1</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%x.0</span><span class="p">,</span> <span class="nv">%y.0</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we‚Äôve used a <code class="language-plaintext highlighter-rouge">var.n</code> convention to indicate which version of a variable a specific register represents (LLVM does not enforce any naming conventions).</p> <p>However, when loops enter the mix, it‚Äôs not clear how to manage versions. The number of registers in a function is static, but the number of loop iterations is dynamic.</p> <p>Concretely, how do we implement this function?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">y</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>  <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>   <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>But there‚Äôs a problem! What are the original definitions of <code class="language-plaintext highlighter-rouge">%r</code> and <code class="language-plaintext highlighter-rouge">%i</code>? The IR verifier will complain that these registers depend directly on themselves, which violates SSA form. What‚Äôs the ‚Äúright‚Äù way to implement this function?</p> <p>One option is to ask LLVM! We‚Äôll implement the function poorly, and let the optimizer clean it up for us.</p> <p>First, let‚Äôs write the function using memory operations, like <code class="language-plaintext highlighter-rouge">load</code>s and <code class="language-plaintext highlighter-rouge">store</code>s, to implement mutation. We can use the <code class="language-plaintext highlighter-rouge">alloca</code> instruction to create statically-sized stack slots; these instructions return a <code class="language-plaintext highlighter-rouge">ptr</code>[^clang-codegen].</p> <blockquote> <h4 id="clang-makes-a-mess-llvm-cleans-it-up"><a href="#clang-makes-a-mess-llvm-cleans-it-up">Clang Makes a Mess, LLVM Cleans It Up</a></h4> <p>Incidentally, this is how Clang and Rust both generate LLVM IR: stack variables are turned into <code class="language-plaintext highlighter-rouge">alloca</code>s and manipulated through loads and stores; temporaries are mostly turned into <code class="language-plaintext highlighter-rouge">%regs</code>s, but the compiler will sometimes emit extra allocas to avoid thinking too hard about needing to create <code class="language-plaintext highlighter-rouge">phi</code> instructions.</p> <p>This is pretty convenient, because it avoids needing to think very hard about SSA form outside of LLVM, and LLVM can trivially eliminate unnecessary allocas. The code I wrote for the codegen of <code class="language-plaintext highlighter-rouge">@pow</code> is very similar to what Rust would send to LLVM (although because we used an iterator, there‚Äôs a lot of extra junk Rust emits that LLVM has to work to eliminate).</p> </blockquote> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">; Create slots for r and the index, and initialize them.</span>
  <span class="c1">; This is equivalent to something like</span>
  <span class="c1">;   int i = 0, r = 1;</span>
  <span class="c1">; in C.</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="c1">; Load the index and check if it equals y.</span>
  <span class="nv">%i.check</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.check</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="c1">; r *= x</span>
  <span class="nv">%r.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.old</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%r.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>

  <span class="c1">; i += 1</span>
  <span class="nv">%i.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.old</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%i.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>

  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="nv">%r.ret</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.ret</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Next, we can pass this into the LLVM optimizer. The command <code class="language-plaintext highlighter-rouge">opt</code>, which is part of the LLVM distribution, runs specific optimizer passes on the IR. In our case, we want <code class="language-plaintext highlighter-rouge">opt -p mem2reg</code>, which runs a single ‚Äúmemory to register‚Äù pass. We can also just run <code class="language-plaintext highlighter-rouge">opt --O2</code> or similar to get similar<sup id="fnref:frontend-optimization" role="doc-noteref"><a href="#fn:frontend-optimization" class="footnote" rel="footnote">4</a></sup> optimizations to the ones <code class="language-plaintext highlighter-rouge">clang -O2</code> runs.</p> <p>This is the result.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; After running through `opt -p mem2reg`</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="nv">%i.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%i.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%r.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%r.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.0</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.0</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">alloca</code>s are gone, but now we‚Äôre faced with a new instruction: <code class="language-plaintext highlighter-rouge">phi</code>. ‚ÄúœÜ node‚Äù is jargon from the original SSA paper; the greek letter œÜ means ‚Äúphoney‚Äù. These instructions select a value from a list based on which basic block we jumped to the block from.</p> <p>For example, <code class="language-plaintext highlighter-rouge">phi i32 [0, %start], [%i.new, %loop]</code> says ‚Äúthis value should be 0 if we came from the <code class="language-plaintext highlighter-rouge">start</code> block; otherwise <code class="language-plaintext highlighter-rouge">%i.new</code> if it came from <code class="language-plaintext highlighter-rouge">%loop</code>‚Äù.</p> <p>Unlike all other instructions, <code class="language-plaintext highlighter-rouge">phi</code> can refer to values that are not defined in all blocks that dominate the current block. This lets us have a dynamic number of versions of a variable! Here‚Äôs what that looks like in a dynamic execution context.</p> <blockquote> <p>A block <code class="language-plaintext highlighter-rouge">%a</code> is said to dominate a block <code class="language-plaintext highlighter-rouge">%b</code> if each of its predecessors is either <code class="language-plaintext highlighter-rouge">%a</code> or a block dominated by <code class="language-plaintext highlighter-rouge">%a</code>. In other words, every path from the first block to <code class="language-plaintext highlighter-rouge">%b</code> passes through <code class="language-plaintext highlighter-rouge">%a</code>. In general instructions can only refer to values defined in previous instructions in the current block or values from blocks that dominate it.</p> </blockquote> <ol> <li> <p><code class="language-plaintext highlighter-rouge">%start</code> directly jumps into <code class="language-plaintext highlighter-rouge">%loop_start</code>. The first block cannot be a jump target, since it cannot have <code class="language-plaintext highlighter-rouge">phi</code> nodes because its predecessors include function‚Äôs callsite.</p> </li> <li> <p>In <code class="language-plaintext highlighter-rouge">%loop_start</code>, since we‚Äôve entered from <code class="language-plaintext highlighter-rouge">%start</code>, <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are selected to be the first versions of the (platonic) <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code> variables, i.e., their initial values; we jump to <code class="language-plaintext highlighter-rouge">%loop</code>.</p> </li> <li> <p>Then, <code class="language-plaintext highlighter-rouge">%loop</code> is dominated by <code class="language-plaintext highlighter-rouge">%loop_start</code> so we can use <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> there directly; these are the <code class="language-plaintext highlighter-rouge">*=</code> and <code class="language-plaintext highlighter-rouge">+=</code> operations. Then we jump back to <code class="language-plaintext highlighter-rouge">%loop_start</code>.</p> </li> <li> <p>Back in <code class="language-plaintext highlighter-rouge">%loop_start</code>, the <code class="language-plaintext highlighter-rouge">phi</code>s now select <code class="language-plaintext highlighter-rouge">%i.new</code> and <code class="language-plaintext highlighter-rouge">%r.new</code>, so now <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are the <em>second</em> versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>. By induction, the nth execution of <code class="language-plaintext highlighter-rouge">%loop_start</code> has the nth versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>.</p> </li> <li> <p>When we finally get sent to <code class="language-plaintext highlighter-rouge">%exit</code>, we can use <code class="language-plaintext highlighter-rouge">%r.0</code> (since <code class="language-plaintext highlighter-rouge">%loop_start</code> dominates <code class="language-plaintext highlighter-rouge">%r.0</code>), which will be the <code class="language-plaintext highlighter-rouge">%y</code>th version of <code class="language-plaintext highlighter-rouge">r</code>; this is our return value.</p> </li> </ol> <p>This is a good place to stop and think about what we‚Äôve done so far. SSA, domination, and <code class="language-plaintext highlighter-rouge">phi</code>s can be hard to wrap your head around, and are not absolutely necessary for reading most IR. However, it is absolutely worth trying to understand, because it captures essential facts about how compilers like to reason about code<sup id="fnref:block-args" role="doc-noteref"><a href="#fn:block-args" class="footnote" rel="footnote">5</a></sup>.</p> <p>With <code class="language-plaintext highlighter-rouge">phi</code> and <code class="language-plaintext highlighter-rouge">br</code>, we can build arbitrarily complicated control flow within a function<sup id="fnref:viz" role="doc-noteref"><a href="#fn:viz" class="footnote" rel="footnote">6</a></sup>.</p> <h2 id="types-and-aggregates"><a href="#types-and-aggregates">Types and Aggregates</a></h2> <p>Now that we have basic scalar functions, let‚Äôs review LLVM‚Äôs type system.</p> <p>We‚Äôve seen <code class="language-plaintext highlighter-rouge">i32</code> and its friends; these are arbitrary-bit-with integers. <code class="language-plaintext highlighter-rouge">i1</code> is special because it is used as the boolean type. LLVM optimizations have been known to generate integer types with non-power-of-two sizes.</p> <p>LLVM also has <code class="language-plaintext highlighter-rouge">float</code> and <code class="language-plaintext highlighter-rouge">double</code>, and some exotic float types like <code class="language-plaintext highlighter-rouge">bfloat</code>; these use their own arithmetic instructions with different options. I‚Äôll pass on them in this explainer; see <code class="language-plaintext highlighter-rouge">fadd</code> and friends in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> for more.</p> <p>We‚Äôve also seen <code class="language-plaintext highlighter-rouge">void</code>, which is only used as a return value, and <code class="language-plaintext highlighter-rouge">ptr</code>, which is an untyped<sup id="fnref:typed-pointers" role="doc-noteref"><a href="#fn:typed-pointers" class="footnote" rel="footnote">7</a></sup> pointer.</p> <p>We‚Äôve also seen the <code class="language-plaintext highlighter-rouge">label</code> pseudo-type, which represents a block label. It does not appear directly at runtime and has limited uses; the <code class="language-plaintext highlighter-rouge">token</code> and <code class="language-plaintext highlighter-rouge">metadata</code> types are similar.</p> <p>Arrays are spelled <code class="language-plaintext highlighter-rouge">[n x T]</code>; the number must be an integer and the type must have a definite size. E.g., <code class="language-plaintext highlighter-rouge">[1024 x i8]</code>. Zero-sized arrays are supported.</p> <p>Structs are spelled <code class="language-plaintext highlighter-rouge">{T1, T2, ...}</code>. E.g., <code class="language-plaintext highlighter-rouge">{i64, ptr}</code> is a Rust slice. Struct fields do not have names and are indexed, instead. The form <code class="language-plaintext highlighter-rouge">&lt;{...}&gt;</code> is a <em>packed</em> struct, which removes inter-field padding. E.g. <code class="language-plaintext highlighter-rouge">#[repr(packed)]</code> compiles down to this.</p> <p>Vectors are like arrays but spelled <code class="language-plaintext highlighter-rouge">&lt;n x T&gt;</code>. These are used to represent types used in SIMD operations. For example, adding two <code class="language-plaintext highlighter-rouge">&lt;4 x i32&gt;</code> would lower to an AVX2 vector add on x86. I will not touch on SIMD stuff beyond this, although at higher optimization levels LLVM will merge scalar operations into vector operations, so you may come across them.</p> <p>Type aliases can be created at file scope with the syntax</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Slice</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This means that <code class="language-plaintext highlighter-rouge">%T</code> can be either a type or a register/label inside of a function, depending on syntactic position.</p> <h3 id="operations-on-aggregates"><a href="#operations-on-aggregates">Operations on Aggregates</a></h3> <p>The <code class="language-plaintext highlighter-rouge">insertvalue</code> and <code class="language-plaintext highlighter-rouge">extractvalue</code> can be used with struct or array types to statically access a field. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%MyStruct</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i32</span><span class="p">,</span> <span class="p">{[</span><span class="m">5</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">],</span> <span class="kt">i64</span><span class="p">}}</span>

<span class="c1">; In Rust-like syntax, this is `let v = s.1.0[4];`</span>
<span class="nv">%v</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><code class="language-plaintext highlighter-rouge">insertvalue</code> is the reverse: it produces a copy of the aggregate with a specific field changed. It <em>does not</em> mutate in-place, because SSA forbids that.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; In Rust-like syntax, this is</span>
<span class="c1">;   let s2 = { let mut s = s; s2.1.1 = 42; s };</span>
<span class="nv">%s2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>There are similar operations called <code class="language-plaintext highlighter-rouge">insertelement</code> and <code class="language-plaintext highlighter-rouge">extractelement</code> work on vectors, but have slightly different syntax and semantics.</p> <p>Finally, there‚Äôs <code class="language-plaintext highlighter-rouge">getelementptr</code>, the ‚Äúpointer arithmetic instruction‚Äù, often abbreviated to GEP. A GEP can be used to calculate an offset pointer into a struct. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="err">ptr</span> <span class="vg">@get_inner_in_array</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%q</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%MyStruct</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="err">ptr</span> <span class="nv">%q</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function takes in a pointer, ostensibly pointing to an array of <code class="language-plaintext highlighter-rouge">%MyStruct</code>s, and an index. This returns a pointer to the <code class="language-plaintext highlighter-rouge">i64</code> field of the <code class="language-plaintext highlighter-rouge">%idx</code>th element of <code class="language-plaintext highlighter-rouge">%p</code>.</p> <p>A few important differences between GEP and <code class="language-plaintext highlighter-rouge">extractvalue</code>:</p> <ol> <li>It takes an untyped pointer instead of a value of a particular struct/array type.</li> <li>There is an extra parameter that specifies an index; from the perspective of GEP, every pointer is a pointer to an array of unspecified bound. When operating on a pointer that does not (at runtime) point to an array, an index operand of <code class="language-plaintext highlighter-rouge">0</code> is still required. (Alternatively, you can view a pointer to <code class="language-plaintext highlighter-rouge">T</code> as being a pointer to a one-element array.)</li> <li>The index parameters need explicit types.</li> </ol> <p>LLVM provides a helpful<sup id="fnref:sarcasm" role="doc-noteref"><a href="#fn:sarcasm" class="footnote" rel="footnote">8</a></sup> FAQ on the GEP instruction: <a href="https://llvm.org/docs/GetElementPtr.html">https://llvm.org/docs/GetElementPtr.html</a>.</p> <h2 id="other-operations"><a href="#other-operations">Other Operations</a></h2> <p>Some other operations are very relevant for reading IR, but don‚Äôt fit into any specific category. As always, the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> provides a full description of what all of these instructions do.</p> <h3 id="function-calls"><a href="#function-calls">Function Calls</a></h3> <p><code class="language-plaintext highlighter-rouge">call</code>, which calls any <code class="language-plaintext highlighter-rouge">ptr</code> as a function. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; Arguments are passed in parentheses.</span>
<span class="nv">%r</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@my_func</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Note that this could have been a <code class="language-plaintext highlighter-rouge">%reg</code> instead of a <code class="language-plaintext highlighter-rouge">@global</code>, which indicates a function pointer call.</p> <p>Sometimes you will see <code class="language-plaintext highlighter-rouge">invoke</code>, which is used to implement ‚Äúcall a function inside of a C++ <code class="language-plaintext highlighter-rouge">try {}</code> block‚Äù. This is rare in Rust, but can occur in some C++ code.</p> <p>Function calls are often noisy areas of IR, because they will be very heavily annotated.</p> <h3 id="synchronization"><a href="#synchronization">Synchronization</a></h3> <p>The <code class="language-plaintext highlighter-rouge">load</code> and <code class="language-plaintext highlighter-rouge">store</code> instructions we‚Äôve already seen can be annotated as <code class="language-plaintext highlighter-rouge">atomic</code>, which is used to implement e.g. <code class="language-plaintext highlighter-rouge">AtomicU32::load</code> in Rust; this requires that an atomic ordering be specified, too. E.g.,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%v</span> <span class="p">=</span> <span class="k">load</span> <span class="k">atomic</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span> <span class="k">acquire</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">fence</code> operation is a general memory fence operation corresponding to e.g. Rust‚Äôs <code class="language-plaintext highlighter-rouge">std::sync::atomic::fence</code> function.</p> <p><code class="language-plaintext highlighter-rouge">cmpxchg</code> provides the CAS (compare-and-swap) primitive. It returns a <code class="language-plaintext highlighter-rouge">{T, i1}</code> containing the old value and whether the CAS succeeded. <code class="language-plaintext highlighter-rouge">cmpxchg weak</code> implements the spuriously-failing ‚Äúweak CAS‚Äù primitive.</p> <p>Finally, <code class="language-plaintext highlighter-rouge">atomicrmw</code> performs a read-modify-write (e.g., <code class="language-plaintext highlighter-rouge">*p = op(*p, val)</code>) atomically. This is used to implement things like <code class="language-plaintext highlighter-rouge">AtomicU32::fetch_add</code> and friends.</p> <p>All of these operations, except for <code class="language-plaintext highlighter-rouge">fence</code>, can also be marked as <code class="language-plaintext highlighter-rouge">volatile</code>. In LLVM IR, much like in Rust but unlike in C/C++, individual loads and stores are volatile (i.e., have compiler-invisible side-effects). <code class="language-plaintext highlighter-rouge">volatile</code> <em>can</em> be combined with atomic operations (e.g. <code class="language-plaintext highlighter-rouge">load atomic volatile</code>), although most languages don‚Äôt provide access to these (except older C++ versions).</p> <h3 id="reinterpret-shenanigans"><a href="#reinterpret-shenanigans">Reinterpret Shenanigans</a></h3> <p><code class="language-plaintext highlighter-rouge">bitcast</code> is what <code class="language-plaintext highlighter-rouge">mem::transmute</code> and <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> in Rust and C++, respectively, ultimately compile into. It can convert any non-aggregate type (integers, vectors) to any other type of the same bit width. For example, it can be used to get at the bits of a floating-point value:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%bits</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span> <span class="nv">%fp</span> <span class="k">to</span> <span class="kt">i64</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>It also used to be what was used to cast pointer types (e.g. <code class="language-plaintext highlighter-rouge">i32*</code> to <code class="language-plaintext highlighter-rouge">i8*</code>). Pointers are now all untyped (<code class="language-plaintext highlighter-rouge">ptr</code>) so this use is no longer present.</p> <p>However, <code class="language-plaintext highlighter-rouge">bitcast</code> cannot cast between pointer and integer data. For this we must use the <code class="language-plaintext highlighter-rouge">inttoptr</code> and <code class="language-plaintext highlighter-rouge">ptrtoint</code><sup id="fnref:i2p" role="doc-noteref"><a href="#fn:i2p" class="footnote" rel="footnote">9</a></sup> instructions. These have the same syntax, but interact with the sketchy semantics of pointer-to-integer conversion and pointer provenance. This part of LLVM‚Äôs semantics is a bit of an ongoing trashfire; see <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">Ralf Jung‚Äôs post</a> for an introduction to this problem.</p> <h3 id="intrinsics"><a href="#intrinsics">Intrinsics</a></h3> <p>There is also a vast collection of LLVM intrinsics, which are specified in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>. For example, if we need a particular built-in memcpy, we can bring it into scope with a <code class="language-plaintext highlighter-rouge">declare</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ptr %dst, ptr %src, i64 %len, i1 %volatile</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.memcpy.p0.p0.i64</span><span class="p">(</span><span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>All of the LLVM intrinsics are functions that start with <code class="language-plaintext highlighter-rouge">llvm.</code>; diving into all of them is far beyond what we can do here.</p> <p>I‚Äôm also leaving out discussion of floating point, SIMD, and exception handling, each of which would require their own articles!</p> <h2 id="undefined-behavior"><a href="#undefined-behavior">Undefined Behavior</a></h2> <p>LLVM exists to generate optimized code, and optimizations require that we declare certain machine states ‚Äúimpossible‚Äù, so that we can detect when we can simplify what the programmer has said. This is ‚Äúundefined behavior‚Äù.</p> <p>For example, we‚Äôve already encountered <code class="language-plaintext highlighter-rouge">unreachable</code>, which LLVM assumes cannot be executed. Division by zero and accessing memory out of bounds is also undefined.</p> <p>Most LLVM UB factors through the concept of ‚Äúpoisoned values‚Äù. A poison value can be thought of as ‚Äútaking on every value at once‚Äù, whichever is convenient for the current optimization pass with no respect to any other passes. This also means that if optimizations <em>don‚Äôt</em> detect a use of poison, it is ok from LLVM‚Äôs perspective to give you a garbage value. This is most visible at <code class="language-plaintext highlighter-rouge">-O0</code>, which performs minimal optimization.</p> <p>Using a poison value as a pointer in a <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">store</code>, or <code class="language-plaintext highlighter-rouge">call</code> must be UB, because LLVM can choose it to be a null pointer. It also can‚Äôt be the denominator of a <code class="language-plaintext highlighter-rouge">udiv</code> or similar, because LLVM can choose it to be zero, which is UB. Passing poison into a <code class="language-plaintext highlighter-rouge">br</code> or a <code class="language-plaintext highlighter-rouge">switch</code> is also defined to be UB.</p> <p>LLVM can perform dataflow analysis to try to determine what operations a poisonous value that was used in a UB way came from, and thus assume those operations cannot produce poison. Because all operations (other than <code class="language-plaintext highlighter-rouge">select</code> and <code class="language-plaintext highlighter-rouge">phi</code>) with a poison input produce poison, backwards reasoning allows LLVM to propagate UB forward. This is where so-called ‚Äútime traveling UB‚Äù comes from.</p> <p>Many operations generate poison. For example, in C, signed overflow is UB, so addition lowers to an <code class="language-plaintext highlighter-rouge">add nsw</code> (<code class="language-plaintext highlighter-rouge">nsw</code> stands for no signed wrap). Instead of wrapping on overflow, the instruction produces poison. There is also an unsigned version of the annotation, <code class="language-plaintext highlighter-rouge">nuw</code>.</p> <p>Many other operations have ‚Äúless defined‚Äù versions, which are either generated by optimizations, or inserted directly by the compiler that invokes LLVM when the language rules allow it (see C above). More examples include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">udiv</code> and friends have an <code class="language-plaintext highlighter-rouge">exact</code> annotation, which requires that the division have a zero remainder, else poison.</li> <li><code class="language-plaintext highlighter-rouge">getelementptr</code> has an <code class="language-plaintext highlighter-rouge">inbounds</code> annotation, which produces poison if the access is actually out of bounds. This changes it from a pure arithmetic operation to one more closely matching C‚Äôs pointer arithmetic restrictions. GEP without <code class="language-plaintext highlighter-rouge">inbounds</code> corresponds to Rust‚Äôs <code class="language-plaintext highlighter-rouge">&lt;*mut T&gt;::wrapping_offset()</code> function.</li> <li>Floating point operations marked with <code class="language-plaintext highlighter-rouge">nnan</code> and <code class="language-plaintext highlighter-rouge">ninf</code> will produce poison instead of a NaN or an infinite value, respectively (or when a NaN or infinity is an argument).</li> </ul> <p>Creating poison is <em>not</em> UB; only using it is. This is weaker than the way UB works in most languages; in C, overflow is instantly UB, but in LLVM overflow that is never ‚Äúwitnessed‚Äù is simply ignored. This is a simpler operational semantics for reasoning about the validity of optimizations: UB must often be viewed as a side-effect, because the compiler will generate code that puts the program into a broken state. For example, division by zero will cause a fault in many architectures. This means UB-causing operations cannot always be reordered soundly. Replacing ‚Äúcauses UB‚Äù with ‚Äúproduces poison‚Äù ensures the vast majority of operations are pure and freely reorderable.</p> <h2 id="reading-some-codegen"><a href="#reading-some-codegen">Reading Some Codegen</a></h2> <p>Let‚Äôs go back to our original Rust example!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This is the output, with metadata redacted and some things moved around for readability.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">source_filename</span> <span class="p">=</span> <span class="s">"example.b6eb2c7a6b40b4d2-cgu.0"</span>
<span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"</span>
<span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">"x86_64-unknown-linux-gnu"</span>

<span class="c1">; example::square</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@_ZN7example6square17hb32bcde4463f37c3E</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span>
  <span class="nv">%_2.0</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%_2.1</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span> <span class="nv">%_2.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="k">false</span><span class="p">)</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%panic</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb1</span>

<span class="nl">bb1:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%_2.0</span>

<span class="nl">panic:</span>
  <span class="c1">; core::panicking::panic</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span> <span class="vg">@str.0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="m">33</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span> <span class="vg">@alloc_1368addac7d22933d93af2809439e507</span>
  <span class="p">)</span>
  <span class="k">unreachable</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">)</span> <span class="vg">#1</span>
<span class="k">declare</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span> <span class="vg">#2</span>

<span class="c1">; core::panicking::panic</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span><span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#3</span>

<span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"/app/example.rs"</span> <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">1</span>

<span class="vg">@alloc_1368addac7d22933d93af2809439e507</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="err">ptr</span><span class="p">,</span> <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span> <span class="p">&lt;{</span>
    <span class="err">ptr</span> <span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span><span class="p">,</span>
    <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"\0F\00\00\00\00\00\00\00\02\00\00\00\03\00\00\00"</span>
  <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">8</span>

<span class="vg">@str.0</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">33</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"attempt to multiply with overflow"</span>

<span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#1</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">speculatable</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#2</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#3</span> <span class="p">=</span> <span class="p">{</span> <span class="k">cold</span> <span class="k">noinline</span> <span class="k">noreturn</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The main function is <code class="language-plaintext highlighter-rouge">@_ZN7example6square17hb32bcde4463f37c3E</code>, which is the mangled name of <code class="language-plaintext highlighter-rouge">example::square</code>. Because this code was compiled in debug mode, overflow panics, so we need to generate code for that. The first operation is a <code class="language-plaintext highlighter-rouge">call</code> to the LLVM intrinsic for ‚Äúmultiply and tell us if it overflowed‚Äù. This returns the equivalent of a <code class="language-plaintext highlighter-rouge">(i32, bool)</code>; we extract both value out of it with <code class="language-plaintext highlighter-rouge">extractvalue</code>. We then pass the bool through <code class="language-plaintext highlighter-rouge">@llvm.expect</code>, which is used to tell the optimizer to treat the panicking branch as ‚Äúcold‚Äù. The success branch goes to a return, which returns the product; otherwise, we go to a function that calls <code class="language-plaintext highlighter-rouge">core::panicking::panic()</code> to panic the current thread. This function never returns, so we can terminate the block with an <code class="language-plaintext highlighter-rouge">unreachable</code>.</p> <p>The rest of the file consists of:</p> <ul> <li><code class="language-plaintext highlighter-rouge">declare</code>s for the llvm intrinsics we used.</li> <li>A <code class="language-plaintext highlighter-rouge">declare</code> for <code class="language-plaintext highlighter-rouge">core::panicking::panic</code>. Any external function we call needs to be <code class="language-plaintext highlighter-rouge">declare</code>d. This also gives us a place to hang attributes for the function off of.</li> <li>Global constants for a <code class="language-plaintext highlighter-rouge">core::panic::Location</code> and a panic message.</li> <li>Attributes for the functions above.</li> </ul> <p>This is a good place to mention attributes: LLVM has all kinds of attributes that can be placed on functions (and function calls) to record optimization-relevant information. For example, <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code> is annotated as <code class="language-plaintext highlighter-rouge">willreturn</code>, which means this function will eventually return; this means that, for example, any UB that comes after the function is guaranteed to occur after finite time, so LLVM can conclude that the code is unreachable despite the call to <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code>. The full set of attributes is vast, but the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> documents all of them!</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>LLVM IR is huge, bigger than any individual ISA, because it is intended to capture <em>every</em> interesting operation. It also has a rich annotation language, so passes can record information for future passes to make use of. Its operational semantics attempt to leave enough space for optimizations to occur, while ensuring that multiple sound optimizations in sequence are not unsound (this last part is a work in progress).</p> <p>Being able to read assembly reveals what will happen, exactly, when code is executed, but reading IR, before and after optimization, shows how the compiler is <em>thinking</em> about your code. Using <code class="language-plaintext highlighter-rouge">opt</code> to run individual optimization passes can also help further this understanding (in fact, ‚Äúbisecting on passes‚Äù is a powerful debugging technique in compiler development).</p> <p>I got into compilers by reading LLVM IR. Hopefully this article inspires you to learn more, too!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:numeric-names" role="doc-endnote"> <p>Registers within a function may have a numeric name. They must be defined in order: you must define <code class="language-plaintext highlighter-rouge">%0</code> (either as a register or a label), then <code class="language-plaintext highlighter-rouge">%1</code>, then <code class="language-plaintext highlighter-rouge">%2</code>, etc. These are often used to represent ‚Äútemporary results‚Äù.</p> <p>If a function does not specify names for its parameters, they will be given the names <code class="language-plaintext highlighter-rouge">%0</code>, <code class="language-plaintext highlighter-rouge">%1</code>, etc implicitly, which affect what the first explicit numeric register name you can use is. Similarly, if the function does not start with a label, it will be implicitly be given the next numeric name.</p> <p>This can result in significant confusion, because if we have <code class="language-plaintext highlighter-rouge">define void @foo(i32, i32) { ... }</code>, the arguments will be <code class="language-plaintext highlighter-rouge">%0</code> and <code class="language-plaintext highlighter-rouge">%1</code>, but if we tried to write <code class="language-plaintext highlighter-rouge">%2 = add i32 %0, %1</code>, we would get an extremely confusing parser error, because <code class="language-plaintext highlighter-rouge">%2</code> is already taken as the name of the first block.¬†<a href="#fnref:numeric-names" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:divz" role="doc-endnote"> <p>For some reason, the optimizer can‚Äôt figure out that the <code class="language-plaintext highlighter-rouge">select</code> is redundant? Alive2 (an SMT-solver correctness checker for optimizations) <a href="https://alive2.llvm.org/ce/z/7nLDRe">seems to agree</a> this is a valid optimization.</p> <p><a href="https://github.com/llvm/llvm-project/issues/64240">So I‚Äôve filed a bug.</a> :D¬†<a href="#fnref:divz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:br-on-real-machines" role="doc-endnote"> <p>If you read my assembly article, you‚Äôll recall that there are many branch instructions. On RV, we have <code class="language-plaintext highlighter-rouge">beq</code>, <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">bgt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>. Later on in the compilation process, after the optimizer runs, LLVM will perform <em>instruction selection</em> (isel) to choose the best machine instruction(s) to implement a particular LLVM instruction (or sequence), which is highly context-dependent: for example, we want to fuse an <code class="language-plaintext highlighter-rouge">icmp eq</code> followed by a <code class="language-plaintext highlighter-rouge">br</code> on the result into a <code class="language-plaintext highlighter-rouge">beq</code>.</p> <p>Isel is far outside my wheelhouse, and doing it efficiently and profitably is an active area of academic research.¬†<a href="#fnref:br-on-real-machines" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:frontend-optimization" role="doc-endnote"> <p>Not exactly the same: language frontends like Clang and Rust will perform their own optimizations. For example, I have an <a href="https://github.com/llvm/llvm-project/issues/59484">open bug</a> for LLVM being unable to convert <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> into <code class="language-plaintext highlighter-rouge">&amp;</code> in some cases; this was never noticed, because Clang performs this optimization while lowering from C/C++ to LLVM, but Rust does not do the equivalent optimization.¬†<a href="#fnref:frontend-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:block-args" role="doc-endnote"> <p>A more intuitive model is used in more modern IRs, like MLIR. In MLIR, you cannot use variables defined in other blocks; instead, each block takes a set of <em>arguments</em>, just like a function call. This is equivalent to <code class="language-plaintext highlighter-rouge">phi</code> instructions, except that now instead of selecting which value we want in the target, each predecessor specifies what it wants to send to the target.</p> <p>If we instead treat each block as having ‚Äúarguments‚Äù, we can rewrite it in the following fantasy syntax where register names are scoped to their block.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">;; Not actual LLVM IR! ;;</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">)</span>

<span class="err">loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="nv">%exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">),</span> <span class="nv">%loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><a href="#fnref:block-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:viz" role="doc-endnote"> <p>What does the CFG look like? LLVM contains ‚Äúoptimization‚Äù passes that print the CFG as a file as a <code class="language-plaintext highlighter-rouge">.dot</code> file, which can be rendered with the <code class="language-plaintext highlighter-rouge">dot</code> command. For <code class="language-plaintext highlighter-rouge">@safe_div</code>, we get something like the following.</p> <figure style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/safe_div.svg" alt=""/></p> </figure> <p>This is useful for understanding complex functions. Consider this Rust hex-parsing function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// hex.rs</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">parse_hex</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0u64</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.bytes</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">digit</span> <span class="o">=</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'f'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'F'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'A'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_mul</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_add</span><span class="p">(</span><span class="n">digit</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Then, we can generate our CFG with some shell commands.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>rustc <span class="nt">-O</span> <span class="nt">--crate-type</span> lib <span class="nt">--emit</span> llvm-ir hex.rs
<span class="nv">$ </span>opt <span class="nt">-p</span> dot-cfg <span class="nt">-o</span> /dev/null hex.ll
Writing <span class="s1">'.parse_hex.dot'</span>...
<span class="nv">$ </span>dot <span class="nt">-Tsvg</span> .parse_hex.dot <span class="nt">-o</span> parse_hex.svg</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Shell</div></div></div> <p>The result is this mess.</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex.svg" alt=""/></p> </div> <p>Without optimizations, we get a bigger mess (most optimization passes are various CFG cleanups).</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex_unopt.svg" alt=""/></p> </div> <p>Exercise: try to trace through what each basic block is doing. You will want to open the SVGs in a separate tab to do that. I recommend following the optimized version, since it is much less noisy.</p> <p>Comparing optimized vs. unoptimized is a good way to see how much the compiler does to simplify the stuff the language frontend gives it. At -O0? All allocas. At -O2? No allocas!¬†<a href="#fnref:viz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:typed-pointers" role="doc-endnote"> <p>Once upon a time we had typed pointers, like <code class="language-plaintext highlighter-rouge">i32*</code>. These turned out to generate more problems than they solved, requiring frequent casts in IR in exchange for mediocre type safety. See <a href="https://llvm.org/docs/OpaquePointers.html">https://llvm.org/docs/OpaquePointers.html</a> for a more complete history.¬†<a href="#fnref:typed-pointers" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:sarcasm" role="doc-endnote"> <p>Sarcasm.¬†<a href="#fnref:sarcasm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i2p" role="doc-endnote"> <p>I quietly judge LLVM for having instructions named <code class="language-plaintext highlighter-rouge">inttoptr</code> when <code class="language-plaintext highlighter-rouge">int2ptr</code> just reads so much nicer.¬†<a href="#fnref:i2p" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> <li> <span class="post-meta">2024-12-10</span> / <h6 style="display:inline"><a href="/2024/12/10/json-sucks/">Nobody Gets Fired for Picking JSON, but Maybe They Should?</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2023-08-01 ‚Ä¢ 5263 words ‚Ä¢ 43 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">‚Ä¢</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> ‚Ä¢ <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> ‚Ä¢ <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2023/08/01/llvm-ir/"> A Gentle Introduction to LLVM IR<br/> </a></h1> </div> <div class="post"> <p>The other day, I saw <a href="https://twitter.com/burntsushi5/status/1684204136571478021?s=20">this tweet</a>. In it, Andrew Gallant argues that reaching for LLVM IR, instead of assembly, is a useful tool for someone working on performance. Unfortunately, learning material on LLVM is usually aimed at compiler engineers, not generalist working programmers.</p> <p>Now, <em>I‚Äôm</em> a compiler engineer, so my answer is <em>of course</em> you should know your optimizer‚Äôs IR. But I do think there‚Äôs a legitimate reason to be able to read it, in the same way that being able to read assembly to understand what your processor is doing is a powerful tool. I wrote an <a href="https://mcyoung.xyz//2021/11/29/assembly-1">introduction to assembly</a> over a year ago (still have to finish the followups‚Ä¶ üíÄ), which I recommend reading first.</p> <p>Learning LLVM IR is similar, but it helps you understand what your <em>compiler</em> is doing to create highly optimized code. LLVM IR is very popular, and as such well-documented and reasonably well-specified, to the point that we can just treat it as a slightly weird programming language.</p> <p>In this article, I want to dig into what LLVM IR <em>is</em> and how to read it.</p> <h2 id="whats-llvm-ir"><a href="#whats-llvm-ir">What‚Äôs LLVM IR?</a></h2> <p>‚ÄúLLVM‚Äù is an umbrella name for a number of software components that can be used to build compilers. If you write performance-critical code, you‚Äôve probably heard of it.</p> <p>Its flagship product is Clang, a high-end C/C++/Objective-C compiler. Clang follows the orthodox compiler architecture: a frontend that parses source code into an AST and lowers it into an <em>intermediate representation</em>, an ‚ÄúIR‚Äù; an optimizer (or ‚Äúmiddle-end‚Äù) that transforms IR into better IR, and a backend that converts IR into machine code for a particular platform.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">                               optimizer (opt)
                                    ___
                                   |   v
          .c file  --&gt;  AST  --&gt;  LLVM IR  --&gt;  assembly
                    ^         ^             ^
                 parser    lowering    backend (llc)

         \____________________/  \_____________________/
             Clang Frontend                LLVM</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button"></div></div></div> <p>LLVM often also refers to just the optimizer and backend parts of Clang; this is can be thought of as a compiler for the ‚ÄúLLVM language‚Äù or ‚ÄúLLVM assembly‚Äù. Clang, and other language frontends like Rust, essentially compile to LLVM IR, which LLVM then compiles to machine code.</p> <p>LLVM IR is well documented and‚Ä¶ <em>somewhat</em> stable, which makes it a very good compilation target, since language implementers can re-use the thousands of engineer hours poured into LLVM already. The source of truth for ‚Äúwhat is LLVM IR?‚Äù is the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>.</p> <p>LLVM IR is also binary format (sometimes called ‚Äúbitcode‚Äù), although we will be working exclusively with its text format (which uses the <code class="language-plaintext highlighter-rouge">.ll</code> extension).</p> <p>LLVM-targeting compilers will have debugging flags to make them emit IR instead of their final output. For Clang, this is e.g. <code class="language-plaintext highlighter-rouge">clang++ -S -emit-llvm foo.cc</code>, while for Rust this is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir foo.rs</code>. Godbolt will also respect these options and correctly display LLVM IR output.</p> <h2 id="back-to-basic-blocks"><a href="#back-to-basic-blocks">Back to Basic Blocks</a></h2> <p>LLVM IR can be quite intimidating to read, since it contains much more ancillary information than an assembly dump. Consider this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>If you click on the ‚ÄúGodbolt‚Äù widget, it will take you to a Godbolt that lowers it to LLVM IR. Most of that code is just metadata, but it‚Äôs really intimidating!</p> <p>Starting from compiler output will have a steep difficulty curve, because we have to face the full complexity of LLVM IR. For Rust, this will likely mean encountering exception-handling, which is how panics are implemented, and function attributes that forward Rust‚Äôs guarantees (e.g. non-null pointers) to LLVM.</p> <p>Instead, we‚Äôll start by introducing the basic syntax of LLVM IR, and <em>then</em> we‚Äôll tackle reading compiler output.</p> <h3 id="a-trivial-function"><a href="#a-trivial-function">A Trivial Function</a></h3> <p>The meat of LLVM IR is function definitions, introduced with a <code class="language-plaintext highlighter-rouge">define</code>. There is also <code class="language-plaintext highlighter-rouge">declare</code>, which has exactly the same purpose as a function without a body in C: it brings an external symbol into scope.</p> <p>For example, the following function takes no arguments and returns immediately:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_nothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The return type of the function (<code class="language-plaintext highlighter-rouge">void</code>) immediately follows the <code class="language-plaintext highlighter-rouge">define</code> keyword; the name of the function starts with an <code class="language-plaintext highlighter-rouge">@</code>, which introduces us to the concept of <em>sigils</em>: every user-defined symbol starts with a sigil, indicating what kind of symbol it is. <code class="language-plaintext highlighter-rouge">@</code> is used for global and functions: things you can take the address of (when used as a value, they are always <code class="language-plaintext highlighter-rouge">ptr</code>-typed).</p> <p>The body of a function resembles assembly: a list of labels and instructions. Unlike ordinary assembly, however, there are significant restrictions on the structure of these instructions.</p> <p>In this case, there is only one instruction: a <code class="language-plaintext highlighter-rouge">void</code>-typed return. Unlike most assembly languages, LLVM IR is strongly typed, and requires explicit type annotations almost everywhere.</p> <p>Here is another trivial function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_not_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">unreachable</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function will trigger undefined behavior upon being called: the <code class="language-plaintext highlighter-rouge">unreachable</code> instruction represents a codepath that the compiler can assume is never executed; this is unlike e.g. the unimplemented <code class="language-plaintext highlighter-rouge">ud2</code> instruction in x86, which is guaranteed to issue a fault.</p> <p>This is an important distinction between LLVM IR and an assembly language: some operations are explicitly left undefined to leave room for potential optimizations. For example, LLVM can reason that, because <code class="language-plaintext highlighter-rouge">@do_not_call</code> immediately triggers undefined behavior, all calls to <code class="language-plaintext highlighter-rouge">@do_not_call</code> are also unreachable (and propagate unreachability from there).</p> <h3 id="purely-scalar-code"><a href="#purely-scalar-code">Purely Scalar Code</a></h3> <p>Let‚Äôs start with basic functions that only operate on integers. Consider the following function, that squares a 32-bit integer:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function takes arguments and has multiple instructions.</p> <p>The argument is specified as <code class="language-plaintext highlighter-rouge">i32 %x</code>. Names a <code class="language-plaintext highlighter-rouge">%</code> sigil are sort of like local variables, but with some restrictions that make them more optimization-friendly; as we‚Äôll see later, they‚Äôre not really ‚Äúvariable‚Äù at all. LLVM sometimes calls them <em>registers</em>; in a sense, LLVM IR is assembly for an abstract machine with an infinite number of registers. I‚Äôll be calling <code class="language-plaintext highlighter-rouge">%</code>-prefixed names ‚Äúregisters‚Äù throughout this article.</p> <p><code class="language-plaintext highlighter-rouge">i32</code> is a primitive integer types. All integer types in LLVM are of the form <code class="language-plaintext highlighter-rouge">iN</code>, for any <code class="language-plaintext highlighter-rouge">N</code> (even non-multiples of eight). There are no signed or unsigned types; instead, instructions that care about signedness will specify which semantic they use.</p> <p>The first instruction is a <code class="language-plaintext highlighter-rouge">mul i32</code>, which multiples the two <code class="language-plaintext highlighter-rouge">i32</code> operands together, and returns a value; we assign this to the new register <code class="language-plaintext highlighter-rouge">%1</code><sup id="fnref:numeric-names" role="doc-noteref"><a href="#fn:numeric-names" class="footnote" rel="footnote">1</a></sup>. The next instruction returns this value.</p> <p>The other arithmetic operations have the names you expect: <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">shl</code> (shift left). There are two division and remainder instructions, signed (<code class="language-plaintext highlighter-rouge">sdiv</code>, <code class="language-plaintext highlighter-rouge">srem</code>) and unsigned (<code class="language-plaintext highlighter-rouge">udiv</code>, <code class="language-plaintext highlighter-rouge">urem</code>). There two shift right instructions, again signed (<code class="language-plaintext highlighter-rouge">ashr</code>) and unsigned (<code class="language-plaintext highlighter-rouge">lshr</code>).</p> <blockquote> <p>Exercise for the reader: why are <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">%</code>, and <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> the only operations with signed and unsigned versions?</p> </blockquote> <p>We can also convert from one integer type to another using <code class="language-plaintext highlighter-rouge">trunc</code>, <code class="language-plaintext highlighter-rouge">zext</code>, and <code class="language-plaintext highlighter-rouge">sext</code>, which truncate, zero-extend, and sign-extend, respectively (<code class="language-plaintext highlighter-rouge">sext</code> and <code class="language-plaintext highlighter-rouge">zext</code> are another signed/unsigned pair). For example, if we wanted the <code class="language-plaintext highlighter-rouge">square</code> function to never overflow, we could write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">sext</span> <span class="kt">i32</span> <span class="nv">%x</span> <span class="k">to</span> <span class="kt">i64</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%1</span><span class="p">,</span> <span class="nv">%1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we cast <code class="language-plaintext highlighter-rouge">%x</code> to <code class="language-plaintext highlighter-rouge">i64</code> by sign-extension (since we‚Äôve decided we‚Äôre squaring signed integers) and then square the result. <code class="language-plaintext highlighter-rouge">trunc</code> and <code class="language-plaintext highlighter-rouge">zext</code> both have the same syntax as <code class="language-plaintext highlighter-rouge">sext</code>.</p> <h3 id="ill-be-back"><a href="#ill-be-back">‚ÄúI‚Äôll Be Back‚Äù</a></h3> <p>Of course, interesting functions have <em>control flow</em>. Suppose we want a safe division function: division by zero is UB, so we need to handle it explicitly. Perhaps something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try doing this using <code class="language-plaintext highlighter-rouge">select</code>, LLVM‚Äôs ‚Äúternary‚Äù operation.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">select</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">-1</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%2</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>However, this has a problem: division by zero is UB<sup id="fnref:divz" role="doc-noteref"><a href="#fn:divz" class="footnote" rel="footnote">2</a></sup>, and <code class="language-plaintext highlighter-rouge">select</code> is not short-circuiting: its semantics are closer to that of <code class="language-plaintext highlighter-rouge">cmov</code> in x86.</p> <p>To compile this correctly, need to use the <code class="language-plaintext highlighter-rouge">br</code> instruction, which represents a general branch operation<sup id="fnref:br-on-real-machines" role="doc-noteref"><a href="#fn:br-on-real-machines" class="footnote" rel="footnote">3</a></sup>. In C terms, a <code class="language-plaintext highlighter-rouge">br i1 %cond, label %a, label %b</code> is equivalent to <code class="language-plaintext highlighter-rouge">if (cond) goto a; else goto b;</code>.</p> <p>This is how we might write that:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%iszero</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%nonzero</span>

<span class="nl">iszero:</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="m">-1</span>

<span class="nl">nonzero:</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function has labels, which are used by the <code class="language-plaintext highlighter-rouge">br</code> instruction as jump targets.</p> <p>In the first block, we do the <code class="language-plaintext highlighter-rouge">d == 0</code> check, implemented by an <code class="language-plaintext highlighter-rouge">icmp eq</code> instruction. This returns an <code class="language-plaintext highlighter-rouge">i1</code> (the type LLVM uses for booleans). We then pass the result into a <code class="language-plaintext highlighter-rouge">br</code> instruction, which jumps to the first label if it‚Äôs zero, otherwise to the second if it isn‚Äôt.</p> <p>The second block is the early-return; it returns the ‚Äúsentinel‚Äù value; the third block is self-explanatory.</p> <p>Each of these blocks is a ‚Äúbasic block‚Äù: a sequence of non-control flow operations, plus an instruction that moves control flow away from the block. These blocks form the control flow graph (CFG) of the function.</p> <p>There are a few other ‚Äúblock terminator‚Äù instructions. The one-argument form of <code class="language-plaintext highlighter-rouge">br</code> takes a single label, and is a simple unconditional <code class="language-plaintext highlighter-rouge">goto</code>. There‚Äôs also <code class="language-plaintext highlighter-rouge">switch</code>, which is similar to a C <code class="language-plaintext highlighter-rouge">switch</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">switch</span> <span class="kt">i32</span> <span class="nv">%value</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%default</span> <span class="p">[</span>
  <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_zero</span>
  <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_one</span><span class="p">,</span>
  <span class="c1">; etc</span>
<span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The type of the <code class="language-plaintext highlighter-rouge">switch</code> must be an integer type. Although you could represent this operation with a chain of <code class="language-plaintext highlighter-rouge">br</code>s, a separate <code class="language-plaintext highlighter-rouge">switch</code> instruction makes it easier for LLVM to generate jump tables.</p> <p><code class="language-plaintext highlighter-rouge">unreachable</code>, which we saw before, is a special terminator that does not trigger control flow per se, but which can terminate a block because reaching it is undefined behavior; it is equivalent to e.g. <code class="language-plaintext highlighter-rouge">std::unreachable()</code> in C++.</p> <blockquote> <h4 id="llvm-deleted-my-code"><a href="#llvm-deleted-my-code">LLVM Deleted My Code!</a></h4> <p>The <code class="language-plaintext highlighter-rouge">unreachable</code> instruction provides a good example of why LLVM uses a basic block CFG: a naive dead code elimination (DCE) optimization pass can be implemented as follows:</p> <ol> <li>Fill a set with every block that ends in <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>For every block, if its terminator references a block in the unreachable set, delete that label from the terminator. For example, if we have <code class="language-plaintext highlighter-rouge">br i1 %c, label %a, label %b</code>, and the unreachable set contains <code class="language-plaintext highlighter-rouge">%a</code>, we can replace this with a <code class="language-plaintext highlighter-rouge">br label %b</code>.</li> <li>If every outgoing edge from a block is deleted in (2), replace the terminator with <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>Delete all blocks in the unreachable set.</li> <li>Repeat from (1) as many times as desired.</li> </ol> <p>Intuitively, <code class="language-plaintext highlighter-rouge">unreachable</code>s bubble <em>upwards</em> in the CFG, dissolving parts of the CFG among them. Other passes can generate <code class="language-plaintext highlighter-rouge">unreachable</code>s to represent UB: interplay between this and DCE results in the ‚Äúthe compiler <em>will</em> delete your code‚Äù outcome from UB.</p> <p>The actual DCE pass is much more complicated, since function calls make it harder to decide if a block is ‚Äúpure‚Äù and thus transparently deletable.</p> </blockquote> <p>But, what if we want to implement something more complicated, like <code class="language-plaintext highlighter-rouge">a / b + 1</code>? This expression needs the intermediate result, so we can‚Äôt use two return statements as before.</p> <p>Working around this is not so straightforward: if we try to assign the same register in different blocks, the IR verifier will complain. This brings us to the concept of static single assignment.</p> <h3 id="phony-phony"><a href="#phony-phony">Phony! Phony!</a></h3> <p>LLVM IR is a <em>static single assignment form</em> (SSA) IR. LLVM was actually started at the turn of the century to create a modern SSA optimizer as an academic project. These days, SSA is extremely fashionable for optimizing imperative code.</p> <p>SSA form means that every register is assigned by at most one instruction per function. Different executions of the same block in the same function may produce different values for particular registers, but we cannot <em>mutate</em> already-assigned registers.</p> <p>In other words:</p> <ol> <li>Every register is guaranteed to be initialized by a single expression.</li> <li>Every register depends only on the values of registers assigned before its definition.</li> </ol> <p>This has many useful properties for writing optimizations: for example, within a basic block, every use of a particular register <code class="language-plaintext highlighter-rouge">%x</code> always refers to the same value, which makes optimizations like <a href="https://en.wikipedia.org/wiki/Value_numbering">global value numbering</a> and constant-folding much simpler to write, since the state of a register throughout a block doesn‚Äôt need to be tracked separately.</p> <p>In SSA, we reinterpret mutation as many <em>versions</em> of a single variable. Thus, we might lower <code class="language-plaintext highlighter-rouge">x += y</code> as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x.1</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%x.0</span><span class="p">,</span> <span class="nv">%y.0</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we‚Äôve used a <code class="language-plaintext highlighter-rouge">var.n</code> convention to indicate which version of a variable a specific register represents (LLVM does not enforce any naming conventions).</p> <p>However, when loops enter the mix, it‚Äôs not clear how to manage versions. The number of registers in a function is static, but the number of loop iterations is dynamic.</p> <p>Concretely, how do we implement this function?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">y</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>  <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>   <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>But there‚Äôs a problem! What are the original definitions of <code class="language-plaintext highlighter-rouge">%r</code> and <code class="language-plaintext highlighter-rouge">%i</code>? The IR verifier will complain that these registers depend directly on themselves, which violates SSA form. What‚Äôs the ‚Äúright‚Äù way to implement this function?</p> <p>One option is to ask LLVM! We‚Äôll implement the function poorly, and let the optimizer clean it up for us.</p> <p>First, let‚Äôs write the function using memory operations, like <code class="language-plaintext highlighter-rouge">load</code>s and <code class="language-plaintext highlighter-rouge">store</code>s, to implement mutation. We can use the <code class="language-plaintext highlighter-rouge">alloca</code> instruction to create statically-sized stack slots; these instructions return a <code class="language-plaintext highlighter-rouge">ptr</code>[^clang-codegen].</p> <blockquote> <h4 id="clang-makes-a-mess-llvm-cleans-it-up"><a href="#clang-makes-a-mess-llvm-cleans-it-up">Clang Makes a Mess, LLVM Cleans It Up</a></h4> <p>Incidentally, this is how Clang and Rust both generate LLVM IR: stack variables are turned into <code class="language-plaintext highlighter-rouge">alloca</code>s and manipulated through loads and stores; temporaries are mostly turned into <code class="language-plaintext highlighter-rouge">%regs</code>s, but the compiler will sometimes emit extra allocas to avoid thinking too hard about needing to create <code class="language-plaintext highlighter-rouge">phi</code> instructions.</p> <p>This is pretty convenient, because it avoids needing to think very hard about SSA form outside of LLVM, and LLVM can trivially eliminate unnecessary allocas. The code I wrote for the codegen of <code class="language-plaintext highlighter-rouge">@pow</code> is very similar to what Rust would send to LLVM (although because we used an iterator, there‚Äôs a lot of extra junk Rust emits that LLVM has to work to eliminate).</p> </blockquote> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">; Create slots for r and the index, and initialize them.</span>
  <span class="c1">; This is equivalent to something like</span>
  <span class="c1">;   int i = 0, r = 1;</span>
  <span class="c1">; in C.</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="c1">; Load the index and check if it equals y.</span>
  <span class="nv">%i.check</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.check</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="c1">; r *= x</span>
  <span class="nv">%r.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.old</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%r.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>

  <span class="c1">; i += 1</span>
  <span class="nv">%i.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.old</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%i.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>

  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="nv">%r.ret</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.ret</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Next, we can pass this into the LLVM optimizer. The command <code class="language-plaintext highlighter-rouge">opt</code>, which is part of the LLVM distribution, runs specific optimizer passes on the IR. In our case, we want <code class="language-plaintext highlighter-rouge">opt -p mem2reg</code>, which runs a single ‚Äúmemory to register‚Äù pass. We can also just run <code class="language-plaintext highlighter-rouge">opt --O2</code> or similar to get similar<sup id="fnref:frontend-optimization" role="doc-noteref"><a href="#fn:frontend-optimization" class="footnote" rel="footnote">4</a></sup> optimizations to the ones <code class="language-plaintext highlighter-rouge">clang -O2</code> runs.</p> <p>This is the result.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; After running through `opt -p mem2reg`</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="nv">%i.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%i.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%r.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%r.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.0</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.0</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">alloca</code>s are gone, but now we‚Äôre faced with a new instruction: <code class="language-plaintext highlighter-rouge">phi</code>. ‚ÄúœÜ node‚Äù is jargon from the original SSA paper; the greek letter œÜ means ‚Äúphoney‚Äù. These instructions select a value from a list based on which basic block we jumped to the block from.</p> <p>For example, <code class="language-plaintext highlighter-rouge">phi i32 [0, %start], [%i.new, %loop]</code> says ‚Äúthis value should be 0 if we came from the <code class="language-plaintext highlighter-rouge">start</code> block; otherwise <code class="language-plaintext highlighter-rouge">%i.new</code> if it came from <code class="language-plaintext highlighter-rouge">%loop</code>‚Äù.</p> <p>Unlike all other instructions, <code class="language-plaintext highlighter-rouge">phi</code> can refer to values that are not defined in all blocks that dominate the current block. This lets us have a dynamic number of versions of a variable! Here‚Äôs what that looks like in a dynamic execution context.</p> <blockquote> <p>A block <code class="language-plaintext highlighter-rouge">%a</code> is said to dominate a block <code class="language-plaintext highlighter-rouge">%b</code> if each of its predecessors is either <code class="language-plaintext highlighter-rouge">%a</code> or a block dominated by <code class="language-plaintext highlighter-rouge">%a</code>. In other words, every path from the first block to <code class="language-plaintext highlighter-rouge">%b</code> passes through <code class="language-plaintext highlighter-rouge">%a</code>. In general instructions can only refer to values defined in previous instructions in the current block or values from blocks that dominate it.</p> </blockquote> <ol> <li> <p><code class="language-plaintext highlighter-rouge">%start</code> directly jumps into <code class="language-plaintext highlighter-rouge">%loop_start</code>. The first block cannot be a jump target, since it cannot have <code class="language-plaintext highlighter-rouge">phi</code> nodes because its predecessors include function‚Äôs callsite.</p> </li> <li> <p>In <code class="language-plaintext highlighter-rouge">%loop_start</code>, since we‚Äôve entered from <code class="language-plaintext highlighter-rouge">%start</code>, <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are selected to be the first versions of the (platonic) <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code> variables, i.e., their initial values; we jump to <code class="language-plaintext highlighter-rouge">%loop</code>.</p> </li> <li> <p>Then, <code class="language-plaintext highlighter-rouge">%loop</code> is dominated by <code class="language-plaintext highlighter-rouge">%loop_start</code> so we can use <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> there directly; these are the <code class="language-plaintext highlighter-rouge">*=</code> and <code class="language-plaintext highlighter-rouge">+=</code> operations. Then we jump back to <code class="language-plaintext highlighter-rouge">%loop_start</code>.</p> </li> <li> <p>Back in <code class="language-plaintext highlighter-rouge">%loop_start</code>, the <code class="language-plaintext highlighter-rouge">phi</code>s now select <code class="language-plaintext highlighter-rouge">%i.new</code> and <code class="language-plaintext highlighter-rouge">%r.new</code>, so now <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are the <em>second</em> versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>. By induction, the nth execution of <code class="language-plaintext highlighter-rouge">%loop_start</code> has the nth versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>.</p> </li> <li> <p>When we finally get sent to <code class="language-plaintext highlighter-rouge">%exit</code>, we can use <code class="language-plaintext highlighter-rouge">%r.0</code> (since <code class="language-plaintext highlighter-rouge">%loop_start</code> dominates <code class="language-plaintext highlighter-rouge">%r.0</code>), which will be the <code class="language-plaintext highlighter-rouge">%y</code>th version of <code class="language-plaintext highlighter-rouge">r</code>; this is our return value.</p> </li> </ol> <p>This is a good place to stop and think about what we‚Äôve done so far. SSA, domination, and <code class="language-plaintext highlighter-rouge">phi</code>s can be hard to wrap your head around, and are not absolutely necessary for reading most IR. However, it is absolutely worth trying to understand, because it captures essential facts about how compilers like to reason about code<sup id="fnref:block-args" role="doc-noteref"><a href="#fn:block-args" class="footnote" rel="footnote">5</a></sup>.</p> <p>With <code class="language-plaintext highlighter-rouge">phi</code> and <code class="language-plaintext highlighter-rouge">br</code>, we can build arbitrarily complicated control flow within a function<sup id="fnref:viz" role="doc-noteref"><a href="#fn:viz" class="footnote" rel="footnote">6</a></sup>.</p> <h2 id="types-and-aggregates"><a href="#types-and-aggregates">Types and Aggregates</a></h2> <p>Now that we have basic scalar functions, let‚Äôs review LLVM‚Äôs type system.</p> <p>We‚Äôve seen <code class="language-plaintext highlighter-rouge">i32</code> and its friends; these are arbitrary-bit-with integers. <code class="language-plaintext highlighter-rouge">i1</code> is special because it is used as the boolean type. LLVM optimizations have been known to generate integer types with non-power-of-two sizes.</p> <p>LLVM also has <code class="language-plaintext highlighter-rouge">float</code> and <code class="language-plaintext highlighter-rouge">double</code>, and some exotic float types like <code class="language-plaintext highlighter-rouge">bfloat</code>; these use their own arithmetic instructions with different options. I‚Äôll pass on them in this explainer; see <code class="language-plaintext highlighter-rouge">fadd</code> and friends in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> for more.</p> <p>We‚Äôve also seen <code class="language-plaintext highlighter-rouge">void</code>, which is only used as a return value, and <code class="language-plaintext highlighter-rouge">ptr</code>, which is an untyped<sup id="fnref:typed-pointers" role="doc-noteref"><a href="#fn:typed-pointers" class="footnote" rel="footnote">7</a></sup> pointer.</p> <p>We‚Äôve also seen the <code class="language-plaintext highlighter-rouge">label</code> pseudo-type, which represents a block label. It does not appear directly at runtime and has limited uses; the <code class="language-plaintext highlighter-rouge">token</code> and <code class="language-plaintext highlighter-rouge">metadata</code> types are similar.</p> <p>Arrays are spelled <code class="language-plaintext highlighter-rouge">[n x T]</code>; the number must be an integer and the type must have a definite size. E.g., <code class="language-plaintext highlighter-rouge">[1024 x i8]</code>. Zero-sized arrays are supported.</p> <p>Structs are spelled <code class="language-plaintext highlighter-rouge">{T1, T2, ...}</code>. E.g., <code class="language-plaintext highlighter-rouge">{i64, ptr}</code> is a Rust slice. Struct fields do not have names and are indexed, instead. The form <code class="language-plaintext highlighter-rouge">&lt;{...}&gt;</code> is a <em>packed</em> struct, which removes inter-field padding. E.g. <code class="language-plaintext highlighter-rouge">#[repr(packed)]</code> compiles down to this.</p> <p>Vectors are like arrays but spelled <code class="language-plaintext highlighter-rouge">&lt;n x T&gt;</code>. These are used to represent types used in SIMD operations. For example, adding two <code class="language-plaintext highlighter-rouge">&lt;4 x i32&gt;</code> would lower to an AVX2 vector add on x86. I will not touch on SIMD stuff beyond this, although at higher optimization levels LLVM will merge scalar operations into vector operations, so you may come across them.</p> <p>Type aliases can be created at file scope with the syntax</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Slice</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This means that <code class="language-plaintext highlighter-rouge">%T</code> can be either a type or a register/label inside of a function, depending on syntactic position.</p> <h3 id="operations-on-aggregates"><a href="#operations-on-aggregates">Operations on Aggregates</a></h3> <p>The <code class="language-plaintext highlighter-rouge">insertvalue</code> and <code class="language-plaintext highlighter-rouge">extractvalue</code> can be used with struct or array types to statically access a field. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%MyStruct</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i32</span><span class="p">,</span> <span class="p">{[</span><span class="m">5</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">],</span> <span class="kt">i64</span><span class="p">}}</span>

<span class="c1">; In Rust-like syntax, this is `let v = s.1.0[4];`</span>
<span class="nv">%v</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><code class="language-plaintext highlighter-rouge">insertvalue</code> is the reverse: it produces a copy of the aggregate with a specific field changed. It <em>does not</em> mutate in-place, because SSA forbids that.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; In Rust-like syntax, this is</span>
<span class="c1">;   let s2 = { let mut s = s; s2.1.1 = 42; s };</span>
<span class="nv">%s2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>There are similar operations called <code class="language-plaintext highlighter-rouge">insertelement</code> and <code class="language-plaintext highlighter-rouge">extractelement</code> work on vectors, but have slightly different syntax and semantics.</p> <p>Finally, there‚Äôs <code class="language-plaintext highlighter-rouge">getelementptr</code>, the ‚Äúpointer arithmetic instruction‚Äù, often abbreviated to GEP. A GEP can be used to calculate an offset pointer into a struct. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="err">ptr</span> <span class="vg">@get_inner_in_array</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%q</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%MyStruct</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="err">ptr</span> <span class="nv">%q</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function takes in a pointer, ostensibly pointing to an array of <code class="language-plaintext highlighter-rouge">%MyStruct</code>s, and an index. This returns a pointer to the <code class="language-plaintext highlighter-rouge">i64</code> field of the <code class="language-plaintext highlighter-rouge">%idx</code>th element of <code class="language-plaintext highlighter-rouge">%p</code>.</p> <p>A few important differences between GEP and <code class="language-plaintext highlighter-rouge">extractvalue</code>:</p> <ol> <li>It takes an untyped pointer instead of a value of a particular struct/array type.</li> <li>There is an extra parameter that specifies an index; from the perspective of GEP, every pointer is a pointer to an array of unspecified bound. When operating on a pointer that does not (at runtime) point to an array, an index operand of <code class="language-plaintext highlighter-rouge">0</code> is still required. (Alternatively, you can view a pointer to <code class="language-plaintext highlighter-rouge">T</code> as being a pointer to a one-element array.)</li> <li>The index parameters need explicit types.</li> </ol> <p>LLVM provides a helpful<sup id="fnref:sarcasm" role="doc-noteref"><a href="#fn:sarcasm" class="footnote" rel="footnote">8</a></sup> FAQ on the GEP instruction: <a href="https://llvm.org/docs/GetElementPtr.html">https://llvm.org/docs/GetElementPtr.html</a>.</p> <h2 id="other-operations"><a href="#other-operations">Other Operations</a></h2> <p>Some other operations are very relevant for reading IR, but don‚Äôt fit into any specific category. As always, the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> provides a full description of what all of these instructions do.</p> <h3 id="function-calls"><a href="#function-calls">Function Calls</a></h3> <p><code class="language-plaintext highlighter-rouge">call</code>, which calls any <code class="language-plaintext highlighter-rouge">ptr</code> as a function. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; Arguments are passed in parentheses.</span>
<span class="nv">%r</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@my_func</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Note that this could have been a <code class="language-plaintext highlighter-rouge">%reg</code> instead of a <code class="language-plaintext highlighter-rouge">@global</code>, which indicates a function pointer call.</p> <p>Sometimes you will see <code class="language-plaintext highlighter-rouge">invoke</code>, which is used to implement ‚Äúcall a function inside of a C++ <code class="language-plaintext highlighter-rouge">try {}</code> block‚Äù. This is rare in Rust, but can occur in some C++ code.</p> <p>Function calls are often noisy areas of IR, because they will be very heavily annotated.</p> <h3 id="synchronization"><a href="#synchronization">Synchronization</a></h3> <p>The <code class="language-plaintext highlighter-rouge">load</code> and <code class="language-plaintext highlighter-rouge">store</code> instructions we‚Äôve already seen can be annotated as <code class="language-plaintext highlighter-rouge">atomic</code>, which is used to implement e.g. <code class="language-plaintext highlighter-rouge">AtomicU32::load</code> in Rust; this requires that an atomic ordering be specified, too. E.g.,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%v</span> <span class="p">=</span> <span class="k">load</span> <span class="k">atomic</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span> <span class="k">acquire</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">fence</code> operation is a general memory fence operation corresponding to e.g. Rust‚Äôs <code class="language-plaintext highlighter-rouge">std::sync::atomic::fence</code> function.</p> <p><code class="language-plaintext highlighter-rouge">cmpxchg</code> provides the CAS (compare-and-swap) primitive. It returns a <code class="language-plaintext highlighter-rouge">{T, i1}</code> containing the old value and whether the CAS succeeded. <code class="language-plaintext highlighter-rouge">cmpxchg weak</code> implements the spuriously-failing ‚Äúweak CAS‚Äù primitive.</p> <p>Finally, <code class="language-plaintext highlighter-rouge">atomicrmw</code> performs a read-modify-write (e.g., <code class="language-plaintext highlighter-rouge">*p = op(*p, val)</code>) atomically. This is used to implement things like <code class="language-plaintext highlighter-rouge">AtomicU32::fetch_add</code> and friends.</p> <p>All of these operations, except for <code class="language-plaintext highlighter-rouge">fence</code>, can also be marked as <code class="language-plaintext highlighter-rouge">volatile</code>. In LLVM IR, much like in Rust but unlike in C/C++, individual loads and stores are volatile (i.e., have compiler-invisible side-effects). <code class="language-plaintext highlighter-rouge">volatile</code> <em>can</em> be combined with atomic operations (e.g. <code class="language-plaintext highlighter-rouge">load atomic volatile</code>), although most languages don‚Äôt provide access to these (except older C++ versions).</p> <h3 id="reinterpret-shenanigans"><a href="#reinterpret-shenanigans">Reinterpret Shenanigans</a></h3> <p><code class="language-plaintext highlighter-rouge">bitcast</code> is what <code class="language-plaintext highlighter-rouge">mem::transmute</code> and <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> in Rust and C++, respectively, ultimately compile into. It can convert any non-aggregate type (integers, vectors) to any other type of the same bit width. For example, it can be used to get at the bits of a floating-point value:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%bits</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span> <span class="nv">%fp</span> <span class="k">to</span> <span class="kt">i64</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>It also used to be what was used to cast pointer types (e.g. <code class="language-plaintext highlighter-rouge">i32*</code> to <code class="language-plaintext highlighter-rouge">i8*</code>). Pointers are now all untyped (<code class="language-plaintext highlighter-rouge">ptr</code>) so this use is no longer present.</p> <p>However, <code class="language-plaintext highlighter-rouge">bitcast</code> cannot cast between pointer and integer data. For this we must use the <code class="language-plaintext highlighter-rouge">inttoptr</code> and <code class="language-plaintext highlighter-rouge">ptrtoint</code><sup id="fnref:i2p" role="doc-noteref"><a href="#fn:i2p" class="footnote" rel="footnote">9</a></sup> instructions. These have the same syntax, but interact with the sketchy semantics of pointer-to-integer conversion and pointer provenance. This part of LLVM‚Äôs semantics is a bit of an ongoing trashfire; see <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">Ralf Jung‚Äôs post</a> for an introduction to this problem.</p> <h3 id="intrinsics"><a href="#intrinsics">Intrinsics</a></h3> <p>There is also a vast collection of LLVM intrinsics, which are specified in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>. For example, if we need a particular built-in memcpy, we can bring it into scope with a <code class="language-plaintext highlighter-rouge">declare</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ptr %dst, ptr %src, i64 %len, i1 %volatile</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.memcpy.p0.p0.i64</span><span class="p">(</span><span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>All of the LLVM intrinsics are functions that start with <code class="language-plaintext highlighter-rouge">llvm.</code>; diving into all of them is far beyond what we can do here.</p> <p>I‚Äôm also leaving out discussion of floating point, SIMD, and exception handling, each of which would require their own articles!</p> <h2 id="undefined-behavior"><a href="#undefined-behavior">Undefined Behavior</a></h2> <p>LLVM exists to generate optimized code, and optimizations require that we declare certain machine states ‚Äúimpossible‚Äù, so that we can detect when we can simplify what the programmer has said. This is ‚Äúundefined behavior‚Äù.</p> <p>For example, we‚Äôve already encountered <code class="language-plaintext highlighter-rouge">unreachable</code>, which LLVM assumes cannot be executed. Division by zero and accessing memory out of bounds is also undefined.</p> <p>Most LLVM UB factors through the concept of ‚Äúpoisoned values‚Äù. A poison value can be thought of as ‚Äútaking on every value at once‚Äù, whichever is convenient for the current optimization pass with no respect to any other passes. This also means that if optimizations <em>don‚Äôt</em> detect a use of poison, it is ok from LLVM‚Äôs perspective to give you a garbage value. This is most visible at <code class="language-plaintext highlighter-rouge">-O0</code>, which performs minimal optimization.</p> <p>Using a poison value as a pointer in a <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">store</code>, or <code class="language-plaintext highlighter-rouge">call</code> must be UB, because LLVM can choose it to be a null pointer. It also can‚Äôt be the denominator of a <code class="language-plaintext highlighter-rouge">udiv</code> or similar, because LLVM can choose it to be zero, which is UB. Passing poison into a <code class="language-plaintext highlighter-rouge">br</code> or a <code class="language-plaintext highlighter-rouge">switch</code> is also defined to be UB.</p> <p>LLVM can perform dataflow analysis to try to determine what operations a poisonous value that was used in a UB way came from, and thus assume those operations cannot produce poison. Because all operations (other than <code class="language-plaintext highlighter-rouge">select</code> and <code class="language-plaintext highlighter-rouge">phi</code>) with a poison input produce poison, backwards reasoning allows LLVM to propagate UB forward. This is where so-called ‚Äútime traveling UB‚Äù comes from.</p> <p>Many operations generate poison. For example, in C, signed overflow is UB, so addition lowers to an <code class="language-plaintext highlighter-rouge">add nsw</code> (<code class="language-plaintext highlighter-rouge">nsw</code> stands for no signed wrap). Instead of wrapping on overflow, the instruction produces poison. There is also an unsigned version of the annotation, <code class="language-plaintext highlighter-rouge">nuw</code>.</p> <p>Many other operations have ‚Äúless defined‚Äù versions, which are either generated by optimizations, or inserted directly by the compiler that invokes LLVM when the language rules allow it (see C above). More examples include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">udiv</code> and friends have an <code class="language-plaintext highlighter-rouge">exact</code> annotation, which requires that the division have a zero remainder, else poison.</li> <li><code class="language-plaintext highlighter-rouge">getelementptr</code> has an <code class="language-plaintext highlighter-rouge">inbounds</code> annotation, which produces poison if the access is actually out of bounds. This changes it from a pure arithmetic operation to one more closely matching C‚Äôs pointer arithmetic restrictions. GEP without <code class="language-plaintext highlighter-rouge">inbounds</code> corresponds to Rust‚Äôs <code class="language-plaintext highlighter-rouge">&lt;*mut T&gt;::wrapping_offset()</code> function.</li> <li>Floating point operations marked with <code class="language-plaintext highlighter-rouge">nnan</code> and <code class="language-plaintext highlighter-rouge">ninf</code> will produce poison instead of a NaN or an infinite value, respectively (or when a NaN or infinity is an argument).</li> </ul> <p>Creating poison is <em>not</em> UB; only using it is. This is weaker than the way UB works in most languages; in C, overflow is instantly UB, but in LLVM overflow that is never ‚Äúwitnessed‚Äù is simply ignored. This is a simpler operational semantics for reasoning about the validity of optimizations: UB must often be viewed as a side-effect, because the compiler will generate code that puts the program into a broken state. For example, division by zero will cause a fault in many architectures. This means UB-causing operations cannot always be reordered soundly. Replacing ‚Äúcauses UB‚Äù with ‚Äúproduces poison‚Äù ensures the vast majority of operations are pure and freely reorderable.</p> <h2 id="reading-some-codegen"><a href="#reading-some-codegen">Reading Some Codegen</a></h2> <p>Let‚Äôs go back to our original Rust example!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This is the output, with metadata redacted and some things moved around for readability.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">source_filename</span> <span class="p">=</span> <span class="s">"example.b6eb2c7a6b40b4d2-cgu.0"</span>
<span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"</span>
<span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">"x86_64-unknown-linux-gnu"</span>

<span class="c1">; example::square</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@_ZN7example6square17hb32bcde4463f37c3E</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span>
  <span class="nv">%_2.0</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%_2.1</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span> <span class="nv">%_2.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="k">false</span><span class="p">)</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%panic</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb1</span>

<span class="nl">bb1:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%_2.0</span>

<span class="nl">panic:</span>
  <span class="c1">; core::panicking::panic</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span> <span class="vg">@str.0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="m">33</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span> <span class="vg">@alloc_1368addac7d22933d93af2809439e507</span>
  <span class="p">)</span>
  <span class="k">unreachable</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">)</span> <span class="vg">#1</span>
<span class="k">declare</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span> <span class="vg">#2</span>

<span class="c1">; core::panicking::panic</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span><span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#3</span>

<span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"/app/example.rs"</span> <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">1</span>

<span class="vg">@alloc_1368addac7d22933d93af2809439e507</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="err">ptr</span><span class="p">,</span> <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span> <span class="p">&lt;{</span>
    <span class="err">ptr</span> <span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span><span class="p">,</span>
    <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"\0F\00\00\00\00\00\00\00\02\00\00\00\03\00\00\00"</span>
  <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">8</span>

<span class="vg">@str.0</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">33</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"attempt to multiply with overflow"</span>

<span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#1</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">speculatable</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#2</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#3</span> <span class="p">=</span> <span class="p">{</span> <span class="k">cold</span> <span class="k">noinline</span> <span class="k">noreturn</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The main function is <code class="language-plaintext highlighter-rouge">@_ZN7example6square17hb32bcde4463f37c3E</code>, which is the mangled name of <code class="language-plaintext highlighter-rouge">example::square</code>. Because this code was compiled in debug mode, overflow panics, so we need to generate code for that. The first operation is a <code class="language-plaintext highlighter-rouge">call</code> to the LLVM intrinsic for ‚Äúmultiply and tell us if it overflowed‚Äù. This returns the equivalent of a <code class="language-plaintext highlighter-rouge">(i32, bool)</code>; we extract both value out of it with <code class="language-plaintext highlighter-rouge">extractvalue</code>. We then pass the bool through <code class="language-plaintext highlighter-rouge">@llvm.expect</code>, which is used to tell the optimizer to treat the panicking branch as ‚Äúcold‚Äù. The success branch goes to a return, which returns the product; otherwise, we go to a function that calls <code class="language-plaintext highlighter-rouge">core::panicking::panic()</code> to panic the current thread. This function never returns, so we can terminate the block with an <code class="language-plaintext highlighter-rouge">unreachable</code>.</p> <p>The rest of the file consists of:</p> <ul> <li><code class="language-plaintext highlighter-rouge">declare</code>s for the llvm intrinsics we used.</li> <li>A <code class="language-plaintext highlighter-rouge">declare</code> for <code class="language-plaintext highlighter-rouge">core::panicking::panic</code>. Any external function we call needs to be <code class="language-plaintext highlighter-rouge">declare</code>d. This also gives us a place to hang attributes for the function off of.</li> <li>Global constants for a <code class="language-plaintext highlighter-rouge">core::panic::Location</code> and a panic message.</li> <li>Attributes for the functions above.</li> </ul> <p>This is a good place to mention attributes: LLVM has all kinds of attributes that can be placed on functions (and function calls) to record optimization-relevant information. For example, <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code> is annotated as <code class="language-plaintext highlighter-rouge">willreturn</code>, which means this function will eventually return; this means that, for example, any UB that comes after the function is guaranteed to occur after finite time, so LLVM can conclude that the code is unreachable despite the call to <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code>. The full set of attributes is vast, but the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> documents all of them!</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>LLVM IR is huge, bigger than any individual ISA, because it is intended to capture <em>every</em> interesting operation. It also has a rich annotation language, so passes can record information for future passes to make use of. Its operational semantics attempt to leave enough space for optimizations to occur, while ensuring that multiple sound optimizations in sequence are not unsound (this last part is a work in progress).</p> <p>Being able to read assembly reveals what will happen, exactly, when code is executed, but reading IR, before and after optimization, shows how the compiler is <em>thinking</em> about your code. Using <code class="language-plaintext highlighter-rouge">opt</code> to run individual optimization passes can also help further this understanding (in fact, ‚Äúbisecting on passes‚Äù is a powerful debugging technique in compiler development).</p> <p>I got into compilers by reading LLVM IR. Hopefully this article inspires you to learn more, too!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:numeric-names" role="doc-endnote"> <p>Registers within a function may have a numeric name. They must be defined in order: you must define <code class="language-plaintext highlighter-rouge">%0</code> (either as a register or a label), then <code class="language-plaintext highlighter-rouge">%1</code>, then <code class="language-plaintext highlighter-rouge">%2</code>, etc. These are often used to represent ‚Äútemporary results‚Äù.</p> <p>If a function does not specify names for its parameters, they will be given the names <code class="language-plaintext highlighter-rouge">%0</code>, <code class="language-plaintext highlighter-rouge">%1</code>, etc implicitly, which affect what the first explicit numeric register name you can use is. Similarly, if the function does not start with a label, it will be implicitly be given the next numeric name.</p> <p>This can result in significant confusion, because if we have <code class="language-plaintext highlighter-rouge">define void @foo(i32, i32) { ... }</code>, the arguments will be <code class="language-plaintext highlighter-rouge">%0</code> and <code class="language-plaintext highlighter-rouge">%1</code>, but if we tried to write <code class="language-plaintext highlighter-rouge">%2 = add i32 %0, %1</code>, we would get an extremely confusing parser error, because <code class="language-plaintext highlighter-rouge">%2</code> is already taken as the name of the first block.¬†<a href="#fnref:numeric-names" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:divz" role="doc-endnote"> <p>For some reason, the optimizer can‚Äôt figure out that the <code class="language-plaintext highlighter-rouge">select</code> is redundant? Alive2 (an SMT-solver correctness checker for optimizations) <a href="https://alive2.llvm.org/ce/z/7nLDRe">seems to agree</a> this is a valid optimization.</p> <p><a href="https://github.com/llvm/llvm-project/issues/64240">So I‚Äôve filed a bug.</a> :D¬†<a href="#fnref:divz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:br-on-real-machines" role="doc-endnote"> <p>If you read my assembly article, you‚Äôll recall that there are many branch instructions. On RV, we have <code class="language-plaintext highlighter-rouge">beq</code>, <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">bgt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>. Later on in the compilation process, after the optimizer runs, LLVM will perform <em>instruction selection</em> (isel) to choose the best machine instruction(s) to implement a particular LLVM instruction (or sequence), which is highly context-dependent: for example, we want to fuse an <code class="language-plaintext highlighter-rouge">icmp eq</code> followed by a <code class="language-plaintext highlighter-rouge">br</code> on the result into a <code class="language-plaintext highlighter-rouge">beq</code>.</p> <p>Isel is far outside my wheelhouse, and doing it efficiently and profitably is an active area of academic research.¬†<a href="#fnref:br-on-real-machines" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:frontend-optimization" role="doc-endnote"> <p>Not exactly the same: language frontends like Clang and Rust will perform their own optimizations. For example, I have an <a href="https://github.com/llvm/llvm-project/issues/59484">open bug</a> for LLVM being unable to convert <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> into <code class="language-plaintext highlighter-rouge">&amp;</code> in some cases; this was never noticed, because Clang performs this optimization while lowering from C/C++ to LLVM, but Rust does not do the equivalent optimization.¬†<a href="#fnref:frontend-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:block-args" role="doc-endnote"> <p>A more intuitive model is used in more modern IRs, like MLIR. In MLIR, you cannot use variables defined in other blocks; instead, each block takes a set of <em>arguments</em>, just like a function call. This is equivalent to <code class="language-plaintext highlighter-rouge">phi</code> instructions, except that now instead of selecting which value we want in the target, each predecessor specifies what it wants to send to the target.</p> <p>If we instead treat each block as having ‚Äúarguments‚Äù, we can rewrite it in the following fantasy syntax where register names are scoped to their block.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">;; Not actual LLVM IR! ;;</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">)</span>

<span class="err">loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="nv">%exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">),</span> <span class="nv">%loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><a href="#fnref:block-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:viz" role="doc-endnote"> <p>What does the CFG look like? LLVM contains ‚Äúoptimization‚Äù passes that print the CFG as a file as a <code class="language-plaintext highlighter-rouge">.dot</code> file, which can be rendered with the <code class="language-plaintext highlighter-rouge">dot</code> command. For <code class="language-plaintext highlighter-rouge">@safe_div</code>, we get something like the following.</p> <figure style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/safe_div.svg" alt=""/></p> </figure> <p>This is useful for understanding complex functions. Consider this Rust hex-parsing function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// hex.rs</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">parse_hex</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0u64</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.bytes</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">digit</span> <span class="o">=</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'f'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'F'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'A'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_mul</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_add</span><span class="p">(</span><span class="n">digit</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Then, we can generate our CFG with some shell commands.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>rustc <span class="nt">-O</span> <span class="nt">--crate-type</span> lib <span class="nt">--emit</span> llvm-ir hex.rs
<span class="nv">$ </span>opt <span class="nt">-p</span> dot-cfg <span class="nt">-o</span> /dev/null hex.ll
Writing <span class="s1">'.parse_hex.dot'</span>...
<span class="nv">$ </span>dot <span class="nt">-Tsvg</span> .parse_hex.dot <span class="nt">-o</span> parse_hex.svg</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Shell</div></div></div> <p>The result is this mess.</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex.svg" alt=""/></p> </div> <p>Without optimizations, we get a bigger mess (most optimization passes are various CFG cleanups).</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex_unopt.svg" alt=""/></p> </div> <p>Exercise: try to trace through what each basic block is doing. You will want to open the SVGs in a separate tab to do that. I recommend following the optimized version, since it is much less noisy.</p> <p>Comparing optimized vs. unoptimized is a good way to see how much the compiler does to simplify the stuff the language frontend gives it. At -O0? All allocas. At -O2? No allocas!¬†<a href="#fnref:viz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:typed-pointers" role="doc-endnote"> <p>Once upon a time we had typed pointers, like <code class="language-plaintext highlighter-rouge">i32*</code>. These turned out to generate more problems than they solved, requiring frequent casts in IR in exchange for mediocre type safety. See <a href="https://llvm.org/docs/OpaquePointers.html">https://llvm.org/docs/OpaquePointers.html</a> for a more complete history.¬†<a href="#fnref:typed-pointers" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:sarcasm" role="doc-endnote"> <p>Sarcasm.¬†<a href="#fnref:sarcasm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i2p" role="doc-endnote"> <p>I quietly judge LLVM for having instructions named <code class="language-plaintext highlighter-rouge">inttoptr</code> when <code class="language-plaintext highlighter-rouge">int2ptr</code> just reads so much nicer.¬†<a href="#fnref:i2p" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> <li> <span class="post-meta">2024-12-10</span> / <h6 style="display:inline"><a href="/2024/12/10/json-sucks/">Nobody Gets Fired for Picking JSON, but Maybe They Should?</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> ‚Ä¢ <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>