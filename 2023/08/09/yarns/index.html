<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> I Wrote A String Type &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="I Wrote A String Type &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/yarns-cf3a9d1c27dded926f781e030067666be9a1b045.png"> <meta property="og:title" content="I Wrote A String Type &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/yarns-cf3a9d1c27dded926f781e030067666be9a1b045.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2023/08/09/yarns/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz/posts"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/posts"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2023-08-09 • 2854 words • 15 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/08/09/yarns/"> I Wrote A String Type<br/> </a></h1> </div> <div class="post"> <p>I write compilers for fun. I can’t help it. Consequently, I also write a lot of parsers. In systems programming, it’s usually a good idea to try to share memory rather than reuse it, so as such my AST types tend to look like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">enum</span> <span class="n">Expr</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">Int</span><span class="p">(</span><span class="nb">u32</span><span class="p">)</span>
  <span class="nf">Ident</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'src</span> <span class="nb">str</span><span class="p">),</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Whenever we parse an identifier, rather than copy its name into a fresh <code class="language-plaintext highlighter-rouge">String</code>, we borrow from the input source string. This avoids an extra allocation, an extra copy, and saves a word in the representation. Compilers can be memory-hungry, so it helps to pick a lean representation.</p> <p>Unfortunately, it’s not so easy for quoted strings. Most strings, like <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code>, are “literally” in the original source, like an identifier. But strings with escapes aren’t: <code class="language-plaintext highlighter-rouge">\n</code> is encoded in the source code with the bytes <code class="language-plaintext highlighter-rouge">[0x5c, 0x6e]</code>, but the actual “decoded” value of a string literal replaces each escape with a single <code class="language-plaintext highlighter-rouge">0x0a</code>.</p> <p>The usual solution is a <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code></a>. In the more common, escape-less verison, we can use <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code>, which avoids the extra allocation and copy, and in the escaped version, we decode the escapes into a <code class="language-plaintext highlighter-rouge">String</code> and wrap it in a <code class="language-plaintext highlighter-rouge">Cow::Owned</code>.</p> <p>For example, suppose that we’re writing a parser for a language that has quoted strings with escapes. The string <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code> can be represented as a byte string that borrows the input source code, so we’d use the <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code> variant. This is most strings in any language: escapes tend to be rare.</p> <p>For example, if we have the string <code class="language-plaintext highlighter-rouge">"not UTF-8 \xff"</code>, the actual byte string value is different from that in the source code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">// Bytes in the source.
hex:   6e 6f 74 20 55 54 46 2d 38 20 5c 78 66 66
ascii: n  o  t     U  T  F  -  8     \  x  f  f

// Bytes represented by the string.
hex:   6e 6f 74 20 55 54 46 2d 38 20 ff
ascii: n  o  t     U  T  F  -  8</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Escapes are relatively rare, so most strings processed by the parser do not need to pay for an allocation.</p> <p>However, we still pay for that extra word, since <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> is 24 bytes (unless otherwise specified, all byte counts assume a 64-bit system), which is eight more than our <code class="language-plaintext highlighter-rouge">&amp;str</code>. Even worse, this is bigger than the string data itself, which is 11 bytes.</p> <p>If most of your strings are small (which is not uncommon in an AST parser), you will wind up paying for significant overhead.</p> <p>Over the years I’ve implemented various optimized string types to deal with this use-case, in various contexts. I finally got around to putting all of the tricks I know into a library, which I call <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a>. It advertises the following nice properties.</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>I’d like to share how these properties are achieved through careful layout optimization.</p> <h2 id="assumptions"><a href="#assumptions">Assumptions</a></h2> <p>We’re going to start by stating assumptions about how our strings will be used:</p> <ol> <li>Most strings are not mutated most of the time.</li> <li>Most strings are small.</li> <li>Most strings are substrings.</li> </ol> <h3 id="most-strings-are-immutable"><a href="#most-strings-are-immutable">Most Strings are Immutable</a></h3> <p><code class="language-plaintext highlighter-rouge">String</code> is modeled after C++’s <code class="language-plaintext highlighter-rouge">std::string</code>, which is a growable buffer that implements amortized linear-time append. This means that if we are appending <code class="language-plaintext highlighter-rouge">n</code> bytes to the buffer, we only pay for <code class="language-plaintext highlighter-rouge">n</code> bytes of <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>This is a useful but often unnecessary property. For example, Go strings are immutable, and when building up a large string, you are expected to use <code class="language-plaintext highlighter-rouge">strings.Builder</code>, which is implemented as essentially a Rust <code class="language-plaintext highlighter-rouge">String</code>. Java also as a similar story for strings, which allows for highly compact representations of <code class="language-plaintext highlighter-rouge">java.lang.String</code>s.</p> <p>In Rust, this kind of immutable string is represented by a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>, which is eight bytes smaller than <code class="language-plaintext highlighter-rouge">String</code>. Converting from <code class="language-plaintext highlighter-rouge">String</code> to <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is just a call to <code class="language-plaintext highlighter-rouge">realloc()</code> to resize the underlying allocation (which is often cheap<sup id="fnref:size-classes" role="doc-noteref"><a href="#fn:size-classes" class="footnote" rel="footnote">1</a></sup>) from being <code class="language-plaintext highlighter-rouge">capacity</code> bytes long to <code class="language-plaintext highlighter-rouge">len</code> bytes long.</p> <p>Thus, this assumption means we only need to store a pointer and a length, which puts our memory footprint floor at 16 bytes.</p> <h3 id="most-strings-are-substrings"><a href="#most-strings-are-substrings">Most Strings are Substrings</a></h3> <p>Suppose again that we’re parsing some textual format. Many structural elements will be verbatim references into the textual input. Not only string literals without escapes, but also identifiers.</p> <p><code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> cannot hold borrowed data, because it will always instruct the allocator to free its pointer when it goes out of scope. <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>, as we saw above, allows us to handle maybe-owned data uniformly, but has a minimum 24 byte overhead. This can’t be made any smaller, because a <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> can contain a 24-byte <code class="language-plaintext highlighter-rouge">String</code> value.</p> <p>But, we don’t want to store a capacity. Can we avoid the extra word of overhead in <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>?</p> <h3 id="most-strings-are-small"><a href="#most-strings-are-small">Most Strings are Small</a></h3> <p>Consider a string that is not a substring but which is small. For example, when parsing a string literal like <code class="language-plaintext highlighter-rouge">"Hello, world!\n"</code>, the trailing <code class="language-plaintext highlighter-rouge">\n</code> (bytes <code class="language-plaintext highlighter-rouge">0x5c 0x6e</code>) must be replaced with a newline byte (<code class="language-plaintext highlighter-rouge">0x0a</code>). This means we must handle a tiny heap allocation, 14 bytes long, that is smaller than a <code class="language-plaintext highlighter-rouge">&amp;str</code> referring to it.</p> <p>This is worse for single character<sup id="fnref:character" role="doc-noteref"><a href="#fn:character" class="footnote" rel="footnote">2</a></sup> strings. The overhead for a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is large.</p> <ul> <li>The <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> struct itself has a pointer field (eight bytes), and a length field (also eight bytes). Spelled out to show all the stored bits, the length is <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0001</code>. That’s a lot of zeroes!</li> <li>The pointer itself points to a heap allocation, which will not be a single byte! Allocators are not in the business of handing out such small pieces of memory. Instead, the allocation is likely costing us another eight bytes!</li> </ul> <p>So, the string <code class="language-plaintext highlighter-rouge">"a"</code>, whose data is just a <em>single byte</em>, instead takes up 24 bytes of memory.</p> <p>It turns out that for really small strings we can avoid the allocation altogether, <em>and</em> make effective use of all those zeroes in the <code class="language-plaintext highlighter-rouge">len</code> field.</p> <h2 id="stealing-bits"><a href="#stealing-bits">Stealing Bits</a></h2> <p>Let’s say we want to stick to a budget of 16 bytes for our <code class="language-plaintext highlighter-rouge">Yarn</code> type. Is there any extra space left for data in a <code class="language-plaintext highlighter-rouge">(*mut u8, usize)</code> pair?</p> <p><em>*cracks Fermi estimation knuckles*</em></p> <p>A <code class="language-plaintext highlighter-rouge">usize</code> is 64 bits, which means that the length of an <code class="language-plaintext highlighter-rouge">&amp;str</code> can be anywhere from zero to 18446744073709551615, or around 18 exabytes. For reference, “hundreds of exabytes” is a reasonable ballpark guess for how much RAM exists in 2023 (consider: 4 billion smartphones with 4GB each). More practically, the largest quantity of RAM you can fit in a server blade is measured in terabytes (much more than your measly eight DIMs on your gaming rig).</p> <p>If we instead use one less bit, 63 bits, this halves the maximum representable memory to nine exabytes. If we take another, it’s now four exabytes. Much more memory than you will ever <em>ever</em> want to stick in a string. <a href="https://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia#Size_of_the_English_Wikipedia_database">Wikpedia asserts</a> that Wikimedia Commons contains around 428 terabytes of media (the articles’ text with history is a measly 10 TB).</p> <p>Ah, but you say you’re programming for a 32-bit machine (today, this likely means either a low-end mobile phone, an embedded micro controller, or WASM).</p> <p>On a 32-bit machine it’s a little bit harrier: Now <code class="language-plaintext highlighter-rouge">usize</code> is 32 bits, for a maximum string size of 4 gigabytes (if you remember the 32-bit era, this limit may sound familiar). “Gigabytes” is an amount of memory that you can actually imagine having in a string.</p> <p>Even then, 1 GB of memory (if we steal two bits) on a 32-bit machine is a lot of data. You can only have four strings that big in a single address space, and every 32-bit allocator in the universe will refuse to serve an allocation of that size. If your strings are comparable in size to the whole address space, you should build your own string type.</p> <p>The upshot is that every <code class="language-plaintext highlighter-rouge">&amp;str</code> contains two bits we can reasonably assume are not used. <em>Free real-estate.</em><sup id="fnref:isize" role="doc-noteref"><a href="#fn:isize" class="footnote" rel="footnote">3</a></sup></p> <h3 id="a-hand-written-niche-optimization"><a href="#a-hand-written-niche-optimization">A Hand-Written Niche Optimization</a></h3> <p>Rust has the concept of <em>niches</em>, or invalid bit-patterns of a particular type, which it uses for automatic layout optimization of <code class="language-plaintext highlighter-rouge">enum</code>s. For example, references cannot be null, so the pointer bit-pattern of <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0000</code> is never used; this bit-pattern is called a “niche”. Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">),</span>
  <span class="n">Second</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>An <code class="language-plaintext highlighter-rouge">enum</code> of this form will not need any “extra” space to store the value that discriminates between the two variants: if a <code class="language-plaintext highlighter-rouge">Foo</code>’s bits are all zero, it’s <code class="language-plaintext highlighter-rouge">Foo::Second</code>; otherwise it’s a <code class="language-plaintext highlighter-rouge">Foo::First</code> and the payload is formed from <code class="language-plaintext highlighter-rouge">Foo</code>’s bit-pattern. This, incidentally, is what makes <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code> a valid representation for a “nullable pinter”.</p> <p>There are more general forms of this: <code class="language-plaintext highlighter-rouge">bool</code> is represented as a single byte, of which two bit are valid; the other 254 potential bit-patterns are niches. In Recent versions of Rust, <code class="language-plaintext highlighter-rouge">RawFd</code> has a niche for the all-ones bit-pattern, since POSIX file descriptors are always non-negative <code class="language-plaintext highlighter-rouge">int</code>s.</p> <p>By stealing two bits off of the length, we have given ourselves four niches, which essentially means we’ll have a hand-written version of something like this <code class="language-plaintext highlighter-rouge">enum</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Yarn</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Second</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Third</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Fourth</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>For reasons that will become clear later, we will specifically steal the <em>high</em> bits of the length, so that to recover the length, we do two shifts<sup id="fnref:two-shifts" role="doc-noteref"><a href="#fn:two-shifts" class="footnote" rel="footnote">4</a></sup> to shift in two high zero bits. Here’s some code that actually implements this for the low level type our string type will be built on.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">,</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the kind back out.</span>
  <span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="k">as</span> <span class="nb">u8</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that I’ve made this type <code class="language-plaintext highlighter-rouge">Copy</code>, and some functions take it by value. This is for two reasons.</p> <ol> <li> <p>There is a type of <code class="language-plaintext highlighter-rouge">Yarn</code> that is itself <code class="language-plaintext highlighter-rouge">Copy</code>, although I’m not covering it in this article.</p> </li> <li> <p>It is a two-word struct, which means that on most architectures it is eligible to be passed in a pair of registers. Passing it by value in the low-level code helps promote keeping it in registers. This isn’t always possible, as we will see when we discuss “SSO”.</p> </li> </ol> <p>Let’s chose kind <code class="language-plaintext highlighter-rouge">0</code> to mean “this is borrowed data”, and kind <code class="language-plaintext highlighter-rouge">1</code> to be “this is heap-allocated data”. We can use this to remember whether we need to call a destructor.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">raw</span><span class="p">:</span> <span class="n">RawYarn</span><span class="p">,</span>
  <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">BORROWED</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">HEAP</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// SAFETY: initialized either from uniquely-owned data,</span>
      <span class="c1">// or borrowed data of lifetime 'a that outlives self.</span>
      <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_slice</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">HEAP</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">dropped</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
        <span class="c1">// SAFETY: This is just reconstituting the box we dismantled</span>
        <span class="c1">// in Yarn::owned().</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_mut_slice</span><span class="p">())</span>
      <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// Same thing as as_slice, basically. This is just to make</span>
    <span class="c1">// Box::from_raw() above typecheck.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This gives us a type that strongly resembles <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> with only half of the bytes. We can even write code to extend the lifetime of a <code class="language-plaintext highlighter-rouge">Yarn</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Removes the bound lifetime from the yarn, allocating if</span>
  <span class="cd">/// necessary.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">immortalize</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">BORROWED</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.as_slice</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
      <span class="k">self</span> <span class="o">=</span> <span class="nn">Yarn</span><span class="p">::</span><span class="nf">owned</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// We need to be careful that we discard the old yarn, since its</span>
    <span class="c1">// destructor may run and delete the heap allocation we created</span>
    <span class="c1">// above.</span>
    <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">;</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
    <span class="nn">Yarn</span><span class="p">::</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">,</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The remaining two niches can be put to use for optimizing small strings.</p> <h2 id="small-string-optimization"><a href="#small-string-optimization">Small String Optimization</a></h2> <p>C++’s <code class="language-plaintext highlighter-rouge">std::string</code> also makes the “most strings are small” assumption. In the <code class="language-plaintext highlighter-rouge">libc++</code> implementation of the standard library, <code class="language-plaintext highlighter-rouge">std::string</code>s of up to 23 bytes never hit the heap!</p> <p>C++ implementations do this by using most of the pointer, length, and capacity fields as a storage buffer for small strings, the so-called “small string optimization” (SSO). In <code class="language-plaintext highlighter-rouge">libc++</code>, in SSO mode, a <code class="language-plaintext highlighter-rouge">std::string</code>’s length fits in one byte, so the other 23 bytes can be used as storage. The capacity isn’t stored at all: an SSO string always has a capacity of 23.</p> <p><code class="language-plaintext highlighter-rouge">RawYarn</code> still has another two niches, so let’s dedicate one to a “small” representation. In small mode, the kind will be 2, and only the 16th byte will be the length.</p> <p>This is why we used the two <em>high</em> bits of <code class="language-plaintext highlighter-rouge">len</code> for our scratch space: no matter what mode it’s in, we can easily extract these bits<sup id="fnref:big-endian" role="doc-noteref"><a href="#fn:big-endian" class="footnote" rel="footnote">5</a></sup>. Some of the existing <code class="language-plaintext highlighter-rouge">RawYarn</code> methods need to be updated, though.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">SMALL</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">adjust</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">SMALL</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.assume_init</span><span class="p">(),</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">adjust</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In the non-<code class="language-plaintext highlighter-rouge">SMALL</code> case, we shift twice as before, but in the <code class="language-plaintext highlighter-rouge">SMALL</code> case, we need to get the high byte of the <code class="language-plaintext highlighter-rouge">len</code> field, so we need to shift down by an additional <code class="language-plaintext highlighter-rouge">usize::BITS - 8</code>. No matter what we’ve scribbled on the low bytes of <code class="language-plaintext highlighter-rouge">len</code>, we will always get just the length this way.</p> <p>We also need to use a different pointer value depending on whether we’re in <code class="language-plaintext highlighter-rouge">SMALL</code> mode. This is why <code class="language-plaintext highlighter-rouge">as_slice</code> needs to take a reference argument, since the slice data may be <em>directly</em> in <code class="language-plaintext highlighter-rouge">self</code>!</p> <p>Also, <code class="language-plaintext highlighter-rouge">ptr</code> is a <code class="language-plaintext highlighter-rouge">MaybeUninit</code> now, which will become clear in the next code listing.</p> <p>We should also provide a way to construct small strings.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">SSO_LEN</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Create a new small yarn. `data` must be valid for `len` bytes</span>
  <span class="cd">/// and `len` must be smaller than `SSO_LEN`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RawYarn</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span><span class="p">);</span>

    <span class="c1">// Create a yarn with an uninitialized pointer value (!!)</span>
    <span class="c1">// and a length whose high byte is packed with `small` and</span>
    <span class="c1">// `len`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">yarn</span> <span class="o">=</span> <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">(),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">SMALL</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span> <span class="p">|</span> <span class="n">len</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// Memcpy the data to the new yarn.</span>
    <span class="c1">// We write directly onto the `yarn` variable. We won't</span>
    <span class="c1">// overwrite the high-byte length because `len` will</span>
    <span class="c1">// never be &gt;= 16.</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">copy_nonoverlapping</span><span class="p">(</span>
      <span class="n">data</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="k">mut</span> <span class="n">yarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">RawYarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
      <span class="n">data</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="n">yarn</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The precise maximum size of an SSO string is a bit more subtle than what’s given above, but it captures the spirit. The <code class="language-plaintext highlighter-rouge">RawYarn::from_small</code> illustrates why the pointer value is hidden in a <code class="language-plaintext highlighter-rouge">MaybeUninit</code>: we’re above to overwrite it with garbage, and in that case it won’t be a pointer at all.</p> <p>We can update our public <code class="language-plaintext highlighter-rouge">Yarn</code> type to use the new small representation whenever possible.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">())</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>It’s also possible to construct a <code class="language-plaintext highlighter-rouge">Yarn</code> directly from a character now, too!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_char</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.encode_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(Note that we do not need to update <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code>; why?)</p> <p>What we have now is a maybe-owned string that does not require an allocation for small strings. However, we still have an extra niche…</p> <h2 id="string-constants"><a href="#string-constants">String Constants</a></h2> <p>String constants in Rust are interesting, because we can actually detect them at compile-time<sup id="fnref:leaks" role="doc-noteref"><a href="#fn:leaks" class="footnote" rel="footnote">6</a></sup>.</p> <p>We can use the last remaining niche, 3, to represent data that came from a string constant, which means that it does not need to be boxed to be immortalized.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">STATIC</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_static</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">STATIC</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This function is identical to <code class="language-plaintext highlighter-rouge">Yarn::borrowed</code>, except that <code class="language-plaintext highlighter-rouge">data</code> most now have a static lifetime, and we pass <code class="language-plaintext highlighter-rouge">STATIC</code> to <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code>.</p> <p>Because of how we’ve written all of the prior code, this does not require any special support in <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code> or in the low-level <code class="language-plaintext highlighter-rouge">RawYarn</code> code.</p> <p>The actual <code class="language-plaintext highlighter-rouge">byteyarn</code> library provides a <code class="language-plaintext highlighter-rouge">yarn!()</code> macro that has the same syntax as <code class="language-plaintext highlighter-rouge">format!()</code>. This is the primary way in which yarns are created. It is has been carefully written so that <code class="language-plaintext highlighter-rouge">yarn!("this is a literal")</code> always produces a <code class="language-plaintext highlighter-rouge">STATIC</code> string, rather than a heap-allocated string.</p> <h2 id="an-extra-niche-as-a-treat"><a href="#an-extra-niche-as-a-treat">An extra niche, as a treat?</a></h2> <p>Unfortunately, because of how we’ve written it, <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is 24 bytes, a whole word larger than a <code class="language-plaintext highlighter-rouge">Yarn</code>. However, there’s still a little gap where we can fit the <code class="language-plaintext highlighter-rouge">None</code> variant. It turns out that because of how we’ve chosen the discriminants, <code class="language-plaintext highlighter-rouge">len</code> is zero if and only if it is an empty <code class="language-plaintext highlighter-rouge">BORROWED</code> string. But this is not the only zero: if the high byte is <code class="language-plaintext highlighter-rouge">0x80</code>, this is an empty <code class="language-plaintext highlighter-rouge">SMALL</code> string. If we simply require that no other empty string is ever constructed (by marking <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code> as unsafe and specifying it should not be passed a length of zero), we can guarantee that <code class="language-plaintext highlighter-rouge">len</code> is <em>never</em> zero.</p> <p>Thus, we can update <code class="language-plaintext highlighter-rouge">len</code> to be a <code class="language-plaintext highlighter-rouge">NonZeroUsize</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="n">NonZeroUsize</span><span class="p">,</span>  <span class="c1">// (!!)</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a *nonzero* length, and a pointer.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="nn">NonZeroUsize</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
        <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is a type especially known to the Rust compiler to have a niche bit-pattern of all zeros, which allows <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> to be 16 bytes too. This also has the convenient property that the all zeros bit-pattern for <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is <code class="language-plaintext highlighter-rouge">None</code>.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>The <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a> blurb describes what we’ve built:</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>There are, of course, some trade-offs. Not only do we need the assumptions we made originally to hold, but we also need to relatively care more about memory than cycle-count performance, since basic operations like reading the length of the string require more math (but no extra branching).</p> <p>The actual implementation of <code class="language-plaintext highlighter-rouge">Yarn</code> is a bit more complicated, partly to keep all of the low-level book-keeping in one place, and partly to offer an ergonomic API that makes <code class="language-plaintext highlighter-rouge">Yarn</code> into a mostly-drop-in replacement for <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>.</p> <p>I hope this peek under the hood has given you a new appreciation for what can be achieved by clever layout-hacking.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:size-classes" role="doc-endnote"> <p>Allocators rarely serve you memory with precisely the size you asked for. Instead, they will have some notion of a “size class” that allows them to use more efficient allocation techniques, <a href="https://mcyoung.xyz//2022/06/07/alkyne-gc">which I have written about</a>.</p> <p>As a result, if the size change in a <code class="language-plaintext highlighter-rouge">realloc()</code> would not change the size class, it becomes a no-op, especially if the allocator can take advantage of the current-size information Rust provides it. <a href="#fnref:size-classes" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:character" role="doc-endnote"> <p>Here and henceforth “character” means “32-bit Unicode scalar”. <a href="#fnref:character" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:isize" role="doc-endnote"> <p>Now, you might also point out that Rust and C do not allow an allocation whose size is larger than the pointer offset type (<code class="language-plaintext highlighter-rouge">isize</code> and <code class="language-plaintext highlighter-rouge">ptrdiff_t</code>, respectively). In practice this means that the high bit is <em>always</em> zero according to the language’s own rules.</p> <p>This is true, but we need to steal two bits, and I wanted to demonstrate that this is an extremely reasonable desire. 64-bit integers are so comically large. <a href="#fnref:isize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:two-shifts" role="doc-endnote"> <p>Interestingly, LLVM will compile <code class="language-plaintext highlighter-rouge">(x &lt;&lt; 2) &gt;&gt; 2</code> to</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">movabs</span> <span class="n">rax</span><span class="p">,</span><span class="mh">0x3fffffffffffffff</span>
<span class="n">and</span>    <span class="n">rax</span><span class="p">,</span><span class="n">rdi</span>
<span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>If we want to play the byte-for-byte game, this costs 14 bytes when encoded in the Intel variable-length encoding. You would think that two shifts would result in marginally smaller code, but no, since the input comes in in <code class="language-plaintext highlighter-rouge">rdi</code> and needs to wind up in <code class="language-plaintext highlighter-rouge">rax</code>.</p> <p>On RISC-V, though, it seems to decide that two shifts is in fact cheaper, and will even optimize <code class="language-plaintext highlighter-rouge">x &amp; 0x3fff_ffff_ffff_ffff</code> back into two shifts. <a href="#fnref:two-shifts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:big-endian" role="doc-endnote"> <p>This only works on little endian. Thankfully all computers are little endian. <a href="#fnref:big-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:leaks" role="doc-endnote"> <p>Technically, a <code class="language-plaintext highlighter-rouge">&amp;'static str</code> may also point to leaked memory. For our purposes, there is no essential difference. <a href="#fnref:leaks" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-01</span> / <h6 style="display:inline"><a href="/2023/08/01/llvm-ir/">A Gentle Introduction to LLVM IR </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2023-08-09 • 2854 words • 15 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/08/09/yarns/"> I Wrote A String Type<br/> </a></h1> </div> <div class="post"> <p>I write compilers for fun. I can’t help it. Consequently, I also write a lot of parsers. In systems programming, it’s usually a good idea to try to share memory rather than reuse it, so as such my AST types tend to look like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">enum</span> <span class="n">Expr</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">Int</span><span class="p">(</span><span class="nb">u32</span><span class="p">)</span>
  <span class="nf">Ident</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'src</span> <span class="nb">str</span><span class="p">),</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Whenever we parse an identifier, rather than copy its name into a fresh <code class="language-plaintext highlighter-rouge">String</code>, we borrow from the input source string. This avoids an extra allocation, an extra copy, and saves a word in the representation. Compilers can be memory-hungry, so it helps to pick a lean representation.</p> <p>Unfortunately, it’s not so easy for quoted strings. Most strings, like <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code>, are “literally” in the original source, like an identifier. But strings with escapes aren’t: <code class="language-plaintext highlighter-rouge">\n</code> is encoded in the source code with the bytes <code class="language-plaintext highlighter-rouge">[0x5c, 0x6e]</code>, but the actual “decoded” value of a string literal replaces each escape with a single <code class="language-plaintext highlighter-rouge">0x0a</code>.</p> <p>The usual solution is a <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code></a>. In the more common, escape-less verison, we can use <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code>, which avoids the extra allocation and copy, and in the escaped version, we decode the escapes into a <code class="language-plaintext highlighter-rouge">String</code> and wrap it in a <code class="language-plaintext highlighter-rouge">Cow::Owned</code>.</p> <p>For example, suppose that we’re writing a parser for a language that has quoted strings with escapes. The string <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code> can be represented as a byte string that borrows the input source code, so we’d use the <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code> variant. This is most strings in any language: escapes tend to be rare.</p> <p>For example, if we have the string <code class="language-plaintext highlighter-rouge">"not UTF-8 \xff"</code>, the actual byte string value is different from that in the source code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">// Bytes in the source.
hex:   6e 6f 74 20 55 54 46 2d 38 20 5c 78 66 66
ascii: n  o  t     U  T  F  -  8     \  x  f  f

// Bytes represented by the string.
hex:   6e 6f 74 20 55 54 46 2d 38 20 ff
ascii: n  o  t     U  T  F  -  8</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Escapes are relatively rare, so most strings processed by the parser do not need to pay for an allocation.</p> <p>However, we still pay for that extra word, since <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> is 24 bytes (unless otherwise specified, all byte counts assume a 64-bit system), which is eight more than our <code class="language-plaintext highlighter-rouge">&amp;str</code>. Even worse, this is bigger than the string data itself, which is 11 bytes.</p> <p>If most of your strings are small (which is not uncommon in an AST parser), you will wind up paying for significant overhead.</p> <p>Over the years I’ve implemented various optimized string types to deal with this use-case, in various contexts. I finally got around to putting all of the tricks I know into a library, which I call <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a>. It advertises the following nice properties.</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>I’d like to share how these properties are achieved through careful layout optimization.</p> <h2 id="assumptions"><a href="#assumptions">Assumptions</a></h2> <p>We’re going to start by stating assumptions about how our strings will be used:</p> <ol> <li>Most strings are not mutated most of the time.</li> <li>Most strings are small.</li> <li>Most strings are substrings.</li> </ol> <h3 id="most-strings-are-immutable"><a href="#most-strings-are-immutable">Most Strings are Immutable</a></h3> <p><code class="language-plaintext highlighter-rouge">String</code> is modeled after C++’s <code class="language-plaintext highlighter-rouge">std::string</code>, which is a growable buffer that implements amortized linear-time append. This means that if we are appending <code class="language-plaintext highlighter-rouge">n</code> bytes to the buffer, we only pay for <code class="language-plaintext highlighter-rouge">n</code> bytes of <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>This is a useful but often unnecessary property. For example, Go strings are immutable, and when building up a large string, you are expected to use <code class="language-plaintext highlighter-rouge">strings.Builder</code>, which is implemented as essentially a Rust <code class="language-plaintext highlighter-rouge">String</code>. Java also as a similar story for strings, which allows for highly compact representations of <code class="language-plaintext highlighter-rouge">java.lang.String</code>s.</p> <p>In Rust, this kind of immutable string is represented by a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>, which is eight bytes smaller than <code class="language-plaintext highlighter-rouge">String</code>. Converting from <code class="language-plaintext highlighter-rouge">String</code> to <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is just a call to <code class="language-plaintext highlighter-rouge">realloc()</code> to resize the underlying allocation (which is often cheap<sup id="fnref:size-classes" role="doc-noteref"><a href="#fn:size-classes" class="footnote" rel="footnote">1</a></sup>) from being <code class="language-plaintext highlighter-rouge">capacity</code> bytes long to <code class="language-plaintext highlighter-rouge">len</code> bytes long.</p> <p>Thus, this assumption means we only need to store a pointer and a length, which puts our memory footprint floor at 16 bytes.</p> <h3 id="most-strings-are-substrings"><a href="#most-strings-are-substrings">Most Strings are Substrings</a></h3> <p>Suppose again that we’re parsing some textual format. Many structural elements will be verbatim references into the textual input. Not only string literals without escapes, but also identifiers.</p> <p><code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> cannot hold borrowed data, because it will always instruct the allocator to free its pointer when it goes out of scope. <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>, as we saw above, allows us to handle maybe-owned data uniformly, but has a minimum 24 byte overhead. This can’t be made any smaller, because a <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> can contain a 24-byte <code class="language-plaintext highlighter-rouge">String</code> value.</p> <p>But, we don’t want to store a capacity. Can we avoid the extra word of overhead in <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>?</p> <h3 id="most-strings-are-small"><a href="#most-strings-are-small">Most Strings are Small</a></h3> <p>Consider a string that is not a substring but which is small. For example, when parsing a string literal like <code class="language-plaintext highlighter-rouge">"Hello, world!\n"</code>, the trailing <code class="language-plaintext highlighter-rouge">\n</code> (bytes <code class="language-plaintext highlighter-rouge">0x5c 0x6e</code>) must be replaced with a newline byte (<code class="language-plaintext highlighter-rouge">0x0a</code>). This means we must handle a tiny heap allocation, 14 bytes long, that is smaller than a <code class="language-plaintext highlighter-rouge">&amp;str</code> referring to it.</p> <p>This is worse for single character<sup id="fnref:character" role="doc-noteref"><a href="#fn:character" class="footnote" rel="footnote">2</a></sup> strings. The overhead for a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is large.</p> <ul> <li>The <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> struct itself has a pointer field (eight bytes), and a length field (also eight bytes). Spelled out to show all the stored bits, the length is <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0001</code>. That’s a lot of zeroes!</li> <li>The pointer itself points to a heap allocation, which will not be a single byte! Allocators are not in the business of handing out such small pieces of memory. Instead, the allocation is likely costing us another eight bytes!</li> </ul> <p>So, the string <code class="language-plaintext highlighter-rouge">"a"</code>, whose data is just a <em>single byte</em>, instead takes up 24 bytes of memory.</p> <p>It turns out that for really small strings we can avoid the allocation altogether, <em>and</em> make effective use of all those zeroes in the <code class="language-plaintext highlighter-rouge">len</code> field.</p> <h2 id="stealing-bits"><a href="#stealing-bits">Stealing Bits</a></h2> <p>Let’s say we want to stick to a budget of 16 bytes for our <code class="language-plaintext highlighter-rouge">Yarn</code> type. Is there any extra space left for data in a <code class="language-plaintext highlighter-rouge">(*mut u8, usize)</code> pair?</p> <p><em>*cracks Fermi estimation knuckles*</em></p> <p>A <code class="language-plaintext highlighter-rouge">usize</code> is 64 bits, which means that the length of an <code class="language-plaintext highlighter-rouge">&amp;str</code> can be anywhere from zero to 18446744073709551615, or around 18 exabytes. For reference, “hundreds of exabytes” is a reasonable ballpark guess for how much RAM exists in 2023 (consider: 4 billion smartphones with 4GB each). More practically, the largest quantity of RAM you can fit in a server blade is measured in terabytes (much more than your measly eight DIMs on your gaming rig).</p> <p>If we instead use one less bit, 63 bits, this halves the maximum representable memory to nine exabytes. If we take another, it’s now four exabytes. Much more memory than you will ever <em>ever</em> want to stick in a string. <a href="https://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia#Size_of_the_English_Wikipedia_database">Wikpedia asserts</a> that Wikimedia Commons contains around 428 terabytes of media (the articles’ text with history is a measly 10 TB).</p> <p>Ah, but you say you’re programming for a 32-bit machine (today, this likely means either a low-end mobile phone, an embedded micro controller, or WASM).</p> <p>On a 32-bit machine it’s a little bit harrier: Now <code class="language-plaintext highlighter-rouge">usize</code> is 32 bits, for a maximum string size of 4 gigabytes (if you remember the 32-bit era, this limit may sound familiar). “Gigabytes” is an amount of memory that you can actually imagine having in a string.</p> <p>Even then, 1 GB of memory (if we steal two bits) on a 32-bit machine is a lot of data. You can only have four strings that big in a single address space, and every 32-bit allocator in the universe will refuse to serve an allocation of that size. If your strings are comparable in size to the whole address space, you should build your own string type.</p> <p>The upshot is that every <code class="language-plaintext highlighter-rouge">&amp;str</code> contains two bits we can reasonably assume are not used. <em>Free real-estate.</em><sup id="fnref:isize" role="doc-noteref"><a href="#fn:isize" class="footnote" rel="footnote">3</a></sup></p> <h3 id="a-hand-written-niche-optimization"><a href="#a-hand-written-niche-optimization">A Hand-Written Niche Optimization</a></h3> <p>Rust has the concept of <em>niches</em>, or invalid bit-patterns of a particular type, which it uses for automatic layout optimization of <code class="language-plaintext highlighter-rouge">enum</code>s. For example, references cannot be null, so the pointer bit-pattern of <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0000</code> is never used; this bit-pattern is called a “niche”. Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">),</span>
  <span class="n">Second</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>An <code class="language-plaintext highlighter-rouge">enum</code> of this form will not need any “extra” space to store the value that discriminates between the two variants: if a <code class="language-plaintext highlighter-rouge">Foo</code>’s bits are all zero, it’s <code class="language-plaintext highlighter-rouge">Foo::Second</code>; otherwise it’s a <code class="language-plaintext highlighter-rouge">Foo::First</code> and the payload is formed from <code class="language-plaintext highlighter-rouge">Foo</code>’s bit-pattern. This, incidentally, is what makes <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code> a valid representation for a “nullable pinter”.</p> <p>There are more general forms of this: <code class="language-plaintext highlighter-rouge">bool</code> is represented as a single byte, of which two bit are valid; the other 254 potential bit-patterns are niches. In Recent versions of Rust, <code class="language-plaintext highlighter-rouge">RawFd</code> has a niche for the all-ones bit-pattern, since POSIX file descriptors are always non-negative <code class="language-plaintext highlighter-rouge">int</code>s.</p> <p>By stealing two bits off of the length, we have given ourselves four niches, which essentially means we’ll have a hand-written version of something like this <code class="language-plaintext highlighter-rouge">enum</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Yarn</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Second</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Third</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Fourth</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>For reasons that will become clear later, we will specifically steal the <em>high</em> bits of the length, so that to recover the length, we do two shifts<sup id="fnref:two-shifts" role="doc-noteref"><a href="#fn:two-shifts" class="footnote" rel="footnote">4</a></sup> to shift in two high zero bits. Here’s some code that actually implements this for the low level type our string type will be built on.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">,</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the kind back out.</span>
  <span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="k">as</span> <span class="nb">u8</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that I’ve made this type <code class="language-plaintext highlighter-rouge">Copy</code>, and some functions take it by value. This is for two reasons.</p> <ol> <li> <p>There is a type of <code class="language-plaintext highlighter-rouge">Yarn</code> that is itself <code class="language-plaintext highlighter-rouge">Copy</code>, although I’m not covering it in this article.</p> </li> <li> <p>It is a two-word struct, which means that on most architectures it is eligible to be passed in a pair of registers. Passing it by value in the low-level code helps promote keeping it in registers. This isn’t always possible, as we will see when we discuss “SSO”.</p> </li> </ol> <p>Let’s chose kind <code class="language-plaintext highlighter-rouge">0</code> to mean “this is borrowed data”, and kind <code class="language-plaintext highlighter-rouge">1</code> to be “this is heap-allocated data”. We can use this to remember whether we need to call a destructor.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">raw</span><span class="p">:</span> <span class="n">RawYarn</span><span class="p">,</span>
  <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">BORROWED</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">HEAP</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// SAFETY: initialized either from uniquely-owned data,</span>
      <span class="c1">// or borrowed data of lifetime 'a that outlives self.</span>
      <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_slice</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">HEAP</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">dropped</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
        <span class="c1">// SAFETY: This is just reconstituting the box we dismantled</span>
        <span class="c1">// in Yarn::owned().</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_mut_slice</span><span class="p">())</span>
      <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// Same thing as as_slice, basically. This is just to make</span>
    <span class="c1">// Box::from_raw() above typecheck.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This gives us a type that strongly resembles <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> with only half of the bytes. We can even write code to extend the lifetime of a <code class="language-plaintext highlighter-rouge">Yarn</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Removes the bound lifetime from the yarn, allocating if</span>
  <span class="cd">/// necessary.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">immortalize</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">BORROWED</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.as_slice</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
      <span class="k">self</span> <span class="o">=</span> <span class="nn">Yarn</span><span class="p">::</span><span class="nf">owned</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// We need to be careful that we discard the old yarn, since its</span>
    <span class="c1">// destructor may run and delete the heap allocation we created</span>
    <span class="c1">// above.</span>
    <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">;</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
    <span class="nn">Yarn</span><span class="p">::</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">,</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The remaining two niches can be put to use for optimizing small strings.</p> <h2 id="small-string-optimization"><a href="#small-string-optimization">Small String Optimization</a></h2> <p>C++’s <code class="language-plaintext highlighter-rouge">std::string</code> also makes the “most strings are small” assumption. In the <code class="language-plaintext highlighter-rouge">libc++</code> implementation of the standard library, <code class="language-plaintext highlighter-rouge">std::string</code>s of up to 23 bytes never hit the heap!</p> <p>C++ implementations do this by using most of the pointer, length, and capacity fields as a storage buffer for small strings, the so-called “small string optimization” (SSO). In <code class="language-plaintext highlighter-rouge">libc++</code>, in SSO mode, a <code class="language-plaintext highlighter-rouge">std::string</code>’s length fits in one byte, so the other 23 bytes can be used as storage. The capacity isn’t stored at all: an SSO string always has a capacity of 23.</p> <p><code class="language-plaintext highlighter-rouge">RawYarn</code> still has another two niches, so let’s dedicate one to a “small” representation. In small mode, the kind will be 2, and only the 16th byte will be the length.</p> <p>This is why we used the two <em>high</em> bits of <code class="language-plaintext highlighter-rouge">len</code> for our scratch space: no matter what mode it’s in, we can easily extract these bits<sup id="fnref:big-endian" role="doc-noteref"><a href="#fn:big-endian" class="footnote" rel="footnote">5</a></sup>. Some of the existing <code class="language-plaintext highlighter-rouge">RawYarn</code> methods need to be updated, though.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">SMALL</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">adjust</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">SMALL</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.assume_init</span><span class="p">(),</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">adjust</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In the non-<code class="language-plaintext highlighter-rouge">SMALL</code> case, we shift twice as before, but in the <code class="language-plaintext highlighter-rouge">SMALL</code> case, we need to get the high byte of the <code class="language-plaintext highlighter-rouge">len</code> field, so we need to shift down by an additional <code class="language-plaintext highlighter-rouge">usize::BITS - 8</code>. No matter what we’ve scribbled on the low bytes of <code class="language-plaintext highlighter-rouge">len</code>, we will always get just the length this way.</p> <p>We also need to use a different pointer value depending on whether we’re in <code class="language-plaintext highlighter-rouge">SMALL</code> mode. This is why <code class="language-plaintext highlighter-rouge">as_slice</code> needs to take a reference argument, since the slice data may be <em>directly</em> in <code class="language-plaintext highlighter-rouge">self</code>!</p> <p>Also, <code class="language-plaintext highlighter-rouge">ptr</code> is a <code class="language-plaintext highlighter-rouge">MaybeUninit</code> now, which will become clear in the next code listing.</p> <p>We should also provide a way to construct small strings.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">SSO_LEN</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Create a new small yarn. `data` must be valid for `len` bytes</span>
  <span class="cd">/// and `len` must be smaller than `SSO_LEN`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RawYarn</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span><span class="p">);</span>

    <span class="c1">// Create a yarn with an uninitialized pointer value (!!)</span>
    <span class="c1">// and a length whose high byte is packed with `small` and</span>
    <span class="c1">// `len`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">yarn</span> <span class="o">=</span> <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">(),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">SMALL</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span> <span class="p">|</span> <span class="n">len</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// Memcpy the data to the new yarn.</span>
    <span class="c1">// We write directly onto the `yarn` variable. We won't</span>
    <span class="c1">// overwrite the high-byte length because `len` will</span>
    <span class="c1">// never be &gt;= 16.</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">copy_nonoverlapping</span><span class="p">(</span>
      <span class="n">data</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="k">mut</span> <span class="n">yarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">RawYarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
      <span class="n">data</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="n">yarn</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The precise maximum size of an SSO string is a bit more subtle than what’s given above, but it captures the spirit. The <code class="language-plaintext highlighter-rouge">RawYarn::from_small</code> illustrates why the pointer value is hidden in a <code class="language-plaintext highlighter-rouge">MaybeUninit</code>: we’re above to overwrite it with garbage, and in that case it won’t be a pointer at all.</p> <p>We can update our public <code class="language-plaintext highlighter-rouge">Yarn</code> type to use the new small representation whenever possible.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">())</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>It’s also possible to construct a <code class="language-plaintext highlighter-rouge">Yarn</code> directly from a character now, too!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_char</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.encode_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(Note that we do not need to update <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code>; why?)</p> <p>What we have now is a maybe-owned string that does not require an allocation for small strings. However, we still have an extra niche…</p> <h2 id="string-constants"><a href="#string-constants">String Constants</a></h2> <p>String constants in Rust are interesting, because we can actually detect them at compile-time<sup id="fnref:leaks" role="doc-noteref"><a href="#fn:leaks" class="footnote" rel="footnote">6</a></sup>.</p> <p>We can use the last remaining niche, 3, to represent data that came from a string constant, which means that it does not need to be boxed to be immortalized.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">STATIC</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_static</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">STATIC</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This function is identical to <code class="language-plaintext highlighter-rouge">Yarn::borrowed</code>, except that <code class="language-plaintext highlighter-rouge">data</code> most now have a static lifetime, and we pass <code class="language-plaintext highlighter-rouge">STATIC</code> to <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code>.</p> <p>Because of how we’ve written all of the prior code, this does not require any special support in <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code> or in the low-level <code class="language-plaintext highlighter-rouge">RawYarn</code> code.</p> <p>The actual <code class="language-plaintext highlighter-rouge">byteyarn</code> library provides a <code class="language-plaintext highlighter-rouge">yarn!()</code> macro that has the same syntax as <code class="language-plaintext highlighter-rouge">format!()</code>. This is the primary way in which yarns are created. It is has been carefully written so that <code class="language-plaintext highlighter-rouge">yarn!("this is a literal")</code> always produces a <code class="language-plaintext highlighter-rouge">STATIC</code> string, rather than a heap-allocated string.</p> <h2 id="an-extra-niche-as-a-treat"><a href="#an-extra-niche-as-a-treat">An extra niche, as a treat?</a></h2> <p>Unfortunately, because of how we’ve written it, <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is 24 bytes, a whole word larger than a <code class="language-plaintext highlighter-rouge">Yarn</code>. However, there’s still a little gap where we can fit the <code class="language-plaintext highlighter-rouge">None</code> variant. It turns out that because of how we’ve chosen the discriminants, <code class="language-plaintext highlighter-rouge">len</code> is zero if and only if it is an empty <code class="language-plaintext highlighter-rouge">BORROWED</code> string. But this is not the only zero: if the high byte is <code class="language-plaintext highlighter-rouge">0x80</code>, this is an empty <code class="language-plaintext highlighter-rouge">SMALL</code> string. If we simply require that no other empty string is ever constructed (by marking <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code> as unsafe and specifying it should not be passed a length of zero), we can guarantee that <code class="language-plaintext highlighter-rouge">len</code> is <em>never</em> zero.</p> <p>Thus, we can update <code class="language-plaintext highlighter-rouge">len</code> to be a <code class="language-plaintext highlighter-rouge">NonZeroUsize</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="n">NonZeroUsize</span><span class="p">,</span>  <span class="c1">// (!!)</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a *nonzero* length, and a pointer.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="nn">NonZeroUsize</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
        <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is a type especially known to the Rust compiler to have a niche bit-pattern of all zeros, which allows <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> to be 16 bytes too. This also has the convenient property that the all zeros bit-pattern for <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is <code class="language-plaintext highlighter-rouge">None</code>.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>The <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a> blurb describes what we’ve built:</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>There are, of course, some trade-offs. Not only do we need the assumptions we made originally to hold, but we also need to relatively care more about memory than cycle-count performance, since basic operations like reading the length of the string require more math (but no extra branching).</p> <p>The actual implementation of <code class="language-plaintext highlighter-rouge">Yarn</code> is a bit more complicated, partly to keep all of the low-level book-keeping in one place, and partly to offer an ergonomic API that makes <code class="language-plaintext highlighter-rouge">Yarn</code> into a mostly-drop-in replacement for <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>.</p> <p>I hope this peek under the hood has given you a new appreciation for what can be achieved by clever layout-hacking.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:size-classes" role="doc-endnote"> <p>Allocators rarely serve you memory with precisely the size you asked for. Instead, they will have some notion of a “size class” that allows them to use more efficient allocation techniques, <a href="https://mcyoung.xyz//2022/06/07/alkyne-gc">which I have written about</a>.</p> <p>As a result, if the size change in a <code class="language-plaintext highlighter-rouge">realloc()</code> would not change the size class, it becomes a no-op, especially if the allocator can take advantage of the current-size information Rust provides it. <a href="#fnref:size-classes" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:character" role="doc-endnote"> <p>Here and henceforth “character” means “32-bit Unicode scalar”. <a href="#fnref:character" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:isize" role="doc-endnote"> <p>Now, you might also point out that Rust and C do not allow an allocation whose size is larger than the pointer offset type (<code class="language-plaintext highlighter-rouge">isize</code> and <code class="language-plaintext highlighter-rouge">ptrdiff_t</code>, respectively). In practice this means that the high bit is <em>always</em> zero according to the language’s own rules.</p> <p>This is true, but we need to steal two bits, and I wanted to demonstrate that this is an extremely reasonable desire. 64-bit integers are so comically large. <a href="#fnref:isize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:two-shifts" role="doc-endnote"> <p>Interestingly, LLVM will compile <code class="language-plaintext highlighter-rouge">(x &lt;&lt; 2) &gt;&gt; 2</code> to</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">movabs</span> <span class="n">rax</span><span class="p">,</span><span class="mh">0x3fffffffffffffff</span>
<span class="n">and</span>    <span class="n">rax</span><span class="p">,</span><span class="n">rdi</span>
<span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>If we want to play the byte-for-byte game, this costs 14 bytes when encoded in the Intel variable-length encoding. You would think that two shifts would result in marginally smaller code, but no, since the input comes in in <code class="language-plaintext highlighter-rouge">rdi</code> and needs to wind up in <code class="language-plaintext highlighter-rouge">rax</code>.</p> <p>On RISC-V, though, it seems to decide that two shifts is in fact cheaper, and will even optimize <code class="language-plaintext highlighter-rouge">x &amp; 0x3fff_ffff_ffff_ffff</code> back into two shifts. <a href="#fnref:two-shifts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:big-endian" role="doc-endnote"> <p>This only works on little endian. Thankfully all computers are little endian. <a href="#fnref:big-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:leaks" role="doc-endnote"> <p>Technically, a <code class="language-plaintext highlighter-rouge">&amp;'static str</code> may also point to leaked memory. For our purposes, there is no essential difference. <a href="#fnref:leaks" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-01</span> / <h6 style="display:inline"><a href="/2023/08/01/llvm-ir/">A Gentle Introduction to LLVM IR </a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>