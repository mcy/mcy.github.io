<!DOCTYPE html> <html lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Optimization-Dependent Rust ABI &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Optimization-Dependent Rust ABI &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/abi-optimization-b3720994cf61b5bda92d445fd38b8f463531eec2.png"> <meta property="og:title" content="Optimization-Dependent Rust ABI &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/abi-optimization-b3720994cf61b5bda92d445fd38b8f463531eec2.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/wip/abi-optimization/"> </head> <body> <div class="sidebar"> <a href="https://mcyoung.xyz/"> <img src="https://mcyoung.xyz/public/avatar.png" alt="Yeah, I drew this. Check out my art blog." class="hide-if-mobile"/> </a> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/">Home</a> • <a class="sidebar-nav-item" href="/about.html">About</a> • <a class="sidebar-nav-item" href="/posts.html">Posts</a> • <a class="sidebar-nav-item" href="/tags.html">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://art.mcyoung.xyz/">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> </nav> <br class="hide-if-mobile"/> <p class="hide-if-mobile"><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota</p> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> Soon™ • 1572 words • 8 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/wip/abi-optimization/"> Optimization-Dependent Rust ABI </a></h1> </div> <div class="post"> <p>Rust generics have an emergent ABI problem. Consider this function from the standard library:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="n">contains</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
  <span class="k">where</span>
      <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">Q</span><span class="p">:</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">HashSet::contains</code> takes a reference to a value that can be used to look up a value in the map; often, <code class="language-plaintext highlighter-rouge">Q</code> will just be <code class="language-plaintext highlighter-rouge">K</code>. Then, consider the following code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">pred</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">set</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If <code class="language-plaintext highlighter-rouge">contains()</code> is not inlined, we will need to spill <code class="language-plaintext highlighter-rouge">x</code> to the stack so that we can pass a pointer to it into <code class="language-plaintext highlighter-rouge">contains()</code>. Now, collection functions are frequently inlined, but this isn’t always the case, particularly when building for code size.</p> <p>However, the reference isn’t actually needed because <code class="language-plaintext highlighter-rouge">HashSet::contains</code> doesn’t retain the address of <code class="language-plaintext highlighter-rouge">x</code>, so the compiler could generate code for <code class="language-plaintext highlighter-rouge">contains()</code> to take its argument by register rather than by pointer. But, when can the compiler make this optimization?</p> <p>In this article I want to describe a class of compiler optimizations I call “ABI optimization” or “optimization-dependent ABI”. I will sketch the general concept, and then an example for promoting pointer arguments to register arguments in Rust.</p> <h2 id="the-c-compilation-model"><a href="#the-c-compilation-model">The C Compilation Model</a></h2> <p>C code is unsual among other popular languages today in that it has separate interface and implementation files. <code class="language-plaintext highlighter-rouge">.h</code> files contain types and function interfaces, while <code class="language-plaintext highlighter-rouge">.c</code> files contain the bodies of those functions. <code class="language-plaintext highlighter-rouge">.h</code> files can be included by other <code class="language-plaintext highlighter-rouge">.h</code> files and <code class="language-plaintext highlighter-rouge">.c</code> files, but <code class="language-plaintext highlighter-rouge">.c</code> files cannot be included by anyone.</p> <p>What this means is that each compilation action consists of compiling a single <code class="language-plaintext highlighter-rouge">.c</code> file, which consumes declarations for all of its dependencies, and implementations of all the functions it defines. Each <code class="language-plaintext highlighter-rouge">.c</code> file defines a single “translation unit”.</p> <p>LLVM is built around this compilation model: each <code class="language-plaintext highlighter-rouge">.ll</code> file (an LLVM module, equivalent to a C translation unit) consists of declarations copied from dependencies, and definitions for functions defined in the translation unit. The optimizer operates on a single module, and thus can’t see the implementations of dependencies, even if they’ve already been analyzed by another LLVM invocation.</p> <p>This is a barrier to many optimizations, but a particularly tricky one is that LLVM can’t change function signatures. Suppose that <code class="language-plaintext highlighter-rouge">a.ll</code> is a dependency of <code class="language-plaintext highlighter-rouge">b.ll</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">//</span> <span class="err">a</span><span class="p">.</span><span class="err">ll</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%0</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%1</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">b</span><span class="p">.</span><span class="err">ll</span>
<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span><span class="p">)</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">start:</span>
   <span class="nv">%1</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
   <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
   <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%1</span><span class="p">)</span>
   <span class="nv">%3</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%2</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">42</span>
   <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>These files are optimized in parallel. We would like to optimize <code class="language-plaintext highlighter-rouge">foo()</code> into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%0</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%0</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>so that the caller of <code class="language-plaintext highlighter-rouge">foo()</code> is required to perform the dereference. However, because the files are not optimized in parallel, the LLVM compiling <code class="language-plaintext highlighter-rouge">b.ll</code> won’t be aware this optimization occured, so we get argument type mismatch and thus, undefined behavior.</p> <p>However, this is not how Rust compiles code. Rust doesn’t have headers, so the compiler generates binary “header” files (<code class="language-plaintext highlighter-rouge">.rmeta</code> files) which downstream compilation jobs can use to import functions across crates. This means that a Rust build has to build crates in topological order (at least, it needs to run enough of the compiler to generate the “headers”). This is a channel for <em>past invocations</em> of the compiler to communicate with <em>future invocations</em> within the same build.</p> <p>Summarized:</p> <ul> <li>C allows all compilation jobs to occur in parallel, but any information shared between compilation units needs to be written by humans.</li> <li>Rust requires compilation of a crate to wait for all dependency crates to emit compiler-generated header files, but the compiler can advertise decisions it made made for dependency crates to downstream users.</li> </ul> <p>This idea is not unique to Rust. Go also requires compilation of all packages a package depends on to be built before it attempts to build the current pacakge (its generated header files are called “export data”, or <code class="language-plaintext highlighter-rouge">.x</code> files).</p> <p>Because the compiler’s decisions can be recorded in <code class="language-plaintext highlighter-rouge">.rmeta</code> files, this suggests a way that we could share optimization information across crates.</p> <h2 id="optimization-remarks"><a href="#optimization-remarks">Optimization Remarks</a></h2> <p>Let’s say that we’re building an optimization or analysis X that only works if findings from dependencies are known. Then, we can implement this within the Rust compilation model like so:</p> <ol> <li>An <code class="language-plaintext highlighter-rouge">.rmeta</code> section is added that specifies the results of the analysis X; abcense of this section means the analysis did not occur.</li> <li>When compiling a function in a crate, we can refer to the findings from all functions that it calls directly, because all those functions must have been analyzed in a dependency crate, and are thus in that crate’s <code class="language-plaintext highlighter-rouge">.rmeta</code>. We perform the analysis using this as input.</li> <li>The result of this analysis is included in the <code class="language-plaintext highlighter-rouge">.rmeta</code> output for that function.</li> </ol> <p>Note that there are some cases where we can call functions that aren’t defined in our dependencies, via function pointers or <code class="language-plaintext highlighter-rouge">dyn</code> objects. It is also possible to call functions via <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="n">hidden</span> <span class="p">{</span>
  <span class="nd">#[no_mangle]</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">foo</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, these functions must have a stable symbol name, through <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> or a similar attribute. The vast majority of Rust symbols cannot be called through an <code class="language-plaintext highlighter-rouge">extern</code> symbol.</p> <p>So, what does scalar argument promotion look like in this framework?</p> <h3 id="escape-analysis-with-remarks"><a href="#escape-analysis-with-remarks">Escape Analysis with Remarks</a></h3> <p>Our goal is to convert functions that take <code class="language-plaintext highlighter-rouge">x: &amp;i32</code> into taking <code class="language-plaintext highlighter-rouge">x: i32</code> as an argument, instead. This optimization is correct when:</p> <ol> <li>The type <code class="language-plaintext highlighter-rouge">&amp;T</code> is such that <code class="language-plaintext highlighter-rouge">T</code> does not contain an <code class="language-plaintext highlighter-rouge">UnsafeCell</code>; i.e., this guarantees that <code class="language-plaintext highlighter-rouge">&amp;T</code> does not need to be reloaded, because that memory location can’t be mutated: for these types, <code class="language-plaintext highlighter-rouge">&amp;T</code> is “transparent”.</li> <li>The address of <code class="language-plaintext highlighter-rouge">&amp;T</code> does not escape, which is true accordiong to a dataflow analysis like the following: a. The lifetime of <code class="language-plaintext highlighter-rouge">&amp;'a T</code> is contravariant in the function’s corresponding fnptr type. For example, <code class="language-plaintext highlighter-rouge">for&lt;'a&gt; fn(&amp;'a T)</code> is contravariant, but it isn’t in either of <code class="language-plaintext highlighter-rouge">for&lt;'a&gt; fn(&amp;'a T, &amp;mut &amp;'a T)</code> or <code class="language-plaintext highlighter-rouge">for&lt;'a&gt; fn(&amp;'a T) -&gt; &amp;'a T</code>. b. The reference is never converted into a raw pointer. We can’t keep track of whether the program depends on the address of a raw poitner, so we shouldn’t change it. c. The reference is not passed into any function pointer, trait object, or <code class="language-plaintext highlighter-rouge">extern</code>-declared function. d. Any other function that the reference was passed into must not escape it, per rules (a)-(d).</li> </ol> <p>The rule (2d) is where remarks come in: by induction, we’ve already run this analysis on all dependencies, so we can check it for any statically-dispatched calls. Requirement (2a) is quite strict: it can be relaxed by doing more extensive dataflow analysis and is only here to simplify the statement of the requirements. A more complete discussion of this type of escape analysis can be found in the <a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/escape/escape.go">Go compiler’s implementation</a>.</p> <p>This analysis needs to occur in MIR, so it can be emitted into <code class="language-plaintext highlighter-rouge">.rmeta</code> for looking at in rule (2d) and so it has access to Rust-specific semantics. Of course, in an unoptimized build this step can be skipped for speed, and functions that are missing escape information can be assumed to escape all their arguments.</p> <p>Also, just this information can be used to improve LLVM’s output quality: pointer arguments that do not escape can be annotated as <code class="language-plaintext highlighter-rouge">nocapture</code> in a <code class="language-plaintext highlighter-rouge">declare</code> when generating LLVM IR.</p> <h3 id="scalar-argument-promotion"><a href="#scalar-argument-promotion">Scalar Argument Promotion</a></h3> <p>Now that we have escape information for all functions we’re generating LLVM IR for, we add an additional annotation which indicates that the ABI of an argument was promoted from “by pointer” to “by register”.</p> <p>Concretely, suppose we have <code class="language-plaintext highlighter-rouge">fn foo(x: &amp;i32)</code> which we know does not escape <code class="language-plaintext highlighter-rouge">x</code>’s address. Then:</p> <ol> <li>Instead of emitting <code class="language-plaintext highlighter-rouge">define void @foo(ptr)</code>, we emit <code class="language-plaintext highlighter-rouge">define void @foo(i32)</code>.</li> <li>We add a prologue to the IR of <code class="language-plaintext highlighter-rouge">foo()</code> that creates an <code class="language-plaintext highlighter-rouge">alloca i32</code>, which we write the <code class="language-plaintext highlighter-rouge">i32</code> argument to; this pointer can be used in place of the original reference argument. LLVM will obliterate this alloca for us during optimization, so generating ugly code is fine in this case.</li> <li>To every static call to <code class="language-plaintext highlighter-rouge">foo()</code>, we place a load immediately before the call to load the value we would have passed into by pointer <code class="language-plaintext highlighter-rouge">foo()</code> into a register. Again, LLVM will clean this up, particularly if we’re loading an alloca created in the current function.</li> <li>We generate a thunk <code class="language-plaintext highlighter-rouge">define void @foo.thunk(ptr)</code> that simply loads the pointer argument and tail calls into <code class="language-plaintext highlighter-rouge">foo()</code>. This thunk is used for creating ABI-compatible function pointers; this allows <code class="language-plaintext highlighter-rouge">let f: fn(&amp;i32) = foo;</code> to continue to work.</li> </ol> <p>Concretely, suppose we have the following rust code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// a.rs</span>
<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">42</span>
<span class="p">}</span>

<span class="c1">// b.rs</span>
<span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="nf">foo</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This would have been codegened into something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">//</span> <span class="err">a</span><span class="p">.</span><span class="err">ll</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%x</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">b</span><span class="p">.</span><span class="err">ll</span>
<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%x</span><span class="p">)</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%2</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>But, if we applied this optimization, we’d get something like this instead.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">//</span> <span class="err">a</span><span class="p">.</span><span class="err">ll</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="err">//</span> <span class="err">Store</span> <span class="nv">%x</span> <span class="err">into</span> <span class="err">a</span> <span class="err">stack</span> <span class="err">slot</span><span class="p">,</span> <span class="err">so</span> <span class="err">that</span> <span class="k">none</span> <span class="err">of</span> <span class="err">the</span> <span class="err">existing</span> <span class="err">code</span>
  <span class="err">//</span> <span class="err">needs</span> <span class="k">to</span> <span class="err">be</span> <span class="err">changed</span><span class="p">.</span> <span class="err">This</span> <span class="err">equivalent</span> <span class="k">to</span> <span class="err">telling</span> <span class="err">LLVM</span> <span class="s">"this
  // argument doesn't have an address, optimize as appropriate"</span><span class="p">.</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>

  <span class="nv">%2</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%2</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%3</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">This</span> <span class="k">function</span> <span class="err">is</span> <span class="err">for</span> <span class="err">creating</span> <span class="k">function</span> <span class="err">pointers</span> <span class="k">to</span> <span class="err">`foo`</span><span class="p">.</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo.thunk</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%x</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%1</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">b</span><span class="p">.</span><span class="err">ll</span>
<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span>  <span class="err">//</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">not</span> <span class="err">ptr</span><span class="p">!</span>
                          <span class="err">//</span> <span class="err">We</span> <span class="err">know</span> <span class="err">we</span> <span class="err">can</span> <span class="err">do</span> <span class="err">this</span> <span class="err">because</span> <span class="err">of</span>
                          <span class="err">//</span> <span class="err">optimization</span> <span class="err">remarks</span><span class="p">.</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%2</span>

  <span class="err">//</span> <span class="err">Load</span> <span class="err">the</span> <span class="err">pointer</span><span class="p">,</span> <span class="err">because</span> <span class="err">we</span> <span class="err">need</span> <span class="k">to</span> <span class="err">pass</span> <span class="err">by</span> <span class="err">register</span><span class="p">.</span>
  <span class="err">//</span> <span class="err">LLVM</span> <span class="err">will</span> <span class="err">see</span> <span class="err">we're</span> <span class="err">loading</span> <span class="err">something</span> <span class="err">that</span> <span class="err">we</span> <span class="err">just</span>
  <span class="err">//</span> <span class="err">stored</span> <span class="err">in</span> <span class="err">an</span> <span class="err">`</span><span class="k">alloca</span><span class="err">`</span><span class="p">,</span> <span class="err">which</span> <span class="err">means</span> <span class="err">it</span> <span class="err">can</span> <span class="err">replace</span> <span class="nv">%3</span> <span class="err">below</span>
  <span class="err">//</span> <span class="err">with</span> <span class="nv">%1</span><span class="p">.</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%2</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%3</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Although it looks like we’re produced <em>worse</em> codegen, this is actually very benefitial to LLVM, because within a function, it can easily see that the memory operations we’re doing to spill and unspill <code class="language-plaintext highlighter-rouge">%x</code> from the stack are redundant.</p> <p>The upshot is that <code class="language-plaintext highlighter-rouge">foo()</code> takes <code class="language-plaintext highlighter-rouge">i32</code> instead of <code class="language-plaintext highlighter-rouge">ptr</code> at the LLVM level, an optimization LLVM could not have performed. After optimization, this will result in reduced memory traffic to the stack!</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This kind of optimization is particularly important for old but entrenched APIs, where it might be possible to provide a more performant ABI without changing the function signature. Other ABI optimizations to explore could include:</p> <ul> <li>Struct exploding: Rust passes structs by pointer if they are two registers or larger, which might not be ideal in some cases.</li> <li>Argument reordering: passing “hotter” arguments in earlier slots means they can be passed by register instead of on the stack.</li> <li>Profiling-inspired ABIs: the compiler could use profiling information to modify an ABI to minimize memory traffic or improve register pressure.</li> </ul> <p>Optimization-dependent ABI is not a concept I’ve seen languages that target LLVM take advantage of, and it is a potential avenue for getting another edge on C and C++ for “ordinary” scalar code.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <a href="/2023/11/27/simd-base64/"> <small class="post-meta-flat">2023-11-27</small> Designing a SIMD Algorithm from Scratch </a> <li> <a href="/2023/09/29/what-is-a-matrix/"> <small class="post-meta-flat">2023-09-29</small> What is a Matrix? A Miserable Pile of Coefficients! </a> <li> <a href="/2023/08/09/yarns/"> <small class="post-meta-flat">2023-08-09</small> I Wrote A String Type </a> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> Soon™ • 1572 words • 8 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/wip/abi-optimization/"> Optimization-Dependent Rust ABI </a></h1> </div> <div class="post"> <p>Rust generics have an emergent ABI problem. Consider this function from the standard library:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="n">contains</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
  <span class="k">where</span>
      <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">Q</span><span class="p">:</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">HashSet::contains</code> takes a reference to a value that can be used to look up a value in the map; often, <code class="language-plaintext highlighter-rouge">Q</code> will just be <code class="language-plaintext highlighter-rouge">K</code>. Then, consider the following code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">pred</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">set</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If <code class="language-plaintext highlighter-rouge">contains()</code> is not inlined, we will need to spill <code class="language-plaintext highlighter-rouge">x</code> to the stack so that we can pass a pointer to it into <code class="language-plaintext highlighter-rouge">contains()</code>. Now, collection functions are frequently inlined, but this isn’t always the case, particularly when building for code size.</p> <p>However, the reference isn’t actually needed because <code class="language-plaintext highlighter-rouge">HashSet::contains</code> doesn’t retain the address of <code class="language-plaintext highlighter-rouge">x</code>, so the compiler could generate code for <code class="language-plaintext highlighter-rouge">contains()</code> to take its argument by register rather than by pointer. But, when can the compiler make this optimization?</p> <p>In this article I want to describe a class of compiler optimizations I call “ABI optimization” or “optimization-dependent ABI”. I will sketch the general concept, and then an example for promoting pointer arguments to register arguments in Rust.</p> <h2 id="the-c-compilation-model"><a href="#the-c-compilation-model">The C Compilation Model</a></h2> <p>C code is unsual among other popular languages today in that it has separate interface and implementation files. <code class="language-plaintext highlighter-rouge">.h</code> files contain types and function interfaces, while <code class="language-plaintext highlighter-rouge">.c</code> files contain the bodies of those functions. <code class="language-plaintext highlighter-rouge">.h</code> files can be included by other <code class="language-plaintext highlighter-rouge">.h</code> files and <code class="language-plaintext highlighter-rouge">.c</code> files, but <code class="language-plaintext highlighter-rouge">.c</code> files cannot be included by anyone.</p> <p>What this means is that each compilation action consists of compiling a single <code class="language-plaintext highlighter-rouge">.c</code> file, which consumes declarations for all of its dependencies, and implementations of all the functions it defines. Each <code class="language-plaintext highlighter-rouge">.c</code> file defines a single “translation unit”.</p> <p>LLVM is built around this compilation model: each <code class="language-plaintext highlighter-rouge">.ll</code> file (an LLVM module, equivalent to a C translation unit) consists of declarations copied from dependencies, and definitions for functions defined in the translation unit. The optimizer operates on a single module, and thus can’t see the implementations of dependencies, even if they’ve already been analyzed by another LLVM invocation.</p> <p>This is a barrier to many optimizations, but a particularly tricky one is that LLVM can’t change function signatures. Suppose that <code class="language-plaintext highlighter-rouge">a.ll</code> is a dependency of <code class="language-plaintext highlighter-rouge">b.ll</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">//</span> <span class="err">a</span><span class="p">.</span><span class="err">ll</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%0</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%1</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">b</span><span class="p">.</span><span class="err">ll</span>
<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span><span class="p">)</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">start:</span>
   <span class="nv">%1</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
   <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
   <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%1</span><span class="p">)</span>
   <span class="nv">%3</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%2</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">42</span>
   <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>These files are optimized in parallel. We would like to optimize <code class="language-plaintext highlighter-rouge">foo()</code> into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%0</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%0</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>so that the caller of <code class="language-plaintext highlighter-rouge">foo()</code> is required to perform the dereference. However, because the files are not optimized in parallel, the LLVM compiling <code class="language-plaintext highlighter-rouge">b.ll</code> won’t be aware this optimization occured, so we get argument type mismatch and thus, undefined behavior.</p> <p>However, this is not how Rust compiles code. Rust doesn’t have headers, so the compiler generates binary “header” files (<code class="language-plaintext highlighter-rouge">.rmeta</code> files) which downstream compilation jobs can use to import functions across crates. This means that a Rust build has to build crates in topological order (at least, it needs to run enough of the compiler to generate the “headers”). This is a channel for <em>past invocations</em> of the compiler to communicate with <em>future invocations</em> within the same build.</p> <p>Summarized:</p> <ul> <li>C allows all compilation jobs to occur in parallel, but any information shared between compilation units needs to be written by humans.</li> <li>Rust requires compilation of a crate to wait for all dependency crates to emit compiler-generated header files, but the compiler can advertise decisions it made made for dependency crates to downstream users.</li> </ul> <p>This idea is not unique to Rust. Go also requires compilation of all packages a package depends on to be built before it attempts to build the current pacakge (its generated header files are called “export data”, or <code class="language-plaintext highlighter-rouge">.x</code> files).</p> <p>Because the compiler’s decisions can be recorded in <code class="language-plaintext highlighter-rouge">.rmeta</code> files, this suggests a way that we could share optimization information across crates.</p> <h2 id="optimization-remarks"><a href="#optimization-remarks">Optimization Remarks</a></h2> <p>Let’s say that we’re building an optimization or analysis X that only works if findings from dependencies are known. Then, we can implement this within the Rust compilation model like so:</p> <ol> <li>An <code class="language-plaintext highlighter-rouge">.rmeta</code> section is added that specifies the results of the analysis X; abcense of this section means the analysis did not occur.</li> <li>When compiling a function in a crate, we can refer to the findings from all functions that it calls directly, because all those functions must have been analyzed in a dependency crate, and are thus in that crate’s <code class="language-plaintext highlighter-rouge">.rmeta</code>. We perform the analysis using this as input.</li> <li>The result of this analysis is included in the <code class="language-plaintext highlighter-rouge">.rmeta</code> output for that function.</li> </ol> <p>Note that there are some cases where we can call functions that aren’t defined in our dependencies, via function pointers or <code class="language-plaintext highlighter-rouge">dyn</code> objects. It is also possible to call functions via <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="n">hidden</span> <span class="p">{</span>
  <span class="nd">#[no_mangle]</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">foo</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, these functions must have a stable symbol name, through <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> or a similar attribute. The vast majority of Rust symbols cannot be called through an <code class="language-plaintext highlighter-rouge">extern</code> symbol.</p> <p>So, what does scalar argument promotion look like in this framework?</p> <h3 id="escape-analysis-with-remarks"><a href="#escape-analysis-with-remarks">Escape Analysis with Remarks</a></h3> <p>Our goal is to convert functions that take <code class="language-plaintext highlighter-rouge">x: &amp;i32</code> into taking <code class="language-plaintext highlighter-rouge">x: i32</code> as an argument, instead. This optimization is correct when:</p> <ol> <li>The type <code class="language-plaintext highlighter-rouge">&amp;T</code> is such that <code class="language-plaintext highlighter-rouge">T</code> does not contain an <code class="language-plaintext highlighter-rouge">UnsafeCell</code>; i.e., this guarantees that <code class="language-plaintext highlighter-rouge">&amp;T</code> does not need to be reloaded, because that memory location can’t be mutated: for these types, <code class="language-plaintext highlighter-rouge">&amp;T</code> is “transparent”.</li> <li>The address of <code class="language-plaintext highlighter-rouge">&amp;T</code> does not escape, which is true accordiong to a dataflow analysis like the following: a. The lifetime of <code class="language-plaintext highlighter-rouge">&amp;'a T</code> is contravariant in the function’s corresponding fnptr type. For example, <code class="language-plaintext highlighter-rouge">for&lt;'a&gt; fn(&amp;'a T)</code> is contravariant, but it isn’t in either of <code class="language-plaintext highlighter-rouge">for&lt;'a&gt; fn(&amp;'a T, &amp;mut &amp;'a T)</code> or <code class="language-plaintext highlighter-rouge">for&lt;'a&gt; fn(&amp;'a T) -&gt; &amp;'a T</code>. b. The reference is never converted into a raw pointer. We can’t keep track of whether the program depends on the address of a raw poitner, so we shouldn’t change it. c. The reference is not passed into any function pointer, trait object, or <code class="language-plaintext highlighter-rouge">extern</code>-declared function. d. Any other function that the reference was passed into must not escape it, per rules (a)-(d).</li> </ol> <p>The rule (2d) is where remarks come in: by induction, we’ve already run this analysis on all dependencies, so we can check it for any statically-dispatched calls. Requirement (2a) is quite strict: it can be relaxed by doing more extensive dataflow analysis and is only here to simplify the statement of the requirements. A more complete discussion of this type of escape analysis can be found in the <a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/escape/escape.go">Go compiler’s implementation</a>.</p> <p>This analysis needs to occur in MIR, so it can be emitted into <code class="language-plaintext highlighter-rouge">.rmeta</code> for looking at in rule (2d) and so it has access to Rust-specific semantics. Of course, in an unoptimized build this step can be skipped for speed, and functions that are missing escape information can be assumed to escape all their arguments.</p> <p>Also, just this information can be used to improve LLVM’s output quality: pointer arguments that do not escape can be annotated as <code class="language-plaintext highlighter-rouge">nocapture</code> in a <code class="language-plaintext highlighter-rouge">declare</code> when generating LLVM IR.</p> <h3 id="scalar-argument-promotion"><a href="#scalar-argument-promotion">Scalar Argument Promotion</a></h3> <p>Now that we have escape information for all functions we’re generating LLVM IR for, we add an additional annotation which indicates that the ABI of an argument was promoted from “by pointer” to “by register”.</p> <p>Concretely, suppose we have <code class="language-plaintext highlighter-rouge">fn foo(x: &amp;i32)</code> which we know does not escape <code class="language-plaintext highlighter-rouge">x</code>’s address. Then:</p> <ol> <li>Instead of emitting <code class="language-plaintext highlighter-rouge">define void @foo(ptr)</code>, we emit <code class="language-plaintext highlighter-rouge">define void @foo(i32)</code>.</li> <li>We add a prologue to the IR of <code class="language-plaintext highlighter-rouge">foo()</code> that creates an <code class="language-plaintext highlighter-rouge">alloca i32</code>, which we write the <code class="language-plaintext highlighter-rouge">i32</code> argument to; this pointer can be used in place of the original reference argument. LLVM will obliterate this alloca for us during optimization, so generating ugly code is fine in this case.</li> <li>To every static call to <code class="language-plaintext highlighter-rouge">foo()</code>, we place a load immediately before the call to load the value we would have passed into by pointer <code class="language-plaintext highlighter-rouge">foo()</code> into a register. Again, LLVM will clean this up, particularly if we’re loading an alloca created in the current function.</li> <li>We generate a thunk <code class="language-plaintext highlighter-rouge">define void @foo.thunk(ptr)</code> that simply loads the pointer argument and tail calls into <code class="language-plaintext highlighter-rouge">foo()</code>. This thunk is used for creating ABI-compatible function pointers; this allows <code class="language-plaintext highlighter-rouge">let f: fn(&amp;i32) = foo;</code> to continue to work.</li> </ol> <p>Concretely, suppose we have the following rust code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// a.rs</span>
<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">42</span>
<span class="p">}</span>

<span class="c1">// b.rs</span>
<span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="nf">foo</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This would have been codegened into something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">//</span> <span class="err">a</span><span class="p">.</span><span class="err">ll</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%x</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">b</span><span class="p">.</span><span class="err">ll</span>
<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%x</span><span class="p">)</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%2</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>But, if we applied this optimization, we’d get something like this instead.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">//</span> <span class="err">a</span><span class="p">.</span><span class="err">ll</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="err">//</span> <span class="err">Store</span> <span class="nv">%x</span> <span class="err">into</span> <span class="err">a</span> <span class="err">stack</span> <span class="err">slot</span><span class="p">,</span> <span class="err">so</span> <span class="err">that</span> <span class="k">none</span> <span class="err">of</span> <span class="err">the</span> <span class="err">existing</span> <span class="err">code</span>
  <span class="err">//</span> <span class="err">needs</span> <span class="k">to</span> <span class="err">be</span> <span class="err">changed</span><span class="p">.</span> <span class="err">This</span> <span class="err">equivalent</span> <span class="k">to</span> <span class="err">telling</span> <span class="err">LLVM</span> <span class="s">"this
  // argument doesn't have an address, optimize as appropriate"</span><span class="p">.</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>

  <span class="nv">%2</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%2</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%3</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">This</span> <span class="k">function</span> <span class="err">is</span> <span class="err">for</span> <span class="err">creating</span> <span class="k">function</span> <span class="err">pointers</span> <span class="k">to</span> <span class="err">`foo`</span><span class="p">.</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@foo.thunk</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%x</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%1</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">b</span><span class="p">.</span><span class="err">ll</span>
<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span>  <span class="err">//</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">not</span> <span class="err">ptr</span><span class="p">!</span>
                          <span class="err">//</span> <span class="err">We</span> <span class="err">know</span> <span class="err">we</span> <span class="err">can</span> <span class="err">do</span> <span class="err">this</span> <span class="err">because</span> <span class="err">of</span>
                          <span class="err">//</span> <span class="err">optimization</span> <span class="err">remarks</span><span class="p">.</span>

<span class="k">declare</span> <span class="kt">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">start:</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%2</span>

  <span class="err">//</span> <span class="err">Load</span> <span class="err">the</span> <span class="err">pointer</span><span class="p">,</span> <span class="err">because</span> <span class="err">we</span> <span class="err">need</span> <span class="k">to</span> <span class="err">pass</span> <span class="err">by</span> <span class="err">register</span><span class="p">.</span>
  <span class="err">//</span> <span class="err">LLVM</span> <span class="err">will</span> <span class="err">see</span> <span class="err">we're</span> <span class="err">loading</span> <span class="err">something</span> <span class="err">that</span> <span class="err">we</span> <span class="err">just</span>
  <span class="err">//</span> <span class="err">stored</span> <span class="err">in</span> <span class="err">an</span> <span class="err">`</span><span class="k">alloca</span><span class="err">`</span><span class="p">,</span> <span class="err">which</span> <span class="err">means</span> <span class="err">it</span> <span class="err">can</span> <span class="err">replace</span> <span class="nv">%3</span> <span class="err">below</span>
  <span class="err">//</span> <span class="err">with</span> <span class="nv">%1</span><span class="p">.</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%2</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%3</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Although it looks like we’re produced <em>worse</em> codegen, this is actually very benefitial to LLVM, because within a function, it can easily see that the memory operations we’re doing to spill and unspill <code class="language-plaintext highlighter-rouge">%x</code> from the stack are redundant.</p> <p>The upshot is that <code class="language-plaintext highlighter-rouge">foo()</code> takes <code class="language-plaintext highlighter-rouge">i32</code> instead of <code class="language-plaintext highlighter-rouge">ptr</code> at the LLVM level, an optimization LLVM could not have performed. After optimization, this will result in reduced memory traffic to the stack!</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This kind of optimization is particularly important for old but entrenched APIs, where it might be possible to provide a more performant ABI without changing the function signature. Other ABI optimizations to explore could include:</p> <ul> <li>Struct exploding: Rust passes structs by pointer if they are two registers or larger, which might not be ideal in some cases.</li> <li>Argument reordering: passing “hotter” arguments in earlier slots means they can be passed by register instead of on the stack.</li> <li>Profiling-inspired ABIs: the compiler could use profiling information to modify an ABI to minimize memory traffic or improve register pressure.</li> </ul> <p>Optimization-dependent ABI is not a concept I’ve seen languages that target LLVM take advantage of, and it is a potential avenue for getting another edge on C and C++ for “ordinary” scalar code.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <a href="/2023/11/27/simd-base64/"> <small class="post-meta-flat">2023-11-27</small> Designing a SIMD Algorithm from Scratch </a> <li> <a href="/2023/09/29/what-is-a-matrix/"> <small class="post-meta-flat">2023-09-29</small> What is a Matrix? A Miserable Pile of Coefficients! </a> <li> <a href="/2023/08/09/yarns/"> <small class="post-meta-flat">2023-08-09</small> I Wrote A String Type </a> </ul> </div> </div> </div> </div></div> </body> <div class="sidebar show-if-mobile"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota </div> </div> </html>