<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Thoughts on std::simd &middot; mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Thoughts on std::simd &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/simd-api-notes-c566d421a52f01b2ad2fe401975b73d61e0a4b54.png"> <meta property="og:title" content="Thoughts on std::simd &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/simd-api-notes-c566d421a52f01b2ad2fe401975b73d61e0a4b54.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/wip/simd-api-notes/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> Soon™ • 2237 words • 18 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/wip/simd-api-notes/"> Thoughts on std::simd </a></h1> </div> <div class="post"> <p>I recently wrote an article about <a href="TODO">parsing base64 with SIMD</a>. In the process, I used it as an opportunity to evaluate Rust’s <a href="https://doc.rust-lang.org/std/simd/index.html"><code class="language-plaintext highlighter-rouge">std::simd</code></a> portable SIMD library.</p> <p>I went into this with fairly low expectations, taking it as a given that the codegen would not be as good as with direct use of intrinsics; LLVM is historically “not good” at optimizing intrinsics code, and <code class="language-plaintext highlighter-rouge">std::simd</code> code would not be using intrinsics at all.</p> <p><em>That said</em>, after using <code class="language-plaintext highlighter-rouge">std::simd</code> I think this is a really good approach. It produces great code (after tripping over some random performance footguns). Most of its issues stem from LLVM having mediocre support for some of the things Rust wants to do, or Rust emitting LLVM IR that results in selection failures, which are both fairly fixable. There’s also some rough edges in the API that I think should be fixed to make the code more readable.</p> <p>After spending <em>a lot</em> of time complaining to Jubilee, the lead for portable SIMD, we’ve agreed I should write up my findings and feedback, which is what this post is going to be.</p> <p>This is not my usual post, since it’s aimed at people with a lot of background, specifically other compiler people. I will be referring to general compiler and LLVM-specific concepts (like LLVM IR), API design, and HPC topics without much introduction. I am writing this based off of my own extensive experience writing vectorized code, compiler optimizations, and subtle algorithms that require extensive comments. These things are the main things going into my discussion here.</p> <p>With that out of the way, let’s dive into the topics in no particular order.</p> <h2 id="do-we-need-a-simd-type"><a href="#do-we-need-a-simd-type">Do We Need a <code class="language-plaintext highlighter-rouge">Simd</code> Type?</a></h2> <p>One question worth looking at is whether having <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> be distinct from <code class="language-plaintext highlighter-rouge">[T; N]</code> is worthwhile at all. The <em>main</em> reason is layout: on some weird platforms, like PPC, things like <code class="language-plaintext highlighter-rouge">[4 x i32]</code> and <code class="language-plaintext highlighter-rouge">&lt;4 x i32&gt;</code> have the same size but different alignment. There may also be endianness problems that I am not aware of; I haven’t bothered to survey this but I wouldn’t be surprised if on some BE architectures, you have</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%v</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>

<span class="c1">; Equivalent to...</span>
<span class="nv">%a</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%v</span> <span class="k">to</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span>
<span class="nv">%x</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%a</span><span class="p">,</span> <span class="m">3</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>I.e. the lanes are also in big-endian order. However, currently, Rust does not respect this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from_array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
<span class="n">vec</span><span class="nf">.as_mut_array</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

<span class="c1">// Does this print [42, 2, 3, 4] or [1, 2, 3, 42]? Depends</span>
<span class="c1">// on whether the lane layout matches [i32; 4].</span>
<span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{vec:?}"</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So we only really care about alignment (or, <code class="language-plaintext highlighter-rouge">as_mut_array()</code> has to be removed). It may be worth interrogating whether alignment matters: the big three modern CPU architectures, x86, ARM, and RISC-V, do not have “overaligned” vectors, so it’s basically a question of whether Rust emits only partially-aligned loads for vectors on “small market share” architectures. I strongly suspect this does not matter for most code, so overaligning via a <code class="language-plaintext highlighter-rouge">AlignAsIfSimd&lt;[i32; 4]&gt;</code> type might be good enough?</p> <p>The reason to ask this question is because arrays are Really Nice, syntactically. It would be very convenient to get to re-use arrays’ <code class="language-plaintext highlighter-rouge">[x, y, z]</code> and <code class="language-plaintext highlighter-rouge">[x; N]</code> syntax for free, and for existing code that uses <code class="language-plaintext highlighter-rouge">[T; N]</code> to be able to use the same vocabulary as SIMD code with minimal cognitive overhead.</p> <p>However, some other design proposals here become problematic, particularly <code class="language-plaintext highlighter-rouge">From</code> impls: for example, it is desireable for a scalar to <code class="language-plaintext highlighter-rouge">Into</code>-convert into a vector of any size via a broadcast, but <code class="language-plaintext highlighter-rouge">i32: Into&lt;[i32; 4]&gt;</code> feels problematic outside of the context of SIMD.</p> <p>I generally lean against having arrays be “the” SIMD type for this reason more than any other: it is useful to change the API available for an array-like type depending on whether it is a “list or things” or a “parallel vector of integers”.</p> <h2 id="whats-the-right-length"><a href="#whats-the-right-length">What’s the Right Length?</a></h2> <p>The <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> type has an “array-like length”, i.e., it’s in units of array elements. However, most SIMD intrinsics have a “register-like length”, where they specify the number of bits in the vector and don’t specify the type at all. For example, <code class="language-plaintext highlighter-rouge">__m256</code> represents an abstract YMM register in x86 intrinsics code.</p> <p>Both interpretations of the length are useful. For example, it is useful to have a <code class="language-plaintext highlighter-rouge">Simd&lt;u64, 4&gt;</code> and then cast it down to <code class="language-plaintext highlighter-rouge">Simd&lt;u32, 4&gt;</code> to get a vector of all the lower halves of the lanes in the <code class="language-plaintext highlighter-rouge">u64</code> vector, but it is <em>also</em> useful to be able to cast it to a <code class="language-plaintext highlighter-rouge">Simd&lt;u32, 8&gt;</code>, which interprets each <code class="language-plaintext highlighter-rouge">u64</code> lane as a pair of <code class="language-plaintext highlighter-rouge">u32</code> lanes.</p> <p>This kind of “size-preserving transmute” is very common in SIMD, particularly because some architectures’ intrinsics (Intel in particular) make it easy, since the lane width is specified on the intrinsic.</p> <p>I think that in an ideal world, it should be possible to specify both length styles. Here’s more-or-less how I’d approach it, as an API.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// mod std::simd</span>

<span class="nd">#[repr(simd)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">Length</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">N</span><span class="p">::</span><span class="n">Array</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_lanes</span><span class="p">(</span><span class="n">lanes</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsLanes</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_bits</span><span class="p">(</span><span class="n">lanes</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_lanes</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsLanes</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_bits</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Length</span><span class="p">:</span> <span class="n">Sealed</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="o">&gt;</span><span class="p">:</span> <span class="nb">Copy</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">AsLanes</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Length</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Length</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Bits</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The units are now part of the type. I think that making the type independent of the units is probably possible, but I don’t think it’s desireable. Suppose we pick the unit in the realized type to be the lane count. Then suppose we want a way to transmute a <code class="language-plaintext highlighter-rouge">Simd&lt;u32, Bits&lt;8&gt;&gt;</code> into a <code class="language-plaintext highlighter-rouge">Simd&lt;u64, Bits&lt;4&gt;&gt;</code>. How do we express this API generically? If we pick bit count as “fundamental”, we have the same trouble trying to specify <code class="language-plaintext highlighter-rouge">Simd::cast()</code>.</p> <p>Having two distinct types may lead to problems around unification, but I think this requires further study to determine potential issues. In particular, I think it is important to note that having both <code class="language-plaintext highlighter-rouge">into_lanes</code> and <code class="language-plaintext highlighter-rouge">from_lanes</code> is important, so we can make programs like the following type check:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">frob</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">Length</span><span class="p">,</span>
<span class="p">{</span>
  <span class="n">x</span><span class="nf">.into_bits</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_it</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span>
<span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Length</span><span class="p">,</span>
<span class="p">{</span>
  <span class="nn">Simd</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="nf">frob</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If we instead tried to do <code class="language-plaintext highlighter-rouge">frob(x).into_lanes()</code>, we would get something like <code class="language-plaintext highlighter-rouge">Simd&lt;T, Lanes&lt;N&gt;::AsBits&lt;N&gt;::AsLanes&lt;N&gt;&gt;</code>, which the trait solver has no way to cancel out to just <code class="language-plaintext highlighter-rouge">Simd&lt;T, Lanes&lt;N&gt;&gt;</code>. <code class="language-plaintext highlighter-rouge">Simd::from_bits</code> allows us to “undo” this.</p> <p>Mind, I think that <em>most</em> people are not going to want to write out a type like <code class="language-plaintext highlighter-rouge">Simd&lt;T, Lanes&lt;N&gt;&gt;</code> all the time, so I think some convenience aliases are in order. I think one option is something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// The core data type.</span>
<span class="nd">#[repr(simd)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">Length</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">N</span><span class="p">::</span><span class="n">Array</span><span class="p">);</span>

<span class="c1">// Array-like SIMD types.</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// "Very large integer" SIMD types, e.g. v128&lt;i32&gt;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v64</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v128</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v256</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">256</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v512</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">512</span><span class="o">&gt;&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Another option is a <code class="language-plaintext highlighter-rouge">Simd!</code> macro of some kind to make it easier to name different SIMD types. There’s definitely bikeshedding opportunities.</p> <p>Also, we need an answer for cases where the length in <code class="language-plaintext highlighter-rouge">Bits&lt;N&gt;</code> is not cleanly divisible by the element type: e.g., <code class="language-plaintext highlighter-rouge">Simd&lt;u8, Bits&lt;15&gt;&gt;</code>, <code class="language-plaintext highlighter-rouge">Simd&lt;u64, Bits&lt;32&gt;&gt;</code>. There are three choices for the semantics of this thing:</p> <ol> <li>Monomorphization error.</li> <li>Round the number of lanes down.</li> <li>Round the number of lanes up.</li> </ol> <p>This is related, but not exactly the same, as whether things like <code class="language-plaintext highlighter-rouge">Simd&lt;u64, Lanes&lt;3&gt;&gt;</code> should be supported. I think it’s hard to tell right now which of these is the best option, but my gut tells me to round down.</p> <p>Also, there is a question of what <code class="language-plaintext highlighter-rouge">Simd&lt;T, Bits&lt;N&gt;&gt;::cast()</code> should mean. Our options are either “size-preserving transmute” or “it’s not available at all”. I don’t think either is wrong; I think that the transmute operation is useful, but it should not have the same name to avoid surprises in generic code.</p> <h2 id="simd-function-name-lookup"><a href="#simd-function-name-lookup">SIMD Function Name Lookup</a></h2> <p>Right now, you’re expected to include a prelude for using most SIMD operations, such as e.g. <code class="language-plaintext highlighter-rouge">SimdUint</code>. I am not a fan of this type of API for a few reasons:</p> <ol> <li>It’s hard to discover what functions are available without digging through many traits.</li> <li>Namespace pollution from <code class="language-plaintext highlighter-rouge">use std::simd::prelude::*;</code> is not ideal, IMO.</li> <li>The APIs of functions that are introduced through traits are kind of messy.</li> </ol> <p>There is effectively no reason for these to be implemented as traits, because all of these functions are manually lowered by the compiler. For example, this is the implementation of <code class="language-plaintext highlighter-rouge">SimdInt::cast()</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[inline]</span>
<span class="k">fn</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdCast</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Safety: supported types are guaranteed by SimdCast</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">intrinsics</span><span class="p">::</span><span class="nf">simd_as</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compiler directly lowers the <code class="language-plaintext highlighter-rouge">simd_as</code> intrinsic to an LLVM <code class="language-plaintext highlighter-rouge">trunc</code>, <code class="language-plaintext highlighter-rouge">sext</code>, or <code class="language-plaintext highlighter-rouge">zext</code> as needed. In my mind, there’s no particular reason this couldn’t be written as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="nd">#[inline]</span>
  <span class="k">fn</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span>
  <span class="k">where</span> <span class="n">U</span><span class="p">:</span> <span class="n">SimdCastFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Safety: supported types are guaranteed by SimdCast</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">intrinsics</span><span class="p">::</span><span class="nf">simd_as</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I think there is an interesting question to ask here whether having a separate cast for pointee types (e.g. what <code class="language-plaintext highlighter-rouge">&lt;Simd&lt;*mut i32, 4&gt; as SimdMutPtr&gt;::cast&lt;u32&gt;()</code> does today) since you could write <code class="language-plaintext highlighter-rouge">vec.cast::&lt;*mut i32&gt;()</code> instead. Currently, <code class="language-plaintext highlighter-rouge">std::simd</code> has distinct pointer cast intrinsics for SIMD, but I don’t believe there is a technical necessity here (integer casts lower as described, pointer casts are no-ops because LLVM only has the <code class="language-plaintext highlighter-rouge">ptr</code> type).</p> <p>In this way, things like <code class="language-plaintext highlighter-rouge">SimdFloat</code> and <code class="language-plaintext highlighter-rouge">SimdInt</code> are replaced with marker traits that guard against invalid calls to intrinsics, but all of the actual callable methods are inherents of <code class="language-plaintext highlighter-rouge">Simd</code>.</p> <p>There are also a handful of functions that would otherwise clash with trait methods from built-in types. For example, lanewise-eq is <code class="language-plaintext highlighter-rouge">simd_eq</code>, because if it was named <code class="language-plaintext highlighter-rouge">eq</code> it would be ambiguous with <code class="language-plaintext highlighter-rouge">PartialEq::eq</code>.</p> <p>But, if instead <code class="language-plaintext highlighter-rouge">simd_eq</code> were inherent, this would not be a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">Mask</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="nb">PartialEq</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Inherent methods always win against trait methods, so <code class="language-plaintext highlighter-rouge">a.eq(b)</code> could coexist with <code class="language-plaintext highlighter-rouge">a == b</code>. There is definitely argument to be made that shadowing well-known trait methods in a standard API is kinda rude, although I counter that no one ever means <code class="language-plaintext highlighter-rouge">PartialEq::eq()</code> when they want to compare two SIMD vectors.</p> <h2 id="gatherscatter"><a href="#gatherscatter">Gather/Scatter</a></h2> <p>The current state of gather/scatter isn’t very good. Rust lowers these to the <code class="language-plaintext highlighter-rouge">load T, &lt;n x ptr&gt;</code> and <code class="language-plaintext highlighter-rouge">store T, &lt;n x ptr&gt;</code> instructions, which produce mediocre code, since LLVM has trouble remembering what relationship these pointers had to each other.</p> <p>I think the current gather/scatter functions should be removed, and replaced with the following more basic primitives.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="k">self</span><span class="nf">.read_masked</span><span class="p">(</span><span class="nn">Mask</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="k">true</span><span class="p">),</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">read_masked</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">isize</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="k">self</span><span class="nf">.write_masked</span><span class="p">(</span><span class="nn">Mask</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="k">true</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">write_masked</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">isize</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Existing gather/scatter operations all lower into something resembling these anyways, and they should be a fairly uncommon operation, so it seems better to provide just the primitive and wait to see what users wind up requesting.</p> <p>What many users <em>actually</em> want when they do a gather is to load localized data in some shuffled order, which is best realized as a load + shuffle.</p> <p>However, <code class="language-plaintext highlighter-rouge">Simd::from_slice()</code> requires that the input slice be no smaller than the vector being loaded, so it can always lower to a single load instruction. This is fine, but there probably needs to be a <code class="language-plaintext highlighter-rouge">Simd::prefix_from_slice()</code> that performs loads less than a full vector of memory. Highly efficient techniques exist for implementing such functions, which perform an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> number of loads and branches; see <a href="https://github.com/mcy/vb64/blob/main/src/lib.rs#L230"><code class="language-plaintext highlighter-rouge">vb64</code>’s padded load implementation</a>.</p> <p>Once users have loaded the localized data into a vector, they can shuffle it as needed. The API should try to steer users away from general gather/scatter where possible, since it’s a performance footgun.</p> <h2 id="arguments-to-simd-operations"><a href="#arguments-to-simd-operations">Arguments To SIMD Operations</a></h2> <p>Certain operations are very, very wordy, because SIMD operations only operate on SIMD vectors. For example, I have a helper function like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">mask_splat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">Mask</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span> <span class="o">+</span> <span class="nb">Default</span><span class="p">,</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="n">mask</span><span class="nf">.select</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Ideally, though, it would have been good to be able to just write <code class="language-plaintext highlighter-rouge">mask.select(val, 0)</code> and be done with it.</p> <p>I think the best approach is to observe that <code class="language-plaintext highlighter-rouge">Simd::splat</code> is the canonical conversion from scalar to vector. For a lot of operations mixed vector and scalar arguments, where the scalars are implicitly splatted, make a lot of sense classically. The most well-known example is scalar multiplication, e.g. <code class="language-plaintext highlighter-rouge">Simd&lt;f32, 4&gt; * f32</code>, but I think it’s a valid conversion for virtually every SIMD operation.</p> <p>In other words, I think that <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> should be <code class="language-plaintext highlighter-rouge">From&lt;N::Array&lt;T&gt;&gt;</code> and <code class="language-plaintext highlighter-rouge">From&lt;T&gt;</code>, and every function on <code class="language-plaintext highlighter-rouge">Simd</code> that takes a <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> should instead take an <code class="language-plaintext highlighter-rouge">impl Into&lt;Simd&lt;T, N&gt;&gt;</code>.</p> <p>I think this is very important for readability: redundant calls to <code class="language-plaintext highlighter-rouge">Simd::splat</code> get in the way of the essential character of the code.</p> <p>Separately, I think that it would be good to expand the scope of existing “array construction” primitives. The following function, for example, makes it easier to build e.g. shuffle index vectors, which are commonly “stripped”.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">tile</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">uninit</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="n">uninit</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="k">self</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cycle</span><span class="p">())</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">b</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="n">uninit</span><span class="nf">.assume_init</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This would make it really easy to write e.g. <code class="language-plaintext highlighter-rouge">table.swizzle_dyn([x, y, z].tile())</code>.</p> <h2 id="shuffling-operations"><a href="#shuffling-operations">Shuffling Operations</a></h2> <p>My understanding is that the <code class="language-plaintext highlighter-rouge">Swizzle</code> and <code class="language-plaintext highlighter-rouge">Swizzle2</code> traits, as they exist, are going away. I think that’s a good step forward but there’s a few issues with shuffles worth considering.</p> <p>My pony for shuffles is that we can have a single operation like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="n">lookup_in_table</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">K</span><span class="p">],</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span>
  <span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">SimdUint</span><span class="p">,</span>
    <span class="n">U</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span> <span class="n">Length</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Essentially the intent here is that <code class="language-plaintext highlighter-rouge">self</code> is a vector of <code class="language-plaintext highlighter-rouge">N</code> indices, which we use to select <code class="language-plaintext highlighter-rouge">N</code> values from the provided lookup table. This generalizes <code class="language-plaintext highlighter-rouge">Swizzle</code>, <code class="language-plaintext highlighter-rouge">Swizzle2</code>, and <code class="language-plaintext highlighter-rouge">swizzle_dyn</code>. The semantics are: <code class="language-plaintext highlighter-rouge">[Simd&lt;U, M&gt;; K]</code> is interpreted as an array <code class="language-plaintext highlighter-rouge">[U; M::Array&lt;U&gt;.len() * K]</code>; elements from <code class="language-plaintext highlighter-rouge">self</code> are indices in this matrix; out-of-bound values produce zero (or equivalent).</p> <p>The “main” issue here is that we really want this to lower to an LLVM <code class="language-plaintext highlighter-rouge">shufflevector</code> when possible, since that can be optimized better, but it requires that the argument be an immediate. I don’t know how good MIR-opt is at constant folding these days.</p> <p>Part of the problem is that LLVM does not have a general “shuffle with dynamic index vector” intrinsic, and instead relegates users to the architecture-specific shuffles. Currently, the Rust standard library does selection itself, rather than letting the compiler do it, which is part of the problem.</p> <p>I’m not sure what the cleanest way out of this is right now. One way to achieve it might be to introduce something like</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#![feature(adt_const_params)]</span>
<span class="nd">#![feature(generic_const_exprs)]</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Indices</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ARRAY</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="p">[</span><span class="nb">usize</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ARRAY</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="p">[</span><span class="nb">usize</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">Indices</span><span class="o">&lt;</span><span class="n">ARRAY</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">lookup_in_table</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">K</span><span class="p">],</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="p">{</span> <span class="n">ARRAY</span><span class="nf">.len</span><span class="p">()</span> <span class="p">}</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="n">U</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span>
    <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
    <span class="n">LaneCount</span><span class="o">&lt;</span><span class="p">{</span> <span class="n">ARRAY</span><span class="nf">.len</span><span class="p">()</span> <span class="p">}</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="nd">todo!</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Then, you could write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nn">simd</span><span class="p">::</span><span class="n">Indices</span><span class="o">&lt;</span><span class="p">{</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="p">}</span><span class="o">&gt;</span><span class="nf">.lookup_in_table</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This ensures that the index vector is an immediate, which simplifies selection.</p> <p>In my opinion, this shouldn’t even have to exist, and LLVM should be able to “just deal with it” by offering an <code class="language-plaintext highlighter-rouge">@llvm.vector.shuffle.vNT</code> intrinsic that it knows it can promote to a <code class="language-plaintext highlighter-rouge">shufflevector</code> after it’s constant-folded and GVN’d a bit. But fixing that seems like a long-term issue, and at least offering something with a very similar interface to the “ideal” one as a stopgap seems like the best direction.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>That’s all I’ve got. Not my usual style of post, but I felt this was something I needed to write up.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> Soon™ • 2237 words • 18 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/wip/simd-api-notes/"> Thoughts on std::simd </a></h1> </div> <div class="post"> <p>I recently wrote an article about <a href="TODO">parsing base64 with SIMD</a>. In the process, I used it as an opportunity to evaluate Rust’s <a href="https://doc.rust-lang.org/std/simd/index.html"><code class="language-plaintext highlighter-rouge">std::simd</code></a> portable SIMD library.</p> <p>I went into this with fairly low expectations, taking it as a given that the codegen would not be as good as with direct use of intrinsics; LLVM is historically “not good” at optimizing intrinsics code, and <code class="language-plaintext highlighter-rouge">std::simd</code> code would not be using intrinsics at all.</p> <p><em>That said</em>, after using <code class="language-plaintext highlighter-rouge">std::simd</code> I think this is a really good approach. It produces great code (after tripping over some random performance footguns). Most of its issues stem from LLVM having mediocre support for some of the things Rust wants to do, or Rust emitting LLVM IR that results in selection failures, which are both fairly fixable. There’s also some rough edges in the API that I think should be fixed to make the code more readable.</p> <p>After spending <em>a lot</em> of time complaining to Jubilee, the lead for portable SIMD, we’ve agreed I should write up my findings and feedback, which is what this post is going to be.</p> <p>This is not my usual post, since it’s aimed at people with a lot of background, specifically other compiler people. I will be referring to general compiler and LLVM-specific concepts (like LLVM IR), API design, and HPC topics without much introduction. I am writing this based off of my own extensive experience writing vectorized code, compiler optimizations, and subtle algorithms that require extensive comments. These things are the main things going into my discussion here.</p> <p>With that out of the way, let’s dive into the topics in no particular order.</p> <h2 id="do-we-need-a-simd-type"><a href="#do-we-need-a-simd-type">Do We Need a <code class="language-plaintext highlighter-rouge">Simd</code> Type?</a></h2> <p>One question worth looking at is whether having <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> be distinct from <code class="language-plaintext highlighter-rouge">[T; N]</code> is worthwhile at all. The <em>main</em> reason is layout: on some weird platforms, like PPC, things like <code class="language-plaintext highlighter-rouge">[4 x i32]</code> and <code class="language-plaintext highlighter-rouge">&lt;4 x i32&gt;</code> have the same size but different alignment. There may also be endianness problems that I am not aware of; I haven’t bothered to survey this but I wouldn’t be surprised if on some BE architectures, you have</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%v</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>

<span class="c1">; Equivalent to...</span>
<span class="nv">%a</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%v</span> <span class="k">to</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span>
<span class="nv">%x</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%a</span><span class="p">,</span> <span class="m">3</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>I.e. the lanes are also in big-endian order. However, currently, Rust does not respect this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from_array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
<span class="n">vec</span><span class="nf">.as_mut_array</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

<span class="c1">// Does this print [42, 2, 3, 4] or [1, 2, 3, 42]? Depends</span>
<span class="c1">// on whether the lane layout matches [i32; 4].</span>
<span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{vec:?}"</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So we only really care about alignment (or, <code class="language-plaintext highlighter-rouge">as_mut_array()</code> has to be removed). It may be worth interrogating whether alignment matters: the big three modern CPU architectures, x86, ARM, and RISC-V, do not have “overaligned” vectors, so it’s basically a question of whether Rust emits only partially-aligned loads for vectors on “small market share” architectures. I strongly suspect this does not matter for most code, so overaligning via a <code class="language-plaintext highlighter-rouge">AlignAsIfSimd&lt;[i32; 4]&gt;</code> type might be good enough?</p> <p>The reason to ask this question is because arrays are Really Nice, syntactically. It would be very convenient to get to re-use arrays’ <code class="language-plaintext highlighter-rouge">[x, y, z]</code> and <code class="language-plaintext highlighter-rouge">[x; N]</code> syntax for free, and for existing code that uses <code class="language-plaintext highlighter-rouge">[T; N]</code> to be able to use the same vocabulary as SIMD code with minimal cognitive overhead.</p> <p>However, some other design proposals here become problematic, particularly <code class="language-plaintext highlighter-rouge">From</code> impls: for example, it is desireable for a scalar to <code class="language-plaintext highlighter-rouge">Into</code>-convert into a vector of any size via a broadcast, but <code class="language-plaintext highlighter-rouge">i32: Into&lt;[i32; 4]&gt;</code> feels problematic outside of the context of SIMD.</p> <p>I generally lean against having arrays be “the” SIMD type for this reason more than any other: it is useful to change the API available for an array-like type depending on whether it is a “list or things” or a “parallel vector of integers”.</p> <h2 id="whats-the-right-length"><a href="#whats-the-right-length">What’s the Right Length?</a></h2> <p>The <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> type has an “array-like length”, i.e., it’s in units of array elements. However, most SIMD intrinsics have a “register-like length”, where they specify the number of bits in the vector and don’t specify the type at all. For example, <code class="language-plaintext highlighter-rouge">__m256</code> represents an abstract YMM register in x86 intrinsics code.</p> <p>Both interpretations of the length are useful. For example, it is useful to have a <code class="language-plaintext highlighter-rouge">Simd&lt;u64, 4&gt;</code> and then cast it down to <code class="language-plaintext highlighter-rouge">Simd&lt;u32, 4&gt;</code> to get a vector of all the lower halves of the lanes in the <code class="language-plaintext highlighter-rouge">u64</code> vector, but it is <em>also</em> useful to be able to cast it to a <code class="language-plaintext highlighter-rouge">Simd&lt;u32, 8&gt;</code>, which interprets each <code class="language-plaintext highlighter-rouge">u64</code> lane as a pair of <code class="language-plaintext highlighter-rouge">u32</code> lanes.</p> <p>This kind of “size-preserving transmute” is very common in SIMD, particularly because some architectures’ intrinsics (Intel in particular) make it easy, since the lane width is specified on the intrinsic.</p> <p>I think that in an ideal world, it should be possible to specify both length styles. Here’s more-or-less how I’d approach it, as an API.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// mod std::simd</span>

<span class="nd">#[repr(simd)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">Length</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">N</span><span class="p">::</span><span class="n">Array</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_lanes</span><span class="p">(</span><span class="n">lanes</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsLanes</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_bits</span><span class="p">(</span><span class="n">lanes</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_lanes</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsLanes</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_bits</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Length</span><span class="p">:</span> <span class="n">Sealed</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="o">&gt;</span><span class="p">:</span> <span class="nb">Copy</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">AsLanes</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Length</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Length</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Bits</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The units are now part of the type. I think that making the type independent of the units is probably possible, but I don’t think it’s desireable. Suppose we pick the unit in the realized type to be the lane count. Then suppose we want a way to transmute a <code class="language-plaintext highlighter-rouge">Simd&lt;u32, Bits&lt;8&gt;&gt;</code> into a <code class="language-plaintext highlighter-rouge">Simd&lt;u64, Bits&lt;4&gt;&gt;</code>. How do we express this API generically? If we pick bit count as “fundamental”, we have the same trouble trying to specify <code class="language-plaintext highlighter-rouge">Simd::cast()</code>.</p> <p>Having two distinct types may lead to problems around unification, but I think this requires further study to determine potential issues. In particular, I think it is important to note that having both <code class="language-plaintext highlighter-rouge">into_lanes</code> and <code class="language-plaintext highlighter-rouge">from_lanes</code> is important, so we can make programs like the following type check:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">frob</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">N</span><span class="p">::</span><span class="n">AsBits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">Length</span><span class="p">,</span>
<span class="p">{</span>
  <span class="n">x</span><span class="nf">.into_bits</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_it</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span>
<span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Length</span><span class="p">,</span>
<span class="p">{</span>
  <span class="nn">Simd</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="nf">frob</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If we instead tried to do <code class="language-plaintext highlighter-rouge">frob(x).into_lanes()</code>, we would get something like <code class="language-plaintext highlighter-rouge">Simd&lt;T, Lanes&lt;N&gt;::AsBits&lt;N&gt;::AsLanes&lt;N&gt;&gt;</code>, which the trait solver has no way to cancel out to just <code class="language-plaintext highlighter-rouge">Simd&lt;T, Lanes&lt;N&gt;&gt;</code>. <code class="language-plaintext highlighter-rouge">Simd::from_bits</code> allows us to “undo” this.</p> <p>Mind, I think that <em>most</em> people are not going to want to write out a type like <code class="language-plaintext highlighter-rouge">Simd&lt;T, Lanes&lt;N&gt;&gt;</code> all the time, so I think some convenience aliases are in order. I think one option is something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// The core data type.</span>
<span class="nd">#[repr(simd)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">Length</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">N</span><span class="p">::</span><span class="n">Array</span><span class="p">);</span>

<span class="c1">// Array-like SIMD types.</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// "Very large integer" SIMD types, e.g. v128&lt;i32&gt;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v64</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v128</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v256</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">256</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">v512</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="mi">512</span><span class="o">&gt;&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Another option is a <code class="language-plaintext highlighter-rouge">Simd!</code> macro of some kind to make it easier to name different SIMD types. There’s definitely bikeshedding opportunities.</p> <p>Also, we need an answer for cases where the length in <code class="language-plaintext highlighter-rouge">Bits&lt;N&gt;</code> is not cleanly divisible by the element type: e.g., <code class="language-plaintext highlighter-rouge">Simd&lt;u8, Bits&lt;15&gt;&gt;</code>, <code class="language-plaintext highlighter-rouge">Simd&lt;u64, Bits&lt;32&gt;&gt;</code>. There are three choices for the semantics of this thing:</p> <ol> <li>Monomorphization error.</li> <li>Round the number of lanes down.</li> <li>Round the number of lanes up.</li> </ol> <p>This is related, but not exactly the same, as whether things like <code class="language-plaintext highlighter-rouge">Simd&lt;u64, Lanes&lt;3&gt;&gt;</code> should be supported. I think it’s hard to tell right now which of these is the best option, but my gut tells me to round down.</p> <p>Also, there is a question of what <code class="language-plaintext highlighter-rouge">Simd&lt;T, Bits&lt;N&gt;&gt;::cast()</code> should mean. Our options are either “size-preserving transmute” or “it’s not available at all”. I don’t think either is wrong; I think that the transmute operation is useful, but it should not have the same name to avoid surprises in generic code.</p> <h2 id="simd-function-name-lookup"><a href="#simd-function-name-lookup">SIMD Function Name Lookup</a></h2> <p>Right now, you’re expected to include a prelude for using most SIMD operations, such as e.g. <code class="language-plaintext highlighter-rouge">SimdUint</code>. I am not a fan of this type of API for a few reasons:</p> <ol> <li>It’s hard to discover what functions are available without digging through many traits.</li> <li>Namespace pollution from <code class="language-plaintext highlighter-rouge">use std::simd::prelude::*;</code> is not ideal, IMO.</li> <li>The APIs of functions that are introduced through traits are kind of messy.</li> </ol> <p>There is effectively no reason for these to be implemented as traits, because all of these functions are manually lowered by the compiler. For example, this is the implementation of <code class="language-plaintext highlighter-rouge">SimdInt::cast()</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[inline]</span>
<span class="k">fn</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">SimdCast</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Safety: supported types are guaranteed by SimdCast</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">intrinsics</span><span class="p">::</span><span class="nf">simd_as</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compiler directly lowers the <code class="language-plaintext highlighter-rouge">simd_as</code> intrinsic to an LLVM <code class="language-plaintext highlighter-rouge">trunc</code>, <code class="language-plaintext highlighter-rouge">sext</code>, or <code class="language-plaintext highlighter-rouge">zext</code> as needed. In my mind, there’s no particular reason this couldn’t be written as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="nd">#[inline]</span>
  <span class="k">fn</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span>
  <span class="k">where</span> <span class="n">U</span><span class="p">:</span> <span class="n">SimdCastFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Safety: supported types are guaranteed by SimdCast</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">intrinsics</span><span class="p">::</span><span class="nf">simd_as</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I think there is an interesting question to ask here whether having a separate cast for pointee types (e.g. what <code class="language-plaintext highlighter-rouge">&lt;Simd&lt;*mut i32, 4&gt; as SimdMutPtr&gt;::cast&lt;u32&gt;()</code> does today) since you could write <code class="language-plaintext highlighter-rouge">vec.cast::&lt;*mut i32&gt;()</code> instead. Currently, <code class="language-plaintext highlighter-rouge">std::simd</code> has distinct pointer cast intrinsics for SIMD, but I don’t believe there is a technical necessity here (integer casts lower as described, pointer casts are no-ops because LLVM only has the <code class="language-plaintext highlighter-rouge">ptr</code> type).</p> <p>In this way, things like <code class="language-plaintext highlighter-rouge">SimdFloat</code> and <code class="language-plaintext highlighter-rouge">SimdInt</code> are replaced with marker traits that guard against invalid calls to intrinsics, but all of the actual callable methods are inherents of <code class="language-plaintext highlighter-rouge">Simd</code>.</p> <p>There are also a handful of functions that would otherwise clash with trait methods from built-in types. For example, lanewise-eq is <code class="language-plaintext highlighter-rouge">simd_eq</code>, because if it was named <code class="language-plaintext highlighter-rouge">eq</code> it would be ambiguous with <code class="language-plaintext highlighter-rouge">PartialEq::eq</code>.</p> <p>But, if instead <code class="language-plaintext highlighter-rouge">simd_eq</code> were inherent, this would not be a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">Mask</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="nb">PartialEq</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Inherent methods always win against trait methods, so <code class="language-plaintext highlighter-rouge">a.eq(b)</code> could coexist with <code class="language-plaintext highlighter-rouge">a == b</code>. There is definitely argument to be made that shadowing well-known trait methods in a standard API is kinda rude, although I counter that no one ever means <code class="language-plaintext highlighter-rouge">PartialEq::eq()</code> when they want to compare two SIMD vectors.</p> <h2 id="gatherscatter"><a href="#gatherscatter">Gather/Scatter</a></h2> <p>The current state of gather/scatter isn’t very good. Rust lowers these to the <code class="language-plaintext highlighter-rouge">load T, &lt;n x ptr&gt;</code> and <code class="language-plaintext highlighter-rouge">store T, &lt;n x ptr&gt;</code> instructions, which produce mediocre code, since LLVM has trouble remembering what relationship these pointers had to each other.</p> <p>I think the current gather/scatter functions should be removed, and replaced with the following more basic primitives.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="k">self</span><span class="nf">.read_masked</span><span class="p">(</span><span class="nn">Mask</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="k">true</span><span class="p">),</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">read_masked</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">isize</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="k">self</span><span class="nf">.write_masked</span><span class="p">(</span><span class="nn">Mask</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="k">true</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">write_masked</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">isize</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Existing gather/scatter operations all lower into something resembling these anyways, and they should be a fairly uncommon operation, so it seems better to provide just the primitive and wait to see what users wind up requesting.</p> <p>What many users <em>actually</em> want when they do a gather is to load localized data in some shuffled order, which is best realized as a load + shuffle.</p> <p>However, <code class="language-plaintext highlighter-rouge">Simd::from_slice()</code> requires that the input slice be no smaller than the vector being loaded, so it can always lower to a single load instruction. This is fine, but there probably needs to be a <code class="language-plaintext highlighter-rouge">Simd::prefix_from_slice()</code> that performs loads less than a full vector of memory. Highly efficient techniques exist for implementing such functions, which perform an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> number of loads and branches; see <a href="https://github.com/mcy/vb64/blob/main/src/lib.rs#L230"><code class="language-plaintext highlighter-rouge">vb64</code>’s padded load implementation</a>.</p> <p>Once users have loaded the localized data into a vector, they can shuffle it as needed. The API should try to steer users away from general gather/scatter where possible, since it’s a performance footgun.</p> <h2 id="arguments-to-simd-operations"><a href="#arguments-to-simd-operations">Arguments To SIMD Operations</a></h2> <p>Certain operations are very, very wordy, because SIMD operations only operate on SIMD vectors. For example, I have a helper function like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">mask_splat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">Mask</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span> <span class="o">+</span> <span class="nb">Default</span><span class="p">,</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="n">mask</span><span class="nf">.select</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Ideally, though, it would have been good to be able to just write <code class="language-plaintext highlighter-rouge">mask.select(val, 0)</code> and be done with it.</p> <p>I think the best approach is to observe that <code class="language-plaintext highlighter-rouge">Simd::splat</code> is the canonical conversion from scalar to vector. For a lot of operations mixed vector and scalar arguments, where the scalars are implicitly splatted, make a lot of sense classically. The most well-known example is scalar multiplication, e.g. <code class="language-plaintext highlighter-rouge">Simd&lt;f32, 4&gt; * f32</code>, but I think it’s a valid conversion for virtually every SIMD operation.</p> <p>In other words, I think that <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> should be <code class="language-plaintext highlighter-rouge">From&lt;N::Array&lt;T&gt;&gt;</code> and <code class="language-plaintext highlighter-rouge">From&lt;T&gt;</code>, and every function on <code class="language-plaintext highlighter-rouge">Simd</code> that takes a <code class="language-plaintext highlighter-rouge">Simd&lt;T, N&gt;</code> should instead take an <code class="language-plaintext highlighter-rouge">impl Into&lt;Simd&lt;T, N&gt;&gt;</code>.</p> <p>I think this is very important for readability: redundant calls to <code class="language-plaintext highlighter-rouge">Simd::splat</code> get in the way of the essential character of the code.</p> <p>Separately, I think that it would be good to expand the scope of existing “array construction” primitives. The following function, for example, makes it easier to build e.g. shuffle index vectors, which are commonly “stripped”.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">tile</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">uninit</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="n">uninit</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="k">self</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cycle</span><span class="p">())</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">b</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="n">uninit</span><span class="nf">.assume_init</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This would make it really easy to write e.g. <code class="language-plaintext highlighter-rouge">table.swizzle_dyn([x, y, z].tile())</code>.</p> <h2 id="shuffling-operations"><a href="#shuffling-operations">Shuffling Operations</a></h2> <p>My understanding is that the <code class="language-plaintext highlighter-rouge">Swizzle</code> and <code class="language-plaintext highlighter-rouge">Swizzle2</code> traits, as they exist, are going away. I think that’s a good step forward but there’s a few issues with shuffles worth considering.</p> <p>My pony for shuffles is that we can have a single operation like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;...&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="n">lookup_in_table</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">K</span><span class="p">],</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">Lanes</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span>
  <span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">SimdUint</span><span class="p">,</span>
    <span class="n">U</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span> <span class="n">Length</span>
  <span class="p">{</span>
    <span class="c1">// Intrinsics call.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Essentially the intent here is that <code class="language-plaintext highlighter-rouge">self</code> is a vector of <code class="language-plaintext highlighter-rouge">N</code> indices, which we use to select <code class="language-plaintext highlighter-rouge">N</code> values from the provided lookup table. This generalizes <code class="language-plaintext highlighter-rouge">Swizzle</code>, <code class="language-plaintext highlighter-rouge">Swizzle2</code>, and <code class="language-plaintext highlighter-rouge">swizzle_dyn</code>. The semantics are: <code class="language-plaintext highlighter-rouge">[Simd&lt;U, M&gt;; K]</code> is interpreted as an array <code class="language-plaintext highlighter-rouge">[U; M::Array&lt;U&gt;.len() * K]</code>; elements from <code class="language-plaintext highlighter-rouge">self</code> are indices in this matrix; out-of-bound values produce zero (or equivalent).</p> <p>The “main” issue here is that we really want this to lower to an LLVM <code class="language-plaintext highlighter-rouge">shufflevector</code> when possible, since that can be optimized better, but it requires that the argument be an immediate. I don’t know how good MIR-opt is at constant folding these days.</p> <p>Part of the problem is that LLVM does not have a general “shuffle with dynamic index vector” intrinsic, and instead relegates users to the architecture-specific shuffles. Currently, the Rust standard library does selection itself, rather than letting the compiler do it, which is part of the problem.</p> <p>I’m not sure what the cleanest way out of this is right now. One way to achieve it might be to introduce something like</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#![feature(adt_const_params)]</span>
<span class="nd">#![feature(generic_const_exprs)]</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Indices</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ARRAY</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="p">[</span><span class="nb">usize</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ARRAY</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="p">[</span><span class="nb">usize</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">Indices</span><span class="o">&lt;</span><span class="n">ARRAY</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">lookup_in_table</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">K</span><span class="p">],</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="p">{</span> <span class="n">ARRAY</span><span class="nf">.len</span><span class="p">()</span> <span class="p">}</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="n">U</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span>
    <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
    <span class="n">LaneCount</span><span class="o">&lt;</span><span class="p">{</span> <span class="n">ARRAY</span><span class="nf">.len</span><span class="p">()</span> <span class="p">}</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="nd">todo!</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Then, you could write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nn">simd</span><span class="p">::</span><span class="n">Indices</span><span class="o">&lt;</span><span class="p">{</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="p">}</span><span class="o">&gt;</span><span class="nf">.lookup_in_table</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This ensures that the index vector is an immediate, which simplifies selection.</p> <p>In my opinion, this shouldn’t even have to exist, and LLVM should be able to “just deal with it” by offering an <code class="language-plaintext highlighter-rouge">@llvm.vector.shuffle.vNT</code> intrinsic that it knows it can promote to a <code class="language-plaintext highlighter-rouge">shufflevector</code> after it’s constant-folded and GVN’d a bit. But fixing that seems like a long-term issue, and at least offering something with a very similar interface to the “ideal” one as a stopgap seems like the best direction.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>That’s all I’ve got. Not my usual style of post, but I felt this was something I needed to write up.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>