<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> The Rust Calling Convention We Need But Don't Deserve &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="The Rust Calling Convention We Need But Don't Deserve &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/calling-convention-8a7792bd7e34bda30547b67f0fe0cbc455e05d40.png"> <meta property="og:title" content="The Rust Calling Convention We Need But Don't Deserve &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/calling-convention-8a7792bd7e34bda30547b67f0fe0cbc455e05d40.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/wip/calling-convention/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz/posts"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/posts"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> Soon™ • 2335 words • 12 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/wip/calling-convention/"> The Rust Calling Convention We Need But Don't Deserve </a></h1> </div> <div class="post"> <p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>As a result, we get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span> <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>This isn’t the half of it: Rust could be producing <em>vastly</em> better ABI code than Clang. Hereforth, I will describe how to do it.</p> <p>Some caveats. I am assuming this theoretical new calling convention is only used on some targets, such as the venerable <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code>. These are targets for which LLVM has a concept of “input registers” and “output registers”.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following rules. First, we need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of).</p> <p>The above values are for x86. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>Incidentally, we have fine-grained control of which registers an input winds up in. For example, on x86, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we can just pass it as the fourth <code class="language-plaintext highlighter-rouge">i64</code>/<code class="language-plaintext highlighter-rouge">ptr</code> argument, and pass <code class="language-plaintext highlighter-rouge">poison</code> as the first three.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@by_rcx</span><span class="p">([</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="err">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span> <span class="n">malloc</span>
  <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">pop</span> <span class="n">rax</span>
  <span class="n">jmp</span> <span class="n">by_rcx</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any way. And as we see, <code class="language-plaintext highlighter-rouge">by_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, and <code class="language-plaintext highlighter-rouge">rdx</code> compiles down to nothing, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, as far as I know, there’s no way to convince LLVM to pass arguments via <code class="language-plaintext highlighter-rouge">rax</code>, but we can simply pretend that <code class="language-plaintext highlighter-rouge">rdx</code> is the “primary” register to avoid the annoying <code class="language-plaintext highlighter-rouge">mov rdi, rax</code> for forwarding the return value of a function as an argument.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="vg">@square</span><span class="p">([</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%1</span><span class="p">,</span> <span class="nv">%1</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="nv">%4</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">ARM Assembly</div></div></div> </div> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <h2 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h2> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>Generally, most ABI allocation algorithms will take each argument type and classify it: is this an integer, a float, a vector, or something that I need to pass by reference? Based on this, it will allocate registers to arguments, from left to right.</p> <p>Right now, Rust is fairly conservative: anything larger than two pointers is passed by reference, and unions are always passed by reference. Given that we have a <em>much</em> larger space for allocating arguments to, we should instead “do what Go does,” as I often say.</p> <ol> <li> <p>Decide which arguments are too big to pass entirely in registers. Doing this optimally is the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, and thus NP-hard. As an ansatz, it’s probably good enough to sort the arguments by effective size<sup id="fnref:effective-size" role="doc-noteref"><a href="#fn:effective-size" class="footnote" rel="footnote">1</a></sup>, and pick arguments off of the list until we run out of space among the registers.</p> </li> <li> <p>Among the arguments we intend to pass in registers, we perform the following:</p> <ol> <li> <p>Put all of them in a big, unpacked struct.</p> </li> <li> <p>Replace all <code class="language-plaintext highlighter-rouge">union</code>s with a <code class="language-plaintext highlighter-rouge">u8</code> array equal to the union’s actual size, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">2</a></sup>.</p> </li> <li> <p>Replace enum discriminants with the smallest non-power-of-two integer type that fits it. For example, an <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> winds up getting replaced with a <code class="language-plaintext highlighter-rouge">(i1, i32)</code>, since the discriminant is only one bit.</p> </li> <li> <p>Split all “non-native” primitive types. This means replacing a <code class="language-plaintext highlighter-rouge">u128</code> with a <code class="language-plaintext highlighter-rouge">[u64; 2]</code>s, or, on a 32-bit architecture, a <code class="language-plaintext highlighter-rouge">f64</code> into a <code class="language-plaintext highlighter-rouge">[u32; 2]</code>. This ensures that every non-aggregate type is only as large as the smallest available register.</p> </li> <li> <p>Flatten out the struct completely (treating arrays and SIMD vectors as tuples), so that every field is either an integer, <code class="language-plaintext highlighter-rouge">bool</code>, a pointer/reference, a float, or a union. This also deletes all zero-sized types.</p> </li> <li> <p>Stable-sort the fields by decreasing effective size.</p> </li> <li> <p>Bin-pack fields into the registers, treating the input registers as a large array. Fields should be packed such that a single field does not straddle multiple registers. <code class="language-plaintext highlighter-rouge">bool</code>s are bit-packed. This is done to minimize the work in the callee and caller to pack and unpack values from registers.</p> </li> </ol> </li> <li> <p>Among the rest of the arguments, replace any argument larger than two pointers with a reference to the argument: the caller is responsible for spilling the argument to the stack and passing this pointer. Then, pass these arguments on the stack (in LLVM terms, add them as extra arguments).</p> </li> </ol> <p>Here’s a simple example. My Rust function is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_thing</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span> <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>After sorting and flattening, our raw argument LLVM type is something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When we bin them into x86 registers, we get something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">rdi -&gt; i64
       |
       payload(op_count)

rsi -&gt; ptr
       |
       data(context)

rdx -&gt; ptr
       |
       vtable(context)

rcx -&gt; ptr
       |
       ptr(name)

r8  -&gt; i64
       |
       len(name)

r9  -&gt; i32, i32
       |    |
       options.retries
            |
            code[0]

xmm0 -&gt; i32, i1, i1, i1, i1, i92
        |    |   |   |   |   |
        code[1]  |   |   |   unused
             |   |   |   |
             discriminant(op_count)
                 |   |   |
                 options.colorize
                     |   |
                     options.verbose_debug
                         |
                         options.allow_spurious_failure</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>All of our inputs fit into registers! On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what <em>returns</em> could look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does!). We have already compiled all of our dependencies “a little bit”, enough that we have seen the function bodies<sup id="fnref:extern-rust" role="doc-noteref"><a href="#fn:extern-rust" class="footnote" rel="footnote">3</a></sup>, meaning that a crate can advertise the precise ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABI. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it. This may not make sense to turn on below -O2, since that <em>will</em> mess with debuggability.</p> <p>Another example: if we know that the address of a shared reference argument is never used (for example, it is not retained and is never converted into a raw pointer), and the reference’s pointee is a pointer or smaller, we can replace the reference with the pointee directly.</p> <p>The most visible candidate for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is another option. We might know that some arguments are hotter than others, which might cause them to be promoted to being passed by register.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. I don’t actually think that the way the Rust project engages with compilation time is healthy for the project – suffice to say that I don’t think this is an <em>interesting</em> argument against a more complicated ABI.</p> <p>Hopefully the stars will align some day and we can develop an ever more audacious unspecified calling convention.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:effective-size" role="doc-endnote"> <p>I.e., the number of bits <em>actually</em> occupied. This allows us to discard padding bytes and the high bits of a <code class="language-plaintext highlighter-rouge">bool</code>. <a href="#fnref:effective-size" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:extern-rust" role="doc-endnote"> <p>Rust allows you to declare undefined functions that use the Rust ABI, like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">my_function</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This <em>seems</em> to get in the way, but it doesn’t. You can only call functions with unmangled names through <code class="language-plaintext highlighter-rouge">extern "Rust"</code>, so we will treat <code class="language-plaintext highlighter-rouge">#[nomangle] extern "Rust"</code> functions has having their own weird little ABI where we cannot make assumptions that a function’s body is visible to the compiler before it is called. <a href="#fnref:extern-rust" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> Soon™ • 2335 words • 12 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/wip/calling-convention/"> The Rust Calling Convention We Need But Don't Deserve </a></h1> </div> <div class="post"> <p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>As a result, we get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span> <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>This isn’t the half of it: Rust could be producing <em>vastly</em> better ABI code than Clang. Hereforth, I will describe how to do it.</p> <p>Some caveats. I am assuming this theoretical new calling convention is only used on some targets, such as the venerable <code class="language-plaintext highlighter-rouge">x86_64-unknown-linux</code>. These are targets for which LLVM has a concept of “input registers” and “output registers”.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following rules. First, we need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of).</p> <p>The above values are for x86. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>Incidentally, we have fine-grained control of which registers an input winds up in. For example, on x86, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we can just pass it as the fourth <code class="language-plaintext highlighter-rouge">i64</code>/<code class="language-plaintext highlighter-rouge">ptr</code> argument, and pass <code class="language-plaintext highlighter-rouge">poison</code> as the first three.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@by_rcx</span><span class="p">([</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="err">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span> <span class="n">malloc</span>
  <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">pop</span> <span class="n">rax</span>
  <span class="n">jmp</span> <span class="n">by_rcx</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any way. And as we see, <code class="language-plaintext highlighter-rouge">by_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, and <code class="language-plaintext highlighter-rouge">rdx</code> compiles down to nothing, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, as far as I know, there’s no way to convince LLVM to pass arguments via <code class="language-plaintext highlighter-rouge">rax</code>, but we can simply pretend that <code class="language-plaintext highlighter-rouge">rdx</code> is the “primary” register to avoid the annoying <code class="language-plaintext highlighter-rouge">mov rdi, rax</code> for forwarding the return value of a function as an argument.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="vg">@square</span><span class="p">([</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%1</span><span class="p">,</span> <span class="nv">%1</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="nv">%4</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">[</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">ARM Assembly</div></div></div> </div> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <h2 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h2> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>Generally, most ABI allocation algorithms will take each argument type and classify it: is this an integer, a float, a vector, or something that I need to pass by reference? Based on this, it will allocate registers to arguments, from left to right.</p> <p>Right now, Rust is fairly conservative: anything larger than two pointers is passed by reference, and unions are always passed by reference. Given that we have a <em>much</em> larger space for allocating arguments to, we should instead “do what Go does,” as I often say.</p> <ol> <li> <p>Decide which arguments are too big to pass entirely in registers. Doing this optimally is the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, and thus NP-hard. As an ansatz, it’s probably good enough to sort the arguments by effective size<sup id="fnref:effective-size" role="doc-noteref"><a href="#fn:effective-size" class="footnote" rel="footnote">1</a></sup>, and pick arguments off of the list until we run out of space among the registers.</p> </li> <li> <p>Among the arguments we intend to pass in registers, we perform the following:</p> <ol> <li> <p>Put all of them in a big, unpacked struct.</p> </li> <li> <p>Replace all <code class="language-plaintext highlighter-rouge">union</code>s with a <code class="language-plaintext highlighter-rouge">u8</code> array equal to the union’s actual size, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">2</a></sup>.</p> </li> <li> <p>Replace enum discriminants with the smallest non-power-of-two integer type that fits it. For example, an <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> winds up getting replaced with a <code class="language-plaintext highlighter-rouge">(i1, i32)</code>, since the discriminant is only one bit.</p> </li> <li> <p>Split all “non-native” primitive types. This means replacing a <code class="language-plaintext highlighter-rouge">u128</code> with a <code class="language-plaintext highlighter-rouge">[u64; 2]</code>s, or, on a 32-bit architecture, a <code class="language-plaintext highlighter-rouge">f64</code> into a <code class="language-plaintext highlighter-rouge">[u32; 2]</code>. This ensures that every non-aggregate type is only as large as the smallest available register.</p> </li> <li> <p>Flatten out the struct completely (treating arrays and SIMD vectors as tuples), so that every field is either an integer, <code class="language-plaintext highlighter-rouge">bool</code>, a pointer/reference, a float, or a union. This also deletes all zero-sized types.</p> </li> <li> <p>Stable-sort the fields by decreasing effective size.</p> </li> <li> <p>Bin-pack fields into the registers, treating the input registers as a large array. Fields should be packed such that a single field does not straddle multiple registers. <code class="language-plaintext highlighter-rouge">bool</code>s are bit-packed. This is done to minimize the work in the callee and caller to pack and unpack values from registers.</p> </li> </ol> </li> <li> <p>Among the rest of the arguments, replace any argument larger than two pointers with a reference to the argument: the caller is responsible for spilling the argument to the stack and passing this pointer. Then, pass these arguments on the stack (in LLVM terms, add them as extra arguments).</p> </li> </ol> <p>Here’s a simple example. My Rust function is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_thing</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span> <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>After sorting and flattening, our raw argument LLVM type is something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When we bin them into x86 registers, we get something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">rdi -&gt; i64
       |
       payload(op_count)

rsi -&gt; ptr
       |
       data(context)

rdx -&gt; ptr
       |
       vtable(context)

rcx -&gt; ptr
       |
       ptr(name)

r8  -&gt; i64
       |
       len(name)

r9  -&gt; i32, i32
       |    |
       options.retries
            |
            code[0]

xmm0 -&gt; i32, i1, i1, i1, i1, i92
        |    |   |   |   |   |
        code[1]  |   |   |   unused
             |   |   |   |
             discriminant(op_count)
                 |   |   |
                 options.colorize
                     |   |
                     options.verbose_debug
                         |
                         options.allow_spurious_failure</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>All of our inputs fit into registers! On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what <em>returns</em> could look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does!). We have already compiled all of our dependencies “a little bit”, enough that we have seen the function bodies<sup id="fnref:extern-rust" role="doc-noteref"><a href="#fn:extern-rust" class="footnote" rel="footnote">3</a></sup>, meaning that a crate can advertise the precise ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABI. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it. This may not make sense to turn on below -O2, since that <em>will</em> mess with debuggability.</p> <p>Another example: if we know that the address of a shared reference argument is never used (for example, it is not retained and is never converted into a raw pointer), and the reference’s pointee is a pointer or smaller, we can replace the reference with the pointee directly.</p> <p>The most visible candidate for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is another option. We might know that some arguments are hotter than others, which might cause them to be promoted to being passed by register.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. I don’t actually think that the way the Rust project engages with compilation time is healthy for the project – suffice to say that I don’t think this is an <em>interesting</em> argument against a more complicated ABI.</p> <p>Hopefully the stars will align some day and we can develop an ever more audacious unspecified calling convention.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:effective-size" role="doc-endnote"> <p>I.e., the number of bits <em>actually</em> occupied. This allows us to discard padding bytes and the high bits of a <code class="language-plaintext highlighter-rouge">bool</code>. <a href="#fnref:effective-size" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:extern-rust" role="doc-endnote"> <p>Rust allows you to declare undefined functions that use the Rust ABI, like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">my_function</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This <em>seems</em> to get in the way, but it doesn’t. You can only call functions with unmangled names through <code class="language-plaintext highlighter-rouge">extern "Rust"</code>, so we will treat <code class="language-plaintext highlighter-rouge">#[nomangle] extern "Rust"</code> functions has having their own weird little ABI where we cannot make assumptions that a function’s body is visible to the compiler before it is called. <a href="#fnref:extern-rust" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>