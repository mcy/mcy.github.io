<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2025-03-11 • 3738 words • 31 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> • <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> • <a href="https://mcyoung.xyz/tags.html#frontend">#frontend</a> </span> <h1><a href="/2025/03/11/formatters/"> The Art of Formatting Code </a></h1> </div> <div class="post"> <p>Every modern programming language needs a <em>formatter</em> to make your code look pretty and consistent. Formatters are source-transformation tools that parse source code and re-print the resulting AST in some canonical form that normalizes whitespace and optional syntactic constructs. They remove the tedium of matching indentation and brace placement to match a style guide.</p> <p>Go is particularly well-known for providing a formatter as part of its toolchain from day one. It is not a <em>good</em> formatter, though, because it cannot enforce a maximum column width. Later formatters of the 2010s, such as rustfmt and clang-format, do provide this feature, which ensure that individual lines of code don’t get too long.</p> <p>The reason Go doesn’t do this is because the naive approach to formatting code makes it intractable to do so. There are many approaches to implementing this, which can make it seem like a very complicated layout constraint solving problem.</p> <p>So what’s so tricky about formatting code? Aren’t you just printing out an AST?</p> <h2 id="just-an-ast"><a href="#just-an-ast">“Just” an AST</a></h2> <p>An AST<sup id="fnref:pronunciation" role="doc-noteref"><a href="#fn:pronunciation" class="footnote" rel="footnote">1</a></sup> (abstract syntax tree) is a graph representation of a program’s syntax. Let’s consider something like JSON, whose naively-defined AST type might look something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The AST for the document <code class="language-plaintext highlighter-rouge">{"foo": null, "bar": 42}</code> might look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_doc</span> <span class="o">=</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Object</span><span class="p">([</span>
  <span class="p">(</span><span class="s">"foo"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span><span class="p">),</span>
  <span class="p">(</span><span class="s">"bar"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mi">42</span><span class="p">)),</span>
<span class="p">]</span><span class="nf">.into</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This AST has some pretty major problems. A formatter must <em>not</em> change the syntactic structure of the program (beyond removing things like redundant braces). Formatting must also be deterministic.</p> <p>First off, <code class="language-plaintext highlighter-rouge">Json::Object</code> is a <code class="language-plaintext highlighter-rouge">HashMap</code>, which is unordered. So it will immediately discard the order of the keys. <code class="language-plaintext highlighter-rouge">Json::String</code> does not retain the escapes from the original string, so <code class="language-plaintext highlighter-rouge">"\n"</code> and <code class="language-plaintext highlighter-rouge">"\u000a"</code> are indistinguishable. <code class="language-plaintext highlighter-rouge">Json::Number</code> will destroy information: JSON numbers can specify values outside of the <code class="language-plaintext highlighter-rouge">f64</code> representable range, but converting to <code class="language-plaintext highlighter-rouge">f64</code> will quantize to the nearest float.</p> <p>Now, JSON doesn’t have comments, but if it did, our AST has no way to record it! So it would destroy all comment information! Plus, if someone has a document that separates keys into stanzas<sup id="fnref:stanza" role="doc-noteref"><a href="#fn:stanza" class="footnote" rel="footnote">2</a></sup>, as shown below, this information is lost too.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"this"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my first stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"second"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="p">,</span><span class="w">

  </span><span class="nl">"here"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my second stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fourth"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Truth is, the AST for virtually all competent toolchains are much more complicated than this. Here’s some important properties an AST needs to have to be useful.</p> <ol> <li> <p>Retain <em>span</em> information. Every node in the graph remembers what piece of the file it was parsed from.</p> </li> <li> <p>Retain whitespace information. “Whitespace” typically includes both whitespace characters, and comments.</p> </li> <li> <p>Retain ordering information. The children of each node need to be stored in ordered containers.</p> </li> </ol> <p>The first point is achieved in a number of ways, but boils down to somehow associating to each token a pair of integers<sup id="fnref:offsets" role="doc-noteref"><a href="#fn:offsets" class="footnote" rel="footnote">3</a></sup>, identifying the start and end offsets of the token in the input file.</p> <p>Given the span information for each token, we can then define the span for each node to be the <em>join</em> of its tokens’ spans, namely the start is the min of its constituent tokens’ starts and its end is the max of the ends. This can be easily calculated recursively.</p> <p>Once we have spans, it’s easy to recover the whitespace between any two adjacent syntactic constructs by calculating the text between them. This approach is more robust than, say, associating each comment with a specific token, because it makes it easier to discriminate stanzas for formatting.</p> <p>Being able to retrieve the comments between any two syntax nodes is crucial. Suppose the user writes the following Rust code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">false</span> <span class="o">&amp;&amp;</span> <span class="c1">// HACK: disable this check.</span>
  <span class="nf">some_complicated_check</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If we’re formatting the binary expression containing the <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, and we can’t query for comments between the LHS and the operator, or the operator and the RHS, the <code class="language-plaintext highlighter-rouge">// HACK</code> comment will get deleted on format, which is pretty bad!</p> <p>An AST that retains this level of information is sometimes called a “concrete syntax tree”. I do not consider this a useful distinction, because any useful AST must retain span and whitespace information, and it’s kind of pointless to implement the same AST more than once. To me, an AST without spans is incomplete.</p> <h3 id="updating-our-json-ast"><a href="#updating-our-json-ast">Updating Our JSON AST</a></h3> <p>With all this in mind, the bare minimum for a “good” AST is gonna be something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are various layout optimizations we can do: for example, the vast majority of strings exist literally in the original file, so there’s no need to copy them into a <code class="language-plaintext highlighter-rouge">String</code>; it’s only necessary if the string contains escapes. My <code class="language-plaintext highlighter-rouge">byteyarn</code> crate, which I wrote about <a href="https://mcyoung.xyz/2023/08/09/yarns">here</a>, is meant to make handling this case easy. So we might rewrite this to be lifetime-bound to the original file.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>But wait, there’s some things that don’t have spans here. We need to include spans for the braces of <code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">Object</code>, their commas, and the colons on object keys. So what we actually get is something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Span</span> <span class="p">{</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>

  <span class="n">Array</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ArrayEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ObjectEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ArrayEntry</span> <span class="p">{</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ObjectEntry</span> <span class="p">{</span>
  <span class="n">key</span><span class="p">:</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Implementing an AST is one of my least favorite parts of writing a toolchain, because it’s tedious to ensure all of the details are recorded and properly populated.</p> <h2 id="just-printing-an-ast"><a href="#just-printing-an-ast">“Just” Printing an AST</a></h2> <p>In Rust, you can easily get a nice recursive print of any struct using the <code class="language-plaintext highlighter-rouge">#[derive(Debug)]</code> construct. This is implemented by recursively calling <code class="language-plaintext highlighter-rouge">Debug::fmt()</code> on the elements of a struct, but passing modified <code class="language-plaintext highlighter-rouge">Formatter</code> state to each call to increase the indentation level each time.</p> <p>This enables printing nested structs in a way that looks like Rust syntax when using the <code class="language-plaintext highlighter-rouge">{:#?}</code> specifier.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Foo</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">baz</span><span class="p">:</span> <span class="n">Baz</span> <span class="p">{</span>
    <span class="n">quux</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We can implement a very simple formatter for our JSON AST by walking it recursively.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="p">,</span> <span class="n">json</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Json</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="o">&amp;</span><span class="n">json</span><span class="py">.kind</span> <span class="p">{</span>
    <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="c1">// Preserve the input exactly.</span>
      <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">json</span><span class="py">.span.start</span><span class="o">..</span><span class="n">json</span><span class="py">.span.end</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'['</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">']'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'{'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Preserve the key exactly.</span>
        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">entry</span><span class="py">.key_span.start</span><span class="o">..</span><span class="n">entry</span><span class="py">.key_span.end</span><span class="p">]);</span>

        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">": "</span><span class="p">);</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'}'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is essentially what every JSON serializer’s “pretty” mode looks like. It’s linear, it’s simple. But it has one big problem: small lists.</p> <p>If I try to format the document <code class="language-plaintext highlighter-rouge">{"foo": []}</code> using this routine, the output will be</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>This is pretty terrible, but easy to fix by adding a special case:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">entries</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"[]"</span><span class="p">);</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this doesn’t handle the similar case of a small but non-empty list. <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> formats as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="mi">2</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Really, we’d like to keep <code class="language-plaintext highlighter-rouge">"foo": [1, 2]</code> on one line. And now we enter the realm of column wrapping.</p> <h2 id="how-wide-is-a-codepoint"><a href="#how-wide-is-a-codepoint">How Wide Is a Codepoint?</a></h2> <p>The whole point of a formatter is to work with <em>monospaced text</em>, which is text formatted using a monospaced or <em>fixed-width</em> typeface, which means each character is the same width, leading to the measure of the width of lines in <em>columns</em>.</p> <p>So how many columns does the string <code class="language-plaintext highlighter-rouge">cat</code> take up? Three, pretty easy. But we obviously don’t want to count bytes, this isn’t 1971. If we did, <code class="language-plaintext highlighter-rouge">кішка</code>, when UTF-8 encoded, it would be 10, rather than 5 columns wide. So we seem to want to count Unicode characters instead?</p> <p>Oh, but what <em>is</em> a Unicode character? Well, we could say that you’re counting Unicode scalar values (what Rust’s <code class="language-plaintext highlighter-rouge">char</code> and Go’s <code class="language-plaintext highlighter-rouge">rune</code>) types represent. Or you could count grapheme clusters (like Swift’s <code class="language-plaintext highlighter-rouge">Character</code>).</p> <p>But that would give wrong answers. CJK languages’ characters, such as <code class="language-plaintext highlighter-rouge">猫</code>, usually want to be rendered as <em>two</em> columns, even in monospaced contexts. So, you might go to Unicode and discover <a href="https://www.unicode.org/reports/tr11/">UAX#11</a>, and attempt to use it for assigning column widths. But it turns out that the precise rules that monospaced fonts use are not written down in a single place in Unicode. You would also discover that some scripts, such as Arabic, have complex ligature rules that mean that the width of a single character depends on the characters around it.</p> <p>This is a place where you should hunt for a library. <a href="https://docs.rs/unicode-width/latest/unicode_width/#rules-for-determining-width"><code class="language-plaintext highlighter-rouge">unicode_width</code></a> is the one for Rust. Given that Unicode segmentation is a closely associated operation to width, segmentation libraries are a good place to look for a width calculation routine.</p> <p>But most such libraries will still give wrong answers, because of tabs. The tab character <code class="language-plaintext highlighter-rouge">U+0009 CHARACTER TABULATION</code>’s width depends on the width of all characters before it, because a tab is as wide as needed to reach the next <em>tabstop</em>, which is a column position an integer multiple of the <em>tab width</em> (usually 2, 4, or, on most terminals, 8).</p> <p>With a tab width of 4, <code class="language-plaintext highlighter-rouge">"\t"</code>, <code class="language-plaintext highlighter-rouge">"a\t"</code>, and <code class="language-plaintext highlighter-rouge">"abc\t"</code> are all four columns wide. Depending on the context, you will either want to treat tabs as behaving as going to the next tabstop (and thus being variable width), or having a fixed width. The former is necessary for assigning correct column numbers in diagnostics, but we’ll find that the latter is a better match for what we’re doing.</p> <p>The reason for being able to calculate the width of a string is to enable line wrapping. At some point in the 2010s, people started writing a lot of code on laptops, where it is not easy to have two editors side by side on the small screen. This removes the motivation to wrap all lines at 80 columns<sup id="fnref:80-cols" role="doc-noteref"><a href="#fn:80-cols" class="footnote" rel="footnote">4</a></sup>, which in turn results in lines that tend to get arbitrarily long.</p> <p>Line wrapping helps ensure that no matter how wide everyone’s editors are, the code <em>I</em> have to read fits on my very narrow editors.</p> <h2 id="accidentally-quadratic"><a href="#accidentally-quadratic">Accidentally Quadratic</a></h2> <p>A lot of folks’ first formatter recursively formats a node by formatting its children to determine if they fit on one line or not, and based on that, and their length if they are single-line, determine if their parent should break.</p> <p>This is a naive approach, which has several disadvantages. First, it’s very easy to accidentally backtrack, trying to only break smaller and smaller subexpressions until things fit on one line, which can lead to quadratic complexity. The logic for whether a node can break is bespoke per node and that makes it easy to make mistakes.</p> <p>Consider formatting <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>. In our AST, this will look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">ObjectEntry</span> <span class="p">{</span>
      <span class="n">key</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
      <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span>
      <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">5</span> <span class="p">},</span>
      <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">9</span> <span class="p">},</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
          <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">11</span> <span class="p">}),</span>
            <span class="p">},</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">s</span><span class="na">.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">13</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">],</span>
        <span class="p">},</span>
        <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}],</span>
  <span class="p">},</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>To format the whole document, we need to know the width of each field in the object to decide whether the object fits on one line. To do that, we need to calculate the width of each value, and add to it the width of the key, and the width of the <code class="language-plaintext highlighter-rouge">: </code> separating them.</p> <p>How can this be accidentally quadratic? If we simply say “format this node” to obtain its width, that will recursively format all of the children it contains without introducing line breaks, performing work that is linear in how many transitive children that node contains. Having done this, we can now decide if we need to introduce line breaks or not, which increases the indentation at which the children are rendered. This means that the children cannot know ahead of time how much of the line is left for them, so we need to recurse into formatting them again, now knowing the indentation at which the direct children are rendered.</p> <p>Thus, each node performs work equal to the number of nodes beneath it. This has resulted in many slow formatters.</p> <p>Now, you could be more clever and have each node be capable of returning its width based on querying its children’s width directly, but that means you need to do complicated arithmetic for each node that needs to be synchronized with the code that actually formats it. Easy to make mistakes.</p> <p>The solution is to invent some kind of model for your document that specifies how lines should be broken if necessary, and which tracks layout information so that it can be computed in one pass, and then used in a second pass to figure out whether to actually break lines or not.</p> <p>This is actually how HTML works. The markup describes constraints on the layout of the content, and then a layout engine, over several passes, calculates sizes, solves constraints, and finally produces a raster image representing that HTML document. Following the lead of HTML, we can design…</p> <h2 id="a-dom-for-your-code"><a href="#a-dom-for-your-code">A DOM for Your Code</a></h2> <p>The HTML DOM is a markup document: a tree of tags where each tag has a type, such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;hr&gt;</code>, or <code class="language-plaintext highlighter-rouge">&lt;strong&gt;</code>, properties, such as <code class="language-plaintext highlighter-rouge">&lt;a href=...&gt;</code>, and content consisting of nested tags (and bare text, which every HTML engine just handles as a special kind of tag), such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;Hello &lt;em&gt;World&lt;/em&gt;!&lt;/p&gt;</code>.</p> <p>We obviously want to have a tag for text that should be rendered literally. We also want a tag for line breaks that is distinct from the text tag, so that they can be merged during rendering. It might be good to treat text tags consisting of just whitespace, such as whitespace, specially: two newlines <code class="language-plaintext highlighter-rouge">\n\n</code> are a blank line, but we might want to merge consecutive blank lines. Similarly, we might want to merge consecutive spaces to simplify generating the DOM.</p> <p>Consider formatting a language like C++, where a function can have many modifiers on it that can show up in any order, such as <code class="language-plaintext highlighter-rouge">inline</code>, <code class="language-plaintext highlighter-rouge">virtual</code>, <code class="language-plaintext highlighter-rouge">constexpr</code>, and <code class="language-plaintext highlighter-rouge">explicit</code>. We might want to canonicalize the order of these modifiers. We don’t want to accidentally wind up printing <code class="language-plaintext highlighter-rouge">inline constexpr Foo()</code> because we printed an empty string for <code class="language-plaintext highlighter-rouge">virtual</code>. Having special merging for spaces means that all entities are always one space apart if necessary. This is a small convenience in the DOM that multiplies to significant simplification when lowering from AST to DOM.</p> <p>Another useful tag is something like <code class="language-plaintext highlighter-rouge">&lt;indent by=" "&gt;</code>, which increases the indentation level by some string (or perhaps simply a number of spaces; the string just makes supporting tabs easier) for the tags inside of it. This allows control of indentation in a carefully-scoped manner.</p> <p>Finally, we need some way to group tags that are candidates for “breaking”: if the width of all of the tags inside of a <code class="language-plaintext highlighter-rouge">&lt;group&gt;</code> is greater than the maximum width that group can have (determined by indentation and any elements on the same line as that group), we can set that group to “broken”, and… well, what should breaking do?</p> <p>We want breaking to not just cause certain newlines (at strategic locations) to appear, but we also want it to cause an indentation increase, and in languages with trailing commas like Rust and Go, we want (or in the case of Go, <em>need</em>) to insert a trailing comma only when broken into multiple lines. We can achieve this by allowing any tag to be <em>conditioned</em> on whether the enclosing group is broken or not.</p> <p>Taken all together, we can render the AST for our <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> document into this DOM, according to the tags we’ve described above.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">XML</div></div></div> <p>Notice a few things: All of the newlines are set to appear only <code class="language-plaintext highlighter-rouge">if=broken</code>. The space between the two commas only appears if the enclosing group is <em>not</em> broken, that is <code class="language-plaintext highlighter-rouge">if=flat</code>. The groups encompass everything that can move due to a break, which includes the outer braces. This is necessary because if that brace is not part of the group, and it is the only character past the line width limit, it will not cause the group to break.</p> <h3 id="laying-out-your-dom"><a href="#laying-out-your-dom">Laying Out Your DOM</a></h3> <p>The first pass is easy: it measures how wide every node is. But we don’t know whether any groups will break, so how can we measure that without calculating breaks, which depend on indentation, and the width of their children, and…</p> <p>This is one tricky thing about multi-pass graph algorithms (or graph algorithms in general): it can be easy to become overwhelmed trying to factor the dependencies at each node so that they are not cyclic. I struggled with this algorithm, until I realized that the only width we care about is the width <em>if no groups are ever broken</em>.</p> <p>Consider the following logic: if a group needs to break, all of its parents must obviously break, because the group will now contain a newline, so its parents must break no matter what. Therefore, we only consider the width of a node when deciding if a group must break intrinsically, i.e., because all of its children decided not to break. This can happen for a document like the following, where each inner node is quite large, but not large enough to hit the limit.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span><span class="w">
  </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span><span class="w">
  </span><span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">]</span><span class="w">
</span><span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Because we prefer to break outer groups rather than inner groups, we can measure the “widest a single line could be” in one pass, bottom-up: each node’s width is the sum of the width of its children, or its literal contents for <code class="language-plaintext highlighter-rouge">&lt;text&gt;</code> elements. However, we must exclude all text nodes that are <code class="language-plaintext highlighter-rouge">if=broken</code>, because they obviously do not contribute to the single-line length. We can also ignore indentation because indentation never happens in a single line.</p> <p>However, this doesn’t give the full answer for whether a given group should break, because that depends on indentation and what nodes came before on the same line.</p> <p>This means we need to perform a second pass: having laid everything out assuming no group is broken, we must lay things out as they would appear when we render them, taking into account breaking. But now that we know the maximum width of each group if left unbroken, we can make breaking decisions.</p> <p>As we walk the DOM, we keep track of the current column and indentation value. For each group, we decide to break it if either:</p> <ol> <li> <p>Its width, plus the current column value, exceeds the maximum column width.</p> </li> <li> <p>It contains any newlines, something that can be determined in the first pass.</p> </li> </ol> <p>The first case is why we can’t actually treat tabs as if they advance to a tabstop. We cannot know the column at which a node will be placed at the time that we measure its width, so we need to assume the worst case.</p> <p>Whenever we hit a newline, we update the current width to the width induced by indentation, simulating a newline plus indent. We also need to evaluate the condition, if present, on each tag now, since by the time we inspect a non-group tag, we have already made a decision as to whether to break or not.</p> <h3 id="render-it"><a href="#render-it">Render It!</a></h3> <p>Now that everything is determined, rendering is super easy: just walk the DOM and print out all the text nodes that either have no condition or whose condition matches the innermost group they’re inside of.</p> <p>And, of course, this is where we need to be careful with indentation: you don’t want to have lines that end in whitespace, so you should make sure to not print out any spaces until text is written after a newline. This is also a good opportunity to merge adjacent only-newlines text blocks. The merge algorithm I like is to make sure that when <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code> newline blocks are adjacent, print <code class="language-plaintext highlighter-rouge">max(n, m)</code> newlines. This ensures that a DOM node containing <code class="language-plaintext highlighter-rouge">\n\n\n</code> is respected, while deleting a bunch of <code class="language-plaintext highlighter-rouge">\n</code>s in a row that would result in many blank lines.</p> <p>What’s awesome about this approach is that the layout algorithm is highly generic: you can re-use it for whatever compiler frontend you like, without needing to fuss with layout yourself. There is a very direct conversion from AST to DOM, and the result is very declarative.</p> <h3 id="more-complicated-yaml"><a href="#more-complicated-yaml">More Complicated: YAML</a></h3> <p>YAML is a superset of JSON that SREs use to write sentient configuration files. It has a funny list syntax that we might want to use for multi-line lists, but we might want to keep JSON-style lists for short ones.</p> <p>A document of nested lists might look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="pi">-</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">,</span> <span class="nv">4</span><span class="pi">,</span> <span class="nv">5</span><span class="pi">,</span> <span class="nv">6</span><span class="pi">,</span> <span class="nv">7</span><span class="pi">,</span> <span class="nv">8</span><span class="pi">,</span> <span class="nv">9</span><span class="pi">,</span> <span class="nv">10</span><span class="pi">,</span> <span class="nv">11</span><span class="pi">,</span> <span class="nv">12</span><span class="pi">]</span>
<span class="pi">-</span> <span class="pi">[</span><span class="nv">13</span><span class="pi">,</span> <span class="nv">14</span><span class="pi">,</span> <span class="nv">15</span><span class="pi">,</span> <span class="nv">16</span><span class="pi">,</span> <span class="nv">17</span><span class="pi">,</span> <span class="nv">18</span><span class="pi">,</span> <span class="nv">19</span><span class="pi">,</span> <span class="nv">20</span><span class="pi">,</span> <span class="nv">21</span><span class="pi">,</span> <span class="nv">22</span><span class="pi">,</span> <span class="nv">23</span><span class="pi">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">YAML</div></div></div> <p>How might we represent this in the DOM? Starting from our original JSON document <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>, we might go for something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">XML</div></div></div> <p>Here, we’ve made the <code class="language-plaintext highlighter-rouge">[]</code> and the comma only appear in flat mode, while in broken mode, we have a <code class="language-plaintext highlighter-rouge">- </code> prefix for each item. The inserted newlines have also changed somewhat, and the indentation blocks have moved: now only the value is indented, since YAML allows the <code class="language-plaintext highlighter-rouge">-</code>s of list items to be at the same indentation level as the parent value for lists nested in objects. (This is a case where some layout logic is language-specific, but now the output is worrying about declarative markup rather than physical measurements.)</p> <p>There are other enhancements you might want to make to the DOM I don’t describe here. For example, comments want to be word-wrapped, but you might not know what the width is until layout happens. Having a separate tag for word-wrapped blocks would help here.</p> <p>Similarly, a mechanism for “partial breaks”, such as for the document below, could be implemented by having a type of line break tag that breaks if the text that follows overflows the column, which can be easily implemented by tracking the position of the last such break tag.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"very"</span><span class="p">,</span><span class="w"> </span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"list"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"of"</span><span class="p">,</span><span class="w"> </span><span class="s2">"strings"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <h2 id="using-this-yourself"><a href="#using-this-yourself">Using This Yourself</a></h2> <p>I think that a really good formatter is essential for any programming language, and I think that a high-quality library that does most of the heavy-lifting is important to make it easier to demand good formatters.</p> <p><a href="https://github.com/mcy/strings/tree/main/allman">So I wrote a Rust library.</a> I haven’t released it on crates.io because I don’t think it’s quite at the state I want, but it turns out that the layout algorithm is very simple, so porting this to other languages should be EZ.</p> <p>Now you have no excuse. :D</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:pronunciation" role="doc-endnote"> <p>Everyone pronounces this acronym “ay ess tee”, but I have a friend who really like to say <em>ast</em>, rhyming with <em>mast</em>, so I’m making a callout post my twitter dot com. <a href="#fnref:pronunciation" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stanza" role="doc-endnote"> <p>In computing, a group of lines not separated by blank lines is called a stanza, in analogy to the stanzas of a poem, which are typeset with no blank lines between the lines of the stanza. <a href="#fnref:stanza" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:offsets" role="doc-endnote"> <p>You could also just store a string, containing the original text, but storing offsets is necessary for <em>diagnostics</em>, which is the jargon term for a compiler error. Compiler errors are recorded using an AST node as context, and to report the line at which the error occurred, we need to be able to map the node back to its offset in the file.</p> <p>Once we have the offset, we can calculate the line in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time using binary search. Having pre-computed an array of the offset of each <code class="language-plaintext highlighter-rouge">\n</code> byte in the input file, binary search will tell us the index and offset of the <code class="language-plaintext highlighter-rouge">\n</code> before the token; this index is the zero-indexed line number, and the string from that <code class="language-plaintext highlighter-rouge">\n</code> to the offset can be used to calculate the column.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">unicode_width</span><span class="p">::</span><span class="n">UnicodeWidthStr</span><span class="p">;</span>

<span class="cd">/// Returns the index of each newline. Can be pre-computed and re-used</span>
<span class="cd">/// multiple times.</span>
<span class="k">fn</span> <span class="nf">newlines</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">file</span><span class="nf">.bytes</span><span class="p">()</span>
      <span class="nf">.enumerate</span><span class="p">()</span>
      <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// Returns the line and column of the given offset, given the line</span>
<span class="cd">/// tarts of the file.</span>
<span class="k">fn</span> <span class="nf">location</span><span class="p">(</span>
  <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="n">newlines</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
  <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">newlines</span><span class="nf">.binary_search</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Ok means that offset refers to a newline, so this means</span>
    <span class="c1">// we want to return the width of the line that it ends as</span>
    <span class="c1">// the column.</span>
    <span class="c1">//</span>
    <span class="c1">// Err means that this is after the nth newline, except Err(0),</span>
    <span class="c1">// which means it is before the first one.</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><a href="#fnref:offsets" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:80-cols" role="doc-endnote"> <p>The Rust people keep trying to convince me that it should be 100. They are wrong. 80 is perfect. They only think they need 100 because they use the incorrect tab width of four spaces, rather than two. This is the default for clang-format and it’s <em>perfect</em>. <a href="#fnref:80-cols" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-16 • 3570 words • 29 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/16/rangefuncs/"> Go's Weird Little Iterators </a></h1> </div> <div class="post"> <p>A second post on Go silliness (Miguel, aren’t you a C++ programmer?): in 1.23, Go <em>finally</em> added custom iterators. Now, back when I was at Google and involved in the Go compiler as “the annoying Rust guy who gets lunch with us”, there were proposals suggesting adding something like this, implemented as either an interface or a func:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Iter</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is not what Go did. No, Go did something really weird. And the implementation is <em>incredible</em>.</p> <h2 id="whats-an-iterator"><a href="#whats-an-iterator">What’s an Iterator?</a></h2> <p>An <em>iterator</em>, in the context of programming language design, is a special type of value that can be used to walk through a sequence of values, without necessarily materializing the sequence as whatever the language’s array type is.</p> <p>But, a proper iterator must fit with the language’s looping construct. An <em>iterable type</em> is one which can be used in a for-each loop, such as C++’s <code class="language-plaintext highlighter-rouge">for (T x : y)</code> or Python’s <code class="language-plaintext highlighter-rouge">for x in y</code> (modern languages usually only have a for-each loop as their only <code class="language-plaintext highlighter-rouge">for</code> loop, because C-style for loops are not in anymore).</p> <h3 id="c-iterator-pairs"><a href="#c-iterator-pairs">C++ Iterator Pairs</a></h3> <p>Every language defines a <em>desugaring</em> that defines how custom iteration works in term of the more primitive loops. For example, in C++, when we write <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> (called a <a href="https://en.cppreference.com/w/cpp/language/range-for"><em>range-based for loop</em></a>, added in C++11), desugars as follows<sup id="fnref:cc-range" role="doc-noteref"><a href="#fn:cc-range" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">__range</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">__begin</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span> <span class="c1">// ADL</span>
<span class="k">auto</span> <span class="n">__end</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span>     <span class="c1">// ADL</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">__begin</span> <span class="o">!=</span> <span class="n">__end</span><span class="p">;</span> <span class="o">++</span><span class="n">__begin</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">__begin</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> inside of the loop body require no special handling: they Just Work, because this is just a plain ol for loop.</p> <p>This begin and end weirdness is because, if the iterator backs an actual array, begin and end can just be pointers to the first element and one-past-the-end and this will Just Work. Before C++11, the convention for C++ iterators was to construct types that imitated pointers; you would usually write loops over non-array types like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">things</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">things</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">whatever</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>C++ simply codified common (if gross) practice. It is very tedious to implement C++ iterators, though. You need to provide a dummy end iterator, you need to provide some kind of comparison operator, and iterators that don’t return a reference out of <code class="language-plaintext highlighter-rouge">operator*()</code> are… weird.</p> <p>Begin and end can be different types (which is how C++20 ranges pretend to be iterable), but being able to query done-ness separately from the next value makes implementation annoying: it means that an iterator that has not begun iteration (i.e., <code class="language-plaintext highlighter-rouge">++</code> has not been executed yet, because it occurs in the loop’s latch, not its header<sup id="fnref:loop-jargon" role="doc-noteref"><a href="#fn:loop-jargon" class="footnote" rel="footnote">2</a></sup>) needs to do extra work to answer <code class="language-plaintext highlighter-rouge">!= end</code>, which usually means an extra bool to keep track of whether iteration has started or not.</p> <p>Here’s what writing an iterator (that is also an iterable usable in a range for-loop) over the non-zero elements of a <code class="language-plaintext highlighter-rouge">std::span&lt;const int&gt;</code> might look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">NonZero</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>In this case, <code class="language-plaintext highlighter-rouge">operator==</code> is <em>not</em> <code class="language-plaintext highlighter-rouge">const</code>, which is a bit naughty. Purists might argue that this type should have a constructor, which adjusts <code class="language-plaintext highlighter-rouge">ints</code> to point to the first non-zero element on construction, and <code class="language-plaintext highlighter-rouge">operator++</code> to perform the mutation. That would look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">NonZero</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">NonZero</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">)</span> <span class="o">:</span> <span class="n">ints_</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
  <span class="kt">void</span> <span class="n">skip_zeros</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">std::sentinel_for</code> (C++’s iterator concepts are terribly named) really wants <code class="language-plaintext highlighter-rouge">operator==</code> to be <code class="language-plaintext highlighter-rouge">const</code>, but I could have also just marked <code class="language-plaintext highlighter-rouge">ints</code> as <code class="language-plaintext highlighter-rouge">mutable</code> to avoid that. It it’s not already clear, I really dislike this pattern. See <a href="https://github.com/mcy/best/blob/main/best/iter/iter.h">here</a> for some faffing about with C++ iterators on my part.</p> <h3 id="java-also-got-this-wrong"><a href="#java-also-got-this-wrong">Java Also Got This Wrong</a></h3> <p>At least Java provides a standard iterable interface, thankfully.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">java.util</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
  <span class="no">E</span> <span class="nf">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The desugaring of <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> is then:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">$iter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">$iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span> <span class="o">{</span>
  <span class="no">T</span> <span class="n">x</span> <span class="o">=</span> <span class="n">$iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>Do you see the problem here? Although Java now provides a standard interface, doesn’t require annoying equality comparisons, and doesn’t require an end value, these things are <em>still</em> a pain to implement! You still need to be able to query if you’re done before you’ve had a chance to step through the iterator.</p> <p>Like before, suppose we have an <code class="language-plaintext highlighter-rouge">int[]</code>, and we want to yield every non-zero value in it. How do we construct an iterator for that?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span><span class="o">[]</span> <span class="n">xs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">var</span> <span class="n">it</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">xs</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;</span> <span class="o">!</span><span class="n">done</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{}</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">done</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">hasNext</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">++];</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">done</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">array</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>What a pain. Java’s anonymous classes being wordy aside, it’s annoying and error-prone to do this: it’s tempting to accidentally implement <code class="language-plaintext highlighter-rouge">hasNext</code> by simply checking if the array is empty. (Aside, I hate that <code class="language-plaintext highlighter-rouge">xs.length</code> throws on null arrays. Just return zero like in Go, c’mon).</p> <p>Also, it’s no a single-abstract-method interface, so I can’t use a lambda to create an iterator.</p> <p>At least <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> Just Work, because the underlying operation is a for loop like before.</p> <h3 id="rust-does-it-better"><a href="#rust-does-it-better">Rust Does It Better</a></h3> <p>Rust <em>also</em> has a standard iterable interface.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// mod core::iter</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">IntoIterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">Iter</span><span class="p">:</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">next</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The desugaring for <code class="language-plaintext highlighter-rouge">for x in y { ... }</code> is reasonably straightforward, like in Java:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">__it</span> <span class="o">=</span> <span class="nn">IntoIterator</span><span class="p">::</span><span class="nf">into_iter</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">__it</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is so straightforward that it’s not <em>so</em> unusual to write it yourself, when you don’t plan on consuming the entire iterator. Alternatively, you can partially iterate over an iterator by taking a mutable reference to it. This is useful for iterators that can yield their remainder.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="n">my_slice</span><span class="nf">.chunks_exact</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span> <span class="p">{</span>
  <span class="nf">do_thing</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">do_thing</span><span class="p">(</span><span class="n">it</span><span class="nf">.remainder</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> work in the obvious way.</p> <p>The interface solves the problems C++ and Java had very cleanly: <code class="language-plaintext highlighter-rouge">next</code> both computes the next item and whether the iterator has more elements. Rust even allows iterators to resume yielding <code class="language-plaintext highlighter-rouge">Some</code> after yielding <code class="language-plaintext highlighter-rouge">None</code>, although few algorithms will make use of this.</p> <p>Implementing the non-zero iterator we’ve been writing so far is quite simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">ints</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
  <span class="k">while</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="n">item</span>
<span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this can be written far more simply<sup id="fnref:size_hint" role="doc-noteref"><a href="#fn:size_hint" class="footnote" rel="footnote">3</a></sup> using iterator combinators:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>It requires a little bit of effort to implement some iterators, but most of the common cases are easy to put together with composition.</p> <p>Python iterators are basically the same thing, but there’s no interface to implement (because Python doesn’t believe in type safety). Lua iterators are similar. The Rust pattern of a function that returns the next item (or a special end-of-sequence value) is relatively popular because of this simplicity and composability, and because they can model a lot of iteration strategies.</p> <h2 id="so-what-did-go-do"><a href="#so-what-did-go-do">So, What Did Go Do?</a></h2> <p>Well. Go has a range for syntax like many other languages. The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">y</span> <span class="p">{</span>
  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">x</code> can be a list of places, and the <code class="language-plaintext highlighter-rouge">:=</code> can be plain assignment, <code class="language-plaintext highlighter-rouge">=</code>. You can also write <code class="language-plaintext highlighter-rouge">for range y { ... }</code> if the iteration values aren’t needed.</p> <p>The behavior of this construct, like many others in Go, depends explicitly on the type after <code class="language-plaintext highlighter-rouge">range</code>. Each range iteration can yield zero or more values; the</p> <p>These are:</p> <ol> <li>For <code class="language-plaintext highlighter-rouge">[]T</code>, <code class="language-plaintext highlighter-rouge">[n]T</code>, and <code class="language-plaintext highlighter-rouge">*[n]T</code>, each step yields an index of the slice and the value at that offset, in order.</li> <li>For <code class="language-plaintext highlighter-rouge">map[K]V</code>, each step yields a key and a value, in a random order.</li> <li> <p>For <code class="language-plaintext highlighter-rouge">&lt;- chan T</code>, it desugars into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
 <span class="n">x</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">y</span>
 <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> </li> <li> <p>Starting in Go 1.22, ranging on an integer type would desugar into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> </li> </ol> <p>All of these desugars are essentially still just loops, so <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work as expected.</p> <p>But, how do custom types, like weird map types, implement iteration? The usual<sup id="fnref:chan-iter" role="doc-noteref"><a href="#fn:chan-iter" class="footnote" rel="footnote">4</a></sup> implementation is <a href="https://pkg.go.dev/sync#Map.Range"><code class="language-plaintext highlighter-rouge">sync.Map.Range</code></a>, which looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">Map</span><span class="p">)</span> <span class="n">Range</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="n">any</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This function will call <code class="language-plaintext highlighter-rouge">yield</code> for each element in the map. If the function returns <code class="language-plaintext highlighter-rouge">false</code>, iteration will stop. This pattern is not uncommon, but sometimes libraries omit the <code class="language-plaintext highlighter-rouge">bool</code> return (like <a href="https://pkg.go.dev/container/ring@go1.23.4#Ring.Do"><code class="language-plaintext highlighter-rouge">container/ring.Ring.Do</code></a>). Some, like <a href="https://pkg.go.dev/path/filepath#WalkFunc"><code class="language-plaintext highlighter-rouge">filepath.WalkDir</code></a>, have a more complex interface involving errors.</p> <p>This is the template for what became <em>rangefuncs</em>, a mechanism for using the for-range syntax with certain function values.</p> <h2 id="rangefuncs"><a href="#rangefuncs">Rangefuncs</a></h2> <p>The word “rangefunc” does not appear in Go’s specification. It is a term used to refer to them in some documentation, within the compiler, and in the runtime.</p> <p>A rangefunc is any function with one of the following signatures:</p> <ul> <li><code class="language-plaintext highlighter-rouge">func(yield func() bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(V) bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(K, V) bool)</code></li> </ul> <p>They work like <code class="language-plaintext highlighter-rouge">sync.Map.Range</code> does: the function calls <code class="language-plaintext highlighter-rouge">yield</code> (hereafter simply called “the yield”) for each element, and stops early if yield returns false. The <code class="language-plaintext highlighter-rouge">iter</code> package contains types for the second and third of these:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="k">type</span> <span class="n">Seq2</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>For example, the <code class="language-plaintext highlighter-rouge">slices</code> package provides an adaptor for converting a slice into an iterator that ranges over it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="c">// All returns an iterator over index-value pairs in the slice</span>
<span class="c">// in the usual order.</span>
<span class="k">func</span> <span class="n">All</span><span class="p">[</span><span class="n">Slice</span> <span class="err">~</span><span class="p">[]</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="n">Slice</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
			<span class="k">if</span> <span class="o">!</span><span class="n">yield</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>So. These things are actually pretty nuts. They break my brain somewhat, because this is the opposite of how iterators usually work. Go calls what I’ve described all the other languages do a “pull iterator”, whereas rangefuncs are “push iterators”.</p> <p>They have a few obvious limitations. For one, you can’t do smart sizing like with Rust or C++ iterators<sup id="fnref:size-hint2" role="doc-noteref"><a href="#fn:size-hint2" class="footnote" rel="footnote">5</a></sup>. Another is that you can’t easily “pause” iteration.</p> <p>But they do have one advantage, which I think is the real reason Go went to so much trouble to implement them (and yes, I will dig into how insane that part is). Using push iterators by default means that users “only” need to write an ordinary for loop packaged into a function. Given that Go makes major performance sacrifices in order to be easy to learn<sup id="fnref:tooling" role="doc-noteref"><a href="#fn:tooling" class="footnote" rel="footnote">6</a></sup>, trying to make it so that an iterator packages the actual looping construct it represents makes quite a bit of sense.</p> <p>Rangefuncs are actually really cool in some respects, because they enable unusual patterns. For example, you can use a rangefunc to provide RAII blocks.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Open</span><span class="p">(</span><span class="n">fs</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">,</span> <span class="n">path</span> <span class="kt">string</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fs</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="p">{</span>
      <span class="n">yield</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="n">yield</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">DirFS</span><span class="p">(</span><span class="s">"/"</span><span class="p">),</span> <span class="s">"etc/passwd"</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Being a block that you can put an epilog onto after yielding a single element is quite powerful! You can also use a nilary rangefunc to simply create a block that you can break out of, instead of having to use <code class="language-plaintext highlighter-rouge">goto</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Once</span><span class="p">()</span> <span class="k">func</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="k">range</span> <span class="n">Once</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">canDo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">break</span>
  <span class="p">}</span>

  <span class="n">do</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>So wait. You can return out of rangefunc loops. That means that… Go has non-local returns?!</p> <h2 id="go-now-has-non-local-returns"><a href="#go-now-has-non-local-returns">Go Now Has Non-Local Returns</a></h2> <p>The desugaring for rangefuncs is very complicated. This is because <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work in a rangefunc! How does this work? Let’s Godbolt it.</p> <p>Let’s start with something really basic: a loop body that just calls a function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This produces the following assembly output (which I’ve reformatted into Intel syntax, and removed some extraneous ABI things, including a writer barrier where <code class="language-plaintext highlighter-rouge">(*)</code> is below).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>  <span class="c1">// (*)</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">api</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic2</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>This is a lot to take in, but if we look carefully, we decompile this function into a Go function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c">// Loop body</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Go will actually enforce invariants on the yield it synthesizes in a range for, in order to catch buggy code. In particular, <code class="language-plaintext highlighter-rouge">__state</code> escapes because <code class="language-plaintext highlighter-rouge">s</code> is an arbitrary function, so it gets spilled to the heap.</p> <p>So, what happens when the loop body contains a break? Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>I’ll spare you the assembly listing, since it’s very similar, so I’ll just reverse-engineer the output directly:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Non-local returns are much more complicated. Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The resulting assembly is something like this, with some irrelevant code, such as write barriers, removed:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int; X1 *int; X2 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rdi</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">jne</span>     <span class="n">resume</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">resume</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">test</span>    <span class="n">al</span><span class="p">,</span> <span class="n">al</span>
    <span class="n">jeq</span>     <span class="n">cont</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_DONE</span>
    <span class="n">xor</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">cont</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>Try to reverse engineer this yourself, if you like! If you write this out as Go, here’s what you get:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">(</span><span class="n">__ret</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">__next</span> <span class="kt">int</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="n">__next</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
      <span class="n">__ret</span> <span class="o">=</span> <span class="n">v</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
  <span class="k">if</span> <span class="n">__next</span> <span class="o">==</span> <span class="o">-</span><span class="m">1</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The reason <code class="language-plaintext highlighter-rouge">__next</code> is an int is because it is also used when exiting the loop via <code class="language-plaintext highlighter-rouge">goto</code> or a <code class="language-plaintext highlighter-rouge">break</code>/<code class="language-plaintext highlighter-rouge">continue</code> with label. It specifies where to jump to after the call into the rangefunc returns. Each potential control flow out of the loop is assigned some negative number.</p> <p>The precise details of the lowering have been <a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/rangefunc/rewrite.go">exquisitely documented</a> by Russ Cox and David Chase, the primary implementers of the feature.</p> <p>You might be curious what <code class="language-plaintext highlighter-rouge">runtime.panicrangestate</code> does. It’s pretty simple, and it lives in <code class="language-plaintext highlighter-rouge">runtime/panic.go</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="c">//go:noinline</span>
<span class="k">func</span> <span class="n">panicrangestate</span><span class="p">(</span><span class="n">state</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_State</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeDoneError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangePanicError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeExhaustedError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_MISSING_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeMissingPanicError</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">throw</span><span class="p">(</span><span class="s">"unexpected state passed to panicrangestate"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If you visit this function in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/panic.go;l=306?q=panicrangestate&amp;ss=go%2Fgo">runtime/panic.go</a>, you will be greeted by this extremely terrifying comment from Russ Cox immediately after it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// deferrangefunc is called by functions that are about to</span>
<span class="c">// execute a range-over-function loop in which the loop body</span>
<span class="c">// may execute a defer statement. That defer needs to add to</span>
<span class="c">// the chain for the current function, not the func literal synthesized</span>
<span class="c">// to represent the loop body. To do that, the original function</span>
<span class="c">// calls deferrangefunc to obtain an opaque token representing</span>
<span class="c">// the current frame, and then the loop body uses deferprocat</span>
<span class="c">// instead of deferproc to add to that frame's defer lists.</span>
<span class="c">//</span>
<span class="c">// The token is an 'any' with underlying type *atomic.Pointer[_defer].</span>
<span class="c">// It is the atomically-updated head of a linked list of _defer structs</span>
<span class="c">// representing deferred calls. At the same time, we create a _defer</span>
<span class="c">// struct on the main g._defer list with d.head set to this head pointer.</span>
<span class="c">//</span>
<span class="c">// The g._defer list is now a linked list of deferred calls,</span>
<span class="c">// but an atomic list hanging off:</span>
<span class="c">//</span>
<span class="c">// (increasingly terrifying discussion of concurrent data structures)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This raises one more thing that works in range funcs, seamlessly: <code class="language-plaintext highlighter-rouge">defer</code>. Yes, despite the yield executing multiple call stacks away, possibly on a different goroutine… <code class="language-plaintext highlighter-rouge">defer</code> still gets attached to the calling function.</p> <h2 id="go-now-has-non-local-defer"><a href="#go-now-has-non-local-defer">Go Now Has Non-Local Defer</a></h2> <p>The way defer works is that each G (the goroutine struct, <code class="language-plaintext highlighter-rouge">runtime.g</code>) holds a linked list of defer records, of type <code class="language-plaintext highlighter-rouge">_defer</code>. Each call to <code class="language-plaintext highlighter-rouge">defer</code> sticks one of these onto this list. On function return, Go calls <code class="language-plaintext highlighter-rouge">runtime.deferreturn()</code>, which essentially executes and pops defers off of the list until it finds one whose stack pointer is not the current function’s stack pointer (so, it must belong to another function).</p> <p>Rangefuncs throw a wrench in that mix: if <code class="language-plaintext highlighter-rouge">myFunc.range-n</code> defers, that defer has to be attached to <code class="language-plaintext highlighter-rouge">myFunc</code>’s defer records somehow. So the list must have a way of inserting in the middle.</p> <p>This is what this comment is about: when <code class="language-plaintext highlighter-rouge">defer</code> occurs in the loop body, that defer gets attached to a defer record for that function, using a token that the yield captures; this is later canonicalized when walking the defer list on the way out of <code class="language-plaintext highlighter-rouge">myFunc</code>. Because the yield can escape onto another goroutine, this part of the <code class="language-plaintext highlighter-rouge">defer</code> chain has to be atomic.</p> <p>Incredibly, this approach is extremely robust. For example, if we spawn the yield as a goroutine, and carefully synchronize between that and the outer function, we can force the runtime to hard-crash when <code class="language-plaintext highlighter-rouge">defer</code>ing to a function that has returned.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">bad</span><span class="p">()</span> <span class="p">(</span><span class="n">out</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="n">w1</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="n">w2</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>

	<span class="n">out</span> <span class="o">=</span> <span class="n">w2</span><span class="o">.</span><span class="n">Done</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">recover</span><span class="p">()</span> <span class="p">}()</span>
	<span class="n">iter</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">yield</span><span class="p">()</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait to enter yield().</span>
    <span class="c">// This panics once w1.Done() executes, because</span>
    <span class="c">// we exit the rangefunc while yield() is still</span>
    <span class="c">// running. The runtime incorrectly attributes</span>
    <span class="c">// this to recovering in the rangefunc.</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="k">range</span> <span class="n">iter</span> <span class="p">{</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="c">// Allow the outer function to exit the loop.</span>
		<span class="n">w2</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait for bad() to return.</span>
		<span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"bang"</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="k">return</span> <span class="no">nil</span> <span class="c">// Unreachable</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">resume</span> <span class="o">:=</span> <span class="n">bad</span><span class="p">()</span>
  <span class="n">resume</span><span class="p">()</span>
  <span class="k">select</span> <span class="p">{}</span>  <span class="c">// Block til crash.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This gets us <code class="language-plaintext highlighter-rouge">fatal error: defer after range func returned</code>. Pretty sick! It accomplishes this by poisoning the token the yield func uses to defer.</p> <p>I have tried various other attempts at causing memory unsafety with rangefuncs, but Go actually does a really good job of avoiding this. The only thing I’ve managed to do that’s especially interesting is to tear the return slot on a function without named returns, but that’s no worse than tearing any other value (which is still really bad, because you can tear interface values, but it’s not <em>worse</em>).</p> <h2 id="pull-iterators-and-coroutines"><a href="#pull-iterators-and-coroutines">Pull Iterators and Coroutines</a></h2> <p>Of course we’re not done. Go provides a mechanism for converting push iterators into pull iterators. Essentially, there is a function that looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">yield</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">})</span>
  <span class="n">pull</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}{})</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">seq</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">pull</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">yield</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">}{</span><span class="n">v</span><span class="p">,</span> <span class="no">true</span><span class="p">}</span>
    <span class="p">})</span>

    <span class="nb">close</span><span class="p">(</span><span class="n">yield</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pull</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="n">yield</span>
  <span class="p">}</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">close</span><span class="p">(</span><span class="n">pull</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Essentially, you can request values with <code class="language-plaintext highlighter-rouge">next()</code>, and <code class="language-plaintext highlighter-rouge">stop()</code> can be used if you finish early. But also, this spawns a whole goroutine and uses channels to communicate and synchronize, which feels very unnecessary.</p> <p>The implementation doesn’t use goroutines. It uses coroutines.</p> <h3 id="giving-up-on-goroutines"><a href="#giving-up-on-goroutines">Giving Up on Goroutines</a></h3> <p>Spawning a goroutine is expensive. Doing so expends scheduler and memory resources. It’s overkill for a helper like this (ironic, because the original premise of Go was that goroutines would be cheap enough to allocate willy-nilly).</p> <p>Go instead implements this using “coroutines”, a mechanism for concurrency without parallelism. This is intended to make context switching very cheap, because it does not need to go through the scheduler: instead, it uses cooperative multitasking.</p> <p>The coroutine interface is something like the following. My “userland” implementation will not be very efficient, because it relies on the scheduler to transfer control. The goroutines may run on different CPUs, so synchronization is necessary for communication, even if they are not running concurrently.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">coro</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"runtime"</span>
  <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Coro</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">m</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="o">*</span><span class="n">Coro</span> <span class="p">{</span>
  <span class="n">c</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Coro</span><span class="p">)</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">f</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Coro</span><span class="p">)</span> <span class="n">Resume</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>When we create a coroutine with <code class="language-plaintext highlighter-rouge">coro.New()</code>, it spawns a goroutine that waits on a mutex. Another goroutine can “take its place” as the mutex holder by calling <code class="language-plaintext highlighter-rouge">c.Resume()</code>, which allows the coroutine spawned by <code class="language-plaintext highlighter-rouge">coro.New</code> to resume and enter <code class="language-plaintext highlighter-rouge">f()</code>.</p> <p>Using the coroutine as a rendezvous point, two goroutines can perform concurrent work: in the case of <code class="language-plaintext highlighter-rouge">iter.Pull</code>, one can be deep inside of whatever loops the iterator wants to do, and the other can request values.</p> <p>Here’s what using my <code class="language-plaintext highlighter-rouge">coro.Coro</code> to implement <code class="language-plaintext highlighter-rouge">iter.Pull</code> might look like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">var</span> <span class="p">(</span>
    <span class="n">done</span> <span class="kt">bool</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">z</span> <span class="n">V</span>
  <span class="p">)</span>

  <span class="n">c</span> <span class="o">:=</span> <span class="n">coro</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v1</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Wait for a request for a value.</span>
      <span class="k">if</span> <span class="n">done</span> <span class="p">{</span>
        <span class="c">// This means we resumed from stop(). Break out of the</span>
        <span class="c">// loop.</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">v1</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
      <span class="c">// Yield the last value.</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">z</span>
    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
  <span class="p">})</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="no">false</span> <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>      <span class="c">// Request a value.</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="no">true</span>  <span class="c">// Return it.</span>
  <span class="p">}</span>

  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span> <span class="c">// Mark iteration as complete.</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Resume the iteration goroutine to it can exit.</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">next</span><span class="p">,</span> <span class="n">stop</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If you look at the implementation in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/iter/iter.go"><code class="language-plaintext highlighter-rouge">iter.go</code></a>, it’s basically this, but with a lot of error checking and race detection, to prevent misuse, such as if <code class="language-plaintext highlighter-rouge">next</code> or <code class="language-plaintext highlighter-rouge">stop</code> escape to other goroutines.</p> <p>Now, the main thing that runtime support brings here is that <code class="language-plaintext highlighter-rouge">Resume()</code> is immediate: it does not go to the scheduler, which might not decide to immediately run the goroutine that last called <code class="language-plaintext highlighter-rouge">Resume()</code> for a variety of reasons (for example, to ensure wakeup fairness). Coroutines sidestep fairness, by making <code class="language-plaintext highlighter-rouge">Resume()</code> little more than a jump to the last <code class="language-plaintext highlighter-rouge">Resume()</code> (with registers fixed up accordingly).</p> <p>This is not going to be <em>that</em> cheap: a goroutine still needs to be allocated, and switching needs to poke and prod the underlying Gs a little bit. But it’s a cool optimization, and I hope coroutines eventually make their way into more things in Go, hopefully as a language or <code class="language-plaintext highlighter-rouge">sync</code> primitive.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Congratulations, you have survived over 3000 words of me going on about iterators. Go’s push iterators are a unique approach to a common language design problem (even if it took a decade for them to materialize).</p> <p>I encountered rangefuncs for the first time earlier this year and have found them absolutely fascinating, both from a “oh my god they actually did that” perspective and from a “how do we express iteration” perspective. I don’t think the result was perfect by any means, and it is unsuitable for languages that need the performance you can only get from pull iterators. I think they would be a great match for a language like Python or Java, though.</p> <p>I’d like to thank David Chase, an old colleague, for tolerating my excited contrived questions about the guts of this feature.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:cc-range" role="doc-endnote"> <p>Ugh, ok. This is the C++20 desugaring, and there are cases where we do not just call <code class="language-plaintext highlighter-rouge">std::begin()</code>. In particular, array references and class type references with <code class="language-plaintext highlighter-rouge">.begin()</code> and <code class="language-plaintext highlighter-rouge">.end()</code> do not call <code class="language-plaintext highlighter-rouge">std::begin()</code> and are open-coded. This means that you can’t use ADL to override these types’ iterator. <a href="#fnref:cc-range" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:loop-jargon" role="doc-endnote"> <p>In compiler jargon, a loop is broken up into three parts: the <em>header</em>, which is where the loop is entered, the <em>body</em>, which is one step of iteration, and the <em>latch</em>, which is the part that jumps back to the start of the body. This is where incrementation in a C-style for loop happens. <a href="#fnref:loop-jargon" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size_hint" role="doc-endnote"> <p>And with better performance. Rust’s iterators can provide a size hint to help size containers before a call to <code class="language-plaintext highlighter-rouge">collect()</code>, via the <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code class="language-plaintext highlighter-rouge">FromIterator</code></a> trait. <a href="#fnref:size_hint" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:chan-iter" role="doc-endnote"> <p>Some people observed that you can use a channel as a custom iterator, by having a parallel goroutine run a for loop to feed the channel. <em>Do not do this.</em> It is slow: it has to transit each element through the heap, forcing anything it points to escape. It takes up an extra M and a P in the scheduler, and requires potentially allocating a stack for a G. It’s probably faster to just build a slice and return that, especially for small iterations. <a href="#fnref:chan-iter" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size-hint2" role="doc-endnote"> <p>For this reason, I wish that Go had instead defined something along these lines.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Iterate</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is functionally identical to what they did, but it would have permitted future extensions such as the following interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">SizedSeq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">]</span>

  <span class="n">SizeHint</span><span class="p">()</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="kt">int64</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This would mean that <code class="language-plaintext highlighter-rouge">slices.Collect</code> could be enhanced into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="k">func</span> <span class="n">Collect</span><span class="p">[</span><span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="n">E</span><span class="p">])</span> <span class="p">[]</span><span class="n">E</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">out</span> <span class="p">[]</span><span class="n">E</span>
  <span class="k">if</span> <span class="n">sized</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">seq</span><span class="o">.</span><span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">SizedSeq</span><span class="p">[</span><span class="n">E</span><span class="p">]);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">sized</span><span class="o">.</span><span class="n">SizeHint</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">E</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">seq</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">out</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>I don’t think there’s an easy way to patch this up, at this point. <a href="#fnref:size-hint2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:tooling" role="doc-endnote"> <p>Disclaimer: I am not going to dig into Go’s rationale for rangefuncs. Knowing how the sausage is made, most big Go proposals are a mix of understandable reasoning and less reasonable veiled post-hoc justification to compensate for either Google planning/approvals weirdness or because the design was some principal engineer’s pony. This isn’t even a Go thing, it’s a Google culture problem. I say this as the architect of <a href="https://protobuf.dev/editions/overview">Protobuf Editions</a>, the biggest change to Protobuf since Rob’s misguided proto3<sup id="fnref:proto2" role="doc-noteref"><a href="#fn:proto2" class="footnote" rel="footnote">7</a></sup> experiment. <em>I</em> have written this kind of language proposal, on purpose, because bad culture mandated it.</p> <p><em>The purpose of a system is what it does.</em> It is easier to understand a system by observing its response to stimuli, rather than what it says on the tin. So let’s use that lens.</p> <p>Go wants to be easy to learn. It intended to replace C++ at Google (lol, lmao), which, of course, failed disastrously, because performance of the things already written in C++ is tied to revenue. They have successfully pivoted to being an easy-to-learn language that makes it easy to onboard programmers regardless of what they already use, as opposed to onboarding them to C++.</p> <p>This does not mean that Go is user-friendly. In fact, user-friendliness is clearly not a core value. Rob and his greybeard crowd didn’t seem to care about the human aspect of interacting with a toolchain, so Go tooling rarely provides good diagnostics, nor did the language, until the last few years, try to reduce toil. After all, if it is tedious to use but simple, that does make it easy to onboard new programmers.</p> <p>Rust is the opposite: it is very difficult to learn with a famously steep learning curve; however, it is very accessible, because the implementors have sanded down every corner and sharp edge using diagnostics, error messages, and tooling. C++ is neither of these things. It is very difficult to learn, and most compilers are pretty unhelpful (if they diagnose anything at all).</p> <p>I think that Go has at least realized the language can be a pain to use in some situations, which is fueled in part by legitimate UX research. This is why Go has generics and other recent advanced language features, like being able to use the <code class="language-plaintext highlighter-rouge">for</code> syntax with integers or with custom iterators.</p> <p>I think that rangefuncs are easy to learn in the way Go needs them to be. If you expect more users to want to write rangefuncs than users want to write complicated <em>uses</em> of rangefuncs, I think push iterators are the easiest to learn how to use.</p> <p>I think this is a much more important reason for all the trouble that rangefuncs generate for the compiler and runtime than, say, compatibility with existing code; I have not seen many cases in the wild or in the standard library that conform to the rangefunc signatures. <a href="#fnref:tooling" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:proto2" role="doc-endnote"> <p>But please don’t use proto3. I’m telling you that as the guy who maintained the compiler. Just don’t. <a href="#fnref:proto2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-12 • 2804 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/12/go-abi/"> Things You Never Wanted To Know About Go Interfaces </a></h1> </div> <div class="post"> <p>Lately I’ve been finding myself writing a bit of Go, and I’ve picked up various fun “layout secrets” that help inform how I write code to minimize hidden allocations, and generally be kind to the optimizer. This article is a series of notes on the topic.</p> <p>This post is about Go implementation details, so they can probably break you at any time if you rely on it. On the other hand, Hyrum’s law is a bitch, so taking your chances may not be that bad. After all, they’re probably never going to be able to properly clean up the mess people made with <code class="language-plaintext highlighter-rouge">//go:linkname</code> with runtime symbols…</p> <p>As with many of my other posts, I’ll assume a basic familiarity with being able to read assembly. I’m using x86 for this post, but it’s worth looking at my <a href="https://mcyoung.xyz//2021/11/09/assembly-1">RISC-V post</a> for a refresher.</p> <h2 id="gc-shapes"><a href="#gc-shapes">GC Shapes</a></h2> <p>The most basic Go-specific concept when it comes to type layouts is the <em>shape</em> of a type. This is an implementation detail of Go’s garbage collector that leaks through the <code class="language-plaintext highlighter-rouge">unsafe</code> package.</p> <p>Like in most native programming languages, every Go type has a size (the number of bytes that type takes up in memory) and an alignment (a power of two that every pointer to that type must be divisible by). Go, like most other languages, requires that size be divisible by the alignment: that is, the size is equal to the stride of an array of that type.</p> <p>The size an alignment of a type can be queried by the intrinsics <a href="https://pkg.go.dev/unsafe#Sizeof"><code class="language-plaintext highlighter-rouge">unsafe.Sizeof</code></a> and <a href="https://pkg.go.dev/unsafe#Alignof"><code class="language-plaintext highlighter-rouge">unsafe.Alignof</code></a>. These are very unwieldy in generic code, so I like to define a couple of helpers<sup id="fnref:constants" role="doc-noteref"><a href="#fn:constants" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Size</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Align</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Together, these two quantities are called the <em>layout</em> of a type (a term common to many native languages). However, the <em>shape</em> of a type also records what pieces thereof contain <em>pointers</em>. This is because memory visible to the GC (such as globals, heap memory, or stack roots) is typed, and the GC needs to know which parts of those types are pointers that it needs to trace through.</p> <p>Because all pointers have the same size and alignment (4 or 8 bytes depending on the system) the pointer words of a type can be represented as a bitset, one bit for every 4 or 8 bytes in the type. This, in fact, is the representation used by the GC<sup id="fnref:gc-programs" role="doc-noteref"><a href="#fn:gc-programs" class="footnote" rel="footnote">2</a></sup>.</p> <p>In particular, this means that whether a field is to be interpreted as an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code> or as a <code class="language-plaintext highlighter-rouge">uintptr</code> is a static property of the type. As we will see when we discuss interfaces, this restriction prevents a few layout optimizations.</p> <h2 id="slices-and-strings"><a href="#slices-and-strings">Slices and Strings</a></h2> <p>Go is very public about the layout of slices and strings. A slice is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">slice</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span>     <span class="o">*</span><span class="n">T</span>
  <span class="nb">len</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">len</code> and <code class="language-plaintext highlighter-rouge">cap</code> are extracted by their eponymous builtins, and <code class="language-plaintext highlighter-rouge">data</code> can be obtained using <code class="language-plaintext highlighter-rouge">unsafe.SliceData</code> (or <code class="language-plaintext highlighter-rouge">&amp;s[0]</code> if the slice is nonempty, but that costs a bounds-check).</p> <p>A string has the same layout as a <code class="language-plaintext highlighter-rouge">[]byte</code>, except for a capacity:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="kt">string</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
  <span class="nb">len</span>  <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Despite essentially being slices, Go treats strings subtly differently. Strings are <code class="language-plaintext highlighter-rouge">comparable</code>, so they can be used as map keys. They are also immutable, which enables a handful of optimizations. Immutability is also why they are <code class="language-plaintext highlighter-rouge">comparable</code>: Go made the mistake of not keeping <code class="language-plaintext highlighter-rouge">const</code> from C, but they really want map keys to be <code class="language-plaintext highlighter-rouge">const</code>.</p> <p>There is nothing stopping us from aliasing strings to data pointed to by a slice: after all, <code class="language-plaintext highlighter-rouge">strings.Builder</code> does it to avoid a copy in <code class="language-plaintext highlighter-rouge">String()</code>. We can implement this easily enough with some <code class="language-plaintext highlighter-rouge">unsafe</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">StringAlias</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Doing this is perfectly safe, so long as data is not mutated while the returned string is accessible. This allows virtually any slice type to be used as a key in a map, with some caveats.</p> <ol> <li> <p>Types which contain alignment padding cannot be used, because Go does not promise that it zeros memory returned by <code class="language-plaintext highlighter-rouge">new</code>.</p> </li> <li> <p>Types which contain pointers will cause those pointers to become unreachable if the only reference is the aliased string; this is because the pointed to data’s shape contains no pointer words.</p> </li> <li> <p>Incomparable types and interfaces will be compared by address (that is, maps, channels and funcs).</p> </li> </ol> <h3 id="dynamic-arrays-with-reflection"><a href="#dynamic-arrays-with-reflection">Dynamic Arrays with Reflection</a></h3> <p>Now, this isn’t the only to accomplish this: you can create dynamically-sized array types using reflection, like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Slice2Array</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span>

  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="n">elem</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">elem</span><span class="p">)</span>

  <span class="c">// NOTE: NewAt will return a reflect.Value containing a</span>
  <span class="c">// pointer, not an array!</span>
  <span class="n">refl</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">NewAt</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
  <span class="n">refl</span> <span class="o">=</span> <span class="n">refl</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span> <span class="c">// Dereference to get a pointer-to-array.</span>
  <span class="k">return</span> <span class="n">refl</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This will return an <code class="language-plaintext highlighter-rouge">any</code> whose type is <code class="language-plaintext highlighter-rouge">[len(s)]T</code>. You can even type assert it for static array sizes. This any is suitable for placing into a <code class="language-plaintext highlighter-rouge">map[any]T</code>, just as if we had built it with e.g. <code class="language-plaintext highlighter-rouge">any([...]byte("foo"))</code></p> <p>However, and this is not at all obvious from the code here, calling <code class="language-plaintext highlighter-rouge">refl.Interface()</code> will perform a copy of the whole array. <code class="language-plaintext highlighter-rouge">Interface()</code> delegates through a few functions until it calls <code class="language-plaintext highlighter-rouge">reflect.packEface()</code>.</p> <p>The code this function (<a href="https://cs.opensource.google/go/go/+/master:src/reflect/value.go;l=119?q=packEface&amp;ss=go%2Fgo">found here</a>) is reproduced below:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">reflect</span>

<span class="c">// packEface converts v to the empty interface.</span>
<span class="k">func</span> <span class="n">packEface</span><span class="p">(</span><span class="n">v</span> <span class="n">Value</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">typ</span><span class="p">()</span>
	<span class="k">var</span> <span class="n">i</span> <span class="n">any</span>
	<span class="n">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">abi</span><span class="o">.</span><span class="n">EmptyInterface</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span>
	<span class="c">// First, fill in the data portion of the interface.</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">t</span><span class="o">.</span><span class="n">IfaceIndir</span><span class="p">()</span><span class="o">:</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">"bad indir"</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c">// Value is indirect, and so is the interface we're making.</span>
		<span class="n">ptr</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagAddr</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">:=</span> <span class="n">unsafe_New</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
			<span class="n">typedmemmove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">c</span>
		<span class="p">}</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">ptr</span>
	<span class="k">case</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">!=</span> <span class="m">0</span><span class="o">:</span>
		<span class="c">// Value is indirect, but interface is direct. We need</span>
		<span class="c">// to load the data at v.ptr into the interface data word.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="c">// Value is direct, and so is the interface.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
	<span class="p">}</span>
	<span class="c">// Now, fill in the type portion. We're very careful here not</span>
	<span class="c">// to have any operation between the e.word and e.typ assignments</span>
	<span class="c">// that would let the garbage collector observe the partially-built</span>
	<span class="c">// interface value.</span>
	<span class="n">e</span><span class="o">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">t</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The switch determines precisely how the interface data pointer is computed. It turns out that (almost all) array types return true for <code class="language-plaintext highlighter-rouge">t.IfaceIndr()</code>, so the first case is selected, which triggers a copy (that being the call to <code class="language-plaintext highlighter-rouge">unsafe_New()</code> followed by a <code class="language-plaintext highlighter-rouge">typedmemmove</code>). This copy is to ensure that the value of the resulting interface cannot be mutated.</p> <p>Now, if only we knew the layout of Go’s interfaces, we might be able to get somewhere here…</p> <h2 id="the-layout-of-gos-interfaces"><a href="#the-layout-of-gos-interfaces">The Layout of Go’s Interfaces</a></h2> <p>Oh, yes, that’s what this article is about. So, if we look at the <code class="language-plaintext highlighter-rouge">runtime2.go</code> file in the runtime (yes, that’s what it’s called), nestled among the giant scheduler types for Gs, Ps, and Ms, we’ll find a couple of structs that really elucidate what’s going on:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">iface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">tab</span>  <span class="o">*</span><span class="n">itab</span>
	<span class="n">data</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">eface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">_type</span> <span class="o">*</span><span class="n">_type</span>
	<span class="n">data</span>  <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">funcval</code> is the layout of a <code class="language-plaintext highlighter-rouge">func()</code>, more on that later. <code class="language-plaintext highlighter-rouge">iface</code> is the layout of your “usual” interface, consisting of an <code class="language-plaintext highlighter-rouge">itab</code> (an interface table, or what Go calls a vtable) and a pointer to some data. <code class="language-plaintext highlighter-rouge">eface</code> is the layout of <code class="language-plaintext highlighter-rouge">any</code> (the artist formerly known as <code class="language-plaintext highlighter-rouge">interface{}</code>, hence the name: <em>e</em>mpty inter<em>face</em>).</p> <p><code class="language-plaintext highlighter-rouge">eface</code> having its own layout is an optimization. Because <code class="language-plaintext highlighter-rouge">any</code> exists to be downcast from dynamically, storing the type directly cuts out a pointer load when doing a type switch on an <code class="language-plaintext highlighter-rouge">any</code> specifically. If we look at what an <code class="language-plaintext highlighter-rouge">itab</code> is (which is “just” an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/iface.go;l=14"><code class="language-plaintext highlighter-rouge">abi.ITab</code></a>):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="c">// The first word of every non-empty interface type contains an *ITab.</span>
<span class="c">// It records the underlying concrete type (Type), the interface type</span>
<span class="c">// it is implementing (Inter), and some ancillary information.</span>
<span class="c">//</span>
<span class="c">// allocated in non-garbage-collected memory</span>
<span class="k">type</span> <span class="n">ITab</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Inter</span> <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">Type</span>  <span class="o">*</span><span class="n">Type</span>
	<span class="n">Hash</span>  <span class="kt">uint32</span>     <span class="c">// copy of Type.Hash. Used for type switches.</span>
	<span class="n">Fun</span>   <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c">// fun[0]==0 means Type does not implement Inter.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <h3 id="codegen-for-interface-operations"><a href="#codegen-for-interface-operations">Codegen for Interface Operations</a></h3> <p>An <code class="language-plaintext highlighter-rouge">ITab</code> contains the same type it would have as an <code class="language-plaintext highlighter-rouge">any</code>, which makes the generated code for a function that upcasts an interface to <code class="language-plaintext highlighter-rouge">any</code> very simple<sup id="fnref:asm" role="doc-noteref"><a href="#fn:asm" class="footnote" rel="footnote">3</a></sup>:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Upcast</span><span class="p">(</span><span class="n">i</span> <span class="n">MyIface</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">F</span><span class="o">:</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>In the register ABI, the x86 argument (and return) registers are <code class="language-plaintext highlighter-rouge">rax</code>, <code class="language-plaintext highlighter-rouge">rbx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, <code class="language-plaintext highlighter-rouge">r10</code> and <code class="language-plaintext highlighter-rouge">r11</code> (with <code class="language-plaintext highlighter-rouge">rdx</code> reserved for passing a closure capture, more on that later; <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the currently running G).</p> <p>The <code class="language-plaintext highlighter-rouge">*ITab</code> comes in on <code class="language-plaintext highlighter-rouge">rax</code> and the data pointer on <code class="language-plaintext highlighter-rouge">rbx</code>. First, we need to check if this is the nil interface, identified by having a nil itab (or type, in the case of <code class="language-plaintext highlighter-rouge">any</code>). If it is nil, we just return: <code class="language-plaintext highlighter-rouge">rax:rbx</code> already contain the data of a nil <code class="language-plaintext highlighter-rouge">any</code>. Otherwise, we load <code class="language-plaintext highlighter-rouge">ITab.Type</code>, at offset 8, into <code class="language-plaintext highlighter-rouge">rax</code>, and return.</p> <p>How do interface function calls work?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span><span class="n">m</span> <span class="n">MyIface</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">Method</span><span class="p">(</span><span class="m">42</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rsp</span><span class="p">,</span> <span class="n">rbp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="mi">42</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="n">nop</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">morestack_noctxt</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>This function seems to be doing a lot more than it actually is. Part of it is that its prologue has to do a call to <code class="language-plaintext highlighter-rouge">runtime.morestack_noctxt()</code>, which is simply a call to <code class="language-plaintext highlighter-rouge">runtime.morestack</code> that clobbers <code class="language-plaintext highlighter-rouge">rdx</code>, the closure capture parameter. The meat of it comes when it loads <code class="language-plaintext highlighter-rouge">[rax + 24]</code>, the first element of <code class="language-plaintext highlighter-rouge">ITab.Fun</code>. It then moves the data pointer in <code class="language-plaintext highlighter-rouge">rbx</code> to <code class="language-plaintext highlighter-rouge">rax</code>, the argument into <code class="language-plaintext highlighter-rouge">rbx</code>, and issues the call.</p> <p>What about upcasts? An upcast to a concrete type is quite simple: simply compare the type in the interface (either directly or in the <code class="language-plaintext highlighter-rouge">*ITab</code>) to a particular statically-known one. Downcasting to an interface (sometimes called a <em>sidecast</em>) is much more complicated, because it essentially requires a little bit of reflection.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Downcast</span><span class="p">(</span><span class="n">m</span> <span class="n">any</span><span class="p">)</span> <span class="n">MyIface</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="p">(</span><span class="n">MyIface</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">hashProbe</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rsi</span>
    <span class="n">and</span>     <span class="n">rsi</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">shl</span>     <span class="n">rsi</span><span class="p">,</span> <span class="mi">4</span>
    <span class="n">mov</span>     <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jeq</span>     <span class="n">found</span>
    <span class="n">lea</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">test</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jnz</span>     <span class="n">hashProbe</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">leq</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">typeAssert</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">done</span>
<span class="n">found</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">done</span><span class="o">:</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="n">foo</span><span class="p">.</span><span class="n">MyIface</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicnildottype</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as it was in foo.Call above.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>When we request an interface downcast, the Go compiler synthesizes a symbol of type <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code>. Its definition is reproduced below.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="k">type</span> <span class="n">TypeAssert</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Cache</span>   <span class="o">*</span><span class="n">TypeAssertCache</span>
	<span class="n">Inter</span>   <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">CanFail</span> <span class="kt">bool</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCache</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Mask</span>    <span class="kt">uintptr</span>
	<span class="n">Entries</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="n">TypeAssertCacheEntry</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCacheEntry</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// type of source value (a *runtime._type)</span>
	<span class="n">Typ</span> <span class="kt">uintptr</span>
	<span class="c">// itab to use for result (a *runtime.itab)</span>
	<span class="c">// nil if CanFail is set and conversion would fail.</span>
	<span class="n">Itab</span> <span class="kt">uintptr</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The first thing this function does is check if <code class="language-plaintext highlighter-rouge">rax</code> contains 0, i.e., if this is a nil <code class="language-plaintext highlighter-rouge">any</code>, and panics if that’s the case (that’s a call to <code class="language-plaintext highlighter-rouge">runtime.panicnildottype</code>). It then loads <code class="language-plaintext highlighter-rouge">foo..typeAssert0</code>, a synthetic global variable containing an <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code> value. It loads the <code class="language-plaintext highlighter-rouge">Cache</code> field, as well as the <code class="language-plaintext highlighter-rouge">Hash</code> field of the <code class="language-plaintext highlighter-rouge">abi.Type</code> attached to the <code class="language-plaintext highlighter-rouge">any</code>. It masks off the low bits using <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Mask</code>, and uses that to start probing the very simple open-addressed hash table located in <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Entries</code>.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with the type we’re looking for (compared by address), we’ve found it. We load that entry’s <code class="language-plaintext highlighter-rouge">Itab</code> value into <code class="language-plaintext highlighter-rouge">rax</code> to change the value from being an <code class="language-plaintext highlighter-rouge">any</code> to being a <code class="language-plaintext highlighter-rouge">MyIface</code>, and we’re done.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with a nil <code class="language-plaintext highlighter-rouge">Typ</code> pointer, we’re forced to hit the slow path, implemented at <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code>. This dynamically builds an itab by searching the method set of the type inside the <code class="language-plaintext highlighter-rouge">any</code>.</p> <p>This then calls the reflection code in <code class="language-plaintext highlighter-rouge">runtime.getitab()</code>, which is what actually performs the messy search through the method set, comparing the names and signatures of methods with those in the interface, to produce an itab at runtime.</p> <p>Then, it shoves this the resulting itab into the global itab cache, which is protected by a global lock! There are lots of scary atomics in this code. There are many places where this can potentially panic, bubbling up a type assertion failure to the user.</p> <p>When <code class="language-plaintext highlighter-rouge">runtime.getitab()</code> returns, <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code> will <em>maybe</em><sup id="fnref:maybe-update" role="doc-noteref"><a href="#fn:maybe-update" class="footnote" rel="footnote">4</a></sup> update the type assertion cache, and return the new itab. This allows the code in our function to return directly, without needing to take another trip into the <code class="language-plaintext highlighter-rouge">hashProbe</code> loop.</p> <p>In theory, PGO could be used to pre-fill the cache, but I couldn’t find any code in the compiler that indicates that this is something they do. In the meantime, you can optimize a hot type assert ahead of time by asserting to a known common type:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">rs</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span>
  <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Check for a known implementation first. This only costs</span>
    <span class="c">// a pointer comparison with the *abi.Type in the itab.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Do an interface type assertion. This would eventually</span>
    <span class="c">// learn os.File, but the branch above skips that "warmup"</span>
    <span class="c">// time. It also lets the hardware branch predictor allocate</span>
    <span class="c">// a prediction slot just for os.File.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// ...</span>
  <span class="p">}</span>
<span class="p">}</span> </code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Type switches, incidentally, use a very similar caching mechanism for switches that include interface types among the cases.</p> <h3 id="what-was-that-about-indirect-interfaces"><a href="#what-was-that-about-indirect-interfaces">What Was That About Indirect Interfaces?</a></h3> <p>Back when we were hacking arrays into existence with reflection, there was some trouble in <code class="language-plaintext highlighter-rouge">reflect.Value.Interface()</code>, where it would do a seemingly unnecessary copy.</p> <p>This is because an interface’s data pointer must be a pointer. If you cram, say, an <code class="language-plaintext highlighter-rouge">int</code> into an <code class="language-plaintext highlighter-rouge">any</code>, Go will spill it to the heap. This is often called <em>boxing</em>, but the Go runtime refers to it as an “indirect interface”.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">push</span>     <span class="n">rbp</span>
  <span class="n">mov</span>      <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
  <span class="n">call</span>     <span class="n">runtime</span><span class="p">.</span><span class="n">convT64</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">pop</span>      <span class="n">rbp</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Like many other managed languages, Go will skip boxing very small values by instead returning pointers into some global array.</p> <p>Now, this boxing could be avoided: after all, an <code class="language-plaintext highlighter-rouge">int</code> is no larger than a pointer, so we could cram it into the data pointer field directly. However, the GC <em>really</em> doesn’t like that: the GC assumes it can trace through any pointer. Now, the GC <em>could</em> treat interfaces differently, and look at the type/itab pointer to determine if the data value pointer or a scalar. However, this would add significant complexity to both the representation of shapes, and to the tracing code in the GC, resulting in more branches and slower tracing.</p> <p>However, if the type being wrapped in an interface happens to be a pointer, it can just use that pointer value directly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Any type that has the same shape as a pointer will be indirect. This includes maps, channels, and funcs. It also includes one element arrays of such types, such as <code class="language-plaintext highlighter-rouge">[1]*int</code> and <code class="language-plaintext highlighter-rouge">[1]chan error</code>, and single-field structs of such types. Curiously, this does not include structs which contain a zero-sized field before the pointer-sized field, even though those have the same shape as a pointer.</p> <p>This means it’s generally not safe to play games with forging an interface out of a pointer to some type: whether that type is indirect in an interface is a subtle implementation detail of the compiler.</p> <p>And of course, it’s important to remember that if you want to return a value by interface, you had best hope it can get inlined, so the compiler can promote the heap allocation to the stack.</p> <h2 id="function-pointers"><a href="#function-pointers">Function Pointers</a></h2> <p>The last thing to look at are Go’s function pointers. For the longest time, I assumed they had the same layout as an interface: a pointer to closure data, and a hardware function pointer.</p> <p>It turns out the layout is weirder: let’s revisit the <code class="language-plaintext highlighter-rouge">runtime.funcval</code> we found in <code class="language-plaintext highlighter-rouge">runtime2.go</code> earlier.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This unusual layout is best understood by looking at the generated assembly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span>
  <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span>
  <span class="n">x</span> <span class="kt">int</span><span class="p">,</span>
<span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>To call <code class="language-plaintext highlighter-rouge">f</code>, first we interpret it as a <code class="language-plaintext highlighter-rouge">*funcval</code> and load <code class="language-plaintext highlighter-rouge">f.fn</code> into a temporary. That is, the first word pointed to by <code class="language-plaintext highlighter-rouge">rax</code> (which holds <code class="language-plaintext highlighter-rouge">f</code> on function entry). Then, we place <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">rdx</code>, the closure context register. The reason for using this extra magic register will become clear shorter. Then, we arrange the rest of the arguments in their usual registers, and we jump to the address stored in <code class="language-plaintext highlighter-rouge">f.fn</code>.</p> <p>Inside of <code class="language-plaintext highlighter-rouge">f</code>, captures are accessed by offsetting from <code class="language-plaintext highlighter-rouge">rdx</code>. What does one of those closures look like?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">imul</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rcx</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>All <code class="language-plaintext highlighter-rouge">Capture</code> is doing is allocating a <code class="language-plaintext highlighter-rouge">funcval</code> with a single <code class="language-plaintext highlighter-rouge">int</code> capture; that’s the <code class="language-plaintext highlighter-rouge">{ F uintptr; X0 int }</code> in the code above. It then places the address of <code class="language-plaintext highlighter-rouge">Capture.func1</code>, which implements the callback, into <code class="language-plaintext highlighter-rouge">F</code>, and the argument of <code class="language-plaintext highlighter-rouge">Capture</code> into <code class="language-plaintext highlighter-rouge">X0</code>.</p> <p>What about when returning a reference to a function? In that case, all that happens is it returns a reference to a global containing the address of the function.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Id</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Id</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="p">]</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="o">:</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="o">:</span>
    <span class="p">.</span><span class="n">quad</span> <span class="n">foo</span><span class="p">.</span><span class="n">Id</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Because we pass the closure arguments in an extra register not used by regular functions, we don’t need to create a thunk for this case.</p> <p>Unfortunately, we do need to create a thunk for methods, even methods with a pointer receiver. This is because of the following incompatible constraints:</p> <ol> <li> <p>The receiver pointer for a method must point exactly to the value the method is called on. It can’t be a fixed offset before, because that would create an out-of-bounds pointer, which the GC does not tolerate.</p> </li> <li> <p>The closure pointer must point to the start of the funcval, <em>not</em> its captures, because adjusting the pointer to point to the captures would cause it to point one-past-the-end of a value, which the GC <em>also</em> does not tolerate!</p> </li> </ol> <p>Thus, <em>even</em> if methods accepted a pointer receiver via <code class="language-plaintext highlighter-rouge">rdx</code>, closures and methods disagree about where that pointer should be passed.</p> <p>Of course, there are adjustments we can make to fix this problem. For example, we could require that all <code class="language-plaintext highlighter-rouge">funcval</code> values have at least one capture. No-capture <code class="language-plaintext highlighter-rouge">funcvals</code> would have a synthetic <code class="language-plaintext highlighter-rouge">_ byte</code> field. This is not unlike how a non-empty struct whose final field is empty will be padded with an extra <code class="language-plaintext highlighter-rouge">_ byte</code> field: this is specifically to avoid a pointer to that field being a past-the-end pointer. The cost is that every non-capturing closure costs twice as much binary size.</p> <p>Another fix is to make the GC blind to the pointer in <code class="language-plaintext highlighter-rouge">rdx</code>. This will never be the only pointer by which a value is reachable, so it would be safe to replace <code class="language-plaintext highlighter-rouge">mov rdx, rax</code> with a <code class="language-plaintext highlighter-rouge">lea rdx, [rax + 8]</code>. The GC would never know!</p> <p>Until then, beware that writing <code class="language-plaintext highlighter-rouge">return foo.Method</code> secretly allocates 16 bytes or so. (Aside: I used to sit next to the Go team at Google, and I remember having a conversation with Austin Clements about this. Apparently I misremembered, because until recently I thought Go already implemented this optimization!)</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>If you made it this far this is probably you right now:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/stickers/dizzy.png" alt="Miguel as a Whimsicott, dizzy with register names."/></p> </figure> <p>This isn’t intended to be as polished as most of my articles, but there’s been enough things I’ve come across that I wanted to write this all up for my own reference.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:constants" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Sizeof</code> and <code class="language-plaintext highlighter-rouge">Alignof</code> are intrinsics, so the compiler will turn them into constants. However, they are only constants if the type being measured is not generic, so wrapping them in a function like this doesn’t actually hurt in generic code. <a href="#fnref:constants" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:gc-programs" role="doc-endnote"> <p>Except for very large types that would have more words than can be recorded by an array of size <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/type.go;l=803;bpv=0"><code class="language-plaintext highlighter-rouge">abi.MaxPtrmaskBytes</code></a>. For larger types, we use GC programs! A GC program is an LZ-compressed bitset serving the same purpose as the pointer bitset most smaller types use. See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/cmd/internal/gcprog/gcprog.go">gcprog.go</a>.</p> <p>In fact, <code class="language-plaintext highlighter-rouge">reflection</code> knows how to create programs on the fly for most types! See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/reflect/type.go;l=2658">reflect/type.go</a>. <a href="#fnref:gc-programs" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:asm" role="doc-endnote"> <p>I will be writing assembly examples in Intel-syntax x86. Go’s assembly syntax is horrible and an impediment to the point I’m making. <a href="#fnref:asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:maybe-update" role="doc-endnote"> <p>Maybe? Well, the cache will only get updated about 0.1% of the time. This is to amortize the costs of growing the cache. I assume they benchmarked this, and found that the cost of growing the cache makes it only worthwhile when that assertion is getting hammered. <a href="#fnref:maybe-update" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div> <div class="pagination post-footer"> <a class="pagination-item newer" href="https://mcyoung.xyz/page3">&lt; Prev</a> • <a class="pagination-item older" href="https://mcyoung.xyz/page5">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>