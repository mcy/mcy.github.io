<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Move Constructors Revisited &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Move Constructors Revisited &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/move-ctors-2-8dad126142e6452354002782c0ca3a7035eef016.png"> <meta property="og:title" content="Move Constructors Revisited &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/move-ctors-2-8dad126142e6452354002782c0ca3a7035eef016.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2021/12/19/move-ctors-2/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz/posts"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/posts"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2021-12-19 • 1945 words • 10 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#ffi">#ffi</a> </span> <h1><a href="/2021/12/19/move-ctors-2/"> Move Constructors Revisited<br/> </a></h1> </div> <div class="post"> <p>Almost a year ago I developed the <a href="https://github.com/google/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a> Rust library, which provides primitives for expressing something like C++’s <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> and move constructors while retaining Rust’s so-called “destructive move property”: moving a value transfers ownership, rather than doing a funny copy.</p> <p>In an <a href="https://mcyoung.xyz//2021/04/26/move-ctors">earlier blogpost</a> I described the theory behind this library and some of the motivation, which I feel fairly confident about, especially in how constructors (and their use of pinning) are defined.</p> <p>However, there is a problem.</p> <h2 id="a-not-so-quick-recap"><a href="#a-not-so-quick-recap">A Not-so-Quick Recap</a></h2> <p>The old post is somewhat outdated, since <code class="language-plaintext highlighter-rouge">moveit</code> uses different names for a lot of things that are geared to fit in with the rest of Rust.</p> <p>The core abstraction of <code class="language-plaintext highlighter-rouge">moveit</code> is the constructor, which are types that implement the <code class="language-plaintext highlighter-rouge">New</code> trait:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">New</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The type to construct.</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

  <span class="cd">/// Construct a new value in-place using the arguments stored</span>
  <span class="cd">/// in `self`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">this</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>A <code class="language-plaintext highlighter-rouge">New</code> type is not what is being constructed; rather, it represents a <em>method</em> of construction, resembling a specialized <code class="language-plaintext highlighter-rouge">Fn</code> trait. The constructed type is given by the associated type <code class="language-plaintext highlighter-rouge">Output</code>.</p> <p>Types that can be constructed are constructed <em>in place</em>, unlike most Rust types. This is a property shared by constructors in C++, allowing values to record their own address at the moment of creation. Explaining why this is useful is a bit long-winded, but let’s assume this is a thing we want to be able to do. Crucially, we need the output of a constructor to be pinned, which is why the <code class="language-plaintext highlighter-rouge">this</code> output parameter is pinned.</p> <p>Calling a constructor requires creating the output location in advance so that we can make it available to it in time:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create storage for the new value.</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>

<span class="c1">// Pin that storage on the stack; by calling this, we may never move</span>
<span class="c1">// `storage` again, even after this goes out of scope.</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Now we can call the constructor. It's only unsafe because it assumes</span>
<span class="c1">// the provided memory is uninitialized.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">());</span>
</code></pre></div></div> <p>However, this is not quite right. <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>’s docs are quite clear that we must ensure that, once we create an <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, we must call <code class="language-plaintext highlighter-rouge">T</code>’s destructor before its memory is re-used; since reuse is unavoidable for stack data, and <code class="language-plaintext highlighter-rouge">storage</code> will not do it for us (it’s a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, after all), we must somehow run the destructor separately.</p> <h3 id="an-easy-solution"><a href="#an-easy-solution">An “Easy” Solution</a></h3> <p>One trick we could use is to replace <code class="language-plaintext highlighter-rouge">storage</code> with some kind of wrapper over a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> that calls the destructor for us:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.assume_init_mut</span><span class="p">())</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This <em>works</em>, but isn’t ideal, because now we can’t write down something like a C++ move constructor without running into the classic C++ problem: all objects must be destroyed unconditionally, so now you can have moved-from state. Giving up Rust’s moves-transfer-ownership (i.e. <em>affine</em>) property is bad, but it turns out to be avoidable!</p> <p>There are also some scary details around panics here that I won’t get into.</p> <h3 id="t-mut-t--move-t"><a href="#t-mut-t--move-t"><code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, … <code class="language-plaintext highlighter-rouge">&amp;move T</code>?</a></h3> <p><code class="language-plaintext highlighter-rouge">moveit</code> instead provides a <a href="https://docs.rs/moveit/latest/moveit/move_ref/struct.MoveRef.html"><code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code></a> type that tries to capture the notion of what an “owning reference” <em>could</em> mean in Rust. An <code class="language-plaintext highlighter-rouge">&amp;move</code> or <code class="language-plaintext highlighter-rouge">&amp;own</code> type has been discussed many times, but implementing it in the full generality it would deserve as a language feature runs into some interesting problems due to how <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, the heap allocated equivalent, <a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">currently behaves.</a></p> <p>We can think of <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code> as wrapping the <em>longest-lived</em> <code class="language-plaintext highlighter-rouge">&amp;mut T</code> reference pointing to a particular location in memory. The longest-lived part is crucial, since it means that <code class="language-plaintext highlighter-rouge">MoveRef</code> is entitled to run its pointee’s destructor:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Notice parallels with EventuallyInit&lt;T&gt; above.</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>No reference to the pointee can ever outlive the <code class="language-plaintext highlighter-rouge">MoveRef</code> itself, by definition, so this is safe. The owner of a value is that which is entitled to destroy it, and therefore a <code class="language-plaintext highlighter-rouge">MoveRef</code> <em>literally</em> owns its pointee. Of course, this means we can move out of it (which was the whole point of the original blogpost).</p> <p>Because of this, we are further entitled to arbitrarily pin a <code class="language-plaintext highlighter-rouge">MoveRef</code> with no consequences: pinning it would consume the unpinned <code class="language-plaintext highlighter-rouge">MoveRef</code> (for obvious reasons, <code class="language-plaintext highlighter-rouge">MoveRefs</code> cannot be reborrowed) so no unpinned reference may outlive the pinning operation.</p> <p>This gives us a very natural solution to the problem above: <code class="language-plaintext highlighter-rouge">result</code> should not be a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, but rather a <code class="language-plaintext highlighter-rouge">Pin&lt;MoveRef&lt;'_, T&gt;&gt;</code>:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pinned</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">())</span>
<span class="p">));</span>
</code></pre></div></div> <p>This messy sequence of steps is nicely wrapped up in a macro provided by the library that ensures safe initialization and eventual destruction:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Allocate storage on the stack, emplace `my_new` onto it, and pin it</span>
<span class="c1">// in an owning reference.</span>
<span class="nd">moveit!</span><span class="p">(</span><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">MoveRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">my_new</span><span class="p">);</span>
</code></pre></div></div> <p>There is also some reasonably complex machinery that allows us to do something like an owning <code class="language-plaintext highlighter-rouge">Deref</code>, which I’ll come back to in a bit.</p> <p>However, there is a small wrinkle that I did not realize when I first designed <code class="language-plaintext highlighter-rouge">MoveRef</code>: what happens if I <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">MoveRef</code>?</p> <h2 id="undefined-behavior-obviously"><a href="#undefined-behavior-obviously">Undefined Behavior, Obviously</a></h2> <p>Quashing destruction isn’t new to Rust: we can <code class="language-plaintext highlighter-rouge">mem::forget</code> just about anything, leaking all kinds of resources. And that’s ok! Destructors alone cannot be used in type design to advert <code class="language-plaintext highlighter-rouge">unsafe</code> catastrophe, a well-understood limitation of the language that we have experience designing libraries around, such as <a href="https://doc.rust-lang.org/nomicon/leaking.html#drain"><code class="language-plaintext highlighter-rouge">Vec::drain()</code></a>.</p> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s design creates a contradiction:</p> <ul> <li><code class="language-plaintext highlighter-rouge">MoveRef</code> is an owning smart pointer, and therefore can be safely pinned, much like <code class="language-plaintext highlighter-rouge">Box::into_pinned()</code> enables. Constructors, in particular, are <em>designed</em> to generate pinned <code class="language-plaintext highlighter-rouge">MoveRef</code>s!</li> <li>Forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code> will cause the pointee destructor to be suppressed, but its storage will still be freed and eventually re-used, a violation of the <code class="language-plaintext highlighter-rouge">Pin</code> drop guarantee.</li> </ul> <p>This would <em>appear</em> to mean that a design like <code class="language-plaintext highlighter-rouge">MoveRef</code> is not viable at all, and that this sort of “stack box” strategy is always unsound.</p> <blockquote> <h3 id="what-about-box"><a href="#what-about-box">What About <code class="language-plaintext highlighter-rouge">Box</code>?</a></h3> <p>What about it? Even though we can trivially create a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;i32&gt;&gt;</code> via <code class="language-plaintext highlighter-rouge">Box::pin()</code>, this is a red herring. When we <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">Box</code>, we also forget about its storage too. Because its storage has been leaked unrecoverably, we are still, <em>technically</em>, within the bounds of the <code class="language-plaintext highlighter-rouge">Pin</code> contract. Only barely, but we’re inside the circle.</p> </blockquote> <p>Interestingly, the Rust language has to deal with a similar problem; perhaps it suggests a way out?</p> <h2 id="drop-flags-and-dynamic-ownership-transfer"><a href="#drop-flags-and-dynamic-ownership-transfer">Drop Flags and Dynamic Ownership Transfer</a></h2> <p>Carefully crafted Rust code emits some very interesting assembly. I’ve annotated the key portion of the output with a play-by-play below.</p> <p>```rust godbolt:o=-O #[inline(never)] pub fn someone_elses_problem(_: Box<i32>) { // What goes in here isn't important,it just needs to // be an optimizer black-box. }</i32></p> <p>pub fn maybe_drop(flag: bool) { let x = Box::new(42); if flag { someone_elses_problem(x) } }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```x86
// See Godbolt widget above for full disassembly.
example::maybe_drop:
  // ...

  // Allocate memory.
  call    __rust_alloc

  // Check if allocation failed; panic if so.
  test    rax, rax
  je      .L.scream

  // Write a 42 to the memory.
  mov     dword ptr [rax], 42

  // Check the flag argument (LLVM decided to put it in rbx). If
  // true, we go free the memory ourselves.
  test    bl, bl
  je      .L.actually_our_problem

  // Otherwise, make it someone else's problem; they get to
  // free the memory for themselves. 
  mov     rdi, rax
  pop     rbx
  jmp     example::someone_elses_problem

  // ...
</code></pre></div></div> <p>The upshot is that <code class="language-plaintext highlighter-rouge">maybe_drop</code> conditions the destructor of <code class="language-plaintext highlighter-rouge">x</code> on a <em>flag</em>, which is allocated next to it on the stack. Rust flips this flag when the value is moved into another function, and only runs the destructor when the flag is left alone. In this case, LLVM folded the flag into the <code class="language-plaintext highlighter-rouge">bool</code> argument, so this isn’t actually a meaningful perf hit.</p> <p>These “drop flags” are key to Rust’s ownership model. Since ownership may be transferred dynamically due to reasonably complex control flow, it needs to leave breadcrumbs for itself to figure out whether the value wound up getting moved away or not. This is unique to Rust: in C++, every object is always destroyed, so no such faffing about is necessary.</p> <p>Similarly, <code class="language-plaintext highlighter-rouge">moveit</code> can close this soundness hole by leaving itself breadcrumbs to determine if safe code is trying to undermine its guarantees.</p> <p>In other words: in Rust, it is not sufficient to manage a pointer to manage a memory location; it is necessary to manage an explicit or implicit drop flag as well.</p> <h2 id="a-flagged-moveref"><a href="#a-flagged-moveref">A Flagged <code class="language-plaintext highlighter-rouge">MoveRef</code></a></h2> <p>We can extend <code class="language-plaintext highlighter-rouge">MoveRef</code> to track an explicit drop flag:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>

  <span class="c1">// Set to `false` once the destructor runs.</span>
  <span class="n">drop_flag</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>Wrapping it in a <code class="language-plaintext highlighter-rouge">Cell</code> is convenient and doesn’t cost us anything, since a <code class="language-plaintext highlighter-rouge">MoveRef</code> can never be made <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code> anyways. Inside of its destructor, we can flip the flag, much like Rust flips a drop flag when transferring ownership to another function:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.drop_flag</span><span class="nf">.set</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>But, how should we use it? The easiest way is to change the definition of <code class="language-plaintext highlighter-rouge">moveit!()</code> to construct a <em>flag trap</em>:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Create a *trapped flag*, which I'll describe below.</span>
<span class="k">let</span> <span class="n">trap</span> <span class="o">=</span> <span class="nn">TrappedFlag</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// Run the constructor as before and construct a MoveRef.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">uninit</span><span class="p">)</span><span class="nf">.assume_init_mut</span><span class="p">(),</span>
  <span class="n">trap</span><span class="nf">.flag</span><span class="p">(),</span>  <span class="c1">// Creating a MoveRef now requires</span>
                <span class="c1">// passing in a flag in addition to </span>
                <span class="c1">// a reference to the owned value itself.</span>
<span class="p">));</span>
</code></pre></div></div> <p>The trap is a deterrent against forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code>: because the <code class="language-plaintext highlighter-rouge">MoveRef</code>’s destructor flips the flag, the trap’s destructor will notice if this <em>doesn’t</em> happen, and take action accordingly.</p> <blockquote> <p>Note: in <code class="language-plaintext highlighter-rouge">moveit</code>, this is actually implemented by having the <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code> type carry a reference to the trap, created in the <code class="language-plaintext highlighter-rouge">slot!()</code> macro. However, this is not a crucial detail for the design.</p> </blockquote> <h3 id="an-earth-shattering-kaboom"><a href="#an-earth-shattering-kaboom">An Earth-Shattering Kaboom</a></h3> <p>The trap is another RAII type that basically looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="nf">TrappedFlag</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">TrappedFlag</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">()</span> <span class="p">{</span> <span class="nf">abort</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The trap is simple: if the contained drop flag is not flipped, it crashes the program. Because <code class="language-plaintext highlighter-rouge">moveit!()</code> allocates it on the stack where uses cannot <code class="language-plaintext highlighter-rouge">mem::forget</code> it, its destructor is guaranteed to run before <code class="language-plaintext highlighter-rouge">storage</code>’s destructor runs (although Rust does not guarantee destructors run, it <em>does</em> guarantee their order).</p> <p>If a <code class="language-plaintext highlighter-rouge">MoveRef</code> is forgotten, it won’t have a chance to flip the flag, which the trap will detect. Once the trap’s destructor notices this, it cannot return, either normally or by panic, since this would cause <code class="language-plaintext highlighter-rouge">storage</code> to be freed. Crashing the program is the only<sup id="fnref:or-we-could-drop-it" role="doc-noteref"><a href="#fn:or-we-could-drop-it" class="footnote" rel="footnote">1</a></sup> acceptable response.</p> <p>Some of <code class="language-plaintext highlighter-rouge">MoveRef</code>’s functions need to be adapted to this new behavior: for example, <code class="language-plaintext highlighter-rouge">MoveRef::into_inner()</code> still needs to flip the flag, since moving out of the <code class="language-plaintext highlighter-rouge">MoveRef</code> is equivalent to running the destructor for the purposes of drop flags.</p> <h2 id="a-safer-derefmove"><a href="#a-safer-derefmove">A Safer <code class="language-plaintext highlighter-rouge">DerefMove</code></a></h2> <p>In order for <code class="language-plaintext highlighter-rouge">MoveRef</code> to be a proper “new” reference type, and not just a funny smart pointer, we also need a <code class="language-plaintext highlighter-rouge">Deref</code> equivalent:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// An "uninitialized" version of `Self`.</span>
  <span class="k">type</span> <span class="n">Uninit</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>
  
  <span class="cd">/// "Deinitializes" `self`, producing an opaque type that will</span>
  <span class="cd">/// destroy the storage of `*self` without calling the pointee</span>
  <span class="cd">/// destructor.</span>
  <span class="k">fn</span> <span class="nf">deinit</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a `MoveRef` that owns its</span>
  <span class="cd">/// contents.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">deref_move</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is the <em>original</em> design for <code class="language-plaintext highlighter-rouge">DerefMove</code>, which had a two-phase operation: first <code class="language-plaintext highlighter-rouge">deinit()</code> was used to create a destructor-suppressed version of the smart pointer that would only run the destructor for the storage (e.g., for <code class="language-plaintext highlighter-rouge">Box</code>, only the call to <code class="language-plaintext highlighter-rouge">free()</code>). Then, <code class="language-plaintext highlighter-rouge">deref_move()</code> would extract the “inner pointee” out of it as a <code class="language-plaintext highlighter-rouge">MoveRef</code>. This had the effect of splitting the smart pointer’s destructor, much like we did above on the stack.</p> <p>This has a number of usability problems. Not only does it <em>need</em> to be called through a macro, but <code class="language-plaintext highlighter-rouge">deinit()</code> isn’t actually safe: failing to call <code class="language-plaintext highlighter-rouge">deref_move()</code> is just as bad as calling <code class="language-plaintext highlighter-rouge">mem::forget</code> on the result. Further, it’s not clear where to plumb the drop flags through.</p> <p>After <a href="https://github.com/google/moveit/pull/23#issuecomment-963549869">many attempts</a> to graft drop flags onto this design, I replaced it with a completely new interface:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The "pure storage" form of `Self`, which owns the storage</span>
  <span class="cd">/// but not the pointee.</span>
  <span class="k">type</span> <span class="n">Storage</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a [`MoveRef`] that owns</span>
  <span class="cd">/// its contents.</span>
  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Storage</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Uninit</code> has been given the clearer name of <code class="language-plaintext highlighter-rouge">Storage</code>: a type that owns <em>just</em> the storage of the moved-from pointer. The two functions were merged into a single, <em>safe</em> function that performs everything in one step, emitting the storage as an out-parameter.</p> <p>The new <code class="language-plaintext highlighter-rouge">DroppingSlot&lt;T&gt;</code> is like a <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code>, but closer to a safe version of the <code class="language-plaintext highlighter-rouge">EventuallyInit&lt;T&gt;</code> type from earlier: its contents are not necessarily initialized, but if they are, it destroys them, and it only does so when its drop flag is set.</p> <p><code class="language-plaintext highlighter-rouge">Box</code> is the most illuminating example of this trait:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// Dismantle the incoming Box into the "storage-only part".</span>
    <span class="k">let</span> <span class="n">this</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span>
    <span class="p">};</span>

    <span class="c1">// Put the Box into the provided storage area. Note that we</span>
    <span class="c1">// don't need to set the drop flag; `DroppingSlot` does</span>
    <span class="c1">// that automatically for us.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="o">=</span> <span class="n">storage</span><span class="nf">.put</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

    <span class="c1">// Construct a new MoveRef, converting `storage` from </span>
    <span class="c1">// `&amp;mut Box&lt;MaybeUninit&lt;T&gt;&gt;` into `&amp;mut T`.</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">storage</span><span class="nf">.assume_init_mut</span><span class="p">(),</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s own implementation illustrates the need for the explicit lifetime bound:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="p">();</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// We can just return directly; this is a mere lifetime narrowing.</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Since this is fundamentally a lifetime narrowing, this can only compile if we insist that <code class="language-plaintext highlighter-rouge">'a: 'frame</code>, which is implied by <code class="language-plaintext highlighter-rouge">Self: 'frame</code>. Earlier iterations of this design enforced it via a <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, Self&gt;</code> receiver, which turned out to be unnecessary.</p> <h2 id="conclusions"><a href="#conclusions">Conclusions</a></h2> <p>As of writing, I’m still in the process of self-reviewing <a href="https://github.com/google/moveit/pull/25">this change</a>, but at this point I feel <em>reasonably</em> confident that it’s correct; this article is, in part, written to convince myself that I’ve done this correctly.</p> <p>The new design will also enable me to finally complete my implementation of a constructor and pinning-friendly vector type; this issue came up in part because the vector type needs to manipulate drop flags in a complex way. For this reason, the <em>actual</em> implementation of drop flags actually uses a counter, not a single boolean.</p> <p>I doubt this is the last issue I’ll need to chase down in <code class="language-plaintext highlighter-rouge">moveit</code>, but for now, we’re ever-closer to true owning references in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:or-we-could-drop-it" role="doc-endnote"> <p>Arguably, running the skipped destructor is <em>also</em> a valid remediation strategy. However, this is incompatible with what the user requested: they asked for the destructor to be supressed, not for it to be run at a later date. This would be somewhat surprising behavior, which we could warn about for the benefit of <code class="language-plaintext highlighter-rouge">unsafe</code> code, but ultimately the incorrect choice for non-stack storage, such as a <code class="language-plaintext highlighter-rouge">MoveRef</code> referring to the heap. <a href="#fnref:or-we-could-drop-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2021-12-19 • 1945 words • 10 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#ffi">#ffi</a> </span> <h1><a href="/2021/12/19/move-ctors-2/"> Move Constructors Revisited<br/> </a></h1> </div> <div class="post"> <p>Almost a year ago I developed the <a href="https://github.com/google/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a> Rust library, which provides primitives for expressing something like C++’s <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> and move constructors while retaining Rust’s so-called “destructive move property”: moving a value transfers ownership, rather than doing a funny copy.</p> <p>In an <a href="https://mcyoung.xyz//2021/04/26/move-ctors">earlier blogpost</a> I described the theory behind this library and some of the motivation, which I feel fairly confident about, especially in how constructors (and their use of pinning) are defined.</p> <p>However, there is a problem.</p> <h2 id="a-not-so-quick-recap"><a href="#a-not-so-quick-recap">A Not-so-Quick Recap</a></h2> <p>The old post is somewhat outdated, since <code class="language-plaintext highlighter-rouge">moveit</code> uses different names for a lot of things that are geared to fit in with the rest of Rust.</p> <p>The core abstraction of <code class="language-plaintext highlighter-rouge">moveit</code> is the constructor, which are types that implement the <code class="language-plaintext highlighter-rouge">New</code> trait:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">New</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The type to construct.</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

  <span class="cd">/// Construct a new value in-place using the arguments stored</span>
  <span class="cd">/// in `self`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">this</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>A <code class="language-plaintext highlighter-rouge">New</code> type is not what is being constructed; rather, it represents a <em>method</em> of construction, resembling a specialized <code class="language-plaintext highlighter-rouge">Fn</code> trait. The constructed type is given by the associated type <code class="language-plaintext highlighter-rouge">Output</code>.</p> <p>Types that can be constructed are constructed <em>in place</em>, unlike most Rust types. This is a property shared by constructors in C++, allowing values to record their own address at the moment of creation. Explaining why this is useful is a bit long-winded, but let’s assume this is a thing we want to be able to do. Crucially, we need the output of a constructor to be pinned, which is why the <code class="language-plaintext highlighter-rouge">this</code> output parameter is pinned.</p> <p>Calling a constructor requires creating the output location in advance so that we can make it available to it in time:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create storage for the new value.</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>

<span class="c1">// Pin that storage on the stack; by calling this, we may never move</span>
<span class="c1">// `storage` again, even after this goes out of scope.</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Now we can call the constructor. It's only unsafe because it assumes</span>
<span class="c1">// the provided memory is uninitialized.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">());</span>
</code></pre></div></div> <p>However, this is not quite right. <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>’s docs are quite clear that we must ensure that, once we create an <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, we must call <code class="language-plaintext highlighter-rouge">T</code>’s destructor before its memory is re-used; since reuse is unavoidable for stack data, and <code class="language-plaintext highlighter-rouge">storage</code> will not do it for us (it’s a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, after all), we must somehow run the destructor separately.</p> <h3 id="an-easy-solution"><a href="#an-easy-solution">An “Easy” Solution</a></h3> <p>One trick we could use is to replace <code class="language-plaintext highlighter-rouge">storage</code> with some kind of wrapper over a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> that calls the destructor for us:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.assume_init_mut</span><span class="p">())</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This <em>works</em>, but isn’t ideal, because now we can’t write down something like a C++ move constructor without running into the classic C++ problem: all objects must be destroyed unconditionally, so now you can have moved-from state. Giving up Rust’s moves-transfer-ownership (i.e. <em>affine</em>) property is bad, but it turns out to be avoidable!</p> <p>There are also some scary details around panics here that I won’t get into.</p> <h3 id="t-mut-t--move-t"><a href="#t-mut-t--move-t"><code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, … <code class="language-plaintext highlighter-rouge">&amp;move T</code>?</a></h3> <p><code class="language-plaintext highlighter-rouge">moveit</code> instead provides a <a href="https://docs.rs/moveit/latest/moveit/move_ref/struct.MoveRef.html"><code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code></a> type that tries to capture the notion of what an “owning reference” <em>could</em> mean in Rust. An <code class="language-plaintext highlighter-rouge">&amp;move</code> or <code class="language-plaintext highlighter-rouge">&amp;own</code> type has been discussed many times, but implementing it in the full generality it would deserve as a language feature runs into some interesting problems due to how <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, the heap allocated equivalent, <a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">currently behaves.</a></p> <p>We can think of <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code> as wrapping the <em>longest-lived</em> <code class="language-plaintext highlighter-rouge">&amp;mut T</code> reference pointing to a particular location in memory. The longest-lived part is crucial, since it means that <code class="language-plaintext highlighter-rouge">MoveRef</code> is entitled to run its pointee’s destructor:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Notice parallels with EventuallyInit&lt;T&gt; above.</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>No reference to the pointee can ever outlive the <code class="language-plaintext highlighter-rouge">MoveRef</code> itself, by definition, so this is safe. The owner of a value is that which is entitled to destroy it, and therefore a <code class="language-plaintext highlighter-rouge">MoveRef</code> <em>literally</em> owns its pointee. Of course, this means we can move out of it (which was the whole point of the original blogpost).</p> <p>Because of this, we are further entitled to arbitrarily pin a <code class="language-plaintext highlighter-rouge">MoveRef</code> with no consequences: pinning it would consume the unpinned <code class="language-plaintext highlighter-rouge">MoveRef</code> (for obvious reasons, <code class="language-plaintext highlighter-rouge">MoveRefs</code> cannot be reborrowed) so no unpinned reference may outlive the pinning operation.</p> <p>This gives us a very natural solution to the problem above: <code class="language-plaintext highlighter-rouge">result</code> should not be a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, but rather a <code class="language-plaintext highlighter-rouge">Pin&lt;MoveRef&lt;'_, T&gt;&gt;</code>:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pinned</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">())</span>
<span class="p">));</span>
</code></pre></div></div> <p>This messy sequence of steps is nicely wrapped up in a macro provided by the library that ensures safe initialization and eventual destruction:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Allocate storage on the stack, emplace `my_new` onto it, and pin it</span>
<span class="c1">// in an owning reference.</span>
<span class="nd">moveit!</span><span class="p">(</span><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">MoveRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">my_new</span><span class="p">);</span>
</code></pre></div></div> <p>There is also some reasonably complex machinery that allows us to do something like an owning <code class="language-plaintext highlighter-rouge">Deref</code>, which I’ll come back to in a bit.</p> <p>However, there is a small wrinkle that I did not realize when I first designed <code class="language-plaintext highlighter-rouge">MoveRef</code>: what happens if I <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">MoveRef</code>?</p> <h2 id="undefined-behavior-obviously"><a href="#undefined-behavior-obviously">Undefined Behavior, Obviously</a></h2> <p>Quashing destruction isn’t new to Rust: we can <code class="language-plaintext highlighter-rouge">mem::forget</code> just about anything, leaking all kinds of resources. And that’s ok! Destructors alone cannot be used in type design to advert <code class="language-plaintext highlighter-rouge">unsafe</code> catastrophe, a well-understood limitation of the language that we have experience designing libraries around, such as <a href="https://doc.rust-lang.org/nomicon/leaking.html#drain"><code class="language-plaintext highlighter-rouge">Vec::drain()</code></a>.</p> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s design creates a contradiction:</p> <ul> <li><code class="language-plaintext highlighter-rouge">MoveRef</code> is an owning smart pointer, and therefore can be safely pinned, much like <code class="language-plaintext highlighter-rouge">Box::into_pinned()</code> enables. Constructors, in particular, are <em>designed</em> to generate pinned <code class="language-plaintext highlighter-rouge">MoveRef</code>s!</li> <li>Forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code> will cause the pointee destructor to be suppressed, but its storage will still be freed and eventually re-used, a violation of the <code class="language-plaintext highlighter-rouge">Pin</code> drop guarantee.</li> </ul> <p>This would <em>appear</em> to mean that a design like <code class="language-plaintext highlighter-rouge">MoveRef</code> is not viable at all, and that this sort of “stack box” strategy is always unsound.</p> <blockquote> <h3 id="what-about-box"><a href="#what-about-box">What About <code class="language-plaintext highlighter-rouge">Box</code>?</a></h3> <p>What about it? Even though we can trivially create a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;i32&gt;&gt;</code> via <code class="language-plaintext highlighter-rouge">Box::pin()</code>, this is a red herring. When we <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">Box</code>, we also forget about its storage too. Because its storage has been leaked unrecoverably, we are still, <em>technically</em>, within the bounds of the <code class="language-plaintext highlighter-rouge">Pin</code> contract. Only barely, but we’re inside the circle.</p> </blockquote> <p>Interestingly, the Rust language has to deal with a similar problem; perhaps it suggests a way out?</p> <h2 id="drop-flags-and-dynamic-ownership-transfer"><a href="#drop-flags-and-dynamic-ownership-transfer">Drop Flags and Dynamic Ownership Transfer</a></h2> <p>Carefully crafted Rust code emits some very interesting assembly. I’ve annotated the key portion of the output with a play-by-play below.</p> <p>```rust godbolt:o=-O #[inline(never)] pub fn someone_elses_problem(_: Box<i32>) { // What goes in here isn't important,it just needs to // be an optimizer black-box. }</i32></p> <p>pub fn maybe_drop(flag: bool) { let x = Box::new(42); if flag { someone_elses_problem(x) } }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```x86
// See Godbolt widget above for full disassembly.
example::maybe_drop:
  // ...

  // Allocate memory.
  call    __rust_alloc

  // Check if allocation failed; panic if so.
  test    rax, rax
  je      .L.scream

  // Write a 42 to the memory.
  mov     dword ptr [rax], 42

  // Check the flag argument (LLVM decided to put it in rbx). If
  // true, we go free the memory ourselves.
  test    bl, bl
  je      .L.actually_our_problem

  // Otherwise, make it someone else's problem; they get to
  // free the memory for themselves. 
  mov     rdi, rax
  pop     rbx
  jmp     example::someone_elses_problem

  // ...
</code></pre></div></div> <p>The upshot is that <code class="language-plaintext highlighter-rouge">maybe_drop</code> conditions the destructor of <code class="language-plaintext highlighter-rouge">x</code> on a <em>flag</em>, which is allocated next to it on the stack. Rust flips this flag when the value is moved into another function, and only runs the destructor when the flag is left alone. In this case, LLVM folded the flag into the <code class="language-plaintext highlighter-rouge">bool</code> argument, so this isn’t actually a meaningful perf hit.</p> <p>These “drop flags” are key to Rust’s ownership model. Since ownership may be transferred dynamically due to reasonably complex control flow, it needs to leave breadcrumbs for itself to figure out whether the value wound up getting moved away or not. This is unique to Rust: in C++, every object is always destroyed, so no such faffing about is necessary.</p> <p>Similarly, <code class="language-plaintext highlighter-rouge">moveit</code> can close this soundness hole by leaving itself breadcrumbs to determine if safe code is trying to undermine its guarantees.</p> <p>In other words: in Rust, it is not sufficient to manage a pointer to manage a memory location; it is necessary to manage an explicit or implicit drop flag as well.</p> <h2 id="a-flagged-moveref"><a href="#a-flagged-moveref">A Flagged <code class="language-plaintext highlighter-rouge">MoveRef</code></a></h2> <p>We can extend <code class="language-plaintext highlighter-rouge">MoveRef</code> to track an explicit drop flag:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>

  <span class="c1">// Set to `false` once the destructor runs.</span>
  <span class="n">drop_flag</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>Wrapping it in a <code class="language-plaintext highlighter-rouge">Cell</code> is convenient and doesn’t cost us anything, since a <code class="language-plaintext highlighter-rouge">MoveRef</code> can never be made <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code> anyways. Inside of its destructor, we can flip the flag, much like Rust flips a drop flag when transferring ownership to another function:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.drop_flag</span><span class="nf">.set</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>But, how should we use it? The easiest way is to change the definition of <code class="language-plaintext highlighter-rouge">moveit!()</code> to construct a <em>flag trap</em>:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Create a *trapped flag*, which I'll describe below.</span>
<span class="k">let</span> <span class="n">trap</span> <span class="o">=</span> <span class="nn">TrappedFlag</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// Run the constructor as before and construct a MoveRef.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">uninit</span><span class="p">)</span><span class="nf">.assume_init_mut</span><span class="p">(),</span>
  <span class="n">trap</span><span class="nf">.flag</span><span class="p">(),</span>  <span class="c1">// Creating a MoveRef now requires</span>
                <span class="c1">// passing in a flag in addition to </span>
                <span class="c1">// a reference to the owned value itself.</span>
<span class="p">));</span>
</code></pre></div></div> <p>The trap is a deterrent against forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code>: because the <code class="language-plaintext highlighter-rouge">MoveRef</code>’s destructor flips the flag, the trap’s destructor will notice if this <em>doesn’t</em> happen, and take action accordingly.</p> <blockquote> <p>Note: in <code class="language-plaintext highlighter-rouge">moveit</code>, this is actually implemented by having the <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code> type carry a reference to the trap, created in the <code class="language-plaintext highlighter-rouge">slot!()</code> macro. However, this is not a crucial detail for the design.</p> </blockquote> <h3 id="an-earth-shattering-kaboom"><a href="#an-earth-shattering-kaboom">An Earth-Shattering Kaboom</a></h3> <p>The trap is another RAII type that basically looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="nf">TrappedFlag</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">TrappedFlag</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">()</span> <span class="p">{</span> <span class="nf">abort</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The trap is simple: if the contained drop flag is not flipped, it crashes the program. Because <code class="language-plaintext highlighter-rouge">moveit!()</code> allocates it on the stack where uses cannot <code class="language-plaintext highlighter-rouge">mem::forget</code> it, its destructor is guaranteed to run before <code class="language-plaintext highlighter-rouge">storage</code>’s destructor runs (although Rust does not guarantee destructors run, it <em>does</em> guarantee their order).</p> <p>If a <code class="language-plaintext highlighter-rouge">MoveRef</code> is forgotten, it won’t have a chance to flip the flag, which the trap will detect. Once the trap’s destructor notices this, it cannot return, either normally or by panic, since this would cause <code class="language-plaintext highlighter-rouge">storage</code> to be freed. Crashing the program is the only<sup id="fnref:or-we-could-drop-it" role="doc-noteref"><a href="#fn:or-we-could-drop-it" class="footnote" rel="footnote">1</a></sup> acceptable response.</p> <p>Some of <code class="language-plaintext highlighter-rouge">MoveRef</code>’s functions need to be adapted to this new behavior: for example, <code class="language-plaintext highlighter-rouge">MoveRef::into_inner()</code> still needs to flip the flag, since moving out of the <code class="language-plaintext highlighter-rouge">MoveRef</code> is equivalent to running the destructor for the purposes of drop flags.</p> <h2 id="a-safer-derefmove"><a href="#a-safer-derefmove">A Safer <code class="language-plaintext highlighter-rouge">DerefMove</code></a></h2> <p>In order for <code class="language-plaintext highlighter-rouge">MoveRef</code> to be a proper “new” reference type, and not just a funny smart pointer, we also need a <code class="language-plaintext highlighter-rouge">Deref</code> equivalent:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// An "uninitialized" version of `Self`.</span>
  <span class="k">type</span> <span class="n">Uninit</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>
  
  <span class="cd">/// "Deinitializes" `self`, producing an opaque type that will</span>
  <span class="cd">/// destroy the storage of `*self` without calling the pointee</span>
  <span class="cd">/// destructor.</span>
  <span class="k">fn</span> <span class="nf">deinit</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a `MoveRef` that owns its</span>
  <span class="cd">/// contents.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">deref_move</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is the <em>original</em> design for <code class="language-plaintext highlighter-rouge">DerefMove</code>, which had a two-phase operation: first <code class="language-plaintext highlighter-rouge">deinit()</code> was used to create a destructor-suppressed version of the smart pointer that would only run the destructor for the storage (e.g., for <code class="language-plaintext highlighter-rouge">Box</code>, only the call to <code class="language-plaintext highlighter-rouge">free()</code>). Then, <code class="language-plaintext highlighter-rouge">deref_move()</code> would extract the “inner pointee” out of it as a <code class="language-plaintext highlighter-rouge">MoveRef</code>. This had the effect of splitting the smart pointer’s destructor, much like we did above on the stack.</p> <p>This has a number of usability problems. Not only does it <em>need</em> to be called through a macro, but <code class="language-plaintext highlighter-rouge">deinit()</code> isn’t actually safe: failing to call <code class="language-plaintext highlighter-rouge">deref_move()</code> is just as bad as calling <code class="language-plaintext highlighter-rouge">mem::forget</code> on the result. Further, it’s not clear where to plumb the drop flags through.</p> <p>After <a href="https://github.com/google/moveit/pull/23#issuecomment-963549869">many attempts</a> to graft drop flags onto this design, I replaced it with a completely new interface:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The "pure storage" form of `Self`, which owns the storage</span>
  <span class="cd">/// but not the pointee.</span>
  <span class="k">type</span> <span class="n">Storage</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a [`MoveRef`] that owns</span>
  <span class="cd">/// its contents.</span>
  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Storage</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Uninit</code> has been given the clearer name of <code class="language-plaintext highlighter-rouge">Storage</code>: a type that owns <em>just</em> the storage of the moved-from pointer. The two functions were merged into a single, <em>safe</em> function that performs everything in one step, emitting the storage as an out-parameter.</p> <p>The new <code class="language-plaintext highlighter-rouge">DroppingSlot&lt;T&gt;</code> is like a <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code>, but closer to a safe version of the <code class="language-plaintext highlighter-rouge">EventuallyInit&lt;T&gt;</code> type from earlier: its contents are not necessarily initialized, but if they are, it destroys them, and it only does so when its drop flag is set.</p> <p><code class="language-plaintext highlighter-rouge">Box</code> is the most illuminating example of this trait:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// Dismantle the incoming Box into the "storage-only part".</span>
    <span class="k">let</span> <span class="n">this</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span>
    <span class="p">};</span>

    <span class="c1">// Put the Box into the provided storage area. Note that we</span>
    <span class="c1">// don't need to set the drop flag; `DroppingSlot` does</span>
    <span class="c1">// that automatically for us.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="o">=</span> <span class="n">storage</span><span class="nf">.put</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

    <span class="c1">// Construct a new MoveRef, converting `storage` from </span>
    <span class="c1">// `&amp;mut Box&lt;MaybeUninit&lt;T&gt;&gt;` into `&amp;mut T`.</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">storage</span><span class="nf">.assume_init_mut</span><span class="p">(),</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s own implementation illustrates the need for the explicit lifetime bound:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="p">();</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// We can just return directly; this is a mere lifetime narrowing.</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Since this is fundamentally a lifetime narrowing, this can only compile if we insist that <code class="language-plaintext highlighter-rouge">'a: 'frame</code>, which is implied by <code class="language-plaintext highlighter-rouge">Self: 'frame</code>. Earlier iterations of this design enforced it via a <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, Self&gt;</code> receiver, which turned out to be unnecessary.</p> <h2 id="conclusions"><a href="#conclusions">Conclusions</a></h2> <p>As of writing, I’m still in the process of self-reviewing <a href="https://github.com/google/moveit/pull/25">this change</a>, but at this point I feel <em>reasonably</em> confident that it’s correct; this article is, in part, written to convince myself that I’ve done this correctly.</p> <p>The new design will also enable me to finally complete my implementation of a constructor and pinning-friendly vector type; this issue came up in part because the vector type needs to manipulate drop flags in a complex way. For this reason, the <em>actual</em> implementation of drop flags actually uses a counter, not a single boolean.</p> <p>I doubt this is the last issue I’ll need to chase down in <code class="language-plaintext highlighter-rouge">moveit</code>, but for now, we’re ever-closer to true owning references in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:or-we-could-drop-it" role="doc-endnote"> <p>Arguably, running the skipped destructor is <em>also</em> a valid remediation strategy. However, this is incompatible with what the user requested: they asked for the destructor to be supressed, not for it to be run at a later date. This would be somewhat surprising behavior, which we could warn about for the benefit of <code class="language-plaintext highlighter-rouge">unsafe</code> code, but ultimately the incorrect choice for non-stack storage, such as a <code class="language-plaintext highlighter-rouge">MoveRef</code> referring to the heap. <a href="#fnref:or-we-could-drop-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>