<!DOCTYPE html> <html lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Move Constructors Revisited &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Rokkitt&family=Spline+Sans+Mono&display=swap" rel="stylesheet"> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Move Constructors Revisited &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/move-ctors-2-8dad126142e6452354002782c0ca3a7035eef016.png"> <meta property="og:title" content="Move Constructors Revisited &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/move-ctors-2-8dad126142e6452354002782c0ca3a7035eef016.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2021/12/19/move-ctors-2/"> </head> <body> <div class="sidebar"> <a href="https://mcyoung.xyz/"> <img src="https://mcyoung.xyz/public/avatar.png" alt="Yeah, I drew this. Check out my art blog." class="hide-if-mobile"/> </a> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/">Home</a> • <a class="sidebar-nav-item" href="/about.html">About</a> • <a class="sidebar-nav-item" href="/posts.html">Posts</a> • <a class="sidebar-nav-item" href="/tags.html">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://art.mcyoung.xyz/">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> </nav> <br class="hide-if-mobile"/> <p class="hide-if-mobile"><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota</p> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2021-12-19 • 1923 words • 10 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#ffi">#ffi</a> </span> <h1><a href="/2021/12/19/move-ctors-2/"> Move Constructors Revisited<br/> </a></h1> </div> <div class="post"> <p>Almost a year ago I developed the <a href="https://github.com/google/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a> Rust library, which provides primitives for expressing something like C++’s <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> and move constructors while retaining Rust’s so-called “destructive move property”: moving a value transfers ownership, rather than doing a funny copy.</p> <p>In an <a href="https://mcyoung.xyz//2021/04/26/move-ctors">earlier blogpost</a> I described the theory behind this library and some of the motivation, which I feel fairly confident about, especially in how constructors (and their use of pinning) are defined.</p> <p>However, there is a problem.</p> <h2 id="a-not-so-quick-recap"><a href="#a-not-so-quick-recap">A Not-so-Quick Recap</a></h2> <p>The old post is somewhat outdated, since <code class="language-plaintext highlighter-rouge">moveit</code> uses different names for a lot of things that are geared to fit in with the rest of Rust.</p> <p>The core abstraction of <code class="language-plaintext highlighter-rouge">moveit</code> is the constructor, which are types that implement the <code class="language-plaintext highlighter-rouge">New</code> trait:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">New</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The type to construct.</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

  <span class="cd">/// Construct a new value in-place using the arguments stored</span>
  <span class="cd">/// in `self`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">this</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>A <code class="language-plaintext highlighter-rouge">New</code> type is not what is being constructed; rather, it represents a <em>method</em> of construction, resembling a specialized <code class="language-plaintext highlighter-rouge">Fn</code> trait. The constructed type is given by the associated type <code class="language-plaintext highlighter-rouge">Output</code>.</p> <p>Types that can be constructed are constructed <em>in place</em>, unlike most Rust types. This is a property shared by constructors in C++, allowing values to record their own address at the moment of creation. Explaining why this is useful is a bit long-winded, but let’s assume this is a thing we want to be able to do. Crucially, we need the output of a constructor to be pinned, which is why the <code class="language-plaintext highlighter-rouge">this</code> output parameter is pinned.</p> <p>Calling a constructor requires creating the output location in advance so that we can make it available to it in time:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Create storage for the new value.</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>

<span class="c1">// Pin that storage on the stack; by calling this, we may never move</span>
<span class="c1">// `storage` again, even after this goes out of scope.</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Now we can call the constructor. It's only unsafe because it assumes</span>
<span class="c1">// the provided memory is uninitialized.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this is not quite right. <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>’s docs are quite clear that we must ensure that, once we create an <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, we must call <code class="language-plaintext highlighter-rouge">T</code>’s destructor before its memory is re-used; since reuse is unavoidable for stack data, and <code class="language-plaintext highlighter-rouge">storage</code> will not do it for us (it’s a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, after all), we must somehow run the destructor separately.</p> <h3 id="an-easy-solution"><a href="#an-easy-solution">An “Easy” Solution</a></h3> <p>One trick we could use is to replace <code class="language-plaintext highlighter-rouge">storage</code> with some kind of wrapper over a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> that calls the destructor for us:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.assume_init_mut</span><span class="p">())</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This <em>works</em>, but isn’t ideal, because now we can’t write down something like a C++ move constructor without running into the classic C++ problem: all objects must be destroyed unconditionally, so now you can have moved-from state. Giving up Rust’s moves-transfer-ownership (i.e. <em>affine</em>) property is bad, but it turns out to be avoidable!</p> <p>There are also some scary details around panics here that I won’t get into.</p> <h3 id="t-mut-t--move-t"><a href="#t-mut-t--move-t"><code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, … <code class="language-plaintext highlighter-rouge">&amp;move T</code>?</a></h3> <p><code class="language-plaintext highlighter-rouge">moveit</code> instead provides a <a href="https://docs.rs/moveit/latest/moveit/move_ref/struct.MoveRef.html"><code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code></a> type that tries to capture the notion of what an “owning reference” <em>could</em> mean in Rust. An <code class="language-plaintext highlighter-rouge">&amp;move</code> or <code class="language-plaintext highlighter-rouge">&amp;own</code> type has been discussed many times, but implementing it in the full generality it would deserve as a language feature runs into some interesting problems due to how <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, the heap allocated equivalent, <a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">currently behaves.</a></p> <p>We can think of <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code> as wrapping the <em>longest-lived</em> <code class="language-plaintext highlighter-rouge">&amp;mut T</code> reference pointing to a particular location in memory. The longest-lived part is crucial, since it means that <code class="language-plaintext highlighter-rouge">MoveRef</code> is entitled to run its pointee’s destructor:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Notice parallels with EventuallyInit&lt;T&gt; above.</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>No reference to the pointee can ever outlive the <code class="language-plaintext highlighter-rouge">MoveRef</code> itself, by definition, so this is safe. The owner of a value is that which is entitled to destroy it, and therefore a <code class="language-plaintext highlighter-rouge">MoveRef</code> <em>literally</em> owns its pointee. Of course, this means we can move out of it (which was the whole point of the original blogpost).</p> <p>Because of this, we are further entitled to arbitrarily pin a <code class="language-plaintext highlighter-rouge">MoveRef</code> with no consequences: pinning it would consume the unpinned <code class="language-plaintext highlighter-rouge">MoveRef</code> (for obvious reasons, <code class="language-plaintext highlighter-rouge">MoveRefs</code> cannot be reborrowed) so no unpinned reference may outlive the pinning operation.</p> <p>This gives us a very natural solution to the problem above: <code class="language-plaintext highlighter-rouge">result</code> should not be a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, but rather a <code class="language-plaintext highlighter-rouge">Pin&lt;MoveRef&lt;'_, T&gt;&gt;</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pinned</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">())</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This messy sequence of steps is nicely wrapped up in a macro provided by the library that ensures safe initialization and eventual destruction:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Allocate storage on the stack, emplace `my_new` onto it, and pin it</span>
<span class="c1">// in an owning reference.</span>
<span class="nd">moveit!</span><span class="p">(</span><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">MoveRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">my_new</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There is also some reasonably complex machinery that allows us to do something like an owning <code class="language-plaintext highlighter-rouge">Deref</code>, which I’ll come back to in a bit.</p> <p>However, there is a small wrinkle that I did not realize when I first designed <code class="language-plaintext highlighter-rouge">MoveRef</code>: what happens if I <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">MoveRef</code>?</p> <h2 id="undefined-behavior-obviously"><a href="#undefined-behavior-obviously">Undefined Behavior, Obviously</a></h2> <p>Quashing destruction isn’t new to Rust: we can <code class="language-plaintext highlighter-rouge">mem::forget</code> just about anything, leaking all kinds of resources. And that’s ok! Destructors alone cannot be used in type design to advert <code class="language-plaintext highlighter-rouge">unsafe</code> catastrophe, a well-understood limitation of the language that we have experience designing libraries around, such as <a href="https://doc.rust-lang.org/nomicon/leaking.html#drain"><code class="language-plaintext highlighter-rouge">Vec::drain()</code></a>.</p> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s design creates a contradiction:</p> <ul> <li><code class="language-plaintext highlighter-rouge">MoveRef</code> is an owning smart pointer, and therefore can be safely pinned, much like <code class="language-plaintext highlighter-rouge">Box::into_pinned()</code> enables. Constructors, in particular, are <em>designed</em> to generate pinned <code class="language-plaintext highlighter-rouge">MoveRef</code>s!</li> <li>Forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code> will cause the pointee destructor to be suppressed, but its storage will still be freed and eventually re-used, a violation of the <code class="language-plaintext highlighter-rouge">Pin</code> drop guarantee.</li> </ul> <p>This would <em>appear</em> to mean that a design like <code class="language-plaintext highlighter-rouge">MoveRef</code> is not viable at all, and that this sort of “stack box” strategy is always unsound.</p> <blockquote> <h3 id="what-about-box"><a href="#what-about-box">What About <code class="language-plaintext highlighter-rouge">Box</code>?</a></h3> <p>What about it? Even though we can trivially create a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;i32&gt;&gt;</code> via <code class="language-plaintext highlighter-rouge">Box::pin()</code>, this is a red herring. When we <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">Box</code>, we also forget about its storage too. Because its storage has been leaked unrecoverably, we are still, <em>technically</em>, within the bounds of the <code class="language-plaintext highlighter-rouge">Pin</code> contract. Only barely, but we’re inside the circle.</p> </blockquote> <p>Interestingly, the Rust language has to deal with a similar problem; perhaps it suggests a way out?</p> <h2 id="drop-flags-and-dynamic-ownership-transfer"><a href="#drop-flags-and-dynamic-ownership-transfer">Drop Flags and Dynamic Ownership Transfer</a></h2> <p>Carefully crafted Rust code emits some very interesting assembly. I’ve annotated the key portion of the output with a play-by-play below.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[inline(never)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// What goes in here isn't important,it just needs to</span>
  <span class="c1">// be an optimizer black-box.</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">maybe_drop</span><span class="p">(</span><span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
  <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span>
    <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6IiNbaW5saW5lKG5ldmVyKV1cbnB1YiBmbiBzb21lb25lX2Vsc2VzX3By b2JsZW0oXzogQm94PGkzMj4pIHtcbiAgLy8gV2hhdCBnb2VzIGluIGhlcmUg aXNuJ3QgaW1wb3J0YW50LGl0IGp1c3QgbmVlZHMgdG9cbiAgLy8gYmUgYW4g b3B0aW1pemVyIGJsYWNrLWJveC5cbn1cblxucHViIGZuIG1heWJlX2Ryb3Ao ZmxhZzogYm9vbCkge1xuICBsZXQgeCA9IEJveDo6bmV3KDQyKTtcbiAgaWYg ZmxhZyB7XG4gICAgc29tZW9uZV9lbHNlc19wcm9ibGVtKHgpXG4gIH1cbn0i LCJjb21waWxlcnMiOlt7ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiItTyJ9XX1d fQ== ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// See Godbolt widget above for full disassembly.</span>
<span class="n">example</span><span class="o">::</span><span class="n">maybe_drop</span><span class="o">:</span>
  <span class="c1">// ...</span>

  <span class="c1">// Allocate memory.</span>
  <span class="n">call</span>    <span class="n">__rust_alloc</span>

  <span class="c1">// Check if allocation failed; panic if so.</span>
  <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">scream</span>

  <span class="c1">// Write a 42 to the memory.</span>
  <span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>

  <span class="c1">// Check the flag argument (LLVM decided to put it in rbx). If</span>
  <span class="c1">// true, we go free the memory ourselves.</span>
  <span class="n">test</span>    <span class="n">bl</span><span class="p">,</span> <span class="n">bl</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">actually_our_problem</span>

  <span class="c1">// Otherwise, make it someone else's problem; they get to</span>
  <span class="c1">// free the memory for themselves. </span>
  <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">pop</span>     <span class="n">rbx</span>
  <span class="n">jmp</span>     <span class="n">example</span><span class="o">::</span><span class="n">someone_elses_problem</span>

  <span class="c1">// ...</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>The upshot is that <code class="language-plaintext highlighter-rouge">maybe_drop</code> conditions the destructor of <code class="language-plaintext highlighter-rouge">x</code> on a <em>flag</em>, which is allocated next to it on the stack. Rust flips this flag when the value is moved into another function, and only runs the destructor when the flag is left alone. In this case, LLVM folded the flag into the <code class="language-plaintext highlighter-rouge">bool</code> argument, so this isn’t actually a meaningful perf hit.</p> <p>These “drop flags” are key to Rust’s ownership model. Since ownership may be transferred dynamically due to reasonably complex control flow, it needs to leave breadcrumbs for itself to figure out whether the value wound up getting moved away or not. This is unique to Rust: in C++, every object is always destroyed, so no such faffing about is necessary.</p> <p>Similarly, <code class="language-plaintext highlighter-rouge">moveit</code> can close this soundness hole by leaving itself breadcrumbs to determine if safe code is trying to undermine its guarantees.</p> <p>In other words: in Rust, it is not sufficient to manage a pointer to manage a memory location; it is necessary to manage an explicit or implicit drop flag as well.</p> <h2 id="a-flagged-moveref"><a href="#a-flagged-moveref">A Flagged <code class="language-plaintext highlighter-rouge">MoveRef</code></a></h2> <p>We can extend <code class="language-plaintext highlighter-rouge">MoveRef</code> to track an explicit drop flag:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>

  <span class="c1">// Set to `false` once the destructor runs.</span>
  <span class="n">drop_flag</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Wrapping it in a <code class="language-plaintext highlighter-rouge">Cell</code> is convenient and doesn’t cost us anything, since a <code class="language-plaintext highlighter-rouge">MoveRef</code> can never be made <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code> anyways. Inside of its destructor, we can flip the flag, much like Rust flips a drop flag when transferring ownership to another function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.drop_flag</span><span class="nf">.set</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>But, how should we use it? The easiest way is to change the definition of <code class="language-plaintext highlighter-rouge">moveit!()</code> to construct a <em>flag trap</em>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Create a *trapped flag*, which I'll describe below.</span>
<span class="k">let</span> <span class="n">trap</span> <span class="o">=</span> <span class="nn">TrappedFlag</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// Run the constructor as before and construct a MoveRef.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">uninit</span><span class="p">)</span><span class="nf">.assume_init_mut</span><span class="p">(),</span>
  <span class="n">trap</span><span class="nf">.flag</span><span class="p">(),</span>  <span class="c1">// Creating a MoveRef now requires</span>
                <span class="c1">// passing in a flag in addition to </span>
                <span class="c1">// a reference to the owned value itself.</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The trap is a deterrent against forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code>: because the <code class="language-plaintext highlighter-rouge">MoveRef</code>’s destructor flips the flag, the trap’s destructor will notice if this <em>doesn’t</em> happen, and take action accordingly.</p> <blockquote> <p>Note: in <code class="language-plaintext highlighter-rouge">moveit</code>, this is actually implemented by having the <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code> type carry a reference to the trap, created in the <code class="language-plaintext highlighter-rouge">slot!()</code> macro. However, this is not a crucial detail for the design.</p> </blockquote> <h3 id="an-earth-shattering-kaboom"><a href="#an-earth-shattering-kaboom">An Earth-Shattering Kaboom</a></h3> <p>The trap is another RAII type that basically looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="nf">TrappedFlag</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">TrappedFlag</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">()</span> <span class="p">{</span> <span class="nf">abort</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The trap is simple: if the contained drop flag is not flipped, it crashes the program. Because <code class="language-plaintext highlighter-rouge">moveit!()</code> allocates it on the stack where uses cannot <code class="language-plaintext highlighter-rouge">mem::forget</code> it, its destructor is guaranteed to run before <code class="language-plaintext highlighter-rouge">storage</code>’s destructor runs (although Rust does not guarantee destructors run, it <em>does</em> guarantee their order).</p> <p>If a <code class="language-plaintext highlighter-rouge">MoveRef</code> is forgotten, it won’t have a chance to flip the flag, which the trap will detect. Once the trap’s destructor notices this, it cannot return, either normally or by panic, since this would cause <code class="language-plaintext highlighter-rouge">storage</code> to be freed. Crashing the program is the only<sup id="fnref:or-we-could-drop-it" role="doc-noteref"><a href="#fn:or-we-could-drop-it" class="footnote" rel="footnote">1</a></sup> acceptable response.</p> <p>Some of <code class="language-plaintext highlighter-rouge">MoveRef</code>’s functions need to be adapted to this new behavior: for example, <code class="language-plaintext highlighter-rouge">MoveRef::into_inner()</code> still needs to flip the flag, since moving out of the <code class="language-plaintext highlighter-rouge">MoveRef</code> is equivalent to running the destructor for the purposes of drop flags.</p> <h2 id="a-safer-derefmove"><a href="#a-safer-derefmove">A Safer <code class="language-plaintext highlighter-rouge">DerefMove</code></a></h2> <p>In order for <code class="language-plaintext highlighter-rouge">MoveRef</code> to be a proper “new” reference type, and not just a funny smart pointer, we also need a <code class="language-plaintext highlighter-rouge">Deref</code> equivalent:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// An "uninitialized" version of `Self`.</span>
  <span class="k">type</span> <span class="n">Uninit</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>
  
  <span class="cd">/// "Deinitializes" `self`, producing an opaque type that will</span>
  <span class="cd">/// destroy the storage of `*self` without calling the pointee</span>
  <span class="cd">/// destructor.</span>
  <span class="k">fn</span> <span class="nf">deinit</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a `MoveRef` that owns its</span>
  <span class="cd">/// contents.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">deref_move</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is the <em>original</em> design for <code class="language-plaintext highlighter-rouge">DerefMove</code>, which had a two-phase operation: first <code class="language-plaintext highlighter-rouge">deinit()</code> was used to create a destructor-suppressed version of the smart pointer that would only run the destructor for the storage (e.g., for <code class="language-plaintext highlighter-rouge">Box</code>, only the call to <code class="language-plaintext highlighter-rouge">free()</code>). Then, <code class="language-plaintext highlighter-rouge">deref_move()</code> would extract the “inner pointee” out of it as a <code class="language-plaintext highlighter-rouge">MoveRef</code>. This had the effect of splitting the smart pointer’s destructor, much like we did above on the stack.</p> <p>This has a number of usability problems. Not only does it <em>need</em> to be called through a macro, but <code class="language-plaintext highlighter-rouge">deinit()</code> isn’t actually safe: failing to call <code class="language-plaintext highlighter-rouge">deref_move()</code> is just as bad as calling <code class="language-plaintext highlighter-rouge">mem::forget</code> on the result. Further, it’s not clear where to plumb the drop flags through.</p> <p>After <a href="https://github.com/google/moveit/pull/23#issuecomment-963549869">many attempts</a> to graft drop flags onto this design, I replaced it with a completely new interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The "pure storage" form of `Self`, which owns the storage</span>
  <span class="cd">/// but not the pointee.</span>
  <span class="k">type</span> <span class="n">Storage</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a [`MoveRef`] that owns</span>
  <span class="cd">/// its contents.</span>
  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Storage</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Uninit</code> has been given the clearer name of <code class="language-plaintext highlighter-rouge">Storage</code>: a type that owns <em>just</em> the storage of the moved-from pointer. The two functions were merged into a single, <em>safe</em> function that performs everything in one step, emitting the storage as an out-parameter.</p> <p>The new <code class="language-plaintext highlighter-rouge">DroppingSlot&lt;T&gt;</code> is like a <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code>, but closer to a safe version of the <code class="language-plaintext highlighter-rouge">EventuallyInit&lt;T&gt;</code> type from earlier: its contents are not necessarily initialized, but if they are, it destroys them, and it only does so when its drop flag is set.</p> <p><code class="language-plaintext highlighter-rouge">Box</code> is the most illuminating example of this trait:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// Dismantle the incoming Box into the "storage-only part".</span>
    <span class="k">let</span> <span class="n">this</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span>
    <span class="p">};</span>

    <span class="c1">// Put the Box into the provided storage area. Note that we</span>
    <span class="c1">// don't need to set the drop flag; `DroppingSlot` does</span>
    <span class="c1">// that automatically for us.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="o">=</span> <span class="n">storage</span><span class="nf">.put</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

    <span class="c1">// Construct a new MoveRef, converting `storage` from </span>
    <span class="c1">// `&amp;mut Box&lt;MaybeUninit&lt;T&gt;&gt;` into `&amp;mut T`.</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">storage</span><span class="nf">.assume_init_mut</span><span class="p">(),</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s own implementation illustrates the need for the explicit lifetime bound:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="p">();</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// We can just return directly; this is a mere lifetime narrowing.</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Since this is fundamentally a lifetime narrowing, this can only compile if we insist that <code class="language-plaintext highlighter-rouge">'a: 'frame</code>, which is implied by <code class="language-plaintext highlighter-rouge">Self: 'frame</code>. Earlier iterations of this design enforced it via a <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, Self&gt;</code> receiver, which turned out to be unnecessary.</p> <h2 id="conclusions"><a href="#conclusions">Conclusions</a></h2> <p>As of writing, I’m still in the process of self-reviewing <a href="https://github.com/google/moveit/pull/25">this change</a>, but at this point I feel <em>reasonably</em> confident that it’s correct; this article is, in part, written to convince myself that I’ve done this correctly.</p> <p>The new design will also enable me to finally complete my implementation of a constructor and pinning-friendly vector type; this issue came up in part because the vector type needs to manipulate drop flags in a complex way. For this reason, the <em>actual</em> implementation of drop flags actually uses a counter, not a single boolean.</p> <p>I doubt this is the last issue I’ll need to chase down in <code class="language-plaintext highlighter-rouge">moveit</code>, but for now, we’re ever-closer to true owning references in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:or-we-could-drop-it" role="doc-endnote"> <p>Arguably, running the skipped destructor is <em>also</em> a valid remediation strategy. However, this is incompatible with what the user requested: they asked for the destructor to be supressed, not for it to be run at a later date. This would be somewhat surprising behavior, which we could warn about for the benefit of <code class="language-plaintext highlighter-rouge">unsafe</code> code, but ultimately the incorrect choice for non-stack storage, such as a <code class="language-plaintext highlighter-rouge">MoveRef</code> referring to the heap. <a href="#fnref:or-we-could-drop-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2021-12-19 • 1923 words • 10 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#ffi">#ffi</a> </span> <h1><a href="/2021/12/19/move-ctors-2/"> Move Constructors Revisited<br/> </a></h1> </div> <div class="post"> <p>Almost a year ago I developed the <a href="https://github.com/google/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a> Rust library, which provides primitives for expressing something like C++’s <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> and move constructors while retaining Rust’s so-called “destructive move property”: moving a value transfers ownership, rather than doing a funny copy.</p> <p>In an <a href="https://mcyoung.xyz//2021/04/26/move-ctors">earlier blogpost</a> I described the theory behind this library and some of the motivation, which I feel fairly confident about, especially in how constructors (and their use of pinning) are defined.</p> <p>However, there is a problem.</p> <h2 id="a-not-so-quick-recap"><a href="#a-not-so-quick-recap">A Not-so-Quick Recap</a></h2> <p>The old post is somewhat outdated, since <code class="language-plaintext highlighter-rouge">moveit</code> uses different names for a lot of things that are geared to fit in with the rest of Rust.</p> <p>The core abstraction of <code class="language-plaintext highlighter-rouge">moveit</code> is the constructor, which are types that implement the <code class="language-plaintext highlighter-rouge">New</code> trait:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">New</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The type to construct.</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

  <span class="cd">/// Construct a new value in-place using the arguments stored</span>
  <span class="cd">/// in `self`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">this</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>A <code class="language-plaintext highlighter-rouge">New</code> type is not what is being constructed; rather, it represents a <em>method</em> of construction, resembling a specialized <code class="language-plaintext highlighter-rouge">Fn</code> trait. The constructed type is given by the associated type <code class="language-plaintext highlighter-rouge">Output</code>.</p> <p>Types that can be constructed are constructed <em>in place</em>, unlike most Rust types. This is a property shared by constructors in C++, allowing values to record their own address at the moment of creation. Explaining why this is useful is a bit long-winded, but let’s assume this is a thing we want to be able to do. Crucially, we need the output of a constructor to be pinned, which is why the <code class="language-plaintext highlighter-rouge">this</code> output parameter is pinned.</p> <p>Calling a constructor requires creating the output location in advance so that we can make it available to it in time:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Create storage for the new value.</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>

<span class="c1">// Pin that storage on the stack; by calling this, we may never move</span>
<span class="c1">// `storage` again, even after this goes out of scope.</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Now we can call the constructor. It's only unsafe because it assumes</span>
<span class="c1">// the provided memory is uninitialized.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this is not quite right. <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>’s docs are quite clear that we must ensure that, once we create an <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, we must call <code class="language-plaintext highlighter-rouge">T</code>’s destructor before its memory is re-used; since reuse is unavoidable for stack data, and <code class="language-plaintext highlighter-rouge">storage</code> will not do it for us (it’s a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, after all), we must somehow run the destructor separately.</p> <h3 id="an-easy-solution"><a href="#an-easy-solution">An “Easy” Solution</a></h3> <p>One trick we could use is to replace <code class="language-plaintext highlighter-rouge">storage</code> with some kind of wrapper over a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> that calls the destructor for us:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.assume_init_mut</span><span class="p">())</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This <em>works</em>, but isn’t ideal, because now we can’t write down something like a C++ move constructor without running into the classic C++ problem: all objects must be destroyed unconditionally, so now you can have moved-from state. Giving up Rust’s moves-transfer-ownership (i.e. <em>affine</em>) property is bad, but it turns out to be avoidable!</p> <p>There are also some scary details around panics here that I won’t get into.</p> <h3 id="t-mut-t--move-t"><a href="#t-mut-t--move-t"><code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, … <code class="language-plaintext highlighter-rouge">&amp;move T</code>?</a></h3> <p><code class="language-plaintext highlighter-rouge">moveit</code> instead provides a <a href="https://docs.rs/moveit/latest/moveit/move_ref/struct.MoveRef.html"><code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code></a> type that tries to capture the notion of what an “owning reference” <em>could</em> mean in Rust. An <code class="language-plaintext highlighter-rouge">&amp;move</code> or <code class="language-plaintext highlighter-rouge">&amp;own</code> type has been discussed many times, but implementing it in the full generality it would deserve as a language feature runs into some interesting problems due to how <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, the heap allocated equivalent, <a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">currently behaves.</a></p> <p>We can think of <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code> as wrapping the <em>longest-lived</em> <code class="language-plaintext highlighter-rouge">&amp;mut T</code> reference pointing to a particular location in memory. The longest-lived part is crucial, since it means that <code class="language-plaintext highlighter-rouge">MoveRef</code> is entitled to run its pointee’s destructor:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Notice parallels with EventuallyInit&lt;T&gt; above.</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>No reference to the pointee can ever outlive the <code class="language-plaintext highlighter-rouge">MoveRef</code> itself, by definition, so this is safe. The owner of a value is that which is entitled to destroy it, and therefore a <code class="language-plaintext highlighter-rouge">MoveRef</code> <em>literally</em> owns its pointee. Of course, this means we can move out of it (which was the whole point of the original blogpost).</p> <p>Because of this, we are further entitled to arbitrarily pin a <code class="language-plaintext highlighter-rouge">MoveRef</code> with no consequences: pinning it would consume the unpinned <code class="language-plaintext highlighter-rouge">MoveRef</code> (for obvious reasons, <code class="language-plaintext highlighter-rouge">MoveRefs</code> cannot be reborrowed) so no unpinned reference may outlive the pinning operation.</p> <p>This gives us a very natural solution to the problem above: <code class="language-plaintext highlighter-rouge">result</code> should not be a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, but rather a <code class="language-plaintext highlighter-rouge">Pin&lt;MoveRef&lt;'_, T&gt;&gt;</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pinned</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">())</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This messy sequence of steps is nicely wrapped up in a macro provided by the library that ensures safe initialization and eventual destruction:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Allocate storage on the stack, emplace `my_new` onto it, and pin it</span>
<span class="c1">// in an owning reference.</span>
<span class="nd">moveit!</span><span class="p">(</span><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">MoveRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">my_new</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There is also some reasonably complex machinery that allows us to do something like an owning <code class="language-plaintext highlighter-rouge">Deref</code>, which I’ll come back to in a bit.</p> <p>However, there is a small wrinkle that I did not realize when I first designed <code class="language-plaintext highlighter-rouge">MoveRef</code>: what happens if I <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">MoveRef</code>?</p> <h2 id="undefined-behavior-obviously"><a href="#undefined-behavior-obviously">Undefined Behavior, Obviously</a></h2> <p>Quashing destruction isn’t new to Rust: we can <code class="language-plaintext highlighter-rouge">mem::forget</code> just about anything, leaking all kinds of resources. And that’s ok! Destructors alone cannot be used in type design to advert <code class="language-plaintext highlighter-rouge">unsafe</code> catastrophe, a well-understood limitation of the language that we have experience designing libraries around, such as <a href="https://doc.rust-lang.org/nomicon/leaking.html#drain"><code class="language-plaintext highlighter-rouge">Vec::drain()</code></a>.</p> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s design creates a contradiction:</p> <ul> <li><code class="language-plaintext highlighter-rouge">MoveRef</code> is an owning smart pointer, and therefore can be safely pinned, much like <code class="language-plaintext highlighter-rouge">Box::into_pinned()</code> enables. Constructors, in particular, are <em>designed</em> to generate pinned <code class="language-plaintext highlighter-rouge">MoveRef</code>s!</li> <li>Forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code> will cause the pointee destructor to be suppressed, but its storage will still be freed and eventually re-used, a violation of the <code class="language-plaintext highlighter-rouge">Pin</code> drop guarantee.</li> </ul> <p>This would <em>appear</em> to mean that a design like <code class="language-plaintext highlighter-rouge">MoveRef</code> is not viable at all, and that this sort of “stack box” strategy is always unsound.</p> <blockquote> <h3 id="what-about-box"><a href="#what-about-box">What About <code class="language-plaintext highlighter-rouge">Box</code>?</a></h3> <p>What about it? Even though we can trivially create a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;i32&gt;&gt;</code> via <code class="language-plaintext highlighter-rouge">Box::pin()</code>, this is a red herring. When we <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">Box</code>, we also forget about its storage too. Because its storage has been leaked unrecoverably, we are still, <em>technically</em>, within the bounds of the <code class="language-plaintext highlighter-rouge">Pin</code> contract. Only barely, but we’re inside the circle.</p> </blockquote> <p>Interestingly, the Rust language has to deal with a similar problem; perhaps it suggests a way out?</p> <h2 id="drop-flags-and-dynamic-ownership-transfer"><a href="#drop-flags-and-dynamic-ownership-transfer">Drop Flags and Dynamic Ownership Transfer</a></h2> <p>Carefully crafted Rust code emits some very interesting assembly. I’ve annotated the key portion of the output with a play-by-play below.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[inline(never)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// What goes in here isn't important,it just needs to</span>
  <span class="c1">// be an optimizer black-box.</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">maybe_drop</span><span class="p">(</span><span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
  <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span>
    <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6IiNbaW5saW5lKG5ldmVyKV1cbnB1YiBmbiBzb21lb25lX2Vsc2VzX3By b2JsZW0oXzogQm94PGkzMj4pIHtcbiAgLy8gV2hhdCBnb2VzIGluIGhlcmUg aXNuJ3QgaW1wb3J0YW50LGl0IGp1c3QgbmVlZHMgdG9cbiAgLy8gYmUgYW4g b3B0aW1pemVyIGJsYWNrLWJveC5cbn1cblxucHViIGZuIG1heWJlX2Ryb3Ao ZmxhZzogYm9vbCkge1xuICBsZXQgeCA9IEJveDo6bmV3KDQyKTtcbiAgaWYg ZmxhZyB7XG4gICAgc29tZW9uZV9lbHNlc19wcm9ibGVtKHgpXG4gIH1cbn0i LCJjb21waWxlcnMiOlt7ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiItTyJ9XX1d fQ== ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// See Godbolt widget above for full disassembly.</span>
<span class="n">example</span><span class="o">::</span><span class="n">maybe_drop</span><span class="o">:</span>
  <span class="c1">// ...</span>

  <span class="c1">// Allocate memory.</span>
  <span class="n">call</span>    <span class="n">__rust_alloc</span>

  <span class="c1">// Check if allocation failed; panic if so.</span>
  <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">scream</span>

  <span class="c1">// Write a 42 to the memory.</span>
  <span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>

  <span class="c1">// Check the flag argument (LLVM decided to put it in rbx). If</span>
  <span class="c1">// true, we go free the memory ourselves.</span>
  <span class="n">test</span>    <span class="n">bl</span><span class="p">,</span> <span class="n">bl</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">actually_our_problem</span>

  <span class="c1">// Otherwise, make it someone else's problem; they get to</span>
  <span class="c1">// free the memory for themselves. </span>
  <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">pop</span>     <span class="n">rbx</span>
  <span class="n">jmp</span>     <span class="n">example</span><span class="o">::</span><span class="n">someone_elses_problem</span>

  <span class="c1">// ...</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>The upshot is that <code class="language-plaintext highlighter-rouge">maybe_drop</code> conditions the destructor of <code class="language-plaintext highlighter-rouge">x</code> on a <em>flag</em>, which is allocated next to it on the stack. Rust flips this flag when the value is moved into another function, and only runs the destructor when the flag is left alone. In this case, LLVM folded the flag into the <code class="language-plaintext highlighter-rouge">bool</code> argument, so this isn’t actually a meaningful perf hit.</p> <p>These “drop flags” are key to Rust’s ownership model. Since ownership may be transferred dynamically due to reasonably complex control flow, it needs to leave breadcrumbs for itself to figure out whether the value wound up getting moved away or not. This is unique to Rust: in C++, every object is always destroyed, so no such faffing about is necessary.</p> <p>Similarly, <code class="language-plaintext highlighter-rouge">moveit</code> can close this soundness hole by leaving itself breadcrumbs to determine if safe code is trying to undermine its guarantees.</p> <p>In other words: in Rust, it is not sufficient to manage a pointer to manage a memory location; it is necessary to manage an explicit or implicit drop flag as well.</p> <h2 id="a-flagged-moveref"><a href="#a-flagged-moveref">A Flagged <code class="language-plaintext highlighter-rouge">MoveRef</code></a></h2> <p>We can extend <code class="language-plaintext highlighter-rouge">MoveRef</code> to track an explicit drop flag:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>

  <span class="c1">// Set to `false` once the destructor runs.</span>
  <span class="n">drop_flag</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Wrapping it in a <code class="language-plaintext highlighter-rouge">Cell</code> is convenient and doesn’t cost us anything, since a <code class="language-plaintext highlighter-rouge">MoveRef</code> can never be made <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code> anyways. Inside of its destructor, we can flip the flag, much like Rust flips a drop flag when transferring ownership to another function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.drop_flag</span><span class="nf">.set</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>But, how should we use it? The easiest way is to change the definition of <code class="language-plaintext highlighter-rouge">moveit!()</code> to construct a <em>flag trap</em>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Create a *trapped flag*, which I'll describe below.</span>
<span class="k">let</span> <span class="n">trap</span> <span class="o">=</span> <span class="nn">TrappedFlag</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// Run the constructor as before and construct a MoveRef.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">uninit</span><span class="p">)</span><span class="nf">.assume_init_mut</span><span class="p">(),</span>
  <span class="n">trap</span><span class="nf">.flag</span><span class="p">(),</span>  <span class="c1">// Creating a MoveRef now requires</span>
                <span class="c1">// passing in a flag in addition to </span>
                <span class="c1">// a reference to the owned value itself.</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The trap is a deterrent against forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code>: because the <code class="language-plaintext highlighter-rouge">MoveRef</code>’s destructor flips the flag, the trap’s destructor will notice if this <em>doesn’t</em> happen, and take action accordingly.</p> <blockquote> <p>Note: in <code class="language-plaintext highlighter-rouge">moveit</code>, this is actually implemented by having the <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code> type carry a reference to the trap, created in the <code class="language-plaintext highlighter-rouge">slot!()</code> macro. However, this is not a crucial detail for the design.</p> </blockquote> <h3 id="an-earth-shattering-kaboom"><a href="#an-earth-shattering-kaboom">An Earth-Shattering Kaboom</a></h3> <p>The trap is another RAII type that basically looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="nf">TrappedFlag</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">TrappedFlag</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">()</span> <span class="p">{</span> <span class="nf">abort</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The trap is simple: if the contained drop flag is not flipped, it crashes the program. Because <code class="language-plaintext highlighter-rouge">moveit!()</code> allocates it on the stack where uses cannot <code class="language-plaintext highlighter-rouge">mem::forget</code> it, its destructor is guaranteed to run before <code class="language-plaintext highlighter-rouge">storage</code>’s destructor runs (although Rust does not guarantee destructors run, it <em>does</em> guarantee their order).</p> <p>If a <code class="language-plaintext highlighter-rouge">MoveRef</code> is forgotten, it won’t have a chance to flip the flag, which the trap will detect. Once the trap’s destructor notices this, it cannot return, either normally or by panic, since this would cause <code class="language-plaintext highlighter-rouge">storage</code> to be freed. Crashing the program is the only<sup id="fnref:or-we-could-drop-it" role="doc-noteref"><a href="#fn:or-we-could-drop-it" class="footnote" rel="footnote">1</a></sup> acceptable response.</p> <p>Some of <code class="language-plaintext highlighter-rouge">MoveRef</code>’s functions need to be adapted to this new behavior: for example, <code class="language-plaintext highlighter-rouge">MoveRef::into_inner()</code> still needs to flip the flag, since moving out of the <code class="language-plaintext highlighter-rouge">MoveRef</code> is equivalent to running the destructor for the purposes of drop flags.</p> <h2 id="a-safer-derefmove"><a href="#a-safer-derefmove">A Safer <code class="language-plaintext highlighter-rouge">DerefMove</code></a></h2> <p>In order for <code class="language-plaintext highlighter-rouge">MoveRef</code> to be a proper “new” reference type, and not just a funny smart pointer, we also need a <code class="language-plaintext highlighter-rouge">Deref</code> equivalent:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// An "uninitialized" version of `Self`.</span>
  <span class="k">type</span> <span class="n">Uninit</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>
  
  <span class="cd">/// "Deinitializes" `self`, producing an opaque type that will</span>
  <span class="cd">/// destroy the storage of `*self` without calling the pointee</span>
  <span class="cd">/// destructor.</span>
  <span class="k">fn</span> <span class="nf">deinit</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a `MoveRef` that owns its</span>
  <span class="cd">/// contents.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">deref_move</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is the <em>original</em> design for <code class="language-plaintext highlighter-rouge">DerefMove</code>, which had a two-phase operation: first <code class="language-plaintext highlighter-rouge">deinit()</code> was used to create a destructor-suppressed version of the smart pointer that would only run the destructor for the storage (e.g., for <code class="language-plaintext highlighter-rouge">Box</code>, only the call to <code class="language-plaintext highlighter-rouge">free()</code>). Then, <code class="language-plaintext highlighter-rouge">deref_move()</code> would extract the “inner pointee” out of it as a <code class="language-plaintext highlighter-rouge">MoveRef</code>. This had the effect of splitting the smart pointer’s destructor, much like we did above on the stack.</p> <p>This has a number of usability problems. Not only does it <em>need</em> to be called through a macro, but <code class="language-plaintext highlighter-rouge">deinit()</code> isn’t actually safe: failing to call <code class="language-plaintext highlighter-rouge">deref_move()</code> is just as bad as calling <code class="language-plaintext highlighter-rouge">mem::forget</code> on the result. Further, it’s not clear where to plumb the drop flags through.</p> <p>After <a href="https://github.com/google/moveit/pull/23#issuecomment-963549869">many attempts</a> to graft drop flags onto this design, I replaced it with a completely new interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The "pure storage" form of `Self`, which owns the storage</span>
  <span class="cd">/// but not the pointee.</span>
  <span class="k">type</span> <span class="n">Storage</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a [`MoveRef`] that owns</span>
  <span class="cd">/// its contents.</span>
  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Storage</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Uninit</code> has been given the clearer name of <code class="language-plaintext highlighter-rouge">Storage</code>: a type that owns <em>just</em> the storage of the moved-from pointer. The two functions were merged into a single, <em>safe</em> function that performs everything in one step, emitting the storage as an out-parameter.</p> <p>The new <code class="language-plaintext highlighter-rouge">DroppingSlot&lt;T&gt;</code> is like a <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code>, but closer to a safe version of the <code class="language-plaintext highlighter-rouge">EventuallyInit&lt;T&gt;</code> type from earlier: its contents are not necessarily initialized, but if they are, it destroys them, and it only does so when its drop flag is set.</p> <p><code class="language-plaintext highlighter-rouge">Box</code> is the most illuminating example of this trait:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// Dismantle the incoming Box into the "storage-only part".</span>
    <span class="k">let</span> <span class="n">this</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span>
    <span class="p">};</span>

    <span class="c1">// Put the Box into the provided storage area. Note that we</span>
    <span class="c1">// don't need to set the drop flag; `DroppingSlot` does</span>
    <span class="c1">// that automatically for us.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="o">=</span> <span class="n">storage</span><span class="nf">.put</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

    <span class="c1">// Construct a new MoveRef, converting `storage` from </span>
    <span class="c1">// `&amp;mut Box&lt;MaybeUninit&lt;T&gt;&gt;` into `&amp;mut T`.</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">storage</span><span class="nf">.assume_init_mut</span><span class="p">(),</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s own implementation illustrates the need for the explicit lifetime bound:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="p">();</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// We can just return directly; this is a mere lifetime narrowing.</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Since this is fundamentally a lifetime narrowing, this can only compile if we insist that <code class="language-plaintext highlighter-rouge">'a: 'frame</code>, which is implied by <code class="language-plaintext highlighter-rouge">Self: 'frame</code>. Earlier iterations of this design enforced it via a <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, Self&gt;</code> receiver, which turned out to be unnecessary.</p> <h2 id="conclusions"><a href="#conclusions">Conclusions</a></h2> <p>As of writing, I’m still in the process of self-reviewing <a href="https://github.com/google/moveit/pull/25">this change</a>, but at this point I feel <em>reasonably</em> confident that it’s correct; this article is, in part, written to convince myself that I’ve done this correctly.</p> <p>The new design will also enable me to finally complete my implementation of a constructor and pinning-friendly vector type; this issue came up in part because the vector type needs to manipulate drop flags in a complex way. For this reason, the <em>actual</em> implementation of drop flags actually uses a counter, not a single boolean.</p> <p>I doubt this is the last issue I’ll need to chase down in <code class="language-plaintext highlighter-rouge">moveit</code>, but for now, we’re ever-closer to true owning references in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:or-we-could-drop-it" role="doc-endnote"> <p>Arguably, running the skipped destructor is <em>also</em> a valid remediation strategy. However, this is incompatible with what the user requested: they asked for the destructor to be supressed, not for it to be run at a later date. This would be somewhat surprising behavior, which we could warn about for the benefit of <code class="language-plaintext highlighter-rouge">unsafe</code> code, but ultimately the incorrect choice for non-stack storage, such as a <code class="language-plaintext highlighter-rouge">MoveRef</code> referring to the heap. <a href="#fnref:or-we-could-drop-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> </div> </div> </div></div> </body> <div class="sidebar show-if-mobile"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota </div> </div> </html>