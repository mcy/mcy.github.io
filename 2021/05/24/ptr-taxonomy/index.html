<!DOCTYPE html> <html lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> The Taxonomy of Pointers &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="The Taxonomy of Pointers &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/ptr-taxonomy-a830752bf2e5dafb3f2a543e5f333bb5542e480d.png"> <meta property="og:title" content="The Taxonomy of Pointers &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/ptr-taxonomy-a830752bf2e5dafb3f2a543e5f333bb5542e480d.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2021/05/24/ptr-taxonomy/"> </head> <body> <div class="sidebar"> <a href="https://mcyoung.xyz/"> <img src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog." class="hide-if-mobile"/> </a> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/">Home</a> • <a class="sidebar-nav-item" href="/about.html">About</a> • <a class="sidebar-nav-item" href="/posts.html">Posts</a> • <a class="sidebar-nav-item" href="/tags.html">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://art.mcyoung.xyz/">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> </nav> <br class="hide-if-mobile"/> <p class="hide-if-mobile"><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota</p> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2021-05-24 • 2069 words • 11 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> </span> <h1><a href="/2021/05/24/ptr-taxonomy/"> The Taxonomy of Pointers </a></h1> </div> <div class="post"> <p>Writing <code class="language-plaintext highlighter-rouge">unsafe</code> in Rust usually involves manual management of memory. Although, ideally, we’d like to exclusively use references for this, sometimes the constraints they apply are too strong. This post is a guide on those constraints and how to weaken them for correctness.</p> <p>“Unmanaged” languages, like C++ and Rust, provide <em>pointer</em> types for manipulating memory. These types serve different purposes and provide different guarantees. These guarantees are useful for the optimizer but get in the way of correctness of low-level code. This is especially true in Rust, where these constraints are very tight.</p> <blockquote> <p>NB: This post only surveys <em>data</em> pointers. Function pointers are their own beast, but generally are less fussy, since they all have static lifetime<sup id="fnref:go-nuts" role="doc-noteref"><a href="#fn:go-nuts" class="footnote" rel="footnote">1</a></sup>.</p> </blockquote> <h2 id="basic-c-pointers"><a href="#basic-c-pointers">Basic C++ Pointers</a></h2> <p>First, let’s survey C++. We have three pointer types: the traditional C pointer <code class="language-plaintext highlighter-rouge">T*</code>, C++ references <code class="language-plaintext highlighter-rouge">T&amp;</code>, and rvalue references <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>. These generally have pretty weak guarantees.</p> <p>Pointers provide virtually no guarantees at all: they can be null, point to uninitialized memory, or point to nothing at all! C++ Only requires that they be aligned<sup id="fnref:unaligned" role="doc-noteref"><a href="#fn:unaligned" class="footnote" rel="footnote">2</a></sup>. They are little more than an address (until they are dereferenced, of course).</p> <p>References, on the other hand, are intended to be the “primary” pointer type. A <code class="language-plaintext highlighter-rouge">T&amp;</code> cannot be null, is well-aligned, and is intended to only refer to live memory (although it’s not something C++ can really guarantee for lack of a borrow-checker). References are short-lived.</p> <p>C++ uses non-nullness to its advantage. For example, Clang will absolutely delete code of the form</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">x</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Because references cannot be null, and dereferencing the null pointer is always UB, the compiler may make this fairly strong assumption.</p> <p>Rvalue references, <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>, are not meaningfully different from normal references, beyond their role in overload resolution.</p> <p>Choosing a C++ (primitive) pointer type is well-studied and not the primary purpose of this blog. Rather, we’re interested in how these map to Rust, which has significantly more complicated pointers.</p> <h2 id="basic-rust-pointers"><a href="#basic-rust-pointers">Basic Rust Pointers</a></h2> <p>Like C++, Rust has two broad pointer types: <code class="language-plaintext highlighter-rouge">*const T</code> and <code class="language-plaintext highlighter-rouge">*mut T</code>, the raw pointers, and <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, the references.</p> <p>Rust pointer have even fewer constraints than C++ pointers; they need not even be aligned<sup id="fnref:unaligned-access" role="doc-noteref"><a href="#fn:unaligned-access" class="footnote" rel="footnote">3</a></sup>! The <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">mut</code> specifier is basically irrelevant, but is useful as programmer book-keeping tool. Rust also does not enforce the dreaded strict-aliasing rule<sup id="fnref:strict-aliasing" role="doc-noteref"><a href="#fn:strict-aliasing" class="footnote" rel="footnote">4</a></sup> on its pointers.</p> <p>On the other hand, Rust references are among the most constrained objects in any language that I know of. A shared reference <code class="language-plaintext highlighter-rouge">&amp;'a T</code>, lasting for the lifetime <code class="language-plaintext highlighter-rouge">'a</code>, satisfies:</p> <ul> <li>Non-null, and well-aligned (like in C++).</li> <li>Points to a valid, initialized <code class="language-plaintext highlighter-rouge">T</code> for the duration of <code class="language-plaintext highlighter-rouge">'a</code>.</li> <li><code class="language-plaintext highlighter-rouge">T</code> is never ever mutated for the duration of the reference: the compiler may fold separate reads into one at will. Stronger still, no <code class="language-plaintext highlighter-rouge">&amp;mut T</code> is reachable from any thread while the reference is reachable.</li> </ul> <p>Stronger still are <code class="language-plaintext highlighter-rouge">&amp;'a mut T</code> references, sometimes called <em>unique</em> references, because in addition to being well-aligned and pointing to a valid <code class="language-plaintext highlighter-rouge">T</code> at all times, no other reachable reference ever aliases it in any thread; this is equivalent to a C <code class="language-plaintext highlighter-rouge">T* restrict</code> pointer.</p> <p>Unlike C++, which has two almost-identical pointer types, Rust’s two pointer types provide either no guarantees or <em>all</em> of them. The following <code class="language-plaintext highlighter-rouge">unsafe</code> operations are all UB:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">null</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null</span><span class="p">()</span> <span class="p">};</span>

<span class="c1">// A reference to u8 need not be sufficiently aligned</span>
<span class="c1">// for a reference to u32.</span>
<span class="k">let</span> <span class="n">unaligned</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">};</span>

<span class="c1">// More on this type later...</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">};</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">unsafe</span> <span class="p">{</span>
  <span class="c1">// Not UB in C++ with const_cast!</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="p">(</span><span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span><span class="nf">.write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Two mutable references live at the same time pointing to</span>
<span class="c1">// the same memory. This would also be fine in C++!</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">};</span>
<span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="wide-pointers"><a href="#wide-pointers">Wide Pointers</a></h3> <p>Rust also provides the slice types <code class="language-plaintext highlighter-rouge">&amp;[T]</code><sup id="fnref:std-span" role="doc-noteref"><a href="#fn:std-span" class="footnote" rel="footnote">5</a></sup> (of which you get mutable/immutable reference and pointer varieties) and dynamic trait object types <code class="language-plaintext highlighter-rouge">&amp;dyn Tr</code> (again, all four basic pointer types are available).</p> <p><code class="language-plaintext highlighter-rouge">&amp;[T]</code> is a <code class="language-plaintext highlighter-rouge">usize</code><sup id="fnref:usize" role="doc-noteref"><a href="#fn:usize" class="footnote" rel="footnote">6</a></sup> length plus a pointer to that many <code class="language-plaintext highlighter-rouge">T</code>s. The pointer type of the slice specifies the guarantees on the pointed-to buffer. <code class="language-plaintext highlighter-rouge">*mut [T]</code>, for example, has no meaningful guarantees, but still contains the length<sup id="fnref:ptr-len" role="doc-noteref"><a href="#fn:ptr-len" class="footnote" rel="footnote">7</a></sup>. Note that the length is part of the pointer value, <em>not</em> the pointee.</p> <p><code class="language-plaintext highlighter-rouge">&amp;dyn Tr</code> is a trait object. For our purposes, it consists of a pointer to some data plus a pointer to a static vtable. <code class="language-plaintext highlighter-rouge">*mut dyn Tr</code> is technically a valid type<sup id="fnref:raw-vtable" role="doc-noteref"><a href="#fn:raw-vtable" class="footnote" rel="footnote">8</a></sup>. Overall, trait objects aren’t really relevant to this post; they are rarely used this way in <code class="language-plaintext highlighter-rouge">unsafe</code> settings.</p> <h2 id="weakening-the-guarantees"><a href="#weakening-the-guarantees">Weakening the Guarantees</a></h2> <p>Suppose we’re building some kind of data structure; in Rust, data structures will need some sprinkling of <code class="language-plaintext highlighter-rouge">unsafe</code>, since they will need to shovel around memory directly. Typically this is done using raw pointers, but it is preferable to use the <em>least weakened</em> pointer type to allow the compiler to perform whatever optimizations it can.</p> <p>There are a number of orthogonal guarantees on <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code> we might want to relax:</p> <ul> <li>Non-nullness.</li> <li>Well-aligned-ness.</li> <li>Validity and initialized-ness of the pointee.</li> <li>Allocated-ness of the pointee (implied by initialized-ness).</li> <li>Global uniqueness of an <code class="language-plaintext highlighter-rouge">&amp;mut T</code>.</li> </ul> <h3 id="pointer-to-zst"><a href="#pointer-to-zst">Pointer to ZST</a></h3> <p>The last three of these properties are irrelevant for a zero-sized type. For example, we can generate infinite <code class="language-plaintext highlighter-rouge">&amp;mut ()</code> with no consequences:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">unique_unit</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="mi">0x1</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">())</span> <span class="p">}</span> 
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We materialize a non-null, well-aligned pointer and reborrow it into a static reference; because there is no data to point to, none of the usual worries about the pointee itself apply. However, the pointer itself must still be non-null and well-aligned; <code class="language-plaintext highlighter-rouge">0x1</code> is not a valid address for an <code class="language-plaintext highlighter-rouge">&amp;[u32; 0]</code>, but <code class="language-plaintext highlighter-rouge">0x4</code> is<sup id="fnref:but-you-cannot-free-it" role="doc-noteref"><a href="#fn:but-you-cannot-free-it" class="footnote" rel="footnote">9</a></sup>.</p> <p>This also applies to empty slices; in fact, the compiler will happily promote the expression <code class="language-plaintext highlighter-rouge">&amp;mut []</code> to an arbitrary lifetime:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">unique_empty</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
  <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="null-references"><a href="#null-references">Null References</a></h3> <p>The most well-known manner of weakening is <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code>. Rust guarantees that this is ABI-compatible with a C pointer <code class="language-plaintext highlighter-rouge">const T*</code>, with <code class="language-plaintext highlighter-rouge">Option::&lt;&amp;T&gt;::None</code> being a null pointer on the C side. This “null pointer optimization” applies to any type recursively containing at least one <code class="language-plaintext highlighter-rouge">T&amp;</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">DoSomething</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_something</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">DoSomething</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>  <span class="c1">// C will see a `NULL` as the argument.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The same effect can be achieved for a pointer type using the <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code class="language-plaintext highlighter-rouge">NonNull&lt;T&gt;</code></a> standard library type: <code class="language-plaintext highlighter-rouge">Option&lt;NonNull&lt;T&gt;&gt;</code> is identical to <code class="language-plaintext highlighter-rouge">*mut T</code>. This is most beneficial for types which would otherwise contain a raw pointer:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;</span><span class="p">(),</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;&gt;</span><span class="p">())</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="uninitialized-pointee"><a href="#uninitialized-pointee">Uninitialized Pointee</a></h3> <p>No matter what, a <code class="language-plaintext highlighter-rouge">&amp;T</code> cannot point to uninitialized memory, since the compiler is free to assume it may read such references at any time with no consequences.</p> <p>The following classic C pattern is verboten:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">initialize_foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C</div></div></div> <p>Rust doesn’t provide any particularly easy ways to allocate memory without initializing it, too, so this usually isn’t a problem. The <a href="https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_ref"><code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code></a> type can be used for safely allocating memory without initializing it, via <code class="language-plaintext highlighter-rouge">MaybeUninit::uninit()</code>.</p> <p>This type acts as a sort of “optimization barrier” that prevents the compiler from assuming the pointee is initialized. <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> is a pointer to potentially uninitialized but definitely allocated memory. It has the same layout as <code class="language-plaintext highlighter-rouge">&amp;T</code>, and Rust provides functions like <code class="language-plaintext highlighter-rouge">assume_init_ref()</code> for asserting that a <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> is definitely initialized. This assertion is similar in consequence to dereferencing a raw pointer.</p> <p><code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">&amp;mut MaybeUninit&lt;T&gt;</code> should almost be viewed as pointer types in their own right, since they can be converted to/from <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code> under certain circumstances.</p> <p>Because <code class="language-plaintext highlighter-rouge">T</code> is almost a “subtype” of <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, we are entitled<sup id="fnref:requires-transmute" role="doc-noteref"><a href="#fn:requires-transmute" class="footnote" rel="footnote">10</a></sup> to “forget” that the referent of a <code class="language-plaintext highlighter-rouge">&amp;T</code> is initialized converting it to a <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code>. This makes sense because <code class="language-plaintext highlighter-rouge">&amp;T</code> is covariant<sup id="fnref:covariance" role="doc-noteref"><a href="#fn:covariance" class="footnote" rel="footnote">11</a></sup> in <code class="language-plaintext highlighter-rouge">&amp;T</code>. However, this is not true of <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, since it’s not covariant:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">uninit</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">)</span> <span class="p">};</span>
<span class="o">*</span><span class="n">uninit</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>  <span class="c1">// Oops, `x` is now uninit!</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>These types are useful for talking to C++ without giving up too many guarantees. <code class="language-plaintext highlighter-rouge">Option&lt;&amp;MaybeUninit&lt;T&gt;&gt;</code> is an almost perfect model of a <code class="language-plaintext highlighter-rouge">const T*</code>, under the assumption that most pointers in C++ are valid most of the time.</p> <p><code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> also finds use in working with raw blocks of memory, such as in a <code class="language-plaintext highlighter-rouge">Vec</code>-style growable slice:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">SliceVec</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Backing memory. The first `len` elements of it are</span>
  <span class="c1">// known to be initialized, but no more than that.</span>
  <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">],</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SliceVec</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;</span> <span class="n">data</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="k">self</span><span class="py">.len</span><span class="p">]</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="aliased-pointee"><a href="#aliased-pointee">Aliased Pointee</a></h3> <p><code class="language-plaintext highlighter-rouge">&amp;mut T</code> can never alias any other pointer, but is also the mechanism by which we perform mutation. It can’t even alias with pointers that Rust can’t see; Rust assumes no one else can touch this memory. Thus, <code class="language-plaintext highlighter-rouge">&amp;mut T</code> is not an appropriate analogue for <code class="language-plaintext highlighter-rouge">T&amp;</code>.</p> <p>Like with uninitialized memory, Rust provides a “barrier” wrapper type, <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code></a>. <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> is the “interior mutability” primitive, which permits us to mutate through an <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> so long as concurrent reads and writes do not occur. We may even convert it to a <code class="language-plaintext highlighter-rouge">&amp;mut T</code> when we’re sure we’re holding the only reference.</p> <p><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> forms the basis of the <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, and <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code> types, each of which performs a sort of “dynamic borrow-checking”:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> only permits direct loads and stores.</li> <li><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> maintains a counter of references into it, which it uses to dynamically determine if a mutable reference would be unique.</li> <li><code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code>, which is like <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> but using concurrency primitives to maintain uniqueness.</li> </ul> <p>Because of this, Rust must treat <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> as always aliasing, but because we can mutate through it, it is a much closer analogue to a C++ <code class="language-plaintext highlighter-rouge">T&amp;</code>. However, because <code class="language-plaintext highlighter-rouge">&amp;T</code> assumes the pointee is never mutated, it cannot coexist with a <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> to the same memory, if mutation is performed through it. The following is explicitly UB:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

<span class="c1">// This is ok; creating the reference to UnsafeCell does not</span>
<span class="c1">// immediately trigger UB.</span>
<span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">};</span>

<span class="c1">// But writing to it does!</span>
<span class="n">q</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> type is useful for non-aliasing references to plain-old-data types, which tend to be <code class="language-plaintext highlighter-rouge">Copy</code>. It allows us to perform mutation without having to utter <code class="language-plaintext highlighter-rouge">unsafe</code>. For example, the correct type for a shared mutable buffer in Rust is <code class="language-plaintext highlighter-rouge">&amp;[Cell&lt;u8&gt;]</code>, which can be freely <code class="language-plaintext highlighter-rouge">memcpy</code>‘d, without worrying about aliasing<sup id="fnref:but-thread-safety" role="doc-noteref"><a href="#fn:but-thread-safety" class="footnote" rel="footnote">12</a></sup>.</p> <p>This is most useful for sharing memory with another language, like C++, which cannot respect Rust’s aliasing rules.</p> <h3 id="combined-barriers"><a href="#combined-barriers">Combined Barriers</a></h3> <p>To recap:</p> <ul> <li>Non-nullness can be disabled with <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code>.</li> <li>Initialized-ness can be disabled with <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code>.</li> <li>Uniqueness can be disabled with <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code>.</li> </ul> <blockquote> <p>There is no way to disable alignment and validity restrictions: references must always be aligned and have a valid lifetime attached. If these are unachievable, raw pointers are your only option.</p> </blockquote> <p>We can combine these various “weakenings” to produce aligned, lifetime-bound references to data with different properties. For example:</p> <ul> <li><code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> is as close as we can get to a C++ <code class="language-plaintext highlighter-rouge">T&amp;</code>.</li> <li><code class="language-plaintext highlighter-rouge">Option&lt;&amp;UnsafeCell&lt;T&gt;&gt;</code> is a like a raw pointer, but to initialized memory.</li> <li><code class="language-plaintext highlighter-rouge">Option&lt;&amp;mut MaybeUninit&lt;T&gt;&gt;</code> is like a raw pointer, but with alignment, aliasing, and lifetime requirements.</li> <li><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;&amp;[T]&gt;</code> permits us to mutate the pointer to the buffer and its length, but not the values it points to themselves.</li> <li><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;&amp;[UnsafeCell&lt;T&gt;]&gt;</code> lets us mutate both the buffer and its actual pointer/length.</li> </ul> <p>Interestingly, there is no equivalent to a C++ raw pointer: there is no way to create a guaranteed-aligned pointer without a designated lifetime<sup id="fnref:unsafe-lifetime" role="doc-noteref"><a href="#fn:unsafe-lifetime" class="footnote" rel="footnote">13</a></sup>.</p> <h2 id="other-pointers"><a href="#other-pointers">Other Pointers</a></h2> <p>Rust and C++ have many other pointer types, such as smart pointers. However, in both languages, both are built in terms of these basic pointer types. Hopefully this article is a useful reference for anyone writing <code class="language-plaintext highlighter-rouge">unsafe</code> abstraction that wishes to avoid using raw pointers when possible.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:go-nuts" role="doc-endnote"> <p>Except in Go, which synthesizes vtables <em>on the fly</em>. Story for another day. <a href="#fnref:go-nuts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned" role="doc-endnote"> <p>It is, apparently, a little-known fact that constructing unaligned pointers, but then never dereferencing them, is still UB in C++. C++ could, for example, store information in the lower bits of such a pointer. The in-memory representation of a pointer is actually unspecified! <a href="#fnref:unaligned" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned-access" role="doc-endnote"> <p>This is useful when paired with the Rust <code class="language-plaintext highlighter-rouge">&lt;*const T&gt;::read_unaligned()</code> function, which can be compiled down to a normal load on architectures that do not have alignment restrictions, like x86_64 and aarch64. <a href="#fnref:unaligned-access" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:strict-aliasing" role="doc-endnote"> <p>Another story for another time. <a href="#fnref:strict-aliasing" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:std-span" role="doc-endnote"> <p>Comparable to the C++20 <a href="https://en.cppreference.com/w/cpp/container/span"><code class="language-plaintext highlighter-rouge">std::span&lt;T&gt;</code></a> type. <a href="#fnref:std-span" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:usize" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">usize</code> is Rust’s machine word type, compare <code class="language-plaintext highlighter-rouge">std::uintptr_t</code>. <a href="#fnref:usize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptr-len" role="doc-endnote"> <p>The length of a <code class="language-plaintext highlighter-rouge">*mut [T]</code> can be accessed via the unstable <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.len-1"><code class="language-plaintext highlighter-rouge">&lt;*mut [T]&gt;::len()</code></a> method. <a href="#fnref:ptr-len" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:raw-vtable" role="doc-endnote"> <p>It is also not a type I have encountered enough to have much knowledge on. For example, I don’t actually know if the vtable half of a <code class="language-plaintext highlighter-rouge">*mut dyn Tr</code> must always be valid or not; I suspect the answer is “no”, but I couldn’t find a citation for this. <a href="#fnref:raw-vtable" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:but-you-cannot-free-it" role="doc-endnote"> <p>Note that you <em>cannot</em> continue to use a reference to freed, zero-sized memory. This subtle distinction is called out in <a href="https://doc.rust-lang.org/std/ptr/index.html#safety">https://doc.rust-lang.org/std/ptr/index.html#safety</a>. <a href="#fnref:but-you-cannot-free-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-transmute" role="doc-endnote"> <p>Currently, a <code class="language-plaintext highlighter-rouge">transmute</code> must be used to perform this operation, but I see no reason way this would permit us to perform an illegal mutation without uttering <code class="language-plaintext highlighter-rouge">unsafe</code> a second time. In particular, <code class="language-plaintext highlighter-rouge">MaybeUninit::assume_init_read()</code>, which could be used to perform illegal copies, is an <code class="language-plaintext highlighter-rouge">unsafe</code> function. <a href="#fnref:requires-transmute" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:covariance" role="doc-endnote"> <p>A covariant type <code class="language-plaintext highlighter-rouge">Cov&lt;T&gt;</code> is once where, if <code class="language-plaintext highlighter-rouge">T</code> is a subtype of <code class="language-plaintext highlighter-rouge">U</code>, then <code class="language-plaintext highlighter-rouge">Cov&lt;T&gt;</code> is a subtype of <code class="language-plaintext highlighter-rouge">Cov&lt;U&gt;</code>. This isn’t particularly noticeable in Rust, where the only subtyping relationships are <code class="language-plaintext highlighter-rouge">&amp;'a T</code> subtypes <code class="language-plaintext highlighter-rouge">&amp;'b T</code> when <code class="language-plaintext highlighter-rouge">'a</code> outlives <code class="language-plaintext highlighter-rouge">'b</code>, but is nonetheless important for advanced type design. <a href="#fnref:covariance" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:but-thread-safety" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> does not provide synchronization; you still need locks to share it between threads. <a href="#fnref:but-thread-safety" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unsafe-lifetime" role="doc-endnote"> <p>I have previously proposed a sort of <code class="language-plaintext highlighter-rouge">'unsafe</code> or <code class="language-plaintext highlighter-rouge">'!</code> “lifetime” that is intended to be the lifetime of dangling references (a bit of an oxymoron). This would allow us to express this concept, but I need to flesh out the concept more. <a href="#fnref:unsafe-lifetime" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2021-05-24 • 2069 words • 11 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> </span> <h1><a href="/2021/05/24/ptr-taxonomy/"> The Taxonomy of Pointers </a></h1> </div> <div class="post"> <p>Writing <code class="language-plaintext highlighter-rouge">unsafe</code> in Rust usually involves manual management of memory. Although, ideally, we’d like to exclusively use references for this, sometimes the constraints they apply are too strong. This post is a guide on those constraints and how to weaken them for correctness.</p> <p>“Unmanaged” languages, like C++ and Rust, provide <em>pointer</em> types for manipulating memory. These types serve different purposes and provide different guarantees. These guarantees are useful for the optimizer but get in the way of correctness of low-level code. This is especially true in Rust, where these constraints are very tight.</p> <blockquote> <p>NB: This post only surveys <em>data</em> pointers. Function pointers are their own beast, but generally are less fussy, since they all have static lifetime<sup id="fnref:go-nuts" role="doc-noteref"><a href="#fn:go-nuts" class="footnote" rel="footnote">1</a></sup>.</p> </blockquote> <h2 id="basic-c-pointers"><a href="#basic-c-pointers">Basic C++ Pointers</a></h2> <p>First, let’s survey C++. We have three pointer types: the traditional C pointer <code class="language-plaintext highlighter-rouge">T*</code>, C++ references <code class="language-plaintext highlighter-rouge">T&amp;</code>, and rvalue references <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>. These generally have pretty weak guarantees.</p> <p>Pointers provide virtually no guarantees at all: they can be null, point to uninitialized memory, or point to nothing at all! C++ Only requires that they be aligned<sup id="fnref:unaligned" role="doc-noteref"><a href="#fn:unaligned" class="footnote" rel="footnote">2</a></sup>. They are little more than an address (until they are dereferenced, of course).</p> <p>References, on the other hand, are intended to be the “primary” pointer type. A <code class="language-plaintext highlighter-rouge">T&amp;</code> cannot be null, is well-aligned, and is intended to only refer to live memory (although it’s not something C++ can really guarantee for lack of a borrow-checker). References are short-lived.</p> <p>C++ uses non-nullness to its advantage. For example, Clang will absolutely delete code of the form</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">x</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Because references cannot be null, and dereferencing the null pointer is always UB, the compiler may make this fairly strong assumption.</p> <p>Rvalue references, <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>, are not meaningfully different from normal references, beyond their role in overload resolution.</p> <p>Choosing a C++ (primitive) pointer type is well-studied and not the primary purpose of this blog. Rather, we’re interested in how these map to Rust, which has significantly more complicated pointers.</p> <h2 id="basic-rust-pointers"><a href="#basic-rust-pointers">Basic Rust Pointers</a></h2> <p>Like C++, Rust has two broad pointer types: <code class="language-plaintext highlighter-rouge">*const T</code> and <code class="language-plaintext highlighter-rouge">*mut T</code>, the raw pointers, and <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, the references.</p> <p>Rust pointer have even fewer constraints than C++ pointers; they need not even be aligned<sup id="fnref:unaligned-access" role="doc-noteref"><a href="#fn:unaligned-access" class="footnote" rel="footnote">3</a></sup>! The <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">mut</code> specifier is basically irrelevant, but is useful as programmer book-keeping tool. Rust also does not enforce the dreaded strict-aliasing rule<sup id="fnref:strict-aliasing" role="doc-noteref"><a href="#fn:strict-aliasing" class="footnote" rel="footnote">4</a></sup> on its pointers.</p> <p>On the other hand, Rust references are among the most constrained objects in any language that I know of. A shared reference <code class="language-plaintext highlighter-rouge">&amp;'a T</code>, lasting for the lifetime <code class="language-plaintext highlighter-rouge">'a</code>, satisfies:</p> <ul> <li>Non-null, and well-aligned (like in C++).</li> <li>Points to a valid, initialized <code class="language-plaintext highlighter-rouge">T</code> for the duration of <code class="language-plaintext highlighter-rouge">'a</code>.</li> <li><code class="language-plaintext highlighter-rouge">T</code> is never ever mutated for the duration of the reference: the compiler may fold separate reads into one at will. Stronger still, no <code class="language-plaintext highlighter-rouge">&amp;mut T</code> is reachable from any thread while the reference is reachable.</li> </ul> <p>Stronger still are <code class="language-plaintext highlighter-rouge">&amp;'a mut T</code> references, sometimes called <em>unique</em> references, because in addition to being well-aligned and pointing to a valid <code class="language-plaintext highlighter-rouge">T</code> at all times, no other reachable reference ever aliases it in any thread; this is equivalent to a C <code class="language-plaintext highlighter-rouge">T* restrict</code> pointer.</p> <p>Unlike C++, which has two almost-identical pointer types, Rust’s two pointer types provide either no guarantees or <em>all</em> of them. The following <code class="language-plaintext highlighter-rouge">unsafe</code> operations are all UB:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">null</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null</span><span class="p">()</span> <span class="p">};</span>

<span class="c1">// A reference to u8 need not be sufficiently aligned</span>
<span class="c1">// for a reference to u32.</span>
<span class="k">let</span> <span class="n">unaligned</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">};</span>

<span class="c1">// More on this type later...</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">};</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">unsafe</span> <span class="p">{</span>
  <span class="c1">// Not UB in C++ with const_cast!</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="p">(</span><span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span><span class="nf">.write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Two mutable references live at the same time pointing to</span>
<span class="c1">// the same memory. This would also be fine in C++!</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">};</span>
<span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="wide-pointers"><a href="#wide-pointers">Wide Pointers</a></h3> <p>Rust also provides the slice types <code class="language-plaintext highlighter-rouge">&amp;[T]</code><sup id="fnref:std-span" role="doc-noteref"><a href="#fn:std-span" class="footnote" rel="footnote">5</a></sup> (of which you get mutable/immutable reference and pointer varieties) and dynamic trait object types <code class="language-plaintext highlighter-rouge">&amp;dyn Tr</code> (again, all four basic pointer types are available).</p> <p><code class="language-plaintext highlighter-rouge">&amp;[T]</code> is a <code class="language-plaintext highlighter-rouge">usize</code><sup id="fnref:usize" role="doc-noteref"><a href="#fn:usize" class="footnote" rel="footnote">6</a></sup> length plus a pointer to that many <code class="language-plaintext highlighter-rouge">T</code>s. The pointer type of the slice specifies the guarantees on the pointed-to buffer. <code class="language-plaintext highlighter-rouge">*mut [T]</code>, for example, has no meaningful guarantees, but still contains the length<sup id="fnref:ptr-len" role="doc-noteref"><a href="#fn:ptr-len" class="footnote" rel="footnote">7</a></sup>. Note that the length is part of the pointer value, <em>not</em> the pointee.</p> <p><code class="language-plaintext highlighter-rouge">&amp;dyn Tr</code> is a trait object. For our purposes, it consists of a pointer to some data plus a pointer to a static vtable. <code class="language-plaintext highlighter-rouge">*mut dyn Tr</code> is technically a valid type<sup id="fnref:raw-vtable" role="doc-noteref"><a href="#fn:raw-vtable" class="footnote" rel="footnote">8</a></sup>. Overall, trait objects aren’t really relevant to this post; they are rarely used this way in <code class="language-plaintext highlighter-rouge">unsafe</code> settings.</p> <h2 id="weakening-the-guarantees"><a href="#weakening-the-guarantees">Weakening the Guarantees</a></h2> <p>Suppose we’re building some kind of data structure; in Rust, data structures will need some sprinkling of <code class="language-plaintext highlighter-rouge">unsafe</code>, since they will need to shovel around memory directly. Typically this is done using raw pointers, but it is preferable to use the <em>least weakened</em> pointer type to allow the compiler to perform whatever optimizations it can.</p> <p>There are a number of orthogonal guarantees on <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code> we might want to relax:</p> <ul> <li>Non-nullness.</li> <li>Well-aligned-ness.</li> <li>Validity and initialized-ness of the pointee.</li> <li>Allocated-ness of the pointee (implied by initialized-ness).</li> <li>Global uniqueness of an <code class="language-plaintext highlighter-rouge">&amp;mut T</code>.</li> </ul> <h3 id="pointer-to-zst"><a href="#pointer-to-zst">Pointer to ZST</a></h3> <p>The last three of these properties are irrelevant for a zero-sized type. For example, we can generate infinite <code class="language-plaintext highlighter-rouge">&amp;mut ()</code> with no consequences:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">unique_unit</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="mi">0x1</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">())</span> <span class="p">}</span> 
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We materialize a non-null, well-aligned pointer and reborrow it into a static reference; because there is no data to point to, none of the usual worries about the pointee itself apply. However, the pointer itself must still be non-null and well-aligned; <code class="language-plaintext highlighter-rouge">0x1</code> is not a valid address for an <code class="language-plaintext highlighter-rouge">&amp;[u32; 0]</code>, but <code class="language-plaintext highlighter-rouge">0x4</code> is<sup id="fnref:but-you-cannot-free-it" role="doc-noteref"><a href="#fn:but-you-cannot-free-it" class="footnote" rel="footnote">9</a></sup>.</p> <p>This also applies to empty slices; in fact, the compiler will happily promote the expression <code class="language-plaintext highlighter-rouge">&amp;mut []</code> to an arbitrary lifetime:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">unique_empty</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
  <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="null-references"><a href="#null-references">Null References</a></h3> <p>The most well-known manner of weakening is <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code>. Rust guarantees that this is ABI-compatible with a C pointer <code class="language-plaintext highlighter-rouge">const T*</code>, with <code class="language-plaintext highlighter-rouge">Option::&lt;&amp;T&gt;::None</code> being a null pointer on the C side. This “null pointer optimization” applies to any type recursively containing at least one <code class="language-plaintext highlighter-rouge">T&amp;</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">DoSomething</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_something</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">DoSomething</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>  <span class="c1">// C will see a `NULL` as the argument.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The same effect can be achieved for a pointer type using the <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code class="language-plaintext highlighter-rouge">NonNull&lt;T&gt;</code></a> standard library type: <code class="language-plaintext highlighter-rouge">Option&lt;NonNull&lt;T&gt;&gt;</code> is identical to <code class="language-plaintext highlighter-rouge">*mut T</code>. This is most beneficial for types which would otherwise contain a raw pointer:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;</span><span class="p">(),</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;&gt;</span><span class="p">())</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="uninitialized-pointee"><a href="#uninitialized-pointee">Uninitialized Pointee</a></h3> <p>No matter what, a <code class="language-plaintext highlighter-rouge">&amp;T</code> cannot point to uninitialized memory, since the compiler is free to assume it may read such references at any time with no consequences.</p> <p>The following classic C pattern is verboten:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">initialize_foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C</div></div></div> <p>Rust doesn’t provide any particularly easy ways to allocate memory without initializing it, too, so this usually isn’t a problem. The <a href="https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_ref"><code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code></a> type can be used for safely allocating memory without initializing it, via <code class="language-plaintext highlighter-rouge">MaybeUninit::uninit()</code>.</p> <p>This type acts as a sort of “optimization barrier” that prevents the compiler from assuming the pointee is initialized. <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> is a pointer to potentially uninitialized but definitely allocated memory. It has the same layout as <code class="language-plaintext highlighter-rouge">&amp;T</code>, and Rust provides functions like <code class="language-plaintext highlighter-rouge">assume_init_ref()</code> for asserting that a <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> is definitely initialized. This assertion is similar in consequence to dereferencing a raw pointer.</p> <p><code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">&amp;mut MaybeUninit&lt;T&gt;</code> should almost be viewed as pointer types in their own right, since they can be converted to/from <code class="language-plaintext highlighter-rouge">&amp;T</code> and <code class="language-plaintext highlighter-rouge">&amp;mut T</code> under certain circumstances.</p> <p>Because <code class="language-plaintext highlighter-rouge">T</code> is almost a “subtype” of <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, we are entitled<sup id="fnref:requires-transmute" role="doc-noteref"><a href="#fn:requires-transmute" class="footnote" rel="footnote">10</a></sup> to “forget” that the referent of a <code class="language-plaintext highlighter-rouge">&amp;T</code> is initialized converting it to a <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code>. This makes sense because <code class="language-plaintext highlighter-rouge">&amp;T</code> is covariant<sup id="fnref:covariance" role="doc-noteref"><a href="#fn:covariance" class="footnote" rel="footnote">11</a></sup> in <code class="language-plaintext highlighter-rouge">&amp;T</code>. However, this is not true of <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, since it’s not covariant:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">uninit</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">)</span> <span class="p">};</span>
<span class="o">*</span><span class="n">uninit</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>  <span class="c1">// Oops, `x` is now uninit!</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>These types are useful for talking to C++ without giving up too many guarantees. <code class="language-plaintext highlighter-rouge">Option&lt;&amp;MaybeUninit&lt;T&gt;&gt;</code> is an almost perfect model of a <code class="language-plaintext highlighter-rouge">const T*</code>, under the assumption that most pointers in C++ are valid most of the time.</p> <p><code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> also finds use in working with raw blocks of memory, such as in a <code class="language-plaintext highlighter-rouge">Vec</code>-style growable slice:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">SliceVec</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Backing memory. The first `len` elements of it are</span>
  <span class="c1">// known to be initialized, but no more than that.</span>
  <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">],</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SliceVec</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;</span> <span class="n">data</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="k">self</span><span class="py">.len</span><span class="p">]</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <h3 id="aliased-pointee"><a href="#aliased-pointee">Aliased Pointee</a></h3> <p><code class="language-plaintext highlighter-rouge">&amp;mut T</code> can never alias any other pointer, but is also the mechanism by which we perform mutation. It can’t even alias with pointers that Rust can’t see; Rust assumes no one else can touch this memory. Thus, <code class="language-plaintext highlighter-rouge">&amp;mut T</code> is not an appropriate analogue for <code class="language-plaintext highlighter-rouge">T&amp;</code>.</p> <p>Like with uninitialized memory, Rust provides a “barrier” wrapper type, <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code></a>. <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> is the “interior mutability” primitive, which permits us to mutate through an <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> so long as concurrent reads and writes do not occur. We may even convert it to a <code class="language-plaintext highlighter-rouge">&amp;mut T</code> when we’re sure we’re holding the only reference.</p> <p><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> forms the basis of the <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, and <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code> types, each of which performs a sort of “dynamic borrow-checking”:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> only permits direct loads and stores.</li> <li><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> maintains a counter of references into it, which it uses to dynamically determine if a mutable reference would be unique.</li> <li><code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code>, which is like <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> but using concurrency primitives to maintain uniqueness.</li> </ul> <p>Because of this, Rust must treat <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> as always aliasing, but because we can mutate through it, it is a much closer analogue to a C++ <code class="language-plaintext highlighter-rouge">T&amp;</code>. However, because <code class="language-plaintext highlighter-rouge">&amp;T</code> assumes the pointee is never mutated, it cannot coexist with a <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code> to the same memory, if mutation is performed through it. The following is explicitly UB:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

<span class="c1">// This is ok; creating the reference to UnsafeCell does not</span>
<span class="c1">// immediately trigger UB.</span>
<span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">};</span>

<span class="c1">// But writing to it does!</span>
<span class="n">q</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> type is useful for non-aliasing references to plain-old-data types, which tend to be <code class="language-plaintext highlighter-rouge">Copy</code>. It allows us to perform mutation without having to utter <code class="language-plaintext highlighter-rouge">unsafe</code>. For example, the correct type for a shared mutable buffer in Rust is <code class="language-plaintext highlighter-rouge">&amp;[Cell&lt;u8&gt;]</code>, which can be freely <code class="language-plaintext highlighter-rouge">memcpy</code>‘d, without worrying about aliasing<sup id="fnref:but-thread-safety" role="doc-noteref"><a href="#fn:but-thread-safety" class="footnote" rel="footnote">12</a></sup>.</p> <p>This is most useful for sharing memory with another language, like C++, which cannot respect Rust’s aliasing rules.</p> <h3 id="combined-barriers"><a href="#combined-barriers">Combined Barriers</a></h3> <p>To recap:</p> <ul> <li>Non-nullness can be disabled with <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code>.</li> <li>Initialized-ness can be disabled with <code class="language-plaintext highlighter-rouge">&amp;MaybeUninit&lt;T&gt;</code>.</li> <li>Uniqueness can be disabled with <code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;T&gt;</code>.</li> </ul> <blockquote> <p>There is no way to disable alignment and validity restrictions: references must always be aligned and have a valid lifetime attached. If these are unachievable, raw pointers are your only option.</p> </blockquote> <p>We can combine these various “weakenings” to produce aligned, lifetime-bound references to data with different properties. For example:</p> <ul> <li><code class="language-plaintext highlighter-rouge">&amp;UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> is as close as we can get to a C++ <code class="language-plaintext highlighter-rouge">T&amp;</code>.</li> <li><code class="language-plaintext highlighter-rouge">Option&lt;&amp;UnsafeCell&lt;T&gt;&gt;</code> is a like a raw pointer, but to initialized memory.</li> <li><code class="language-plaintext highlighter-rouge">Option&lt;&amp;mut MaybeUninit&lt;T&gt;&gt;</code> is like a raw pointer, but with alignment, aliasing, and lifetime requirements.</li> <li><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;&amp;[T]&gt;</code> permits us to mutate the pointer to the buffer and its length, but not the values it points to themselves.</li> <li><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;&amp;[UnsafeCell&lt;T&gt;]&gt;</code> lets us mutate both the buffer and its actual pointer/length.</li> </ul> <p>Interestingly, there is no equivalent to a C++ raw pointer: there is no way to create a guaranteed-aligned pointer without a designated lifetime<sup id="fnref:unsafe-lifetime" role="doc-noteref"><a href="#fn:unsafe-lifetime" class="footnote" rel="footnote">13</a></sup>.</p> <h2 id="other-pointers"><a href="#other-pointers">Other Pointers</a></h2> <p>Rust and C++ have many other pointer types, such as smart pointers. However, in both languages, both are built in terms of these basic pointer types. Hopefully this article is a useful reference for anyone writing <code class="language-plaintext highlighter-rouge">unsafe</code> abstraction that wishes to avoid using raw pointers when possible.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:go-nuts" role="doc-endnote"> <p>Except in Go, which synthesizes vtables <em>on the fly</em>. Story for another day. <a href="#fnref:go-nuts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned" role="doc-endnote"> <p>It is, apparently, a little-known fact that constructing unaligned pointers, but then never dereferencing them, is still UB in C++. C++ could, for example, store information in the lower bits of such a pointer. The in-memory representation of a pointer is actually unspecified! <a href="#fnref:unaligned" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned-access" role="doc-endnote"> <p>This is useful when paired with the Rust <code class="language-plaintext highlighter-rouge">&lt;*const T&gt;::read_unaligned()</code> function, which can be compiled down to a normal load on architectures that do not have alignment restrictions, like x86_64 and aarch64. <a href="#fnref:unaligned-access" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:strict-aliasing" role="doc-endnote"> <p>Another story for another time. <a href="#fnref:strict-aliasing" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:std-span" role="doc-endnote"> <p>Comparable to the C++20 <a href="https://en.cppreference.com/w/cpp/container/span"><code class="language-plaintext highlighter-rouge">std::span&lt;T&gt;</code></a> type. <a href="#fnref:std-span" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:usize" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">usize</code> is Rust’s machine word type, compare <code class="language-plaintext highlighter-rouge">std::uintptr_t</code>. <a href="#fnref:usize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptr-len" role="doc-endnote"> <p>The length of a <code class="language-plaintext highlighter-rouge">*mut [T]</code> can be accessed via the unstable <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.len-1"><code class="language-plaintext highlighter-rouge">&lt;*mut [T]&gt;::len()</code></a> method. <a href="#fnref:ptr-len" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:raw-vtable" role="doc-endnote"> <p>It is also not a type I have encountered enough to have much knowledge on. For example, I don’t actually know if the vtable half of a <code class="language-plaintext highlighter-rouge">*mut dyn Tr</code> must always be valid or not; I suspect the answer is “no”, but I couldn’t find a citation for this. <a href="#fnref:raw-vtable" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:but-you-cannot-free-it" role="doc-endnote"> <p>Note that you <em>cannot</em> continue to use a reference to freed, zero-sized memory. This subtle distinction is called out in <a href="https://doc.rust-lang.org/std/ptr/index.html#safety">https://doc.rust-lang.org/std/ptr/index.html#safety</a>. <a href="#fnref:but-you-cannot-free-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-transmute" role="doc-endnote"> <p>Currently, a <code class="language-plaintext highlighter-rouge">transmute</code> must be used to perform this operation, but I see no reason way this would permit us to perform an illegal mutation without uttering <code class="language-plaintext highlighter-rouge">unsafe</code> a second time. In particular, <code class="language-plaintext highlighter-rouge">MaybeUninit::assume_init_read()</code>, which could be used to perform illegal copies, is an <code class="language-plaintext highlighter-rouge">unsafe</code> function. <a href="#fnref:requires-transmute" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:covariance" role="doc-endnote"> <p>A covariant type <code class="language-plaintext highlighter-rouge">Cov&lt;T&gt;</code> is once where, if <code class="language-plaintext highlighter-rouge">T</code> is a subtype of <code class="language-plaintext highlighter-rouge">U</code>, then <code class="language-plaintext highlighter-rouge">Cov&lt;T&gt;</code> is a subtype of <code class="language-plaintext highlighter-rouge">Cov&lt;U&gt;</code>. This isn’t particularly noticeable in Rust, where the only subtyping relationships are <code class="language-plaintext highlighter-rouge">&amp;'a T</code> subtypes <code class="language-plaintext highlighter-rouge">&amp;'b T</code> when <code class="language-plaintext highlighter-rouge">'a</code> outlives <code class="language-plaintext highlighter-rouge">'b</code>, but is nonetheless important for advanced type design. <a href="#fnref:covariance" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:but-thread-safety" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> does not provide synchronization; you still need locks to share it between threads. <a href="#fnref:but-thread-safety" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unsafe-lifetime" role="doc-endnote"> <p>I have previously proposed a sort of <code class="language-plaintext highlighter-rouge">'unsafe</code> or <code class="language-plaintext highlighter-rouge">'!</code> “lifetime” that is intended to be the lifetime of dangling references (a bit of an oxymoron). This would allow us to express this concept, but I need to flesh out the concept more. <a href="#fnref:unsafe-lifetime" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> </div> </div> </div></div> </body> <div class="sidebar show-if-mobile"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota </div> </div> </html>