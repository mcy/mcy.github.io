<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Understanding Assembly Part I: RISC-V &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Understanding Assembly Part I: RISC-V &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/assembly-1-3439bb311159a60ba38de998b4bde06241fc7f9a.png"> <meta property="og:title" content="Understanding Assembly Part I: RISC-V &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/assembly-1-3439bb311159a60ba38de998b4bde06241fc7f9a.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2021/11/29/assembly-1/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz/posts"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/posts"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2021-11-29 • 4503 words • 25 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2021/11/29/assembly-1/"> Understanding Assembly<br/> Part I: RISC-V<br/> </a></h1> </div> <div class="post"> <p>A <a href="https://en.wikipedia.org/wiki/Turing_tarpit">Turing tarpit</a> is a programming language that is Turing-complete but very painful to accomplish anything in. One particularly notable tarpit is <a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a>, which has a reputation among beginner and intermediate programmers as being unapproachable and only accessible to the most elite programmers hence the name, as Wikipedia puts it:</p> <blockquote> <p>The language’s name is a reference to the slang term <em>brainfuck</em>, which refers to things so complicated or unusual that they exceed the limits of one’s understanding.</p> </blockquote> <p>Assembly language, the “lowest-level” programming language on any computer, has a similar reputation: difficult, mysterious, and beyond understanding. A Turing tarpit that no programmer would want to have anything to do with.</p> <p>Although advanced programmers usually stop seeing assembly as mysterious and inaccessible, I feel like it is a valuable topic even for intermediate programmers, and one that can be made approachable and interesting.</p> <p>This series seeks to be that: assuming you have already been using a compiled language like Rust, C++, or Go, how <em>is</em> assembly relevant to you?</p> <blockquote> <p>If you’re here to just learn assembly and don’t really care for motivation, you can just <a href="#diving-in">skip ahead</a>.</p> <p>This series is about learning to <em>understand</em> assembly, not write it. I do occasionally write assembly for a living, but I’m not an <em>expert</em>, and I don’t particularly relish it. I do read a ton of assembly, though.</p> </blockquote> <h2 id="what-is-it-anyways"><a href="#what-is-it-anyways">What Is It, Anyways?</a></h2> <p>As every programmer knows, computers are very stupid. They are very good at following instructions and little else. In fact, the computer is <em>so</em> stupid, it can only process basic instructions serially<sup id="fnref:superscalar" role="doc-noteref"><a href="#fn:superscalar" class="footnote" rel="footnote">1</a></sup>, one by one. The instructions are very simple: “add these two values”, “copy this value from here to there”, “go run these instructions over here”.</p> <p>A computer processor implements these instructions as electronic circuits. At its most basic level, every computer looks like the following program:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">program_counter</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">program</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Instruction</span> <span class="n">next</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_counter</span><span class="p">];</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Figure out what you're supposed to be doing and do it.</span>
  <span class="p">}</span>
  <span class="n">program_counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The array <code class="language-plaintext highlighter-rouge">program</code> is a your program encoded as a sequence of these “machine instructions” in some kind of binary format. For example, in RISC-V programs, each instruction is a 32-bit integer. This binary format is called <em>machine code</em>.</p> <p>For example, when a RISC-V processor encounters the value <code class="language-plaintext highlighter-rouge">5407443</code> decoding circuitry decides that it means that it should take the value in the “register” <code class="language-plaintext highlighter-rouge">a0</code>, add <code class="language-plaintext highlighter-rouge">10</code> to it, and place the result in the register <code class="language-plaintext highlighter-rouge">a1</code>.</p> <blockquote> <h3 id="decoding-instructions"><a href="#decoding-instructions">Decoding Instructions</a></h3> <p><code class="language-plaintext highlighter-rouge">5407443</code> seems opaque, but when viewed as binary, we can see how the processor decodes it:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0b 000000000101 00101 000 00110 0010011
   \__________/ \___/ \_/ \___/ \_____/
    |           |     |   |     |
    imm         rs1   fn  rd    opcode
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">opcode</code> describes what sort of instruction this is, and what format it’s in; <code class="language-plaintext highlighter-rouge">0b0010011</code> means it’s an “immediate arithmetic” instruction, which uses the “I-type” format, given above. <code class="language-plaintext highlighter-rouge">fn</code> further specifies what the operation does; <code class="language-plaintext highlighter-rouge">0b000</code>, combined with the value of <code class="language-plaintext highlighter-rouge">opcode</code>, means this is an <em>addition</em> instruction.</p> <p><code class="language-plaintext highlighter-rouge">rs1</code> is the source: it gives the name of the source register, <code class="language-plaintext highlighter-rouge">a0</code>, given by it index, <code class="language-plaintext highlighter-rouge">0b00101</code>, i.e., <code class="language-plaintext highlighter-rouge">10</code>. Similarly, <code class="language-plaintext highlighter-rouge">rd</code> specifies the destination <code class="language-plaintext highlighter-rouge">a1</code> by its index <code class="language-plaintext highlighter-rouge">11</code>. Finally, <code class="language-plaintext highlighter-rouge">imm</code> is the value to add, <code class="language-plaintext highlighter-rouge">0b000000000101</code>, or <code class="language-plaintext highlighter-rouge">10</code>. The constant value appears immediately in the instruction itself, so it’s called an <em>immediate</em>.</p> </blockquote> <p>However, if you’re a human programming a computer, writing all of this by hand is… very 60s, and you might prefer to have a textual representation, so you can write this more simply as <code class="language-plaintext highlighter-rouge">addi a1, a0, 10</code>.</p> <p><code class="language-plaintext highlighter-rouge">addi a1, a0, 10</code> is a single line of assembly: it describes a <em>single</em> instruction in text form. Assembly language is “just” a textual representation of the program’s machine code. Your assembler can convert from text into machine instructions, and a <em>dis</em>assembler reverses the process.</p> <p>The simple nature of these instructions is what makes assembly a sort of Turing tarpit: you only get the most basic operations possible: you’re responsible for building <em>everything</em> else.</p> <h3 id="on-architectures"><a href="#on-architectures">On Architectures</a></h3> <p>There isn’t “an” assembly language. Every computer has a different instruction set architecture, or “ISA”; I use the terms “instruction set”, “architecture”, and “ISA” interchangeably. Each ISA has a corresponding assembly language that describes that ISA’s specific instructions, but they all generally have similar overall structure.</p> <p>I’m going to focus on three ISAs for ease of exposition, introduced in this order:</p> <ol> <li>RISC-V, a modern and fairly simple instruction set (specifically, the rv32gc variant). That’s Part I.</li> <li>x86_64, the instruction set of the device you’re reading this on (unless it’s a phone, an Apple M1 laptop, or something like a Nintendo Switch). That’s Part II.</li> <li>MOS 6502, a fairly ancient ISA still popular in very small microcontrollers. That’s Part III.</li> </ol> <p>We’re starting with RISC-V because it’s a particularly elegant ISA (having been developed for academic work originally), while still being representative of the operations most ISAs offer.</p> <p>In the future, I may dig into some other, more specialized ISAs.</p> <h2 id="but-why"><a href="#but-why">But <em>Why</em>?</a></h2> <p>It’s actually very rare to write actual assembly. Thanks to modern (relatively) languages like Rust, C++, and Go, and even things like Haskell and JavaScript, virtually no programmers need to write assembly anymore.</p> <p>But that’s only because it’s the leading language written by <em>computers themselves</em>. A compiler’s job is, fundamentally, to write the the assembly you would have had to write <em>for</em> you. To better understand what a compiler is doing for you, you need to be able to read its output.</p> <p>At this point, it may be worth looking at my <a href="https://mcyoung.xyz//2021/06/01/linker-script/#seriously-whats-a-linker">article on linkers</a> as a refresher on the C compilation model.</p> <p>For example, let’s suppose we have the very simple C program below.</p> <p>```c filename:square.c godbolt:c=rv32-cclang,o=-Oz #include <stdio.h></stdio.h></p> <p>int square_and_print(int x) { x *= x; printf(“%d\n”, x); return x; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Clang, my C compiler of choice, can turn it directly into a library via
`clang -c square.c`. `-c` asks the compiler to stop before the link step,
outputting the *object file* `square.o`. We can ask the compiler to stop even
sooner than that by writing `clang -S square.c`, which will output `square.s`,
the assembly file the compiler produced! For this example, and virtually all
others in this post, I'm using a RISC-V target:
`-target riscv32-unknown-elf -march=rv32gc`.

If you build with `-Oz` to make the code as small as possible (this makes it
easiest to see what's going on, too), you get something like this:

```riscv filename:square.s
        .text
        .file   "square.c"
        .globl  square_and_print
square_and_print:
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)
        mul     s0, a0, a0          // !
        lui     a0, %hi(.L.str)
        addi    a0, a0, %lo(.L.str)
        mv      a1, s0
        call    printf              // !
        mv      a0, s0
        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret

        .section        .rodata
.L.str:
        .asciz  "%d\n"
</code></pre></div></div> <p>There’s a lot going on! But pay attention to the two lines with a <code class="language-plaintext highlighter-rouge">// !</code>: the first is <code class="language-plaintext highlighter-rouge">mul s0, a0, a0</code>, which is the multiplication <code class="language-plaintext highlighter-rouge">x *= x;</code>. The second is <code class="language-plaintext highlighter-rouge">call printf</code>, which is our function call to <code class="language-plaintext highlighter-rouge">printf()</code>! I’ll explain what everything else means in short order.</p> <p>Writing assembly isn’t a crucial skill, but being able to read it is. It’s actually so useful, that a website exists for quickly generating the assembly output of a vast library of compilers: the <a href="https://godbolt.org/">Compiler Explorer</a>, frequently just called “godbolt” after its creator, Matt Godbolt. Being able to compare the output of different compilers can help understand what they do! Click on the <code class="language-plaintext highlighter-rouge">godbolt</code> button in the code fences to a godbolt for it.</p> <p>“Low-level” languages like C aren’t the only ones where you can inspect assembly output. Godbolt supports Go: for example, click the <code class="language-plaintext highlighter-rouge">godbolt</code> button below.</p> <p>```go godbolt: package sq</p> <p>import “fmt”</p> <p>func SquareAndPrint(x int) int { x *= x fmt.Printf(“%d\n”, x) return x }</p> <div id="big-example" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Hopefully this is motivation enough to jump into the language proper. It is very
useful to have a godbolt tab open to play around with examples!

## Diving In

So, let's say you *do* want to read assembly. How do we do that?

Let's revisit our `square.c` example above. This time, I've added comments
explaining what all the salient parts of the code do, including the *assembler
directives*, which are all of the form `.blah`. Note that the *actual* compiler
output includes way more directives that would get in the way of exposition.

There's a lot of terms below that I haven't defined yet. I'll break down what
this code does gradually, so feel free to refer back to it as necessary,
using [this handy-dandy link.](#big-example)

```riscv filename:square.s

        // This tells the assembler to place all code that
        // follows in the `.text` section, where executable
        // data goes.
        .text

        // This is just metadata that tools can use to figure out
        // how the executable was built.
        .file   "square.c"

        // This asks the assembler to mark `square_and_print`
        // as an externally linkable symbol. Other files that
        // refer to `square_and_print` will be able to find it
        // at link time.
        .globl  square_and_print

square_and_print: // This is a label, which gives this position
                  // in the executable a name that can be
                  // referenced. They're very similar to `goto`
                  // labels from C.
                  //
                  // We'll see more labels later on.


        // This is the function prologue, which "sets up" the
        // function: it allocates stack space and saves the
        // return address, along with other calling-convention
        // fussiness.
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)

        // This is our `x *= x;` from before! Notice that the
        // compiler rewrote this to `temp = x * x;` at some
        // point, since the destination register is `s0`.
        mul     s0, a0, a0

        // These two instructions load the address of a string
        // constant; this pattern is specific to RISC-V.
        lui     a0, %hi(.L.str)
        addi    a0, a0, %lo(.L.str)
        
        // This copies the multiplication result into `a1`.
        mv      a1, s0

        // Call to printf!
        call    printf

        // Move `s0` into `a0`, since it's the return value.
        mv      a0, s0

        // This is the function epilogue, which restores state
        // saved in the prologue and de-allocates the stack
        // frame.
        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        
        // We're done; return from the function!
        ret

        // This tells the assembler to place what follows in
        // the `.rodata` section, for read-only constants like
        // strings.
        .section        .rodata

.L.str: // Give our string constant a private name. By convention,
        // .L labels are "private" names emitted by the compiler.

        // Emit an ASCII string into `.rodata` with an extra null
        // terminator at the end: that's what the `z` stands for.
        .asciz  "%d\n"
</code></pre></div></div> <h3 id="the-core-syntax"><a href="#the-core-syntax">The Core Syntax</a></h3> <p>All assemblers are different, but the core syntax tends to be the same. There are three main kinds of syntax productions:</p> <ul> <li>Instructions, which consist of a <em>mnemonic</em> followed by some number of <em>operands</em>, such as <code class="language-plaintext highlighter-rouge">addi sp, sp -16</code> and <code class="language-plaintext highlighter-rouge">call printf</code> above. These are the text encoding of machine code.</li> <li>Labels, which consist of a symbol followed by a colon, like <code class="language-plaintext highlighter-rouge">square_and_print:</code> or <code class="language-plaintext highlighter-rouge">.L.str:</code>. These are used to let instruction operands refer to locations in the program.</li> <li>Directives, which vary wildly by assembler. GCC-style assembly like that above uses a <code class="language-plaintext highlighter-rouge">.directive arg, arg</code> syntax, as seen in <code class="language-plaintext highlighter-rouge">.text</code>, <code class="language-plaintext highlighter-rouge">.globl</code>, and <code class="language-plaintext highlighter-rouge">.asciz</code>. They control the behavior of the assembler in various ways.</li> </ul> <p>An assembler’s purpose is to read the <code class="language-plaintext highlighter-rouge">.s</code> file and serialize it as a binary <code class="language-plaintext highlighter-rouge">.o</code> file. It’s kind of like a compiler, but it does virtually no interesting work at all, beyond knowing how to encode instructions.</p> <p>Directives control how this serialization occurs (such as moving around the output cursor); instructions are emitted as-is, and labels refer to locations in the object file. Simple enough, right?</p> <h3 id="anatomy-of-an-instruction"><a href="#anatomy-of-an-instruction">Anatomy of an Instruction</a></h3> <p>Let’s look at the very first instruction in <code class="language-plaintext highlighter-rouge">square_and_print</code>:</p> <pre><code class="language-riscv">
        addi sp, sp, -16
        ---- --  --  ---
         |   |   |    |
        mnemonic |   immediate operand
             |  input operand
             |
            output operand
</code></pre> <p>The first token is called the <em>mnemonic</em>, which is a painfully terse abbreviation of what the instruction does. In this case, <code class="language-plaintext highlighter-rouge">addi</code> means “add with immediate”.</p> <p><code class="language-plaintext highlighter-rouge">sp</code> is a <em>register</em>. Registers are special variables wired directly into the processor that can be used as operands in instructions. The degree to which only registers are permitted as operands varies by architecture; RISC-V only allows registers, but x86, as we’ll see, does not. Registers come in many flavors, but <code class="language-plaintext highlighter-rouge">sp</code> is a GPR, or “general purpose register”; it holds a machine word-sized integer, which in the case of 32-bit RISC-V is… 32-bit<sup id="fnref:whats-a-word" role="doc-noteref"><a href="#fn:whats-a-word" class="footnote" rel="footnote">2</a></sup>.</p> <blockquote> <h4 id="risc-v-registers"><a href="#risc-v-registers">RISC-V Registers</a></h4> <p>One of my absolute favorite parts of RISC-V is how it names its registers. It has 32 GPRs named <code class="language-plaintext highlighter-rouge">x0</code> through <code class="language-plaintext highlighter-rouge">x31</code>. However, these registers have so-called “ABI names” that specify the <em>role</em> of each register in the ABI.</p> <p>The usefulness of these names will be much more apparent when we discuss <a href="#the-calling-convention">the calling convention</a>, so feel free to come back to this later.</p> <p><code class="language-plaintext highlighter-rouge">x0</code> is called <code class="language-plaintext highlighter-rouge">zero</code>, because of its special property: writes to it are ignored, and reads always produce zero. This is handy for encoding certain common operations: for example, it can be used to quickly get a constant value= into a register: <code class="language-plaintext highlighter-rouge">addi rd, zero, 42</code>.</p> <p><code class="language-plaintext highlighter-rouge">x1</code>, <code class="language-plaintext highlighter-rouge">x2</code>, <code class="language-plaintext highlighter-rouge">x3</code>, and <code class="language-plaintext highlighter-rouge">x4</code> have special roles and generally aren’t used for general computation. The first two are the link register <code class="language-plaintext highlighter-rouge">ra</code>, which holds the <u>r</u>eturn <u>a</u>ddress, and <code class="language-plaintext highlighter-rouge">sp</code>, the <u>s</u>tack <u>p</u>ointer.</p> <p>The latter two are <code class="language-plaintext highlighter-rouge">gp</code> and <code class="language-plaintext highlighter-rouge">tp</code>; the <u>g</u>lobal <u>p</u>pointer and the <u>t</u>hread <u>p</u>pointer; their roles are somewhat complicated, so we won’t discuss them in this post.</p> <p>The remaining registers belong to one of three categories: <em>argument</em> registers, <em>saved</em> registers, and <em>temporary</em> registers, named so for their role in calling a function (as described <a href="#the-calling-convention">below</a>).</p> <p>The argument registers are <code class="language-plaintext highlighter-rouge">x10</code> through <code class="language-plaintext highlighter-rouge">x17</code>, and use the names <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a7</code>. The saved registers are <code class="language-plaintext highlighter-rouge">x8</code>, <code class="language-plaintext highlighter-rouge">x9</code>, and <code class="language-plaintext highlighter-rouge">x18</code> through <code class="language-plaintext highlighter-rouge">x27</code>, called <code class="language-plaintext highlighter-rouge">s0</code>, through <code class="language-plaintext highlighter-rouge">s11</code>. The temporary registers are <code class="language-plaintext highlighter-rouge">x5</code> through <code class="language-plaintext highlighter-rouge">x7</code> and <code class="language-plaintext highlighter-rouge">x28</code> through <code class="language-plaintext highlighter-rouge">x31</code>, called <code class="language-plaintext highlighter-rouge">t0</code> through <code class="language-plaintext highlighter-rouge">t6</code>.</p> <p>As a matter of personal preference, you may notice me reaching for argument registers for most examples.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">-16</code> is an <em>immediate</em>, which is a literal value that is encoded directly into the instruction. The encoding of <code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code> will include the binary representation of <code class="language-plaintext highlighter-rouge">-16</code> (in the case of RISC-V, as a 12-bit integer). [The decoding example above]{#decoding-instructions} shows how immediates are literally encoded <em>immediately</em> in the instruction.</p> <p>Immediates allow for small but fixed integer arguments to be encoded with high locality to the instruction, which is good for code size and performance.</p> <p>The first operand in RISC-V is (almost) always the output. <code class="language-plaintext highlighter-rouge">addi, rd, rs, imm</code> should be read as <code class="language-plaintext highlighter-rouge">rd = rs + imm</code>. Virtually all assembler syntax follows this convention, which is called the <a href="https://en.wikipedia.org/wiki/Three-address_code">three-address code</a>.</p> <p>Other kinds of operands exist: for example, <code class="language-plaintext highlighter-rouge">call printf</code> refers to the <em>symbol</em> <code class="language-plaintext highlighter-rouge">printf</code>. The assembler, which doesn’t actually know where <code class="language-plaintext highlighter-rouge">printf</code> is, will emit a small note in the object file that tells the linker to find <code class="language-plaintext highlighter-rouge">printf</code> and splat it into the assembly according to some instructions in the note. These notes are called <em>relocations</em>.</p> <p>The instructions <code class="language-plaintext highlighter-rouge">lui a0, %hi(.L.str)</code> and <code class="language-plaintext highlighter-rouge">addi a0, a0, %lo(.L.str)</code> use the <code class="language-plaintext highlighter-rouge">%lo</code> and <code class="language-plaintext highlighter-rouge">%hi</code> operand types, which are specific to RISC-V; they load the low 12 bits and high 20 bits of a symbol’s address into the immediate operand. This is a RISC-V-specific pattern for loading an address into a register, which most assemblers provide with the <em>pseudoinstruction</em> <code class="language-plaintext highlighter-rouge">la a0, .L.str</code> (where <code class="language-plaintext highlighter-rouge">la</code> stands for “load address”).</p> <p>Most architectures have their own funny architecture-specific operand types to deal with the architecture’s idiosyncrasy.</p> <h3 id="types-of-instructions"><a href="#types-of-instructions">Types of Instructions</a></h3> <p>Available instructions tend to be motivated by providing one of three classes of functionality:</p> <ol> <li>A Turing-complete <a href="https://en.wikipedia.org/wiki/Register_machine">register machine</a> execution environment. This lends to the Turing tarpit nature of assembly: only the absolute minimum in terms of control flow and memory access is provided.</li> <li>Efficient silicon implementation of common operations on bit strings and integers, ranging from arithmetic to cryptographic algorithms.</li> <li>Building a secure operating system, hosting virtual machines, and actuating hardware external to the processor, like a monitor, a keyboard, or speakers.</li> </ol> <p>Instructions can be broadly classified into four categories: arithmetic, memory, control flow, and “everything else”. In the last thirty years, the bar for general-purpose architectures is usually “this is enough to implement a C runtime.”</p> <h4 id="arithmetic-instructions"><a href="#arithmetic-instructions">Arithmetic Instructions</a></h4> <p>Arithmetic makes up the bulk of the instruction set. This always includes addition, subtraction, and bitwise and, or, and xor, as well as unary not and negation.</p> <p>In RISC-V, these come in two variants: a three-register version and a two-register, one immediate version. For example, <code class="language-plaintext highlighter-rouge">add a0, a1, a2</code> is the three-register version of addition, while <code class="language-plaintext highlighter-rouge">addi a0, a1, 42</code> is the immediate version. There isn’t a <code class="language-plaintext highlighter-rouge">subi</code> though, since you can just use negative immediates with <code class="language-plaintext highlighter-rouge">addi</code>.</p> <p><code class="language-plaintext highlighter-rouge">not</code> and <code class="language-plaintext highlighter-rouge">neg</code> are not actual instructions in RISC-V, but pseudoinstructions: <code class="language-plaintext highlighter-rouge">not a0, a1</code> encodes as <code class="language-plaintext highlighter-rouge">xori a0, a1, -1</code>, while <code class="language-plaintext highlighter-rouge">neg a0, a1</code> becomes <code class="language-plaintext highlighter-rouge">sub a0, zero, a1</code>.</p> <p>Most instruction sets also have bit shifts, usually in three flavors: left shifts, right shifts, and <em>arithmetic</em> right shifts; arithmetic right shift is defined such that it behaves like division by powers of two on signed integers. RISC-V’s names for these instructions are <code class="language-plaintext highlighter-rouge">sll</code>, <code class="language-plaintext highlighter-rouge">srl</code>, and <code class="language-plaintext highlighter-rouge">sra</code>.</p> <p>Multiplication and division are somewhat rarer, because they are expensive to implement in silicon; smaller devices don’t have them<sup id="fnref:mul-polyfill" role="doc-noteref"><a href="#fn:mul-polyfill" class="footnote" rel="footnote">3</a></sup>. Division in particular is very complex to implement in silicon. Instruction sets usually have different behavior around division by zero: some architectures will fault, similar to a memory error, while some, like RISC-V, produce a well-defined trap value.</p> <p>There is usually also a “copy” instruction that moves the value of one register to another, which is kind of like a trivial arithmetic instruction. RISC-V calls this <code class="language-plaintext highlighter-rouge">mv a0, a1</code>, but it’s just a pseudoinstruction that expands to <code class="language-plaintext highlighter-rouge">addi a0, a1, 0</code>.</p> <p>Some architectures also offer more exotic arithmetic. This is just a sampler of what’s sometimes available:</p> <ul> <li>Bit rotation, which is like a shift but bits that get shifted off end up at the other end of the integer. This is useful for a vast array of numeric algorithms, including ARX ciphers like <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha20</a>.</li> <li>Byte reversal, which can be used for changing the endianness of an integer; bit reversal is analogous.</li> <li>Bit extraction, which can be used to form new integers out of bitfields of another.</li> <li>Carry-less multiplication, which is like long multiplication but you don’t bother to carry anything when you add intermediates. This is used to implement <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois/Counter mode encryption</a>.</li> <li>Fused instructions, like <code class="language-plaintext highlighter-rouge">xnor</code> and <code class="language-plaintext highlighter-rouge">nand</code>.</li> <li>Floating point instructions, usually implementing the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> standard.</li> </ul> <p>There is also a special kind of arithmetic instruction called a <em>vector instruction</em>, but I’ll leave those for another time.</p> <h4 id="memory-instructions"><a href="#memory-instructions">Memory Instructions</a></h4> <p>Load instructions fetch memory from RAM into registers, while store instructions write it back. These instructions are what we use to implement pointers.</p> <p>They come in all sorts of different sizes: RISC-V has <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">lh</code>, and <code class="language-plaintext highlighter-rouge">lb</code> for loading 32-, 16-, and 8-bit values from a location; <code class="language-plaintext highlighter-rouge">sw</code>, <code class="language-plaintext highlighter-rouge">sh</code>, and <code class="language-plaintext highlighter-rouge">sb</code> are their store counterparts. 64-bit RISC-V also provides <code class="language-plaintext highlighter-rouge">ld</code> and <code class="language-plaintext highlighter-rouge">sd</code> for 64-bit loads and stores.</p> <p>Load/store instructions frequently take an offset for indexing into memory. <code class="language-plaintext highlighter-rouge">lw a1, 4(a0)</code><sup id="fnref:offset-syntax" role="doc-noteref"><a href="#fn:offset-syntax" class="footnote" rel="footnote">4</a></sup> is effectively <code class="language-plaintext highlighter-rouge">a1 = a0[4]</code>, treating <code class="language-plaintext highlighter-rouge">a0</code> like a pointer.</p> <p>These instructions frequently have an <em>alignment</em> constraint: the pointer value must (or, at least, should) be divisible by the number of bytes being loaded. RISC-V, for example, mandates that <code class="language-plaintext highlighter-rouge">lw</code> only be used on pointers divisible by 4. This constraint simplifies the microarchitecture; even on architectures that don’t mandate it, aligned loads and stores are typically far faster.</p> <p>This category also includes instructions necessary for implementing atomics, such as <code class="language-plaintext highlighter-rouge">lock cmpxchg</code> on x86 and <code class="language-plaintext highlighter-rouge">lr</code>/<code class="language-plaintext highlighter-rouge">sc</code> on RISC-V. Atomics are fundamentally about changing the semantics of reading and writing from RAM, and thus require special processor support.</p> <p>Some architectures, like x86, 65816, and very recently, ARM, provide instructions that implement <code class="language-plaintext highlighter-rouge">memcpy</code> and its ilk in hardware: in x86, for example, this is called <code class="language-plaintext highlighter-rouge">rep movsb</code>.</p> <h4 id="control-flow-instructions"><a href="#control-flow-instructions">Control Flow Instructions</a></h4> <p>Control flow is the secret ingredient that turns our glorified calculator into a Turing tarpit: they allow changing the flow of program execution based on its current state.</p> <p><em>Unconditional jumps</em> implement <code class="language-plaintext highlighter-rouge">goto</code>: given some <code class="language-plaintext highlighter-rouge">label</code>, the <code class="language-plaintext highlighter-rouge">j label</code> instruction jumps directly to it. <code class="language-plaintext highlighter-rouge">j</code> can be thought of as writing to a special <code class="language-plaintext highlighter-rouge">pc</code> register that holds the program counter. RISC-V also provides a <em>dynamic</em> jump, <code class="language-plaintext highlighter-rouge">jr</code>, which will jump to the address in a register. Function calls and returns are a special kind of unconditional jump.</p> <p><em>Conditional jumps</em>, often called <em>branches</em>, implement <code class="language-plaintext highlighter-rouge">if</code>. <code class="language-plaintext highlighter-rouge">beq a0, a1, label</code> will jump to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">a0</code> and <code class="language-plaintext highlighter-rouge">a1</code> contain the same value. RISC-V provides branch instructions for all kinds of comparisons, like <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">blt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>.</p> <p>Conditional and unconditional jumps can be used together to build loops, much like we could in C using <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">goto</code>.</p> <p>For example, to zero a region of memory:</p> <pre><code class="language-riscv">
        // Assume a0 is the start of the region, and a1 the
        // number of bytes to zero.

        // Set a1 to the end of the region.
        addi a1, a0, a1
loop_start:
        // If a0 == a1, we're done!
        beq a0, a1, loop_done

        // Store a zero byte to `a0` and advance the pointer.
        sb zero, 0(a0)
        addi a0, a0, 1

        // Take it from the top!
        j loop_start
loop_done:

</code></pre> <h4 id="miscellaneous-instructions"><a href="#miscellaneous-instructions">Miscellaneous Instructions</a></h4> <p>“Everything else” is, well… everything else.</p> <p>No-op instructions do nothing: <code class="language-plaintext highlighter-rouge">nop</code>’s only purpose is to take up space in the instruction stream. No-op instructions can be used to pad space in the instruction stream, provide space for the linker to fix things up later, or implement <a href="https://en.wikipedia.org/wiki/NOP_slide"><code class="language-plaintext highlighter-rouge">nop</code> sleds</a>.</p> <p>Instructions for poking processor state, like <code class="language-plaintext highlighter-rouge">csrrw</code> in RISC-V and <code class="language-plaintext highlighter-rouge">wrmsr</code> in <code class="language-plaintext highlighter-rouge">x86</code> also belong in this category, as do “hinting” instructions like memory prefetches.</p> <p>There are also instructions for special control flow: <code class="language-plaintext highlighter-rouge">ecall</code> is RISC-V’s “syscall” instruction, which “traps” to the kernel for it to do something; other architectures have similar instructions.</p> <p>Breakpoint instructions and <a href="https://www.felixcloutier.com/x86/lfence">“fence” instructions</a> belong here, too.</p> <h2 id="the-calling-convention"><a href="#the-calling-convention">The Calling Convention</a></h2> <p>Functions are the core abstraction of all of programming. Assembly is no different: we have functions there, too!</p> <p>Like in any language, functions are <em>passed</em> a list of arguments, perform some work, and <em>return</em> a value. For example, in C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">identity</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="n">identity</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1">// Returns 5.</span>
</code></pre></div></div> <p>Unfortunately, there isn’t anything like function call syntax in assembly. As with everything else, we need do it instruction by instruction. All we <em>do</em> get in most architectures is a <code class="language-plaintext highlighter-rouge">call</code> instruction, which sets up a return address somewhere, and a <code class="language-plaintext highlighter-rouge">ret</code> instruction, which uses the return address to jump to where the function was called.</p> <p>We need some way to pass arguments, return a computed value, and maintain a call stack, so that each function’s return address is kept intact for its <code class="language-plaintext highlighter-rouge">ret</code> instruction to consume. We also need this to be universal: if I pull in a library, I should be able to call its functions.</p> <p>This mechanism is called the <em>calling convention</em> of the platform’s ABI. It’s a convention, because all libraries must respect it in their exposed API for code to work correctly at runtime.</p> <h3 id="a-function-call-in-slow-mo"><a href="#a-function-call-in-slow-mo">A Function Call in Slow-Mo</a></h3> <p>At the instruction level, function calls look something like this:</p> <ol> <li> <p>Pre-call setup. The caller sets up the function call arguments by placing them in the appointed locations for arguments. These are usually either registers or locations on the stack. a. The caller also saves the <em>caller-saved registers</em> to the stack.</p> </li> <li> <p>Jump to the function. The caller executes a <code class="language-plaintext highlighter-rouge">call</code> instruction (or whatever the function call instruction might be called – virtually all architectures have one). This sets the program counter to the first instruction of the callee.</p> </li> <li> <p>Function prologue. The callee does some setup before executing its code. a. The callee reserves space on the stack in an architecture-dependent manner. b. The callee saves the <em>callee-saved registers</em> to this stack space.</p> </li> <li> <p>Function body. The actual code of the function runs now! This part of the function needs to make sure the return value winds up wherever the <em>return slot</em> for the function is.</p> </li> <li> <p>Function epilogue. The callee undoes whatever work it did in the prologue, such as restoring saved registers, and executes a <code class="language-plaintext highlighter-rouge">ret</code> (or equivalent) instruction to return.</p> </li> <li> <p>Post-call cleanup. The caller is now executing again; it can unspill any saved state that it needs immediately after the function call, and can retrieve the return value from the return slot.</p> <p>In some ABIs, such as C++’s on Linux, this is where the destructors of the arguments get run. (Rust, and C++ on Windows, have <em>callee</em>-destroyed arguments instead.)</p> </li> </ol> <p>When people say that function calls have overhead, this is what they mean. Not only does the <code class="language-plaintext highlighter-rouge">call</code> instruction cause the processor to slam the breaks on its pipeline, causing all kinds of work to get thrown away, but state needs to be delicately saved and restored across the function boundary to maintain the illusion of a callstack.</p> <p>Small functions which don’t need to use as many registers can avoid some of the setup and cleanup, and <em>leaf functions</em> which don’t call any other functions can avoid basically all of it!</p> <p>Almost all registers in RISC-V are caller-saved, except for <code class="language-plaintext highlighter-rouge">ra</code> and the “saved” registers <code class="language-plaintext highlighter-rouge">s0</code> and <code class="language-plaintext highlighter-rouge">s11</code>.</p> <p>Callee-saved registers are convenient, because they won’t be wiped out by function calls. We can actually see the call to <code class="language-plaintext highlighter-rouge">printf</code> use this: even though the compiler could have emitted <code class="language-plaintext highlighter-rouge">mul a1, a0, a0</code> and avoided the <code class="language-plaintext highlighter-rouge">mv</code>, this is actually less optimal. We need to keep the value around to return, and <code class="language-plaintext highlighter-rouge">a1</code> is caller-saved, so we would have had to spill <code class="language-plaintext highlighter-rouge">a1</code> before calling <code class="language-plaintext highlighter-rouge">printf</code>, regardless of whether <code class="language-plaintext highlighter-rouge">printf</code> overwrites <code class="language-plaintext highlighter-rouge">a1</code> or not. We would then have to unspill it into <code class="language-plaintext highlighter-rouge">a0</code> before <code class="language-plaintext highlighter-rouge">ret</code>. This costs us a hit to RAM. However, by emitting <code class="language-plaintext highlighter-rouge">mul s0, a0, a0; mv a1, s0</code>, we speculatively avoid the spill: if <code class="language-plaintext highlighter-rouge">printf</code> is compiled such that it never touches <code class="language-plaintext highlighter-rouge">s0</code>, the value never leaves registers at all!</p> <h3 id="caller-side"><a href="#caller-side">Caller-Side</a></h3> <p>We can see steps 1 and 2 in the call to <code class="language-plaintext highlighter-rouge">printf</code>:</p> <pre><code class="language-riscv">
        lui     a0, %hi(.L.str)
        addi    a0, a0, %lo(.L.str)
        mv      a1, s0
        call    printf
</code></pre> <p>Arguments in the usual<sup id="fnref:custom-abis" role="doc-noteref"><a href="#fn:custom-abis" class="footnote" rel="footnote">5</a></sup> RISC-V calling convention, word-sized arguments are passed in the <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a7</code> registers, falling back to passing on the stack if they run out of space. If the argument is too big to fit in a register, it gets passed by reference instead. Arguments that fit into two registers can be split across registers.</p> <p>We can see this in action <a href="#big-example">above</a>. The first argument, a string, is passed by pointer in <code class="language-plaintext highlighter-rouge">a0</code>; <code class="language-plaintext highlighter-rouge">lui</code> and <code class="language-plaintext highlighter-rouge">addi</code> do the work of actually putting that pointer into <code class="language-plaintext highlighter-rouge">a0</code>. The second argument <code class="language-plaintext highlighter-rouge">x</code> is passed in <code class="language-plaintext highlighter-rouge">a1</code>, copied from <code class="language-plaintext highlighter-rouge">s0</code> where it landed from the earlier <code class="language-plaintext highlighter-rouge">mul</code> instruction.</p> <p>Complex function signatures require much more<sup id="fnref:all-args" role="doc-noteref"><a href="#fn:all-args" class="footnote" rel="footnote">6</a></sup> work to set up.</p> <p>#include <stdio.h> #include <stdint.h> #include <stdnoreturn.h></stdnoreturn.h></stdint.h></stdio.h></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Pair {
  uint32_t x, y;
};
struct Triple {
  uint32_t x, y, z;
};
struct Packed {
  uint8_t x, y, z;
};

// `noreturn` obviates the
// {pro,epi}logue in `call_it`.
noreturn void all_the_args(
  uint32_t a0,
  uint64_t a1a2,
  struct Pair a3a4,
  struct Triple a5_by_ref,
  uint16_t a6,
  struct Packed a7,
  uint32_t on_the_stack,
  struct Triple stack_by_ref
);

void call_it(void) {
  struct Pair u = {7, 9};
  struct Triple v = {11, 13, 15};
  struct Packed w = {14, 16, 18};
  all_the_args(
    42, -42,  u, v,
     5,   w, 21, v
  );
}
```

```riscv
call_it:
  // Reserve stack space.
  addi    sp, sp, -48

  // Get `&amp;call_it.v` into `a3`.
  lui     a3, %hi(call_it.v)
  addi    a3, a3, %lo(call_it.v)

  // Copy contents of `*a3`
  // into `a0...a2`.
  lw      a0, 0(a3)
  lw      a1, 4(a3)
  lw      a2, 8(a3)

  // Create two copies of `v`
  // on the stack to pass by
  // reference.

  // This is `a5_by_ref`.
  sw      a2, 40(sp)
  sw      a1, 36(sp)
  sw      a0, 32(sp)

  // This is `stack_by_ref`.
  sw      a2, 24(sp)
  sw      a2, 20(sp)
  sw      a0, 16(sp)
  
  // Load the argument regs.
  addi    a0, zero, 42
  addi    a1, zero, -42
  addi    a2, zero, -1
  addi    a3, zero, 7
  addi    a4, zero, 9
  // A pointer to `a5_by_ref`!
  addi    a5, sp, 32
  addi    a6, zero, 5
  // Note that `a7` is three
  // packed bytes!
  lui     a0, 289
  addi    a7, a0, 14

  // Store `21` on the top of
  // the stack (our "a8")
  addi    t0, zero, 21
  sw      t0, 0(sp)

  // Store a pointer to
  // `stack_by_ref` on the 
  // second spot from the
  // stack top (our "a9")
  addi    t0, sp, 16
  sw      t0, 4(sp)

  // Call it!
  call    all_the_args

call_it.v:
  // The constant `{11, 13, 15}`.
  .word   11
  .word   13
  .word   15
```

&lt;/div&gt;
</code></pre></div></div> <p>Once we’re done getting arguments into place, we <code class="language-plaintext highlighter-rouge">call</code>, which switches execution over to <code class="language-plaintext highlighter-rouge">printf</code>’s first instruction. In addition, it stores the return address, specifically, the address of the instruction immediately after the <code class="language-plaintext highlighter-rouge">call</code>, into an architecture-specific location. On RISC-V, this is the special register <code class="language-plaintext highlighter-rouge">ra</code>.</p> <h3 id="callee-side"><a href="#callee-side">Callee-Side</a></h3> <p>Meanwhile, steps 3 and 4 occur in <code class="language-plaintext highlighter-rouge">square_and_print</code>’s prologue/epilogue itself:</p> <pre><code class="language-riscv">
square_and_print: 
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)

        // ...

        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret
</code></pre> <p><code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code>, which we stared at so hard above, grows the stack by 16 bytes. <code class="language-plaintext highlighter-rouge">sp</code> holds the <em>stack pointer</em>, which points to the top of the stack at all times. The stack grows downwards (as in most architectures!) and must be aligned to 16-byte boundaries across function calls: even though <code class="language-plaintext highlighter-rouge">square_and_print</code> only uses eight of those bytes, the full 16 bytes must be allocated.</p> <p>The two <code class="language-plaintext highlighter-rouge">sw</code> instructions that follow store (or “spill”) the callee-saved registers <code class="language-plaintext highlighter-rouge">ra</code> and <code class="language-plaintext highlighter-rouge">s0</code> to the stack. Note that <code class="language-plaintext highlighter-rouge">s1</code> through <code class="language-plaintext highlighter-rouge">s11</code> are <em>not</em> spilled, since <code class="language-plaintext highlighter-rouge">square_and_print</code> doesn’t use them!</p> <p>Th this point, the function does its thing, whatever that means. This includes putting the return value in the return slot, which, for a function that returns an <code class="language-plaintext highlighter-rouge">int</code>, is in <code class="language-plaintext highlighter-rouge">a0</code>. In general, the return slot is passed back to the caller much like arguments are: if it fits in registers, <code class="language-plaintext highlighter-rouge">a0</code> and <code class="language-plaintext highlighter-rouge">a1</code> are used; otherwise, the caller allocates space for it and passes a pointer to the return slot as a hidden argument (in e.g. <code class="language-plaintext highlighter-rouge">a0</code>)<sup id="fnref:return-slot" role="doc-noteref"><a href="#fn:return-slot" class="footnote" rel="footnote">7</a></sup>.</p> <p>The epilogue inverts all operations of the prologue in reverse, unspilling registers and shrinking the stack, followed by <code class="language-plaintext highlighter-rouge">ret</code>. On RISC-V, all <code class="language-plaintext highlighter-rouge">ret</code> does is jump to the location referred to by the <code class="language-plaintext highlighter-rouge">ra</code> register.</p> <p>Of course, all this work is only necessary to maintain the illusion of a callstack; if <code class="language-plaintext highlighter-rouge">square_and_print</code> were a leaf function, it would not need to spill anything at all! This results in an almost trivial function:</p> <div class="code-multicol"> <p>```c godbolt:c=rv32-cclang,o=-Oz int square(int x) { return x * x; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```riscv
// `x` is already in a0, and the
// return value needs to wind up
// in a0. EZ!
square:
        mul a0, a0, a0
        ret
</code></pre></div> </div> </div> <p>Because leaf functions won’t call other functions, they won’t need to save the caller-saved <code class="language-plaintext highlighter-rouge">tX</code> registers, so they can freely use them instead of the <code class="language-plaintext highlighter-rouge">sX</code> registers.</p> <h2 id="the-end-for-now"><a href="#the-end-for-now">The End, for Now</a></h2> <p>Phew! We’re around six thousand words in, so let’s checkpoint what we’ve learned:</p> <ol> <li> <p>Computers are stupid, but can at least follow <em>extremely</em> basic instructions, which are encoded as binary.</p> </li> <li> <p>Assembly language is human-readable version of these basic instructions for a particular computer.</p> </li> <li> <p>Assembly language programs consist of <em>instructions</em>, <em>labels</em>, and <em>directives</em>.</p> </li> <li> <p>Each instruction is a <em>mnemonic</em> followed by zero or more <em>operands</em>.</p> </li> <li> <p><em>Registers</em> hold values the machine is currently operating on.</p> </li> <li> <p>Instructions can be broadly categorized as <em>arithmetic</em>, <em>memory</em>, <em>control flow</em>, and “miscellaneous” (plus <em>vector</em> and <em>float</em> instructions, for another time).</p> </li> <li> <p>The <em>calling convention</em> describes the low-level interface of a general function, consisting of some pre-call setup, and a prologue and epilogue in each function.</p> </li> </ol> <p>That’s all for now. RISC-V is a powerful but reasonably simple ISA. Next time, we’ll dive into the much older, much larger, and much more complex Intel x86.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:superscalar" role="doc-endnote"> <p>This is a hilarious lie that is beyond the scope of this post. See, for example, <a href="https://en.wikipedia.org/wiki/Superscalar_processor">https://en.wikipedia.org/wiki/Superscalar_processor</a>. <a href="#fnref:superscalar" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:whats-a-word" role="doc-endnote"> <p>What’s a machine word, exactly? It really depends on context. Most popular architectures has a straight-forward definition: the size of a GPR <em>or</em> the size of a pointer, which are the same.</p> <p>This is not true of all architectures, so beware. <a href="#fnref:whats-a-word" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:mul-polyfill" role="doc-endnote"> <p>Thankfully, these can be polyfilled using the previous ubiquitous instructions. Hacker’s Delight contains all of the relevant algorithms, so I won’t reproduce them here. The division polyfills are particularly interesting. <a href="#fnref:mul-polyfill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:offset-syntax" role="doc-endnote"> <p>It’s a bit interesting that we don’t write <code class="language-plaintext highlighter-rouge">lw a1, a0[4]</code> in imitation of array syntax. This specific corner of the notation is shockingly diverse across assemblers: in ARM, we write <code class="language-plaintext highlighter-rouge">ldr r0, [r1, #offset]</code>; in x86, <code class="language-plaintext highlighter-rouge">mov rax, [rdx + offset]</code>, or <code class="language-plaintext highlighter-rouge">movq offset(%rdx), %rax</code> for AT&amp;T-flavored assemblers (which is surprisingly similar to the RISC-V syntax!); in 6502, <code class="language-plaintext highlighter-rouge">lda ($1234, X)</code>. <a href="#fnref:offset-syntax" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:custom-abis" role="doc-endnote"> <p>The calling convention isn’t actually determined by the architecture in most cases; that’s why it’s called a <em>convention</em>. The convention on x86 actually differs on Windows and Linux, and is usually also language-dependent; C’s calling convention is usually documented, but C++, Rust, and Go invent their own to handle language-specific fussiness.</p> <p>Of course, if you’re writing assembly, you can do whatever you want (though the silicon may be optimized for a particular recommended calling convention).</p> <p>RISC-V defines a recommended calling convention for ELF-based targets: <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">https://github.com/riscv-non-isa/riscv-elf-psabi-doc</a>. <a href="#fnref:custom-abis" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:all-args" role="doc-endnote"> <p>The following listing shows how all kinds of different arguments are passed. The output isn’t quite what Clang emits, since I’ve cleaned it up for clarity.</p> <div class="code-multicol" style="height: 860px;"> <p>```c godbolt:c=rv32-cclang,o=-Oz</p> </div> <p><a href="#fnref:all-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:return-slot" role="doc-endnote"> <p>LLVM occasionally does somewhat clueless things around this corner of some ABIs. Given</p> <p>```c godbolt:c=rv32-cclang,o=-Oz typedef struct { char p[100]; } X;</p> <p>X make_big(int x) { return (X) {x}; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
we get the following from Clang:

```riscv
// NOTE: Return slot passed in `a0`, `x` passed in `a1`.
make_big:
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)
        sw      s1, 4(sp)
        mv      s0, a1
        mv      s1, a0
        addi    a0, a0, 1
        addi    a2, zero, 99
        mv      a1, zero
        call    memset
        sb      s0, 0(s1)
        lw      s1, 4(sp)
        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret
</code></pre></div> </div> <p>Note that <code class="language-plaintext highlighter-rouge">sb s0, 0(s1)</code> stores the input value <code class="language-plaintext highlighter-rouge">x</code> into the first element of the big array <em>after</em> calling memset. If we move the store to before, we can avoid much silliness, including some unnecessary spills:</p> <pre><code class="language-riscv">make_big:
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sb      a1, 0(a0)
        addi    a0, a0, 1
        mv      a1, zero
        addi    a2, zero, 99
        call    memset
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret
</code></pre> <p><a href="#fnref:return-slot" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2021-11-29 • 4503 words • 25 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2021/11/29/assembly-1/"> Understanding Assembly<br/> Part I: RISC-V<br/> </a></h1> </div> <div class="post"> <p>A <a href="https://en.wikipedia.org/wiki/Turing_tarpit">Turing tarpit</a> is a programming language that is Turing-complete but very painful to accomplish anything in. One particularly notable tarpit is <a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a>, which has a reputation among beginner and intermediate programmers as being unapproachable and only accessible to the most elite programmers hence the name, as Wikipedia puts it:</p> <blockquote> <p>The language’s name is a reference to the slang term <em>brainfuck</em>, which refers to things so complicated or unusual that they exceed the limits of one’s understanding.</p> </blockquote> <p>Assembly language, the “lowest-level” programming language on any computer, has a similar reputation: difficult, mysterious, and beyond understanding. A Turing tarpit that no programmer would want to have anything to do with.</p> <p>Although advanced programmers usually stop seeing assembly as mysterious and inaccessible, I feel like it is a valuable topic even for intermediate programmers, and one that can be made approachable and interesting.</p> <p>This series seeks to be that: assuming you have already been using a compiled language like Rust, C++, or Go, how <em>is</em> assembly relevant to you?</p> <blockquote> <p>If you’re here to just learn assembly and don’t really care for motivation, you can just <a href="#diving-in">skip ahead</a>.</p> <p>This series is about learning to <em>understand</em> assembly, not write it. I do occasionally write assembly for a living, but I’m not an <em>expert</em>, and I don’t particularly relish it. I do read a ton of assembly, though.</p> </blockquote> <h2 id="what-is-it-anyways"><a href="#what-is-it-anyways">What Is It, Anyways?</a></h2> <p>As every programmer knows, computers are very stupid. They are very good at following instructions and little else. In fact, the computer is <em>so</em> stupid, it can only process basic instructions serially<sup id="fnref:superscalar" role="doc-noteref"><a href="#fn:superscalar" class="footnote" rel="footnote">1</a></sup>, one by one. The instructions are very simple: “add these two values”, “copy this value from here to there”, “go run these instructions over here”.</p> <p>A computer processor implements these instructions as electronic circuits. At its most basic level, every computer looks like the following program:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">program_counter</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">program</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Instruction</span> <span class="n">next</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_counter</span><span class="p">];</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Figure out what you're supposed to be doing and do it.</span>
  <span class="p">}</span>
  <span class="n">program_counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The array <code class="language-plaintext highlighter-rouge">program</code> is a your program encoded as a sequence of these “machine instructions” in some kind of binary format. For example, in RISC-V programs, each instruction is a 32-bit integer. This binary format is called <em>machine code</em>.</p> <p>For example, when a RISC-V processor encounters the value <code class="language-plaintext highlighter-rouge">5407443</code> decoding circuitry decides that it means that it should take the value in the “register” <code class="language-plaintext highlighter-rouge">a0</code>, add <code class="language-plaintext highlighter-rouge">10</code> to it, and place the result in the register <code class="language-plaintext highlighter-rouge">a1</code>.</p> <blockquote> <h3 id="decoding-instructions"><a href="#decoding-instructions">Decoding Instructions</a></h3> <p><code class="language-plaintext highlighter-rouge">5407443</code> seems opaque, but when viewed as binary, we can see how the processor decodes it:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0b 000000000101 00101 000 00110 0010011
   \__________/ \___/ \_/ \___/ \_____/
    |           |     |   |     |
    imm         rs1   fn  rd    opcode
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">opcode</code> describes what sort of instruction this is, and what format it’s in; <code class="language-plaintext highlighter-rouge">0b0010011</code> means it’s an “immediate arithmetic” instruction, which uses the “I-type” format, given above. <code class="language-plaintext highlighter-rouge">fn</code> further specifies what the operation does; <code class="language-plaintext highlighter-rouge">0b000</code>, combined with the value of <code class="language-plaintext highlighter-rouge">opcode</code>, means this is an <em>addition</em> instruction.</p> <p><code class="language-plaintext highlighter-rouge">rs1</code> is the source: it gives the name of the source register, <code class="language-plaintext highlighter-rouge">a0</code>, given by it index, <code class="language-plaintext highlighter-rouge">0b00101</code>, i.e., <code class="language-plaintext highlighter-rouge">10</code>. Similarly, <code class="language-plaintext highlighter-rouge">rd</code> specifies the destination <code class="language-plaintext highlighter-rouge">a1</code> by its index <code class="language-plaintext highlighter-rouge">11</code>. Finally, <code class="language-plaintext highlighter-rouge">imm</code> is the value to add, <code class="language-plaintext highlighter-rouge">0b000000000101</code>, or <code class="language-plaintext highlighter-rouge">10</code>. The constant value appears immediately in the instruction itself, so it’s called an <em>immediate</em>.</p> </blockquote> <p>However, if you’re a human programming a computer, writing all of this by hand is… very 60s, and you might prefer to have a textual representation, so you can write this more simply as <code class="language-plaintext highlighter-rouge">addi a1, a0, 10</code>.</p> <p><code class="language-plaintext highlighter-rouge">addi a1, a0, 10</code> is a single line of assembly: it describes a <em>single</em> instruction in text form. Assembly language is “just” a textual representation of the program’s machine code. Your assembler can convert from text into machine instructions, and a <em>dis</em>assembler reverses the process.</p> <p>The simple nature of these instructions is what makes assembly a sort of Turing tarpit: you only get the most basic operations possible: you’re responsible for building <em>everything</em> else.</p> <h3 id="on-architectures"><a href="#on-architectures">On Architectures</a></h3> <p>There isn’t “an” assembly language. Every computer has a different instruction set architecture, or “ISA”; I use the terms “instruction set”, “architecture”, and “ISA” interchangeably. Each ISA has a corresponding assembly language that describes that ISA’s specific instructions, but they all generally have similar overall structure.</p> <p>I’m going to focus on three ISAs for ease of exposition, introduced in this order:</p> <ol> <li>RISC-V, a modern and fairly simple instruction set (specifically, the rv32gc variant). That’s Part I.</li> <li>x86_64, the instruction set of the device you’re reading this on (unless it’s a phone, an Apple M1 laptop, or something like a Nintendo Switch). That’s Part II.</li> <li>MOS 6502, a fairly ancient ISA still popular in very small microcontrollers. That’s Part III.</li> </ol> <p>We’re starting with RISC-V because it’s a particularly elegant ISA (having been developed for academic work originally), while still being representative of the operations most ISAs offer.</p> <p>In the future, I may dig into some other, more specialized ISAs.</p> <h2 id="but-why"><a href="#but-why">But <em>Why</em>?</a></h2> <p>It’s actually very rare to write actual assembly. Thanks to modern (relatively) languages like Rust, C++, and Go, and even things like Haskell and JavaScript, virtually no programmers need to write assembly anymore.</p> <p>But that’s only because it’s the leading language written by <em>computers themselves</em>. A compiler’s job is, fundamentally, to write the the assembly you would have had to write <em>for</em> you. To better understand what a compiler is doing for you, you need to be able to read its output.</p> <p>At this point, it may be worth looking at my <a href="https://mcyoung.xyz//2021/06/01/linker-script/#seriously-whats-a-linker">article on linkers</a> as a refresher on the C compilation model.</p> <p>For example, let’s suppose we have the very simple C program below.</p> <p>```c filename:square.c godbolt:c=rv32-cclang,o=-Oz #include <stdio.h></stdio.h></p> <p>int square_and_print(int x) { x *= x; printf(“%d\n”, x); return x; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Clang, my C compiler of choice, can turn it directly into a library via
`clang -c square.c`. `-c` asks the compiler to stop before the link step,
outputting the *object file* `square.o`. We can ask the compiler to stop even
sooner than that by writing `clang -S square.c`, which will output `square.s`,
the assembly file the compiler produced! For this example, and virtually all
others in this post, I'm using a RISC-V target:
`-target riscv32-unknown-elf -march=rv32gc`.

If you build with `-Oz` to make the code as small as possible (this makes it
easiest to see what's going on, too), you get something like this:

```riscv filename:square.s
        .text
        .file   "square.c"
        .globl  square_and_print
square_and_print:
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)
        mul     s0, a0, a0          // !
        lui     a0, %hi(.L.str)
        addi    a0, a0, %lo(.L.str)
        mv      a1, s0
        call    printf              // !
        mv      a0, s0
        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret

        .section        .rodata
.L.str:
        .asciz  "%d\n"
</code></pre></div></div> <p>There’s a lot going on! But pay attention to the two lines with a <code class="language-plaintext highlighter-rouge">// !</code>: the first is <code class="language-plaintext highlighter-rouge">mul s0, a0, a0</code>, which is the multiplication <code class="language-plaintext highlighter-rouge">x *= x;</code>. The second is <code class="language-plaintext highlighter-rouge">call printf</code>, which is our function call to <code class="language-plaintext highlighter-rouge">printf()</code>! I’ll explain what everything else means in short order.</p> <p>Writing assembly isn’t a crucial skill, but being able to read it is. It’s actually so useful, that a website exists for quickly generating the assembly output of a vast library of compilers: the <a href="https://godbolt.org/">Compiler Explorer</a>, frequently just called “godbolt” after its creator, Matt Godbolt. Being able to compare the output of different compilers can help understand what they do! Click on the <code class="language-plaintext highlighter-rouge">godbolt</code> button in the code fences to a godbolt for it.</p> <p>“Low-level” languages like C aren’t the only ones where you can inspect assembly output. Godbolt supports Go: for example, click the <code class="language-plaintext highlighter-rouge">godbolt</code> button below.</p> <p>```go godbolt: package sq</p> <p>import “fmt”</p> <p>func SquareAndPrint(x int) int { x *= x fmt.Printf(“%d\n”, x) return x }</p> <div id="big-example" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Hopefully this is motivation enough to jump into the language proper. It is very
useful to have a godbolt tab open to play around with examples!

## Diving In

So, let's say you *do* want to read assembly. How do we do that?

Let's revisit our `square.c` example above. This time, I've added comments
explaining what all the salient parts of the code do, including the *assembler
directives*, which are all of the form `.blah`. Note that the *actual* compiler
output includes way more directives that would get in the way of exposition.

There's a lot of terms below that I haven't defined yet. I'll break down what
this code does gradually, so feel free to refer back to it as necessary,
using [this handy-dandy link.](#big-example)

```riscv filename:square.s

        // This tells the assembler to place all code that
        // follows in the `.text` section, where executable
        // data goes.
        .text

        // This is just metadata that tools can use to figure out
        // how the executable was built.
        .file   "square.c"

        // This asks the assembler to mark `square_and_print`
        // as an externally linkable symbol. Other files that
        // refer to `square_and_print` will be able to find it
        // at link time.
        .globl  square_and_print

square_and_print: // This is a label, which gives this position
                  // in the executable a name that can be
                  // referenced. They're very similar to `goto`
                  // labels from C.
                  //
                  // We'll see more labels later on.


        // This is the function prologue, which "sets up" the
        // function: it allocates stack space and saves the
        // return address, along with other calling-convention
        // fussiness.
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)

        // This is our `x *= x;` from before! Notice that the
        // compiler rewrote this to `temp = x * x;` at some
        // point, since the destination register is `s0`.
        mul     s0, a0, a0

        // These two instructions load the address of a string
        // constant; this pattern is specific to RISC-V.
        lui     a0, %hi(.L.str)
        addi    a0, a0, %lo(.L.str)
        
        // This copies the multiplication result into `a1`.
        mv      a1, s0

        // Call to printf!
        call    printf

        // Move `s0` into `a0`, since it's the return value.
        mv      a0, s0

        // This is the function epilogue, which restores state
        // saved in the prologue and de-allocates the stack
        // frame.
        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        
        // We're done; return from the function!
        ret

        // This tells the assembler to place what follows in
        // the `.rodata` section, for read-only constants like
        // strings.
        .section        .rodata

.L.str: // Give our string constant a private name. By convention,
        // .L labels are "private" names emitted by the compiler.

        // Emit an ASCII string into `.rodata` with an extra null
        // terminator at the end: that's what the `z` stands for.
        .asciz  "%d\n"
</code></pre></div></div> <h3 id="the-core-syntax"><a href="#the-core-syntax">The Core Syntax</a></h3> <p>All assemblers are different, but the core syntax tends to be the same. There are three main kinds of syntax productions:</p> <ul> <li>Instructions, which consist of a <em>mnemonic</em> followed by some number of <em>operands</em>, such as <code class="language-plaintext highlighter-rouge">addi sp, sp -16</code> and <code class="language-plaintext highlighter-rouge">call printf</code> above. These are the text encoding of machine code.</li> <li>Labels, which consist of a symbol followed by a colon, like <code class="language-plaintext highlighter-rouge">square_and_print:</code> or <code class="language-plaintext highlighter-rouge">.L.str:</code>. These are used to let instruction operands refer to locations in the program.</li> <li>Directives, which vary wildly by assembler. GCC-style assembly like that above uses a <code class="language-plaintext highlighter-rouge">.directive arg, arg</code> syntax, as seen in <code class="language-plaintext highlighter-rouge">.text</code>, <code class="language-plaintext highlighter-rouge">.globl</code>, and <code class="language-plaintext highlighter-rouge">.asciz</code>. They control the behavior of the assembler in various ways.</li> </ul> <p>An assembler’s purpose is to read the <code class="language-plaintext highlighter-rouge">.s</code> file and serialize it as a binary <code class="language-plaintext highlighter-rouge">.o</code> file. It’s kind of like a compiler, but it does virtually no interesting work at all, beyond knowing how to encode instructions.</p> <p>Directives control how this serialization occurs (such as moving around the output cursor); instructions are emitted as-is, and labels refer to locations in the object file. Simple enough, right?</p> <h3 id="anatomy-of-an-instruction"><a href="#anatomy-of-an-instruction">Anatomy of an Instruction</a></h3> <p>Let’s look at the very first instruction in <code class="language-plaintext highlighter-rouge">square_and_print</code>:</p> <pre><code class="language-riscv">
        addi sp, sp, -16
        ---- --  --  ---
         |   |   |    |
        mnemonic |   immediate operand
             |  input operand
             |
            output operand
</code></pre> <p>The first token is called the <em>mnemonic</em>, which is a painfully terse abbreviation of what the instruction does. In this case, <code class="language-plaintext highlighter-rouge">addi</code> means “add with immediate”.</p> <p><code class="language-plaintext highlighter-rouge">sp</code> is a <em>register</em>. Registers are special variables wired directly into the processor that can be used as operands in instructions. The degree to which only registers are permitted as operands varies by architecture; RISC-V only allows registers, but x86, as we’ll see, does not. Registers come in many flavors, but <code class="language-plaintext highlighter-rouge">sp</code> is a GPR, or “general purpose register”; it holds a machine word-sized integer, which in the case of 32-bit RISC-V is… 32-bit<sup id="fnref:whats-a-word" role="doc-noteref"><a href="#fn:whats-a-word" class="footnote" rel="footnote">2</a></sup>.</p> <blockquote> <h4 id="risc-v-registers"><a href="#risc-v-registers">RISC-V Registers</a></h4> <p>One of my absolute favorite parts of RISC-V is how it names its registers. It has 32 GPRs named <code class="language-plaintext highlighter-rouge">x0</code> through <code class="language-plaintext highlighter-rouge">x31</code>. However, these registers have so-called “ABI names” that specify the <em>role</em> of each register in the ABI.</p> <p>The usefulness of these names will be much more apparent when we discuss <a href="#the-calling-convention">the calling convention</a>, so feel free to come back to this later.</p> <p><code class="language-plaintext highlighter-rouge">x0</code> is called <code class="language-plaintext highlighter-rouge">zero</code>, because of its special property: writes to it are ignored, and reads always produce zero. This is handy for encoding certain common operations: for example, it can be used to quickly get a constant value= into a register: <code class="language-plaintext highlighter-rouge">addi rd, zero, 42</code>.</p> <p><code class="language-plaintext highlighter-rouge">x1</code>, <code class="language-plaintext highlighter-rouge">x2</code>, <code class="language-plaintext highlighter-rouge">x3</code>, and <code class="language-plaintext highlighter-rouge">x4</code> have special roles and generally aren’t used for general computation. The first two are the link register <code class="language-plaintext highlighter-rouge">ra</code>, which holds the <u>r</u>eturn <u>a</u>ddress, and <code class="language-plaintext highlighter-rouge">sp</code>, the <u>s</u>tack <u>p</u>ointer.</p> <p>The latter two are <code class="language-plaintext highlighter-rouge">gp</code> and <code class="language-plaintext highlighter-rouge">tp</code>; the <u>g</u>lobal <u>p</u>pointer and the <u>t</u>hread <u>p</u>pointer; their roles are somewhat complicated, so we won’t discuss them in this post.</p> <p>The remaining registers belong to one of three categories: <em>argument</em> registers, <em>saved</em> registers, and <em>temporary</em> registers, named so for their role in calling a function (as described <a href="#the-calling-convention">below</a>).</p> <p>The argument registers are <code class="language-plaintext highlighter-rouge">x10</code> through <code class="language-plaintext highlighter-rouge">x17</code>, and use the names <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a7</code>. The saved registers are <code class="language-plaintext highlighter-rouge">x8</code>, <code class="language-plaintext highlighter-rouge">x9</code>, and <code class="language-plaintext highlighter-rouge">x18</code> through <code class="language-plaintext highlighter-rouge">x27</code>, called <code class="language-plaintext highlighter-rouge">s0</code>, through <code class="language-plaintext highlighter-rouge">s11</code>. The temporary registers are <code class="language-plaintext highlighter-rouge">x5</code> through <code class="language-plaintext highlighter-rouge">x7</code> and <code class="language-plaintext highlighter-rouge">x28</code> through <code class="language-plaintext highlighter-rouge">x31</code>, called <code class="language-plaintext highlighter-rouge">t0</code> through <code class="language-plaintext highlighter-rouge">t6</code>.</p> <p>As a matter of personal preference, you may notice me reaching for argument registers for most examples.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">-16</code> is an <em>immediate</em>, which is a literal value that is encoded directly into the instruction. The encoding of <code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code> will include the binary representation of <code class="language-plaintext highlighter-rouge">-16</code> (in the case of RISC-V, as a 12-bit integer). [The decoding example above]{#decoding-instructions} shows how immediates are literally encoded <em>immediately</em> in the instruction.</p> <p>Immediates allow for small but fixed integer arguments to be encoded with high locality to the instruction, which is good for code size and performance.</p> <p>The first operand in RISC-V is (almost) always the output. <code class="language-plaintext highlighter-rouge">addi, rd, rs, imm</code> should be read as <code class="language-plaintext highlighter-rouge">rd = rs + imm</code>. Virtually all assembler syntax follows this convention, which is called the <a href="https://en.wikipedia.org/wiki/Three-address_code">three-address code</a>.</p> <p>Other kinds of operands exist: for example, <code class="language-plaintext highlighter-rouge">call printf</code> refers to the <em>symbol</em> <code class="language-plaintext highlighter-rouge">printf</code>. The assembler, which doesn’t actually know where <code class="language-plaintext highlighter-rouge">printf</code> is, will emit a small note in the object file that tells the linker to find <code class="language-plaintext highlighter-rouge">printf</code> and splat it into the assembly according to some instructions in the note. These notes are called <em>relocations</em>.</p> <p>The instructions <code class="language-plaintext highlighter-rouge">lui a0, %hi(.L.str)</code> and <code class="language-plaintext highlighter-rouge">addi a0, a0, %lo(.L.str)</code> use the <code class="language-plaintext highlighter-rouge">%lo</code> and <code class="language-plaintext highlighter-rouge">%hi</code> operand types, which are specific to RISC-V; they load the low 12 bits and high 20 bits of a symbol’s address into the immediate operand. This is a RISC-V-specific pattern for loading an address into a register, which most assemblers provide with the <em>pseudoinstruction</em> <code class="language-plaintext highlighter-rouge">la a0, .L.str</code> (where <code class="language-plaintext highlighter-rouge">la</code> stands for “load address”).</p> <p>Most architectures have their own funny architecture-specific operand types to deal with the architecture’s idiosyncrasy.</p> <h3 id="types-of-instructions"><a href="#types-of-instructions">Types of Instructions</a></h3> <p>Available instructions tend to be motivated by providing one of three classes of functionality:</p> <ol> <li>A Turing-complete <a href="https://en.wikipedia.org/wiki/Register_machine">register machine</a> execution environment. This lends to the Turing tarpit nature of assembly: only the absolute minimum in terms of control flow and memory access is provided.</li> <li>Efficient silicon implementation of common operations on bit strings and integers, ranging from arithmetic to cryptographic algorithms.</li> <li>Building a secure operating system, hosting virtual machines, and actuating hardware external to the processor, like a monitor, a keyboard, or speakers.</li> </ol> <p>Instructions can be broadly classified into four categories: arithmetic, memory, control flow, and “everything else”. In the last thirty years, the bar for general-purpose architectures is usually “this is enough to implement a C runtime.”</p> <h4 id="arithmetic-instructions"><a href="#arithmetic-instructions">Arithmetic Instructions</a></h4> <p>Arithmetic makes up the bulk of the instruction set. This always includes addition, subtraction, and bitwise and, or, and xor, as well as unary not and negation.</p> <p>In RISC-V, these come in two variants: a three-register version and a two-register, one immediate version. For example, <code class="language-plaintext highlighter-rouge">add a0, a1, a2</code> is the three-register version of addition, while <code class="language-plaintext highlighter-rouge">addi a0, a1, 42</code> is the immediate version. There isn’t a <code class="language-plaintext highlighter-rouge">subi</code> though, since you can just use negative immediates with <code class="language-plaintext highlighter-rouge">addi</code>.</p> <p><code class="language-plaintext highlighter-rouge">not</code> and <code class="language-plaintext highlighter-rouge">neg</code> are not actual instructions in RISC-V, but pseudoinstructions: <code class="language-plaintext highlighter-rouge">not a0, a1</code> encodes as <code class="language-plaintext highlighter-rouge">xori a0, a1, -1</code>, while <code class="language-plaintext highlighter-rouge">neg a0, a1</code> becomes <code class="language-plaintext highlighter-rouge">sub a0, zero, a1</code>.</p> <p>Most instruction sets also have bit shifts, usually in three flavors: left shifts, right shifts, and <em>arithmetic</em> right shifts; arithmetic right shift is defined such that it behaves like division by powers of two on signed integers. RISC-V’s names for these instructions are <code class="language-plaintext highlighter-rouge">sll</code>, <code class="language-plaintext highlighter-rouge">srl</code>, and <code class="language-plaintext highlighter-rouge">sra</code>.</p> <p>Multiplication and division are somewhat rarer, because they are expensive to implement in silicon; smaller devices don’t have them<sup id="fnref:mul-polyfill" role="doc-noteref"><a href="#fn:mul-polyfill" class="footnote" rel="footnote">3</a></sup>. Division in particular is very complex to implement in silicon. Instruction sets usually have different behavior around division by zero: some architectures will fault, similar to a memory error, while some, like RISC-V, produce a well-defined trap value.</p> <p>There is usually also a “copy” instruction that moves the value of one register to another, which is kind of like a trivial arithmetic instruction. RISC-V calls this <code class="language-plaintext highlighter-rouge">mv a0, a1</code>, but it’s just a pseudoinstruction that expands to <code class="language-plaintext highlighter-rouge">addi a0, a1, 0</code>.</p> <p>Some architectures also offer more exotic arithmetic. This is just a sampler of what’s sometimes available:</p> <ul> <li>Bit rotation, which is like a shift but bits that get shifted off end up at the other end of the integer. This is useful for a vast array of numeric algorithms, including ARX ciphers like <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha20</a>.</li> <li>Byte reversal, which can be used for changing the endianness of an integer; bit reversal is analogous.</li> <li>Bit extraction, which can be used to form new integers out of bitfields of another.</li> <li>Carry-less multiplication, which is like long multiplication but you don’t bother to carry anything when you add intermediates. This is used to implement <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois/Counter mode encryption</a>.</li> <li>Fused instructions, like <code class="language-plaintext highlighter-rouge">xnor</code> and <code class="language-plaintext highlighter-rouge">nand</code>.</li> <li>Floating point instructions, usually implementing the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> standard.</li> </ul> <p>There is also a special kind of arithmetic instruction called a <em>vector instruction</em>, but I’ll leave those for another time.</p> <h4 id="memory-instructions"><a href="#memory-instructions">Memory Instructions</a></h4> <p>Load instructions fetch memory from RAM into registers, while store instructions write it back. These instructions are what we use to implement pointers.</p> <p>They come in all sorts of different sizes: RISC-V has <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">lh</code>, and <code class="language-plaintext highlighter-rouge">lb</code> for loading 32-, 16-, and 8-bit values from a location; <code class="language-plaintext highlighter-rouge">sw</code>, <code class="language-plaintext highlighter-rouge">sh</code>, and <code class="language-plaintext highlighter-rouge">sb</code> are their store counterparts. 64-bit RISC-V also provides <code class="language-plaintext highlighter-rouge">ld</code> and <code class="language-plaintext highlighter-rouge">sd</code> for 64-bit loads and stores.</p> <p>Load/store instructions frequently take an offset for indexing into memory. <code class="language-plaintext highlighter-rouge">lw a1, 4(a0)</code><sup id="fnref:offset-syntax" role="doc-noteref"><a href="#fn:offset-syntax" class="footnote" rel="footnote">4</a></sup> is effectively <code class="language-plaintext highlighter-rouge">a1 = a0[4]</code>, treating <code class="language-plaintext highlighter-rouge">a0</code> like a pointer.</p> <p>These instructions frequently have an <em>alignment</em> constraint: the pointer value must (or, at least, should) be divisible by the number of bytes being loaded. RISC-V, for example, mandates that <code class="language-plaintext highlighter-rouge">lw</code> only be used on pointers divisible by 4. This constraint simplifies the microarchitecture; even on architectures that don’t mandate it, aligned loads and stores are typically far faster.</p> <p>This category also includes instructions necessary for implementing atomics, such as <code class="language-plaintext highlighter-rouge">lock cmpxchg</code> on x86 and <code class="language-plaintext highlighter-rouge">lr</code>/<code class="language-plaintext highlighter-rouge">sc</code> on RISC-V. Atomics are fundamentally about changing the semantics of reading and writing from RAM, and thus require special processor support.</p> <p>Some architectures, like x86, 65816, and very recently, ARM, provide instructions that implement <code class="language-plaintext highlighter-rouge">memcpy</code> and its ilk in hardware: in x86, for example, this is called <code class="language-plaintext highlighter-rouge">rep movsb</code>.</p> <h4 id="control-flow-instructions"><a href="#control-flow-instructions">Control Flow Instructions</a></h4> <p>Control flow is the secret ingredient that turns our glorified calculator into a Turing tarpit: they allow changing the flow of program execution based on its current state.</p> <p><em>Unconditional jumps</em> implement <code class="language-plaintext highlighter-rouge">goto</code>: given some <code class="language-plaintext highlighter-rouge">label</code>, the <code class="language-plaintext highlighter-rouge">j label</code> instruction jumps directly to it. <code class="language-plaintext highlighter-rouge">j</code> can be thought of as writing to a special <code class="language-plaintext highlighter-rouge">pc</code> register that holds the program counter. RISC-V also provides a <em>dynamic</em> jump, <code class="language-plaintext highlighter-rouge">jr</code>, which will jump to the address in a register. Function calls and returns are a special kind of unconditional jump.</p> <p><em>Conditional jumps</em>, often called <em>branches</em>, implement <code class="language-plaintext highlighter-rouge">if</code>. <code class="language-plaintext highlighter-rouge">beq a0, a1, label</code> will jump to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">a0</code> and <code class="language-plaintext highlighter-rouge">a1</code> contain the same value. RISC-V provides branch instructions for all kinds of comparisons, like <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">blt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>.</p> <p>Conditional and unconditional jumps can be used together to build loops, much like we could in C using <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">goto</code>.</p> <p>For example, to zero a region of memory:</p> <pre><code class="language-riscv">
        // Assume a0 is the start of the region, and a1 the
        // number of bytes to zero.

        // Set a1 to the end of the region.
        addi a1, a0, a1
loop_start:
        // If a0 == a1, we're done!
        beq a0, a1, loop_done

        // Store a zero byte to `a0` and advance the pointer.
        sb zero, 0(a0)
        addi a0, a0, 1

        // Take it from the top!
        j loop_start
loop_done:

</code></pre> <h4 id="miscellaneous-instructions"><a href="#miscellaneous-instructions">Miscellaneous Instructions</a></h4> <p>“Everything else” is, well… everything else.</p> <p>No-op instructions do nothing: <code class="language-plaintext highlighter-rouge">nop</code>’s only purpose is to take up space in the instruction stream. No-op instructions can be used to pad space in the instruction stream, provide space for the linker to fix things up later, or implement <a href="https://en.wikipedia.org/wiki/NOP_slide"><code class="language-plaintext highlighter-rouge">nop</code> sleds</a>.</p> <p>Instructions for poking processor state, like <code class="language-plaintext highlighter-rouge">csrrw</code> in RISC-V and <code class="language-plaintext highlighter-rouge">wrmsr</code> in <code class="language-plaintext highlighter-rouge">x86</code> also belong in this category, as do “hinting” instructions like memory prefetches.</p> <p>There are also instructions for special control flow: <code class="language-plaintext highlighter-rouge">ecall</code> is RISC-V’s “syscall” instruction, which “traps” to the kernel for it to do something; other architectures have similar instructions.</p> <p>Breakpoint instructions and <a href="https://www.felixcloutier.com/x86/lfence">“fence” instructions</a> belong here, too.</p> <h2 id="the-calling-convention"><a href="#the-calling-convention">The Calling Convention</a></h2> <p>Functions are the core abstraction of all of programming. Assembly is no different: we have functions there, too!</p> <p>Like in any language, functions are <em>passed</em> a list of arguments, perform some work, and <em>return</em> a value. For example, in C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">identity</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="n">identity</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1">// Returns 5.</span>
</code></pre></div></div> <p>Unfortunately, there isn’t anything like function call syntax in assembly. As with everything else, we need do it instruction by instruction. All we <em>do</em> get in most architectures is a <code class="language-plaintext highlighter-rouge">call</code> instruction, which sets up a return address somewhere, and a <code class="language-plaintext highlighter-rouge">ret</code> instruction, which uses the return address to jump to where the function was called.</p> <p>We need some way to pass arguments, return a computed value, and maintain a call stack, so that each function’s return address is kept intact for its <code class="language-plaintext highlighter-rouge">ret</code> instruction to consume. We also need this to be universal: if I pull in a library, I should be able to call its functions.</p> <p>This mechanism is called the <em>calling convention</em> of the platform’s ABI. It’s a convention, because all libraries must respect it in their exposed API for code to work correctly at runtime.</p> <h3 id="a-function-call-in-slow-mo"><a href="#a-function-call-in-slow-mo">A Function Call in Slow-Mo</a></h3> <p>At the instruction level, function calls look something like this:</p> <ol> <li> <p>Pre-call setup. The caller sets up the function call arguments by placing them in the appointed locations for arguments. These are usually either registers or locations on the stack. a. The caller also saves the <em>caller-saved registers</em> to the stack.</p> </li> <li> <p>Jump to the function. The caller executes a <code class="language-plaintext highlighter-rouge">call</code> instruction (or whatever the function call instruction might be called – virtually all architectures have one). This sets the program counter to the first instruction of the callee.</p> </li> <li> <p>Function prologue. The callee does some setup before executing its code. a. The callee reserves space on the stack in an architecture-dependent manner. b. The callee saves the <em>callee-saved registers</em> to this stack space.</p> </li> <li> <p>Function body. The actual code of the function runs now! This part of the function needs to make sure the return value winds up wherever the <em>return slot</em> for the function is.</p> </li> <li> <p>Function epilogue. The callee undoes whatever work it did in the prologue, such as restoring saved registers, and executes a <code class="language-plaintext highlighter-rouge">ret</code> (or equivalent) instruction to return.</p> </li> <li> <p>Post-call cleanup. The caller is now executing again; it can unspill any saved state that it needs immediately after the function call, and can retrieve the return value from the return slot.</p> <p>In some ABIs, such as C++’s on Linux, this is where the destructors of the arguments get run. (Rust, and C++ on Windows, have <em>callee</em>-destroyed arguments instead.)</p> </li> </ol> <p>When people say that function calls have overhead, this is what they mean. Not only does the <code class="language-plaintext highlighter-rouge">call</code> instruction cause the processor to slam the breaks on its pipeline, causing all kinds of work to get thrown away, but state needs to be delicately saved and restored across the function boundary to maintain the illusion of a callstack.</p> <p>Small functions which don’t need to use as many registers can avoid some of the setup and cleanup, and <em>leaf functions</em> which don’t call any other functions can avoid basically all of it!</p> <p>Almost all registers in RISC-V are caller-saved, except for <code class="language-plaintext highlighter-rouge">ra</code> and the “saved” registers <code class="language-plaintext highlighter-rouge">s0</code> and <code class="language-plaintext highlighter-rouge">s11</code>.</p> <p>Callee-saved registers are convenient, because they won’t be wiped out by function calls. We can actually see the call to <code class="language-plaintext highlighter-rouge">printf</code> use this: even though the compiler could have emitted <code class="language-plaintext highlighter-rouge">mul a1, a0, a0</code> and avoided the <code class="language-plaintext highlighter-rouge">mv</code>, this is actually less optimal. We need to keep the value around to return, and <code class="language-plaintext highlighter-rouge">a1</code> is caller-saved, so we would have had to spill <code class="language-plaintext highlighter-rouge">a1</code> before calling <code class="language-plaintext highlighter-rouge">printf</code>, regardless of whether <code class="language-plaintext highlighter-rouge">printf</code> overwrites <code class="language-plaintext highlighter-rouge">a1</code> or not. We would then have to unspill it into <code class="language-plaintext highlighter-rouge">a0</code> before <code class="language-plaintext highlighter-rouge">ret</code>. This costs us a hit to RAM. However, by emitting <code class="language-plaintext highlighter-rouge">mul s0, a0, a0; mv a1, s0</code>, we speculatively avoid the spill: if <code class="language-plaintext highlighter-rouge">printf</code> is compiled such that it never touches <code class="language-plaintext highlighter-rouge">s0</code>, the value never leaves registers at all!</p> <h3 id="caller-side"><a href="#caller-side">Caller-Side</a></h3> <p>We can see steps 1 and 2 in the call to <code class="language-plaintext highlighter-rouge">printf</code>:</p> <pre><code class="language-riscv">
        lui     a0, %hi(.L.str)
        addi    a0, a0, %lo(.L.str)
        mv      a1, s0
        call    printf
</code></pre> <p>Arguments in the usual<sup id="fnref:custom-abis" role="doc-noteref"><a href="#fn:custom-abis" class="footnote" rel="footnote">5</a></sup> RISC-V calling convention, word-sized arguments are passed in the <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a7</code> registers, falling back to passing on the stack if they run out of space. If the argument is too big to fit in a register, it gets passed by reference instead. Arguments that fit into two registers can be split across registers.</p> <p>We can see this in action <a href="#big-example">above</a>. The first argument, a string, is passed by pointer in <code class="language-plaintext highlighter-rouge">a0</code>; <code class="language-plaintext highlighter-rouge">lui</code> and <code class="language-plaintext highlighter-rouge">addi</code> do the work of actually putting that pointer into <code class="language-plaintext highlighter-rouge">a0</code>. The second argument <code class="language-plaintext highlighter-rouge">x</code> is passed in <code class="language-plaintext highlighter-rouge">a1</code>, copied from <code class="language-plaintext highlighter-rouge">s0</code> where it landed from the earlier <code class="language-plaintext highlighter-rouge">mul</code> instruction.</p> <p>Complex function signatures require much more<sup id="fnref:all-args" role="doc-noteref"><a href="#fn:all-args" class="footnote" rel="footnote">6</a></sup> work to set up.</p> <p>#include <stdio.h> #include <stdint.h> #include <stdnoreturn.h></stdnoreturn.h></stdint.h></stdio.h></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Pair {
  uint32_t x, y;
};
struct Triple {
  uint32_t x, y, z;
};
struct Packed {
  uint8_t x, y, z;
};

// `noreturn` obviates the
// {pro,epi}logue in `call_it`.
noreturn void all_the_args(
  uint32_t a0,
  uint64_t a1a2,
  struct Pair a3a4,
  struct Triple a5_by_ref,
  uint16_t a6,
  struct Packed a7,
  uint32_t on_the_stack,
  struct Triple stack_by_ref
);

void call_it(void) {
  struct Pair u = {7, 9};
  struct Triple v = {11, 13, 15};
  struct Packed w = {14, 16, 18};
  all_the_args(
    42, -42,  u, v,
     5,   w, 21, v
  );
}
```

```riscv
call_it:
  // Reserve stack space.
  addi    sp, sp, -48

  // Get `&amp;call_it.v` into `a3`.
  lui     a3, %hi(call_it.v)
  addi    a3, a3, %lo(call_it.v)

  // Copy contents of `*a3`
  // into `a0...a2`.
  lw      a0, 0(a3)
  lw      a1, 4(a3)
  lw      a2, 8(a3)

  // Create two copies of `v`
  // on the stack to pass by
  // reference.

  // This is `a5_by_ref`.
  sw      a2, 40(sp)
  sw      a1, 36(sp)
  sw      a0, 32(sp)

  // This is `stack_by_ref`.
  sw      a2, 24(sp)
  sw      a2, 20(sp)
  sw      a0, 16(sp)
  
  // Load the argument regs.
  addi    a0, zero, 42
  addi    a1, zero, -42
  addi    a2, zero, -1
  addi    a3, zero, 7
  addi    a4, zero, 9
  // A pointer to `a5_by_ref`!
  addi    a5, sp, 32
  addi    a6, zero, 5
  // Note that `a7` is three
  // packed bytes!
  lui     a0, 289
  addi    a7, a0, 14

  // Store `21` on the top of
  // the stack (our "a8")
  addi    t0, zero, 21
  sw      t0, 0(sp)

  // Store a pointer to
  // `stack_by_ref` on the 
  // second spot from the
  // stack top (our "a9")
  addi    t0, sp, 16
  sw      t0, 4(sp)

  // Call it!
  call    all_the_args

call_it.v:
  // The constant `{11, 13, 15}`.
  .word   11
  .word   13
  .word   15
```

&lt;/div&gt;
</code></pre></div></div> <p>Once we’re done getting arguments into place, we <code class="language-plaintext highlighter-rouge">call</code>, which switches execution over to <code class="language-plaintext highlighter-rouge">printf</code>’s first instruction. In addition, it stores the return address, specifically, the address of the instruction immediately after the <code class="language-plaintext highlighter-rouge">call</code>, into an architecture-specific location. On RISC-V, this is the special register <code class="language-plaintext highlighter-rouge">ra</code>.</p> <h3 id="callee-side"><a href="#callee-side">Callee-Side</a></h3> <p>Meanwhile, steps 3 and 4 occur in <code class="language-plaintext highlighter-rouge">square_and_print</code>’s prologue/epilogue itself:</p> <pre><code class="language-riscv">
square_and_print: 
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)

        // ...

        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret
</code></pre> <p><code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code>, which we stared at so hard above, grows the stack by 16 bytes. <code class="language-plaintext highlighter-rouge">sp</code> holds the <em>stack pointer</em>, which points to the top of the stack at all times. The stack grows downwards (as in most architectures!) and must be aligned to 16-byte boundaries across function calls: even though <code class="language-plaintext highlighter-rouge">square_and_print</code> only uses eight of those bytes, the full 16 bytes must be allocated.</p> <p>The two <code class="language-plaintext highlighter-rouge">sw</code> instructions that follow store (or “spill”) the callee-saved registers <code class="language-plaintext highlighter-rouge">ra</code> and <code class="language-plaintext highlighter-rouge">s0</code> to the stack. Note that <code class="language-plaintext highlighter-rouge">s1</code> through <code class="language-plaintext highlighter-rouge">s11</code> are <em>not</em> spilled, since <code class="language-plaintext highlighter-rouge">square_and_print</code> doesn’t use them!</p> <p>Th this point, the function does its thing, whatever that means. This includes putting the return value in the return slot, which, for a function that returns an <code class="language-plaintext highlighter-rouge">int</code>, is in <code class="language-plaintext highlighter-rouge">a0</code>. In general, the return slot is passed back to the caller much like arguments are: if it fits in registers, <code class="language-plaintext highlighter-rouge">a0</code> and <code class="language-plaintext highlighter-rouge">a1</code> are used; otherwise, the caller allocates space for it and passes a pointer to the return slot as a hidden argument (in e.g. <code class="language-plaintext highlighter-rouge">a0</code>)<sup id="fnref:return-slot" role="doc-noteref"><a href="#fn:return-slot" class="footnote" rel="footnote">7</a></sup>.</p> <p>The epilogue inverts all operations of the prologue in reverse, unspilling registers and shrinking the stack, followed by <code class="language-plaintext highlighter-rouge">ret</code>. On RISC-V, all <code class="language-plaintext highlighter-rouge">ret</code> does is jump to the location referred to by the <code class="language-plaintext highlighter-rouge">ra</code> register.</p> <p>Of course, all this work is only necessary to maintain the illusion of a callstack; if <code class="language-plaintext highlighter-rouge">square_and_print</code> were a leaf function, it would not need to spill anything at all! This results in an almost trivial function:</p> <div class="code-multicol"> <p>```c godbolt:c=rv32-cclang,o=-Oz int square(int x) { return x * x; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```riscv
// `x` is already in a0, and the
// return value needs to wind up
// in a0. EZ!
square:
        mul a0, a0, a0
        ret
</code></pre></div> </div> </div> <p>Because leaf functions won’t call other functions, they won’t need to save the caller-saved <code class="language-plaintext highlighter-rouge">tX</code> registers, so they can freely use them instead of the <code class="language-plaintext highlighter-rouge">sX</code> registers.</p> <h2 id="the-end-for-now"><a href="#the-end-for-now">The End, for Now</a></h2> <p>Phew! We’re around six thousand words in, so let’s checkpoint what we’ve learned:</p> <ol> <li> <p>Computers are stupid, but can at least follow <em>extremely</em> basic instructions, which are encoded as binary.</p> </li> <li> <p>Assembly language is human-readable version of these basic instructions for a particular computer.</p> </li> <li> <p>Assembly language programs consist of <em>instructions</em>, <em>labels</em>, and <em>directives</em>.</p> </li> <li> <p>Each instruction is a <em>mnemonic</em> followed by zero or more <em>operands</em>.</p> </li> <li> <p><em>Registers</em> hold values the machine is currently operating on.</p> </li> <li> <p>Instructions can be broadly categorized as <em>arithmetic</em>, <em>memory</em>, <em>control flow</em>, and “miscellaneous” (plus <em>vector</em> and <em>float</em> instructions, for another time).</p> </li> <li> <p>The <em>calling convention</em> describes the low-level interface of a general function, consisting of some pre-call setup, and a prologue and epilogue in each function.</p> </li> </ol> <p>That’s all for now. RISC-V is a powerful but reasonably simple ISA. Next time, we’ll dive into the much older, much larger, and much more complex Intel x86.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:superscalar" role="doc-endnote"> <p>This is a hilarious lie that is beyond the scope of this post. See, for example, <a href="https://en.wikipedia.org/wiki/Superscalar_processor">https://en.wikipedia.org/wiki/Superscalar_processor</a>. <a href="#fnref:superscalar" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:whats-a-word" role="doc-endnote"> <p>What’s a machine word, exactly? It really depends on context. Most popular architectures has a straight-forward definition: the size of a GPR <em>or</em> the size of a pointer, which are the same.</p> <p>This is not true of all architectures, so beware. <a href="#fnref:whats-a-word" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:mul-polyfill" role="doc-endnote"> <p>Thankfully, these can be polyfilled using the previous ubiquitous instructions. Hacker’s Delight contains all of the relevant algorithms, so I won’t reproduce them here. The division polyfills are particularly interesting. <a href="#fnref:mul-polyfill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:offset-syntax" role="doc-endnote"> <p>It’s a bit interesting that we don’t write <code class="language-plaintext highlighter-rouge">lw a1, a0[4]</code> in imitation of array syntax. This specific corner of the notation is shockingly diverse across assemblers: in ARM, we write <code class="language-plaintext highlighter-rouge">ldr r0, [r1, #offset]</code>; in x86, <code class="language-plaintext highlighter-rouge">mov rax, [rdx + offset]</code>, or <code class="language-plaintext highlighter-rouge">movq offset(%rdx), %rax</code> for AT&amp;T-flavored assemblers (which is surprisingly similar to the RISC-V syntax!); in 6502, <code class="language-plaintext highlighter-rouge">lda ($1234, X)</code>. <a href="#fnref:offset-syntax" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:custom-abis" role="doc-endnote"> <p>The calling convention isn’t actually determined by the architecture in most cases; that’s why it’s called a <em>convention</em>. The convention on x86 actually differs on Windows and Linux, and is usually also language-dependent; C’s calling convention is usually documented, but C++, Rust, and Go invent their own to handle language-specific fussiness.</p> <p>Of course, if you’re writing assembly, you can do whatever you want (though the silicon may be optimized for a particular recommended calling convention).</p> <p>RISC-V defines a recommended calling convention for ELF-based targets: <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">https://github.com/riscv-non-isa/riscv-elf-psabi-doc</a>. <a href="#fnref:custom-abis" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:all-args" role="doc-endnote"> <p>The following listing shows how all kinds of different arguments are passed. The output isn’t quite what Clang emits, since I’ve cleaned it up for clarity.</p> <div class="code-multicol" style="height: 860px;"> <p>```c godbolt:c=rv32-cclang,o=-Oz</p> </div> <p><a href="#fnref:all-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:return-slot" role="doc-endnote"> <p>LLVM occasionally does somewhat clueless things around this corner of some ABIs. Given</p> <p>```c godbolt:c=rv32-cclang,o=-Oz typedef struct { char p[100]; } X;</p> <p>X make_big(int x) { return (X) {x}; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
we get the following from Clang:

```riscv
// NOTE: Return slot passed in `a0`, `x` passed in `a1`.
make_big:
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sw      s0, 8(sp)
        sw      s1, 4(sp)
        mv      s0, a1
        mv      s1, a0
        addi    a0, a0, 1
        addi    a2, zero, 99
        mv      a1, zero
        call    memset
        sb      s0, 0(s1)
        lw      s1, 4(sp)
        lw      s0, 8(sp)
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret
</code></pre></div> </div> <p>Note that <code class="language-plaintext highlighter-rouge">sb s0, 0(s1)</code> stores the input value <code class="language-plaintext highlighter-rouge">x</code> into the first element of the big array <em>after</em> calling memset. If we move the store to before, we can avoid much silliness, including some unnecessary spills:</p> <pre><code class="language-riscv">make_big:
        addi    sp, sp, -16
        sw      ra, 12(sp)
        sb      a1, 0(a0)
        addi    a0, a0, 1
        mv      a1, zero
        addi    a2, zero, 99
        call    memset
        lw      ra, 12(sp)
        addi    sp, sp, 16
        ret
</code></pre> <p><a href="#fnref:return-slot" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>