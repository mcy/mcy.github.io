<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Everything You Never Wanted To Know About Linker Script &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Everything You Never Wanted To Know About Linker Script &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/linker-script-d8449181d8bbd4222ee9ad1bad74541df6a77a4a.png"> <meta property="og:title" content="Everything You Never Wanted To Know About Linker Script &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/linker-script-d8449181d8bbd4222ee9ad1bad74541df6a77a4a.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2021/06/01/linker-script/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz/posts"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/posts"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2021-06-01 • 4785 words • 26 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#linkers">#linkers</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2021/06/01/linker-script/"> Everything You Never Wanted To Know About Linker Script </a></h1> </div> <div class="post"> <p>Low level software usually has lots of <code class="language-plaintext highlighter-rouge">.cc</code> or <code class="language-plaintext highlighter-rouge">.rs</code> files. Even lower-level software, like your cryptography library, probably has <code class="language-plaintext highlighter-rouge">.S</code> containing assembly, my least favorite language for code review.</p> <p>The lowest level software out there, firmware, kernels, and drivers, have one third file type to feed into the toolchain: an <code class="language-plaintext highlighter-rouge">.ld</code> file, a “linker script”. The linker script, provided to Clang as <code class="language-plaintext highlighter-rouge">-Wl,-T,foo.ld</code><sup id="fnref:linker-flag" role="doc-noteref"><a href="#fn:linker-flag" class="footnote" rel="footnote">1</a></sup>, is like a template for the final executable. It tells the linker how to organize code from the input objects. This permits extremely precise control over the toolchain’s output.</p> <p>Very few people know how to write linker script; it’s a bit of an obscure skill. Unfortunately, I’m one of them, so I get called to do it on occasion. Hopefully, this post is a good enough summary of the linker script language that you, too, can build your own binary!</p> <p>Everything in this post can be found in excruciating detail in <a href="https://sourceware.org/binutils/docs/ld/index.html">GNU <code class="language-plaintext highlighter-rouge">ld</code>’s documentation</a>; <code class="language-plaintext highlighter-rouge">lld</code> accepts basically the same syntax. There’s no spec, just what your linker happens to accept. I will, however, do my best to provide a more friendly introduction.</p> <p>No prior knowledge of how toolchains work is necessary! Where possible, I’ve tried to provide historical context on the names of everything. Toolchains are, unfortunately, bound by half a century of tradition. Better to at least know why they’re called that.</p> <blockquote> <h3 id="wait-an-s-file"><a href="#wait-an-s-file">Wait, an <code class="language-plaintext highlighter-rouge">.S</code> file?</a></h3> <p>On Windows, assembly files use the sensible <code class="language-plaintext highlighter-rouge">.asm</code> extension. POSIX we use the <code class="language-plaintext highlighter-rouge">.s</code> extension, or <code class="language-plaintext highlighter-rouge">.S</code> when we’d like Clang to run the C preprocessor on them (virtually all hand-written assembly is of the second kind).</p> <p>I don’t actually have a historical citation<sup id="fnref:etymology-of-s" role="doc-noteref"><a href="#fn:etymology-of-s" class="footnote" rel="footnote">2</a></sup> for <code class="language-plaintext highlighter-rouge">.s</code>, other than that it came from the Unix tradition of obnoxiously terse names. If we are to believe that <code class="language-plaintext highlighter-rouge">.o</code> stands for “object”, and <code class="language-plaintext highlighter-rouge">.a</code> stands for “archive”, then <code class="language-plaintext highlighter-rouge">.s</code> must stand for “source”, up until the B compiler replaced them with <code class="language-plaintext highlighter-rouge">.b</code> files! See <a href="http://man.cat-v.org/unix-1st/1/b">http://man.cat-v.org/unix-1st/1/b</a>.</p> <p>A final bit of trivia: <code class="language-plaintext highlighter-rouge">.C</code> files are obviously different from <code class="language-plaintext highlighter-rouge">.c</code> files… they’re C++ files! (Seriously, try it.)</p> </blockquote> <blockquote> <p>Note: This post is specifically about POSIX. I know basically nothing about MSVC and <code class="language-plaintext highlighter-rouge">link.exe</code> other than that they exist. The most I’ve done is helped people debug trivial <code class="language-plaintext highlighter-rouge">__declspec</code> issues.</p> <p>I will also only be covering things specific to linking an executable; linking other outputs, like shared libraries, is beyond this post.</p> </blockquote> <h2 id="seriously-whats-a-linker"><a href="#seriously-whats-a-linker">Seriously, What’s a linker?</a></h2> <p>A linker is but a small part of a <em>toolchain</em>, the low-level programmer’s toolbox: everything you need to go from source code to execution.</p> <p>The crown jewel of any toolchain is the compiler. The LLVM toolchain, for example, includes Clang, a C/C++<sup id="fnref:clang-languages" role="doc-noteref"><a href="#fn:clang-languages" class="footnote" rel="footnote">3</a></sup> compiler. The compiler takes source code, such as <code class="language-plaintext highlighter-rouge">.cc</code>, and lowers it down to a <code class="language-plaintext highlighter-rouge">.s</code> file, an <em>assembly file</em> which textually describes machine code for a specific architecture (you can also write them yourself).</p> <p>Another toolchain program, the assembler, <em>assembles</em> each <code class="language-plaintext highlighter-rouge">.s</code> into a <code class="language-plaintext highlighter-rouge">.o</code> file, an <em>object file</em><sup id="fnref:object-what" role="doc-noteref"><a href="#fn:object-what" class="footnote" rel="footnote">4</a></sup>. An assembly file is merely a textual representation of an object file; assemblers are not particularly interesting programs.</p> <p>A third program, the linker, <em>links</em> all of your object files into a final <em>executable</em> or <em>binary</em>, traditionally given the name <code class="language-plaintext highlighter-rouge">a.out</code><sup id="fnref:aout" role="doc-noteref"><a href="#fn:aout" class="footnote" rel="footnote">5</a></sup>.</p> <p>This three (or two, if you do compile/assemble in one step) phase process is sometimes called the <em>C compilation model</em>. All modern software build infrastructure is built around this model<sup id="fnref:rust-objects" role="doc-noteref"><a href="#fn:rust-objects" class="footnote" rel="footnote">6</a></sup>.</p> <blockquote> <h3 id="even-more-stages"><a href="#even-more-stages">Even More Stages!</a></h3> <p>Clang, being based on LLVM, actually exposes one stage in between the <code class="language-plaintext highlighter-rouge">.cc</code> file and the <code class="language-plaintext highlighter-rouge">.s</code> file. You can ask it to skip doing codegen and emit a <code class="language-plaintext highlighter-rouge">.ll</code> file filled with LLVM IR, an intermediate between human-writable source code and assembly. The magic words to get this file are <code class="language-plaintext highlighter-rouge">clang -S -emit-llvm</code>. (The Rust equivalent is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir</code>.)</p> <p>The LLVM toolchain provides <code class="language-plaintext highlighter-rouge">llc</code>, the LLVM compiler, which performs the <code class="language-plaintext highlighter-rouge">.ll</code> -&gt; <code class="language-plaintext highlighter-rouge">.s</code> step (optionally assembling it, too). <code class="language-plaintext highlighter-rouge">lli</code> is an interpreter for the IR. Studying IR is mostly useful for understanding optimization behavior; topic for another day.</p> </blockquote> <p>The compiler, assembler, and linker are the central components of a toolchain. Other languages, like Rust, usually provide their own toolchain, or just a compiler, reusing the existing C/C++ toolchain. The assembler and linker are language agnostic.</p> <p>The toolchain also provides various debugging tools, including an interactive debugger, and tools for manipulating object files, such as <code class="language-plaintext highlighter-rouge">nm</code>, <code class="language-plaintext highlighter-rouge">objdump</code>, <code class="language-plaintext highlighter-rouge">objcopy</code>, and <code class="language-plaintext highlighter-rouge">ar</code>.</p> <p>These days, most of this stuff is bundled into a single program, the compiler frontend, which knows how to compiler, assemble, and link, in one invocation. You can ask Clang to spit out <code class="language-plaintext highlighter-rouge">.o</code> files with <code class="language-plaintext highlighter-rouge">clang -c</code>, and <code class="language-plaintext highlighter-rouge">.s</code> files with <code class="language-plaintext highlighter-rouge">clang -S</code>.</p> <blockquote> <h3 id="trs-nms"><a href="#trs-nms">Trs Nms</a></h3> <p>The UNIX crowd at Bell Labs was very excited about short, terse names. This tradition survives in Go’s somewhat questionable practice of single-letter variables.</p> <p>Most toolchain program names are cute contractions. <code class="language-plaintext highlighter-rouge">cc</code> is “C compiler”; compilers for almost all other languages follow this convention, like <code class="language-plaintext highlighter-rouge">rustc</code>, <code class="language-plaintext highlighter-rouge">javac</code>, <code class="language-plaintext highlighter-rouge">protoc</code>, and <code class="language-plaintext highlighter-rouge">scalac</code>; Clang is just <code class="language-plaintext highlighter-rouge">clang</code>, but is perfectly ok being called as <code class="language-plaintext highlighter-rouge">cc</code>.</p> <p><code class="language-plaintext highlighter-rouge">as</code> is “assembler”; <code class="language-plaintext highlighter-rouge">ld</code> is “loader” (you’ll learn why sooner). <code class="language-plaintext highlighter-rouge">ar</code> is “archiver”, <code class="language-plaintext highlighter-rouge">nm</code> is “names”. Other names tend to be a bit more sensible.</p> </blockquote> <h3 id="final-link"><a href="#final-link">Final Link</a></h3> <p>Some fifty years ago at Bell Labs, someone really wanted to write a program with more than one <code class="language-plaintext highlighter-rouge">.s</code> file. To solve this, a program that could “link” symbol references across object files was written: the first linker.</p> <p>You can take several <code class="language-plaintext highlighter-rouge">.o</code> files and use <code class="language-plaintext highlighter-rouge">ar</code> (an archaic <code class="language-plaintext highlighter-rouge">tar</code>, basically) to create a library, which always have names like <code class="language-plaintext highlighter-rouge">libfoo.a</code> (the <code class="language-plaintext highlighter-rouge">lib</code> is mandatory). A static library is just a collection of objects, which can be provided on an as-needed basis to the linker.</p> <p>The “final link” incorporates several <code class="language-plaintext highlighter-rouge">.o</code> files and <code class="language-plaintext highlighter-rouge">.a</code> files to produce an executable. It does roughly the following:</p> <ol> <li>Parse all the objects and static libraries and put their <em>symbols</em> into a database. Symbols are named addresses of functions and global variables.</li> <li>Search for all unresolved symbol references in the <code class="language-plaintext highlighter-rouge">.o</code> files and match it up with a symbol from the database, recursively doing this for any code in a <code class="language-plaintext highlighter-rouge">.a</code> referenced during this process. This forms a sort of dependency graph between sections. This step is called <em>symbol resolution</em>.</li> <li>Throw out any code that isn’t referenced by the input files by tracing the dependency graph from the entry-point symbol (e.g., <code class="language-plaintext highlighter-rouge">_start</code> on Linux). This step is called <em>garbage collection</em>.</li> <li>Execute the linker script to figure out how to stitch the final binary together. This includes discovering the offsets at which everything will go.</li> <li>Resolve <em>relocations</em>, “holes” in the binary that require knowing the final runtime address of the section. Relocations are instructions placed in the object file for the linker to execute.</li> <li>Write out the completed binary.</li> </ol> <p>This process is extremely memory-intensive; it is possible for colossal binaries, especially ones with tons of debug information, to “fail to link” because the linker exhausts the system’s memory.</p> <p>We only care about step 4; whole books can be written about the previous steps. Thankfully, Ian Lance Taylor, mad linker scientist and author of <code class="language-plaintext highlighter-rouge">gold</code>, has written several excellent words on this topic: <a href="https://lwn.net/Articles/276782/">https://lwn.net/Articles/276782/</a>.</p> <h2 id="object-files-and-sections"><a href="#object-files-and-sections">Object Files and Sections</a></h2> <p>Linkers, fundamentally, consume object files and produce object files; the output is executable, meaning that all relocations have been resolved and an entry-point address (where the OS/bootloader will jump to to start the binary).</p> <p>It’s useful to be able to peek into object files. The <code class="language-plaintext highlighter-rouge">objdump</code> utility is best for this. <code class="language-plaintext highlighter-rouge">objdump -x my_object.o</code> will show <em>all</em> headers, telling you what exactly is in it.</p> <p>At a high level, an object file describes how a program should be loaded into memory. The object is divided into sections, which are named blocks of data. Sections may have file-like permissions, such as allocatable, loadable, readonly, and executable. <code class="language-plaintext highlighter-rouge">objdump -h</code> can be used to show the list of sections. Some selected lines of output from <code class="language-plaintext highlighter-rouge">objdump</code> on my machine (I’m on a 64-bit machine, but I’ve trimmed leading zeros to make it all fit):</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-h</span> <span class="s2">"</span><span class="si">$(</span>which clang<span class="si">)</span><span class="s2">"</span>
<span class="go">/usr/bin/clang:     file format elf64-x86-64

Sections:
Idx Name    Size      VMA       LMA       File off  Algn
 11 .init   00000017  00691ab8  00691ab8  00291ab8  2**2
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt    00006bb0  00691ad0  00691ad0  00291ad0  2**4
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text   0165e861  00698680  00698680  00298680  2**4
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini   00000009  01cf6ee4  01cf6ee4  018f6ee4  2**2
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata 0018ec68  01cf6ef0  01cf6ef0  018f6ef0  2**4
            CONTENTS, ALLOC, LOAD, READONLY, DATA
 24 .data   000024e8  021cd5d0  021cd5d0  01dcc5d0  2**4
            CONTENTS, ALLOC, LOAD, DATA
 26 .bss    00009d21  021cfac0  021cfac0  01dceab8  2**4
            ALLOC
</span></code></pre></div></div> <p>Allocateable (<code class="language-plaintext highlighter-rouge">ALLOC</code>) sections must be <em>allocated</em> space by the operating system; if the section is loadable (<code class="language-plaintext highlighter-rouge">LOAD</code>), then the operating system must further fill that space with the contents of the section. This process is called <em>loading</em> and is performed by a <em>loader</em> program<sup id="fnref:bare-metal-loading" role="doc-noteref"><a href="#fn:bare-metal-loading" class="footnote" rel="footnote">7</a></sup>. The loader is sometimes called the “dynamic linker”, and is often the same program as the “program linker”; this is why the linker is called <code class="language-plaintext highlighter-rouge">ld</code>.</p> <p>Loading can also be done beforehand using the <code class="language-plaintext highlighter-rouge">binary</code> output format. This is useful for tiny microcontrollers that are too primitive to perform any loading. <code class="language-plaintext highlighter-rouge">objcopy</code> is useful for this and many other tasks that involve transforming object files.</p> <p>Some common (POSIX) sections include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">.text</code>, where your code lives<sup id="fnref:text-section" role="doc-noteref"><a href="#fn:text-section" class="footnote" rel="footnote">8</a></sup>. It’s usually a loadable, readonly, executable section.</li> <li><code class="language-plaintext highlighter-rouge">.data</code> contains the initial values of global variables. It’s loadable.</li> <li><code class="language-plaintext highlighter-rouge">.rodata</code> contains constants. It’s loadable and readonly.</li> <li><code class="language-plaintext highlighter-rouge">.bss</code> is an empty allocatable section<sup id="fnref:bss-section" role="doc-noteref"><a href="#fn:bss-section" class="footnote" rel="footnote">9</a></sup>. C specifies that uninitialized globals default to zero; this is a convenient way for avoiding storing a huge block of zeros in the executable!</li> <li>Debug sections that are not loaded or allocated; these are usually removed for release builds.</li> </ul> <p>After the linker decides which sections from the <code class="language-plaintext highlighter-rouge">.o</code> and <code class="language-plaintext highlighter-rouge">.a</code> inputs to keep (based on which symbols it decided it needed), it looks to the linker script how to arrange them in the output.</p> <p>Let’s write our first linker script!</p> <pre><code class="language-ld">SECTIONS {
  /* Define an output section ".text". */
  .text : {
    /* Pull in all symbols in input sections named .text */
    *(.text)
    /* Do the same for sections starting with .text.,
       such as .text.foo */
    *(.text.*)
  }

  /* Do the same for ".bss", ".rodata", and ".data". */
  .bss : { *(.bss); *(.bss.*) }
  .data : { *(.data); *(.data.*) }
  .rodata : { *(.rodata); *(.rodata.*) }
}
</code></pre> <p>This tells the linker to create a <code class="language-plaintext highlighter-rouge">.text</code> section in the output, which contains all sections named <code class="language-plaintext highlighter-rouge">.text</code> from all inputs, plus all sections with names like <code class="language-plaintext highlighter-rouge">.text.foo</code>. The content of the section is laid out in order: the contents of all <code class="language-plaintext highlighter-rouge">.text</code> sections will come before any <code class="language-plaintext highlighter-rouge">.text.*</code> sections; I don’t think the linker makes any promises about the ordering between different objects<sup id="fnref:order-sorting" role="doc-noteref"><a href="#fn:order-sorting" class="footnote" rel="footnote">10</a></sup>.</p> <p>As I mentioned before, parsers for linker script are fussy<sup id="fnref:comment-syntax" role="doc-noteref"><a href="#fn:comment-syntax" class="footnote" rel="footnote">11</a></sup>: the space in <code class="language-plaintext highlighter-rouge">.text :</code> is significant.</p> <p>Note that the two <code class="language-plaintext highlighter-rouge">.text</code> sections are different, and can have different names! The linker generally doesn’t care what a section is named; just its attributes. We could name it <code class="language-plaintext highlighter-rouge">code</code> if we wanted to; even the leading period is mere convention. Some object file formats don’t support arbitrary sections; all the sane ones (ELF, COFF, Mach-O) don’t care, but they don’t all spell it the same way; in Mach-O, you call it <code class="language-plaintext highlighter-rouge">__text</code>.</p> <p>Before continuing, I recommend looking at the <a href="#appendix">appendix</a> so that you have a clear path towards being able to run and test your linker scripts!</p> <blockquote> <h3 id="input-section-syntax"><a href="#input-section-syntax">Input Section Syntax</a></h3> <p>None of this syntax is used in practice but it’s useful to contextualize the syntax for pulling in a section. The full form of the syntax is</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>archive:object(section1 section2 ...)
</code></pre></div> </div> <p>Naturally, all of this is optional, so you can write <code class="language-plaintext highlighter-rouge">foo.o</code> or <code class="language-plaintext highlighter-rouge">libbar.a:(.text)</code> or <code class="language-plaintext highlighter-rouge">:baz.o(.text .data)</code>, where the last one means “not part of a library”. There’s even an <code class="language-plaintext highlighter-rouge">EXCLUDE_FILE</code> syntax for filtering by source object, and a <code class="language-plaintext highlighter-rouge">INPUT_SECTION_FLAGS</code> syntax for filtering by the presence of format-specific flags.</p> <p>Do not use any of this. Just write <code class="language-plaintext highlighter-rouge">*(.text)</code> and don’t think about it too hard. The <code class="language-plaintext highlighter-rouge">*</code> is just a glob for all objects.</p> </blockquote> <p>Each section has an <em>alignment</em>, which is just the maximum of the alignments of all input sections pulled into it. This is important for ensuring that code and globals are aligned the way the architecture expects them to be. The alignment of a section can be set explicitly with</p> <pre><code class="language-ld">SECTIONS {
  .super_aligned : ALIGN(16) {
    /* ... */
  }
}
</code></pre> <p>You can also instruct the linker to toss out sections using the special <code class="language-plaintext highlighter-rouge">/DISCARD/</code> output section, which overrides any decisions made at garbage-collection time. I’ve only ever used this to discard debug information that GCC was really excited about keeping around.</p> <p>On the other hand, you can use <code class="language-plaintext highlighter-rouge">KEEP(*(.text.*))</code> to ensure no <code class="language-plaintext highlighter-rouge">.text</code> sections are discarded by garbage-collection. Unfortunately, this doesn’t let you pull in sections from static libraries that weren’t referenced in the input objects.</p> <h3 id="lma-and-vma"><a href="#lma-and-vma">LMA and VMA</a></h3> <p>Every section has three addresses associated with it. The simplest is the file offset: how far from the start of the file to find the section.</p> <p>The <em>virtual memory address</em>, or VMA, is where the program expects to find the section at runtime. This is the address that is used by pointers and the program counter.</p> <p>The <em>load memory address</em>, or LMA, is where the loader (be it a runtime loader or <code class="language-plaintext highlighter-rouge">objcpy</code>) must place the code. This is almost always the same as the VMA. Later on, in <a href="#rom-ram-lma">Using Symbols and LMAs</a>, I’ll explain a place where this is actually useful.</p> <p>When declaring a new section, the VMA and LMA are both set to the value<sup id="fnref:dot-align" role="doc-noteref"><a href="#fn:dot-align" class="footnote" rel="footnote">12</a></sup> of the <em>location counter</em>, which has the <em>extremely</em> descriptive name <code class="language-plaintext highlighter-rouge">.</code><sup id="fnref:dot-in-asm" role="doc-noteref"><a href="#fn:dot-in-asm" class="footnote" rel="footnote">13</a></sup>. This counter is automatically incremented as data is copied from the input</p> <p>We can explicitly specify the VMA of a section by putting an expression before the colon, and the LMA by putting an expression in the <code class="language-plaintext highlighter-rouge">AT(lma)</code> specifier <em>after</em> the colon:</p> <pre><code class="language-ld">SECTIONS {
  .text 0x10008000: AT(0x40008000) {
    /* ... */
  }
}
</code></pre> <p>This will modify the location counter; you could also write it as</p> <pre><code class="language-ld">SECTIONS {
  . = 0x10008000;
  .text : AT(0x40008000) {
    /* ... */
  }
}
</code></pre> <p>Within <code class="language-plaintext highlighter-rouge">SECTIONS</code>, the location counter can be set at any point, even while in the middle of declaring a section (though the linker will probably complain if you do something rude like move it backwards).</p> <p>The location counter is incremented automatically as sections are added, so it’s rarely necessary to fuss with it directly.</p> <h2 id="memory-regions-and-section-allocation"><a href="#memory-regions-and-section-allocation">Memory Regions and Section Allocation</a></h2> <p>By default, the linker will simply allocate sections starting at address <code class="language-plaintext highlighter-rouge">0</code>. The <code class="language-plaintext highlighter-rouge">MEMORY</code> statement can be used to define <em>memory regions</em> for more finely controlling how VMAs and LMAs are allocated without writing them down explicitly.</p> <p>A classic example of a <code class="language-plaintext highlighter-rouge">MEMORY</code> block separates the address space into ROM and RAM:</p> <pre><code class="language-ld">MEMORY {
  rom (rx)   : ORIGIN = 0x8000,     LENGTH = 16K
  ram (rw!x) : ORIGIN = 0x10000000, LENGTH = 256M
}
</code></pre> <p>A region is a block of memory with a name and some attributes. The name is irrelevant beyond the scope of the linker script. The attributes in parens are used to specify what sections could conceivably go in that region. A section is compatible if it has any of the attributes before the <code class="language-plaintext highlighter-rouge">!</code>, and none which come after the <code class="language-plaintext highlighter-rouge">!</code>. (This filter mini-language isn’t very expressive.)</p> <p>The attributes are the ones we mentioned earlier: <code class="language-plaintext highlighter-rouge">rwxal</code> are readonly, read/write, executable, allocated, and loadable<sup id="fnref:attrs-in-asm" role="doc-noteref"><a href="#fn:attrs-in-asm" class="footnote" rel="footnote">14</a></sup>.</p> <p>When allocating a section a VMA, the linker will try to pick the best memory region that matches the filter using a heuristic. I don’t really trust the heuristic, but you can instead write <code class="language-plaintext highlighter-rouge">&gt; region</code> to put something into a specific region. Thus,</p> <pre><code class="language-ld">SECTION {
  .data {
    /* ... */
  } &gt; ram AT&gt; rom
}
</code></pre> <p><code class="language-plaintext highlighter-rouge">AT&gt;</code> is the “obvious” of <code class="language-plaintext highlighter-rouge">AT()</code> and <code class="language-plaintext highlighter-rouge">&gt;</code>, and sets which region to allocate the LMA from.</p> <p>The origin and length of a region can be obtained with the <code class="language-plaintext highlighter-rouge">ORIGIN(region)</code> and <code class="language-plaintext highlighter-rouge">LENGTH(region)</code> functions.</p> <h2 id="other-stuff-to-put-in-sections"><a href="#other-stuff-to-put-in-sections">Other Stuff to Put In Sections</a></h2> <p>Output sections can hold more than just input sections. Arbitrary data can be placed into sections using the <code class="language-plaintext highlighter-rouge">BYTE</code>, <code class="language-plaintext highlighter-rouge">SHORT</code>, <code class="language-plaintext highlighter-rouge">LONG</code> and <code class="language-plaintext highlighter-rouge">QUAD</code> for placing literal 8, 16, 32, and 64-bit unsigned integers into the section:</p> <pre><code class="language-ld">SECTIONS {
  .screams_internally : { LONG(0xaaaaaaaa) }
}
</code></pre> <p>Numeric literals in linker script may, conveniently, be given the suffixes <code class="language-plaintext highlighter-rouge">K</code> or <code class="language-plaintext highlighter-rouge">M</code> to specify a kilobyte or megabyte quantity. E.g., <code class="language-plaintext highlighter-rouge">4K</code> is sugar for <code class="language-plaintext highlighter-rouge">4096</code>.</p> <h3 id="fill"><a href="#fill">Fill</a></h3> <p>You can fill the unused portions of a section by using the <code class="language-plaintext highlighter-rouge">FILL</code> command, which sets the “fill pattern” from that point onward. For example, we can create four kilobytes of <code class="language-plaintext highlighter-rouge">0xaa</code> using <code class="language-plaintext highlighter-rouge">FILL</code> and the location counter:</p> <pre><code class="language-ld">SECTIONS {
  .scream_page : {
    FILL(0xaa)
    . += 4K;
  }
}
</code></pre> <p>The “fill pattern” is used to fill any unspecified space, such as alignment padding or jumping around with the location counter. We can use multiple FILLs to vary the fill pattern, such as if we wanted half the page to be <code class="language-plaintext highlighter-rouge">0x0a</code> and half <code class="language-plaintext highlighter-rouge">0xa0</code>:</p> <pre><code class="language-ld">SECTIONS {
  .scream_page : {
    FILL(0x0a)
    . += 2K;
    FILL(0xa0)
    . += 2K;
  }
}
</code></pre> <p>When using one fill pattern for the whole section, you can just write <code class="language-plaintext highlighter-rouge">= fill;</code> at the end of the section. For example,</p> <pre><code class="language-ld">SECTIONS {
  .scream_page : {
    . += 4K;
  } = 0xaa;
}
</code></pre> <h3 id="linker-symbols"><a href="#linker-symbols">Linker Symbols</a></h3> <p>Although the linker needs to resolve all symbols using the input <code class="language-plaintext highlighter-rouge">.o</code> and <code class="language-plaintext highlighter-rouge">.a</code> files, you can also declare symbols directly in linker script; this is the absolute latest that symbols can be provided. For example:</p> <pre><code class="language-ld">SECTIONS {
  my_cool_symbol = 5;
}
</code></pre> <p>This will define a new symbol with value <code class="language-plaintext highlighter-rouge">5</code>. If we then wrote <code class="language-plaintext highlighter-rouge">extern char my_cool_symbol;</code>, we can access the value placed by the linker. However, note that the value of a symbol is an <em>address</em>! If you did</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">char</span> <span class="n">my_cool_symbol</span><span class="p">;</span>

<span class="kt">uintptr_t</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">my_cool_symbol</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>the processor would be very confused about why you just dereferenced a pointer with address <code class="language-plaintext highlighter-rouge">5</code>. The <em>correct</em> way to extract a linker symbol’s value is to write</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">char</span> <span class="n">my_cool_symbol</span><span class="p">;</span>

<span class="kt">uintptr_t</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">my_cool_symbol</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>It seems a bit silly to take the address of the global and use that as some kind of magic value, but that’s just how it works. The exact same mechanism works in Rust, too:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="nd">#[link_name</span> <span class="nd">=</span> <span class="s">"my_cool_symbol"</span><span class="nd">]</span>
    <span class="k">static</span> <span class="n">SYM</span><span class="p">:</span> <span class="nb">u8</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">addr_of!</span><span class="p">(</span><span class="n">SYM</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div> <p>The most common use of this mechanism is percolating information not known until link time. For example, a common idiom is</p> <pre><code class="language-ld">SECTIONS {
  .text : {
    __text_start = .;
    /* stuff */
    __text_end = .;
  }
}
</code></pre> <p>This allows initialization code to find the section’s address and length; in this case, the pointer values are actually meaningful!</p> <blockquote> <h3 id="wunderbars"><a href="#wunderbars">Wunderbars</a></h3> <p>It’s common practice to lead linker symbols with two underscores, because C declares a surprisingly large class of symbols reserved for the implementation, so normal user code won’t call them. These include names like <code class="language-plaintext highlighter-rouge">__text_start</code>, which start with two underscores, and names starting with an underscore and an uppercase letter, like <code class="language-plaintext highlighter-rouge">_Atomic</code>.</p> <p>However, libc and STL headers will totally use the double underscore symbols to make them resistant to tampering by users (which they are entitled to), so beware!</p> </blockquote> <p>Symbol assignments can even go inside of a section, to capture the location counter’s value between input sections:</p> <pre><code class="language-ld">SECTIONS {
  .text : {
    *(.text)
    text_middle = .;
    *(.text.*)
  }
}
</code></pre> <p>Symbol names are not limited to C identifiers, and may contain dashes, periods, dollar signs, and other symbols. They may even be quoted, like <code class="language-plaintext highlighter-rouge">"this symbol has spaces"</code>, which C will never be able to access as an <code class="language-plaintext highlighter-rouge">extern</code>.</p> <p>There is a mini-language of expressions that symbols can be assigned to. This includes:</p> <ul> <li>Numeric literals like <code class="language-plaintext highlighter-rouge">42</code>, <code class="language-plaintext highlighter-rouge">0xaa</code>, and <code class="language-plaintext highlighter-rouge">4K</code>.</li> <li>The location counter, <code class="language-plaintext highlighter-rouge">.</code>.</li> <li>Other symbols.</li> <li>The usual set of C operators, such as arithmetic and bit operations. Xor is curiously missing.</li> <li>A handful of builtin functions, described below.</li> </ul> <p>There are some fairly complicated rules around how symbols may be given relative addresses to the start of a section, which are only relevant when dealing with position-independent code: <a href="https://sourceware.org/binutils/docs/ld/Expression-Section.html">https://sourceware.org/binutils/docs/ld/Expression-Section.html</a></p> <p>Functions belong to one of two board categories: getters for properties of sections, memory regions, and other linker structures; and arithmetic. Useful functions include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">ADDR</code>, <code class="language-plaintext highlighter-rouge">LOADADDR</code>, <code class="language-plaintext highlighter-rouge">SIZEOF</code>, and <code class="language-plaintext highlighter-rouge">ALIGNOF</code>, which produce the VMA, LMA, size, and alignment of a previously defined section.</li> <li><code class="language-plaintext highlighter-rouge">ORIGIN</code> and <code class="language-plaintext highlighter-rouge">LENGTH</code>, which produce the start address and length of a memory region.</li> <li><code class="language-plaintext highlighter-rouge">MAX</code>, <code class="language-plaintext highlighter-rouge">MIN</code> are obvious; <code class="language-plaintext highlighter-rouge">LOG2CEIL</code> computes the base-2 log, rounded up.</li> <li><code class="language-plaintext highlighter-rouge">ALIGN(expr, align)</code> rounds <code class="language-plaintext highlighter-rouge">expr</code> to the next multiple of <code class="language-plaintext highlighter-rouge">align</code>. <code class="language-plaintext highlighter-rouge">ALIGN(align)</code> is roughly equivalent to <code class="language-plaintext highlighter-rouge">ALIGN(., align)</code> with some subtleties around PIC. <code class="language-plaintext highlighter-rouge">. = ALIGN(align);</code> will align the location counter to <code class="language-plaintext highlighter-rouge">align</code>.</li> </ul> <p>Some other builtins can be found at <a href="https://sourceware.org/binutils/docs/ld/Builtin-Functions.html">https://sourceware.org/binutils/docs/ld/Builtin-Functions.html</a>.</p> <p>A symbol definition can be wrapped in the <code class="language-plaintext highlighter-rouge">PROVIDEO()</code> function to make it “weak”, analogous to the “weak symbol” feature found in Clang. This means that the linker will not use the definition if any input object defines it.</p> <h3 id="rom-ram-lma"><a href="#rom-ram-lma">Using Symbols and LMAs</a></h3> <p>As mentioned before, it is extremely rare for the LMA and VMA to be different. The most common situation where this occurs is when you’re running on a system, like a microcontroller, where memory is partitioned into two pieces: ROM and RAM. The ROM has the executable burned into it, and RAM starts out full of random garbage.</p> <p>Most of the contents of the linked executable are read-only, so their VMA can be in ROM. However, the <code class="language-plaintext highlighter-rouge">.data</code> and <code class="language-plaintext highlighter-rouge">.bss</code> sections need to lie in RAM, because they’re writable. For <code class="language-plaintext highlighter-rouge">.bss</code> this is easy, because it doesn’t have loadable content. For <code class="language-plaintext highlighter-rouge">.data</code>, though, we need to separate the VMA and LMA: the VMA must go in RAM, and the LMA in ROM.</p> <p>This distinction is important for the code that initializes the RAM: while for <code class="language-plaintext highlighter-rouge">.bss</code> all it has to do is zero it, for <code class="language-plaintext highlighter-rouge">.data</code>, it has to copy from ROM to RAM! The LMA lets us distinguish the copy source and the copy destination.</p> <p>This has the important property that it tells the loader (usually <code class="language-plaintext highlighter-rouge">objcopy</code> in this case) to use the ROM addresses for actually loading the section to, but to link the code as if it were at a RAM address (which is needed for things like PC-relative loads to work correctly).</p> <p>Here’s how we’d do it in linker script:</p> <pre><code class="language-ld">MEMORY {
  rom : /* ... */
  ram : /* ... */
}

SECTIONS {
  /* .text and .rodata just go straight into the ROM. We don't need
     to mutate them ever. */
  .text : { *(.text) } &gt; rom
  .rodata : { *(.rodata) } &gt; rom

  /* .bss doesn't have any "loadable" content, so it goes straight
     into RAM. We could include `AT&gt; rom`, but because the sections
     have no content, it doesn't matter. */
  .bss : { *(.bss) } &gt; ram

  /* As described above, we need to get a RAM VMA but a ROM LMA;
     the &gt; and AT&gt; operators achieve this. */
  .data : { *(.data) } &gt; ram AT&gt; rom
}

/* The initialization code will need some symbols to know how to
   zero the .bss and copy the initial .data values. We can use the
   functions from the previous section for this! */

bss_start = ADDR(.bss);
bss_end = bss_start + SIZEOF(.bss);

data_start = ADDR(.data);
data_end = data_start + SIZEOF(.data);

rom_data_start = LOADADDR(.data);
</code></pre> <p>Although we would normally write the initialization code in assembly (since it’s undefined behavior to execute C before initializing the <code class="language-plaintext highlighter-rouge">.bss</code> and <code class="language-plaintext highlighter-rouge">.data</code> sections), I’ve written it in C for illustrative purposes:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">bss_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">bss_end</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">data_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">data_end</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">rom_data_start</span><span class="p">[];</span>

<span class="kt">void</span> <span class="nf">init_sections</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Zero the .bss.</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">bss_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bss_end</span> <span class="o">-</span> <span class="n">bss_start</span><span class="p">);</span>

  <span class="c1">// Copy the .data values from ROM to RAM.</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">data_start</span><span class="p">,</span> <span class="n">rom_data_start</span><span class="p">,</span> <span class="n">data_end</span> <span class="o">-</span> <span class="n">data_start</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="misc-linker-script-features"><a href="#misc-linker-script-features">Misc Linker Script Features</a></h2> <p>Linker script includes a bunch of other commands that don’t fit into a specific category:</p> <ul> <li><code class="language-plaintext highlighter-rouge">ENTRY()</code> sets the program entry-point, either as a symbol or a raw address. The <code class="language-plaintext highlighter-rouge">-e</code> flag can be used to override it. The <code class="language-plaintext highlighter-rouge">ld</code> docs assert that there are fallbacks if an entry-point can’t be found, but in my experience you can sometimes get errors here. <code class="language-plaintext highlighter-rouge">ENTRY(_start)</code> would use the <code class="language-plaintext highlighter-rouge">_start</code> symbol, for example<sup id="fnref:not-main" role="doc-noteref"><a href="#fn:not-main" class="footnote" rel="footnote">15</a></sup>.</li> <li><code class="language-plaintext highlighter-rouge">INCLUDE "path/to/file.ld"</code> is <code class="language-plaintext highlighter-rouge">#include</code> but for linker script.</li> <li><code class="language-plaintext highlighter-rouge">INPUT(foo.o)</code> will add <code class="language-plaintext highlighter-rouge">foo.o</code> as a linker input, as if it was passed at the commandline. <code class="language-plaintext highlighter-rouge">GROUP</code> is similar, but with the semantics of <code class="language-plaintext highlighter-rouge">--start-group</code>.</li> <li><code class="language-plaintext highlighter-rouge">OUTPUT()</code> overrides the usual <code class="language-plaintext highlighter-rouge">a.out</code> default output name.</li> <li><code class="language-plaintext highlighter-rouge">ASSERT()</code> provides static assertions.</li> <li><code class="language-plaintext highlighter-rouge">EXTERN(sym)</code> causes the linker to behave as if an undefined reference to <code class="language-plaintext highlighter-rouge">sym</code> existed in an input object.</li> </ul> <p>(Other commands are documented, but I’ve never needed them in practice.)</p> <h2 id="real-linker-scripts"><a href="#real-linker-scripts">Real Linker Scripts</a></h2> <p>It may be useful to look at some real-life linker scripts.</p> <p>If you wanna see what Clang, Rust, and the like all ultimately use, run <code class="language-plaintext highlighter-rouge">ld --verbose</code>. This will print the default linker script for your machine; this is a really intense script that uses basically every feature available in linker script (and, since it’s GNU, is very poorly formatted).</p> <p>The Linux kernel also has linker scripts, which are differently intense, because they use the C preprocessor. For example, the one for amd64: <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S">https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S</a>.</p> <p>Tock OS, a secure operating system written in Rust, has some pretty solid linker scripts, with lots of comments: <a href="https://github.com/tock/tock/blob/master/boards/kernel_layout.ld">https://github.com/tock/tock/blob/master/boards/kernel_layout.ld</a>. I recommend taking a look to see what a “real” but not too wild linker script looks like. There’s a fair bit of toolchain-specific stuff in there, too, that should give you an idea of what to expect.</p> <p>Happy linking!</p> <hr/> <h2 id="appendix"><a href="#appendix">Appendix: A Linker Playground</a></h2> <p>tl;dr: If you don’t wanna try out any examples, skip this section.</p> <p>I want you to be able to try out the examples above, but there’s no Godbolt for linker scripts (yet!). Unlike normal code, you can’t just run linker script through a compiler, you’re gonna need some objects to link, too! Let’s set up a very small C project for testing your linker scripts.</p> <blockquote> <p>Note: I’m assuming you’re on Linux, with x86_64, and using Clang. If you’re on a Mac (even M1), you can probably make <code class="language-plaintext highlighter-rouge">ld64</code> do the right thing, but this is outside of what I’m an expert on.</p> <p>If you’re on Windows, use WSL. I have no idea how MSCV does linker scripts at all.</p> </blockquote> <p>First, we want a very simple static library:</p> <p>```c filename:extern.c godbolt: int lib_call(const char* str) { // Discard <code class="language-plaintext highlighter-rouge">str</code>, we just want to take any argument. (void)str;</p> <p>// This will go in <code class="language-plaintext highlighter-rouge">.bss</code>. static int count; return count++; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Compile `extern.c` into a static library like so:

```shell
clang -c extern.c
ar rc libextern.a extern.o
</code></pre></div></div> <p>We can check out that we got something reasonable by using <code class="language-plaintext highlighter-rouge">nm</code>. The <code class="language-plaintext highlighter-rouge">nm</code> program shows you all the symbols a library or object defines.</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>nm libextern.a
<span class="go">extern.o:
0000000000000000 T lib_call
0000000000000000 b lib_call.count
</span></code></pre></div></div> <p>This shows us the address, section type, and name of each symbol; <code class="language-plaintext highlighter-rouge">man nm</code> tells us that <code class="language-plaintext highlighter-rouge">T</code> means <code class="language-plaintext highlighter-rouge">.text</code> and <code class="language-plaintext highlighter-rouge">b</code> means <code class="language-plaintext highlighter-rouge">.bss</code>. Capital letters mean that the symbol is <em>exported</em>, so the linker can use it to resolve a symbol reference or a relocation. In C/C++, symbols declared <code class="language-plaintext highlighter-rouge">static</code> or in an unnamed namespace are “hidden”, and can’t be referenced outside of the object. This is sometimes called internal vs external linkage.</p> <p>Next, we need a C program that uses the library:</p> <p>```c filename:run.c godbolt: extern int lib_call(const char* str);</p> <p>// We’re gonna use a custom entrypoint. This code will never run anyways, we // just care about the linker output. void run(void) { // This will go in <code class="language-plaintext highlighter-rouge">.data</code>, because it’s initialized to non-zero. static int data = 5;</p> <p>// The string-constant will go into <code class="language-plaintext highlighter-rouge">.rodata</code>. data = lib_call(“Hello from .rodata!”); }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Compile it with `clang -c run.c`. We can inspect the symbol table with `nm` as
before:

```terminal
$ nm run.o
                 U lib_call
0000000000000000 T run
0000000000000000 d run.data
</code></pre></div></div> <p>As you might guess, <code class="language-plaintext highlighter-rouge">d</code> is just <code class="language-plaintext highlighter-rouge">.data</code>. However, <code class="language-plaintext highlighter-rouge">U</code> is interesting: it’s an undefined symbol, meaning the linker will need to perform a symbol resolution! In fact, if we ask Clang to link this for us (it just shells out to a linker like <code class="language-plaintext highlighter-rouge">ld</code>):</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>clang run.o
<span class="go">/usr/bin/ld: /somewhere/crt1.o: in function `_start':
(.text+0x20): undefined reference to `main'
/usr/bin/ld: run.o: in function `run':
run.c:(.text+0xf): undefined reference to `lib_call'
</span></code></pre></div></div> <p>The linker also complains that there’s no <code class="language-plaintext highlighter-rouge">main()</code> function, and that some object we didn’t provide called <code class="language-plaintext highlighter-rouge">crt1.o</code> wants it. This is the startup code for the C runtime; we can skip linking it with <code class="language-plaintext highlighter-rouge">-nostartfiles</code>. This will result in the linker picking an entry point for us.</p> <p>We can resolve the missing symbol by linking against our library. <code class="language-plaintext highlighter-rouge">-lfoo</code> says to search for the library <code class="language-plaintext highlighter-rouge">libfoo.a</code>; <code class="language-plaintext highlighter-rouge">-L.</code> says to include the current directory for searching for libraries.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang run.o <span class="nt">-L</span><span class="nb">.</span> <span class="nt">-lextern</span> <span class="nt">-nostartfiles</span>
</code></pre></div></div> <p>This gives us our binary, <code class="language-plaintext highlighter-rouge">a.out</code>, which we can now <code class="language-plaintext highlighter-rouge">objdump</code>:</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-d</span> <span class="nt">-Mintel</span> a.out
<span class="go">
a.out:     file format elf64-x86-64


Disassembly of section .text:

</span><span class="gp">0000000000401000 &lt;run&gt;</span>:
<span class="go">  401000:  55                      push   rbp
  401001:  48 89 e5                mov    rbp,rsp
  401004:  48 bf 00 20 40 00 00    movabs rdi,0x402000
  40100b:  00 00 00 
</span><span class="gp">  40100e:  e8 0d 00 00 00          call   401020 &lt;lib_call&gt;</span><span class="w">
</span><span class="go">  401013:  89 04 25 00 40 40 00    mov    DWORD PTR ds:0x404000,eax
  40101a:  5d                      pop    rbp
  40101b:  c3                      ret    
  40101c:  0f 1f 40 00             nop    DWORD PTR [rax+0x0]

</span><span class="gp">0000000000401020 &lt;lib_call&gt;</span>:
<span class="go">  401020:  55                      push   rbp
  401021:  48 89 e5                mov    rbp,rsp
  401024:  48 89 7d f8             mov    QWORD PTR [rbp-0x8],rdi
  401028:  8b 04 25 04 40 40 00    mov    eax,DWORD PTR ds:0x404004
  40102f:  89 c1                   mov    ecx,eax
  401031:  83 c1 01                add    ecx,0x1
  401034:  89 0c 25 04 40 40 00    mov    DWORD PTR ds:0x404004,ecx
  40103b:  5d                      pop    rbp
  40103c:  c3                      ret    
</span></code></pre></div></div> <p>Let’s write up the simplest possible linker script for all this:</p> <p>```ld filename:link.ld ENTRY(run) SECTIONS { .text : { <em>(.text); *(.text.</em>) } .bss : { <em>(.bss); *(.bss.</em>) } .data : { <em>(.data); *(.data.</em>) } .rodata : { <em>(.rodata); *(.rodata.</em>) } }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Let's link! We'll also want to make sure that the system libc doesn't get in
the way, using `-nostdlib`[^libgcc_s].

[^libgcc_s]:
    If you include libc, you will get bizarre errors involving something called
    "`gcc_s`". `libgcc` (and `libgcc_s`) is GCC's *compiler runtime* library.
    Where `libc` exposes high-level operations on the C runtime and utilities
    for manipulating common objects, `libgcc` provides even lower-level support,
    including:
    - Polyfills for arithmetic operations not available on the target. For
      example, dividing two 64-bit integers on most 32-bit targets will emit a
      reference to the a symbol like `__udivmoddi4` (they all have utterly
      incomprehensible names like this one).
    - Soft-float implementations, i.e., IEEE floats implemented in software for
      targets without an FPU.
    - Bits of unwinding (e.g. exceptions and panics) support (the rest is in
      `libunwind`).
    - Miscellaneous runtime support code, such as the code that calls C++ static
      initializers.

    Clang's version, `libcompiler-rt`, is ABI-compatible with `libgcc` and
    provides various support for profiling, sanitizers, and many, many other
    things the compiler needs available for compiling code.

```shell
clang run.o -L. -lextern -nostartfiles -nostdlib -Wl,-T,link.ld
</code></pre></div></div> <p>At this point, you can use <code class="language-plaintext highlighter-rouge">objdump</code> to inspect <code class="language-plaintext highlighter-rouge">a.out</code> at your leisure! You’ll notice there are a few other sections, like <code class="language-plaintext highlighter-rouge">.eh_frame</code>. Clang adds these by default, but you can throw them out using <code class="language-plaintext highlighter-rouge">/DISCARD/</code>.</p> <p>It’s worth it to run the examples in the post through the linker using this “playground”. You can actually control the sections Clang puts symbols into using the <code class="language-plaintext highlighter-rouge">__attribute__((section("blah")))</code> compiler extension. The Rust equivalent is <code class="language-plaintext highlighter-rouge">#[link_section = "blah"]</code>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:linker-flag" role="doc-endnote"> <p>Blame GCC for this. <code class="language-plaintext highlighter-rouge">-Wl</code> feeds arguments through to the linker, and <code class="language-plaintext highlighter-rouge">-T</code> is <code class="language-plaintext highlighter-rouge">ld</code>’s linker script input flag. Thankfully, rustc is far more sensible here: <code class="language-plaintext highlighter-rouge">-Clink-args=-Wl,-T,foo.ld</code> (when GCC/Clang is your linker frontend). <a href="#fnref:linker-flag" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:etymology-of-s" role="doc-endnote"> <p>Correction, 2022-09-11. I have really been bothered by not knowing if this is actually true, and have periodically asked around about it. I asked Russ Cox, who was actually <em>at</em> Bell Labs back in the day, and he asked Ken Thompson, who confirms: it’s genuinely <code class="language-plaintext highlighter-rouge">.s</code> for source, because it was the only source they had back then.</p> <p>I am glad I got this from the horse’s mouth. :) <a href="#fnref:etymology-of-s" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:clang-languages" role="doc-endnote"> <p>And many other things, like Objective-C. <a href="#fnref:clang-languages" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:object-what" role="doc-endnote"> <p>Completely and utterly unrelated to the objects of object-oriented programming. Best I can tell, the etymology is lost to time. <a href="#fnref:object-what" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:aout" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">a.out</code> is <em>also</em> an object file format, like ELF, but toolchains live and die by tradition, so that’s the name given to the linker’s output by default. <a href="#fnref:aout" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rust-objects" role="doc-endnote"> <p>Rust does not compile each <code class="language-plaintext highlighter-rouge">.rs</code> file into an object, and its “crates” are much larger than the average C++ translation unit. However, the Rust compiler will nonetheless produce many object files for a single crate, precisely for the benefit of this compilation model. <a href="#fnref:rust-objects" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:bare-metal-loading" role="doc-endnote"> <p>Operating systems are loaded by a bootloader. Bootloaders are themselves loaded by other bootloaders, such as the BIOS. At the bottom of the turtles is the mask ROM, which is a tiny bootloader permanently burned into the device. <a href="#fnref:bare-metal-loading" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:text-section" role="doc-endnote"> <p>No idea on the etymology. This isn’t ASCII text! <a href="#fnref:text-section" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:bss-section" role="doc-endnote"> <p>Back in the 50s, this stood for “block started by symbol”. <a href="#fnref:bss-section" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:order-sorting" role="doc-endnote"> <p>Yes, yes, you can write <code class="language-plaintext highlighter-rouge">SORT_BY_NAME(*)(.text)</code> but that’s not really something you ever wind up needing.</p> <p>See <a href="https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html">https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html</a> for more information on this. <a href="#fnref:order-sorting" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:comment-syntax" role="doc-endnote"> <p>You only get <code class="language-plaintext highlighter-rouge">/* */</code> comment syntax because that’s the lowest common denominator. <a href="#fnref:comment-syntax" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:dot-align" role="doc-endnote"> <p>Well, <code class="language-plaintext highlighter-rouge">.</code> actually gets increased to the alignment of the section first. If you insist on an unaligned section, the syntax is, obviously,</p> <pre><code class="language-ld">SECTIONS {
  .unaligned .: {
    /* ... */
  }
}
</code></pre> <p>(That was sarcasm. It must be stressed that this is not a friendly language.) <a href="#fnref:dot-align" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:dot-in-asm" role="doc-endnote"> <p>This symbol is also available in assembly files. <code class="language-plaintext highlighter-rouge">jmp .</code> is an overly-cute idiom for an infinity busy loop. It is even more terse in ARM and RISC-V, where it’s written <code class="language-plaintext highlighter-rouge">b .</code> and <code class="language-plaintext highlighter-rouge">j .</code>, respectively.</p> <p>Personally, I prefer the obtuse clarity of <code class="language-plaintext highlighter-rouge">loop_forever: j loop_forever</code>. <a href="#fnref:dot-in-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:attrs-in-asm" role="doc-endnote"> <p>These are the same characters used to declare a section in assembly. If I wanted to place my code in a section named <code class="language-plaintext highlighter-rouge">.crt0</code> but wanted it to be placed into a readonly, executable memory block, use the the assembler directive <code class="language-plaintext highlighter-rouge">.section .crt0, rxal</code> <a href="#fnref:attrs-in-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:not-main" role="doc-endnote"> <p>Note that the entry point is almost never a function called <code class="language-plaintext highlighter-rouge">main()</code>. In the default configuration of most toolchains, an object called <code class="language-plaintext highlighter-rouge">crt0.o</code> is provided as part of the libc, which provides a <code class="language-plaintext highlighter-rouge">_start()</code> function that itself calls <code class="language-plaintext highlighter-rouge">main()</code>. CRT stands for “C runtime”; thus, <code class="language-plaintext highlighter-rouge">crt0.o</code> initializes the C runtime.</p> <p>This file contains the moral equivalent of the following C code, which varies according to target:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
<span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">init_libc</span><span class="p">();</span>    <span class="c1">// Initializes global libc state.</span>
  <span class="n">run_ctors</span><span class="p">();</span>    <span class="c1">// Runs all library constructors.</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">main</span><span class="p">(</span><span class="n">get_argc</span><span class="p">(),</span> <span class="n">get_argv</span><span class="p">());</span>
  <span class="n">run_dtors</span><span class="p">();</span>    <span class="c1">// Runs all library destructors.</span>
  <span class="n">cleanup_libc</span><span class="p">();</span> <span class="c1">// Deinitializes the libc.</span>
  
  <span class="n">exit</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="c1">// Asks the OS to gracefully destroy the process.</span>
<span class="p">}</span>
</code></pre></div> </div> <p>This behavior can be disabled with <code class="language-plaintext highlighter-rouge">-nostartfiles</code> in Clang. The OSDev wiki has some on this topic: <a href="https://wiki.osdev.org/Creating_a_C_Library#Program_Initialization">https://wiki.osdev.org/Creating_a_C_Library#Program_Initialization</a>. <a href="#fnref:not-main" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2021-06-01 • 4785 words • 26 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#linkers">#linkers</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2021/06/01/linker-script/"> Everything You Never Wanted To Know About Linker Script </a></h1> </div> <div class="post"> <p>Low level software usually has lots of <code class="language-plaintext highlighter-rouge">.cc</code> or <code class="language-plaintext highlighter-rouge">.rs</code> files. Even lower-level software, like your cryptography library, probably has <code class="language-plaintext highlighter-rouge">.S</code> containing assembly, my least favorite language for code review.</p> <p>The lowest level software out there, firmware, kernels, and drivers, have one third file type to feed into the toolchain: an <code class="language-plaintext highlighter-rouge">.ld</code> file, a “linker script”. The linker script, provided to Clang as <code class="language-plaintext highlighter-rouge">-Wl,-T,foo.ld</code><sup id="fnref:linker-flag" role="doc-noteref"><a href="#fn:linker-flag" class="footnote" rel="footnote">1</a></sup>, is like a template for the final executable. It tells the linker how to organize code from the input objects. This permits extremely precise control over the toolchain’s output.</p> <p>Very few people know how to write linker script; it’s a bit of an obscure skill. Unfortunately, I’m one of them, so I get called to do it on occasion. Hopefully, this post is a good enough summary of the linker script language that you, too, can build your own binary!</p> <p>Everything in this post can be found in excruciating detail in <a href="https://sourceware.org/binutils/docs/ld/index.html">GNU <code class="language-plaintext highlighter-rouge">ld</code>’s documentation</a>; <code class="language-plaintext highlighter-rouge">lld</code> accepts basically the same syntax. There’s no spec, just what your linker happens to accept. I will, however, do my best to provide a more friendly introduction.</p> <p>No prior knowledge of how toolchains work is necessary! Where possible, I’ve tried to provide historical context on the names of everything. Toolchains are, unfortunately, bound by half a century of tradition. Better to at least know why they’re called that.</p> <blockquote> <h3 id="wait-an-s-file"><a href="#wait-an-s-file">Wait, an <code class="language-plaintext highlighter-rouge">.S</code> file?</a></h3> <p>On Windows, assembly files use the sensible <code class="language-plaintext highlighter-rouge">.asm</code> extension. POSIX we use the <code class="language-plaintext highlighter-rouge">.s</code> extension, or <code class="language-plaintext highlighter-rouge">.S</code> when we’d like Clang to run the C preprocessor on them (virtually all hand-written assembly is of the second kind).</p> <p>I don’t actually have a historical citation<sup id="fnref:etymology-of-s" role="doc-noteref"><a href="#fn:etymology-of-s" class="footnote" rel="footnote">2</a></sup> for <code class="language-plaintext highlighter-rouge">.s</code>, other than that it came from the Unix tradition of obnoxiously terse names. If we are to believe that <code class="language-plaintext highlighter-rouge">.o</code> stands for “object”, and <code class="language-plaintext highlighter-rouge">.a</code> stands for “archive”, then <code class="language-plaintext highlighter-rouge">.s</code> must stand for “source”, up until the B compiler replaced them with <code class="language-plaintext highlighter-rouge">.b</code> files! See <a href="http://man.cat-v.org/unix-1st/1/b">http://man.cat-v.org/unix-1st/1/b</a>.</p> <p>A final bit of trivia: <code class="language-plaintext highlighter-rouge">.C</code> files are obviously different from <code class="language-plaintext highlighter-rouge">.c</code> files… they’re C++ files! (Seriously, try it.)</p> </blockquote> <blockquote> <p>Note: This post is specifically about POSIX. I know basically nothing about MSVC and <code class="language-plaintext highlighter-rouge">link.exe</code> other than that they exist. The most I’ve done is helped people debug trivial <code class="language-plaintext highlighter-rouge">__declspec</code> issues.</p> <p>I will also only be covering things specific to linking an executable; linking other outputs, like shared libraries, is beyond this post.</p> </blockquote> <h2 id="seriously-whats-a-linker"><a href="#seriously-whats-a-linker">Seriously, What’s a linker?</a></h2> <p>A linker is but a small part of a <em>toolchain</em>, the low-level programmer’s toolbox: everything you need to go from source code to execution.</p> <p>The crown jewel of any toolchain is the compiler. The LLVM toolchain, for example, includes Clang, a C/C++<sup id="fnref:clang-languages" role="doc-noteref"><a href="#fn:clang-languages" class="footnote" rel="footnote">3</a></sup> compiler. The compiler takes source code, such as <code class="language-plaintext highlighter-rouge">.cc</code>, and lowers it down to a <code class="language-plaintext highlighter-rouge">.s</code> file, an <em>assembly file</em> which textually describes machine code for a specific architecture (you can also write them yourself).</p> <p>Another toolchain program, the assembler, <em>assembles</em> each <code class="language-plaintext highlighter-rouge">.s</code> into a <code class="language-plaintext highlighter-rouge">.o</code> file, an <em>object file</em><sup id="fnref:object-what" role="doc-noteref"><a href="#fn:object-what" class="footnote" rel="footnote">4</a></sup>. An assembly file is merely a textual representation of an object file; assemblers are not particularly interesting programs.</p> <p>A third program, the linker, <em>links</em> all of your object files into a final <em>executable</em> or <em>binary</em>, traditionally given the name <code class="language-plaintext highlighter-rouge">a.out</code><sup id="fnref:aout" role="doc-noteref"><a href="#fn:aout" class="footnote" rel="footnote">5</a></sup>.</p> <p>This three (or two, if you do compile/assemble in one step) phase process is sometimes called the <em>C compilation model</em>. All modern software build infrastructure is built around this model<sup id="fnref:rust-objects" role="doc-noteref"><a href="#fn:rust-objects" class="footnote" rel="footnote">6</a></sup>.</p> <blockquote> <h3 id="even-more-stages"><a href="#even-more-stages">Even More Stages!</a></h3> <p>Clang, being based on LLVM, actually exposes one stage in between the <code class="language-plaintext highlighter-rouge">.cc</code> file and the <code class="language-plaintext highlighter-rouge">.s</code> file. You can ask it to skip doing codegen and emit a <code class="language-plaintext highlighter-rouge">.ll</code> file filled with LLVM IR, an intermediate between human-writable source code and assembly. The magic words to get this file are <code class="language-plaintext highlighter-rouge">clang -S -emit-llvm</code>. (The Rust equivalent is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir</code>.)</p> <p>The LLVM toolchain provides <code class="language-plaintext highlighter-rouge">llc</code>, the LLVM compiler, which performs the <code class="language-plaintext highlighter-rouge">.ll</code> -&gt; <code class="language-plaintext highlighter-rouge">.s</code> step (optionally assembling it, too). <code class="language-plaintext highlighter-rouge">lli</code> is an interpreter for the IR. Studying IR is mostly useful for understanding optimization behavior; topic for another day.</p> </blockquote> <p>The compiler, assembler, and linker are the central components of a toolchain. Other languages, like Rust, usually provide their own toolchain, or just a compiler, reusing the existing C/C++ toolchain. The assembler and linker are language agnostic.</p> <p>The toolchain also provides various debugging tools, including an interactive debugger, and tools for manipulating object files, such as <code class="language-plaintext highlighter-rouge">nm</code>, <code class="language-plaintext highlighter-rouge">objdump</code>, <code class="language-plaintext highlighter-rouge">objcopy</code>, and <code class="language-plaintext highlighter-rouge">ar</code>.</p> <p>These days, most of this stuff is bundled into a single program, the compiler frontend, which knows how to compiler, assemble, and link, in one invocation. You can ask Clang to spit out <code class="language-plaintext highlighter-rouge">.o</code> files with <code class="language-plaintext highlighter-rouge">clang -c</code>, and <code class="language-plaintext highlighter-rouge">.s</code> files with <code class="language-plaintext highlighter-rouge">clang -S</code>.</p> <blockquote> <h3 id="trs-nms"><a href="#trs-nms">Trs Nms</a></h3> <p>The UNIX crowd at Bell Labs was very excited about short, terse names. This tradition survives in Go’s somewhat questionable practice of single-letter variables.</p> <p>Most toolchain program names are cute contractions. <code class="language-plaintext highlighter-rouge">cc</code> is “C compiler”; compilers for almost all other languages follow this convention, like <code class="language-plaintext highlighter-rouge">rustc</code>, <code class="language-plaintext highlighter-rouge">javac</code>, <code class="language-plaintext highlighter-rouge">protoc</code>, and <code class="language-plaintext highlighter-rouge">scalac</code>; Clang is just <code class="language-plaintext highlighter-rouge">clang</code>, but is perfectly ok being called as <code class="language-plaintext highlighter-rouge">cc</code>.</p> <p><code class="language-plaintext highlighter-rouge">as</code> is “assembler”; <code class="language-plaintext highlighter-rouge">ld</code> is “loader” (you’ll learn why sooner). <code class="language-plaintext highlighter-rouge">ar</code> is “archiver”, <code class="language-plaintext highlighter-rouge">nm</code> is “names”. Other names tend to be a bit more sensible.</p> </blockquote> <h3 id="final-link"><a href="#final-link">Final Link</a></h3> <p>Some fifty years ago at Bell Labs, someone really wanted to write a program with more than one <code class="language-plaintext highlighter-rouge">.s</code> file. To solve this, a program that could “link” symbol references across object files was written: the first linker.</p> <p>You can take several <code class="language-plaintext highlighter-rouge">.o</code> files and use <code class="language-plaintext highlighter-rouge">ar</code> (an archaic <code class="language-plaintext highlighter-rouge">tar</code>, basically) to create a library, which always have names like <code class="language-plaintext highlighter-rouge">libfoo.a</code> (the <code class="language-plaintext highlighter-rouge">lib</code> is mandatory). A static library is just a collection of objects, which can be provided on an as-needed basis to the linker.</p> <p>The “final link” incorporates several <code class="language-plaintext highlighter-rouge">.o</code> files and <code class="language-plaintext highlighter-rouge">.a</code> files to produce an executable. It does roughly the following:</p> <ol> <li>Parse all the objects and static libraries and put their <em>symbols</em> into a database. Symbols are named addresses of functions and global variables.</li> <li>Search for all unresolved symbol references in the <code class="language-plaintext highlighter-rouge">.o</code> files and match it up with a symbol from the database, recursively doing this for any code in a <code class="language-plaintext highlighter-rouge">.a</code> referenced during this process. This forms a sort of dependency graph between sections. This step is called <em>symbol resolution</em>.</li> <li>Throw out any code that isn’t referenced by the input files by tracing the dependency graph from the entry-point symbol (e.g., <code class="language-plaintext highlighter-rouge">_start</code> on Linux). This step is called <em>garbage collection</em>.</li> <li>Execute the linker script to figure out how to stitch the final binary together. This includes discovering the offsets at which everything will go.</li> <li>Resolve <em>relocations</em>, “holes” in the binary that require knowing the final runtime address of the section. Relocations are instructions placed in the object file for the linker to execute.</li> <li>Write out the completed binary.</li> </ol> <p>This process is extremely memory-intensive; it is possible for colossal binaries, especially ones with tons of debug information, to “fail to link” because the linker exhausts the system’s memory.</p> <p>We only care about step 4; whole books can be written about the previous steps. Thankfully, Ian Lance Taylor, mad linker scientist and author of <code class="language-plaintext highlighter-rouge">gold</code>, has written several excellent words on this topic: <a href="https://lwn.net/Articles/276782/">https://lwn.net/Articles/276782/</a>.</p> <h2 id="object-files-and-sections"><a href="#object-files-and-sections">Object Files and Sections</a></h2> <p>Linkers, fundamentally, consume object files and produce object files; the output is executable, meaning that all relocations have been resolved and an entry-point address (where the OS/bootloader will jump to to start the binary).</p> <p>It’s useful to be able to peek into object files. The <code class="language-plaintext highlighter-rouge">objdump</code> utility is best for this. <code class="language-plaintext highlighter-rouge">objdump -x my_object.o</code> will show <em>all</em> headers, telling you what exactly is in it.</p> <p>At a high level, an object file describes how a program should be loaded into memory. The object is divided into sections, which are named blocks of data. Sections may have file-like permissions, such as allocatable, loadable, readonly, and executable. <code class="language-plaintext highlighter-rouge">objdump -h</code> can be used to show the list of sections. Some selected lines of output from <code class="language-plaintext highlighter-rouge">objdump</code> on my machine (I’m on a 64-bit machine, but I’ve trimmed leading zeros to make it all fit):</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-h</span> <span class="s2">"</span><span class="si">$(</span>which clang<span class="si">)</span><span class="s2">"</span>
<span class="go">/usr/bin/clang:     file format elf64-x86-64

Sections:
Idx Name    Size      VMA       LMA       File off  Algn
 11 .init   00000017  00691ab8  00691ab8  00291ab8  2**2
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt    00006bb0  00691ad0  00691ad0  00291ad0  2**4
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text   0165e861  00698680  00698680  00298680  2**4
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini   00000009  01cf6ee4  01cf6ee4  018f6ee4  2**2
            CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata 0018ec68  01cf6ef0  01cf6ef0  018f6ef0  2**4
            CONTENTS, ALLOC, LOAD, READONLY, DATA
 24 .data   000024e8  021cd5d0  021cd5d0  01dcc5d0  2**4
            CONTENTS, ALLOC, LOAD, DATA
 26 .bss    00009d21  021cfac0  021cfac0  01dceab8  2**4
            ALLOC
</span></code></pre></div></div> <p>Allocateable (<code class="language-plaintext highlighter-rouge">ALLOC</code>) sections must be <em>allocated</em> space by the operating system; if the section is loadable (<code class="language-plaintext highlighter-rouge">LOAD</code>), then the operating system must further fill that space with the contents of the section. This process is called <em>loading</em> and is performed by a <em>loader</em> program<sup id="fnref:bare-metal-loading" role="doc-noteref"><a href="#fn:bare-metal-loading" class="footnote" rel="footnote">7</a></sup>. The loader is sometimes called the “dynamic linker”, and is often the same program as the “program linker”; this is why the linker is called <code class="language-plaintext highlighter-rouge">ld</code>.</p> <p>Loading can also be done beforehand using the <code class="language-plaintext highlighter-rouge">binary</code> output format. This is useful for tiny microcontrollers that are too primitive to perform any loading. <code class="language-plaintext highlighter-rouge">objcopy</code> is useful for this and many other tasks that involve transforming object files.</p> <p>Some common (POSIX) sections include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">.text</code>, where your code lives<sup id="fnref:text-section" role="doc-noteref"><a href="#fn:text-section" class="footnote" rel="footnote">8</a></sup>. It’s usually a loadable, readonly, executable section.</li> <li><code class="language-plaintext highlighter-rouge">.data</code> contains the initial values of global variables. It’s loadable.</li> <li><code class="language-plaintext highlighter-rouge">.rodata</code> contains constants. It’s loadable and readonly.</li> <li><code class="language-plaintext highlighter-rouge">.bss</code> is an empty allocatable section<sup id="fnref:bss-section" role="doc-noteref"><a href="#fn:bss-section" class="footnote" rel="footnote">9</a></sup>. C specifies that uninitialized globals default to zero; this is a convenient way for avoiding storing a huge block of zeros in the executable!</li> <li>Debug sections that are not loaded or allocated; these are usually removed for release builds.</li> </ul> <p>After the linker decides which sections from the <code class="language-plaintext highlighter-rouge">.o</code> and <code class="language-plaintext highlighter-rouge">.a</code> inputs to keep (based on which symbols it decided it needed), it looks to the linker script how to arrange them in the output.</p> <p>Let’s write our first linker script!</p> <pre><code class="language-ld">SECTIONS {
  /* Define an output section ".text". */
  .text : {
    /* Pull in all symbols in input sections named .text */
    *(.text)
    /* Do the same for sections starting with .text.,
       such as .text.foo */
    *(.text.*)
  }

  /* Do the same for ".bss", ".rodata", and ".data". */
  .bss : { *(.bss); *(.bss.*) }
  .data : { *(.data); *(.data.*) }
  .rodata : { *(.rodata); *(.rodata.*) }
}
</code></pre> <p>This tells the linker to create a <code class="language-plaintext highlighter-rouge">.text</code> section in the output, which contains all sections named <code class="language-plaintext highlighter-rouge">.text</code> from all inputs, plus all sections with names like <code class="language-plaintext highlighter-rouge">.text.foo</code>. The content of the section is laid out in order: the contents of all <code class="language-plaintext highlighter-rouge">.text</code> sections will come before any <code class="language-plaintext highlighter-rouge">.text.*</code> sections; I don’t think the linker makes any promises about the ordering between different objects<sup id="fnref:order-sorting" role="doc-noteref"><a href="#fn:order-sorting" class="footnote" rel="footnote">10</a></sup>.</p> <p>As I mentioned before, parsers for linker script are fussy<sup id="fnref:comment-syntax" role="doc-noteref"><a href="#fn:comment-syntax" class="footnote" rel="footnote">11</a></sup>: the space in <code class="language-plaintext highlighter-rouge">.text :</code> is significant.</p> <p>Note that the two <code class="language-plaintext highlighter-rouge">.text</code> sections are different, and can have different names! The linker generally doesn’t care what a section is named; just its attributes. We could name it <code class="language-plaintext highlighter-rouge">code</code> if we wanted to; even the leading period is mere convention. Some object file formats don’t support arbitrary sections; all the sane ones (ELF, COFF, Mach-O) don’t care, but they don’t all spell it the same way; in Mach-O, you call it <code class="language-plaintext highlighter-rouge">__text</code>.</p> <p>Before continuing, I recommend looking at the <a href="#appendix">appendix</a> so that you have a clear path towards being able to run and test your linker scripts!</p> <blockquote> <h3 id="input-section-syntax"><a href="#input-section-syntax">Input Section Syntax</a></h3> <p>None of this syntax is used in practice but it’s useful to contextualize the syntax for pulling in a section. The full form of the syntax is</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>archive:object(section1 section2 ...)
</code></pre></div> </div> <p>Naturally, all of this is optional, so you can write <code class="language-plaintext highlighter-rouge">foo.o</code> or <code class="language-plaintext highlighter-rouge">libbar.a:(.text)</code> or <code class="language-plaintext highlighter-rouge">:baz.o(.text .data)</code>, where the last one means “not part of a library”. There’s even an <code class="language-plaintext highlighter-rouge">EXCLUDE_FILE</code> syntax for filtering by source object, and a <code class="language-plaintext highlighter-rouge">INPUT_SECTION_FLAGS</code> syntax for filtering by the presence of format-specific flags.</p> <p>Do not use any of this. Just write <code class="language-plaintext highlighter-rouge">*(.text)</code> and don’t think about it too hard. The <code class="language-plaintext highlighter-rouge">*</code> is just a glob for all objects.</p> </blockquote> <p>Each section has an <em>alignment</em>, which is just the maximum of the alignments of all input sections pulled into it. This is important for ensuring that code and globals are aligned the way the architecture expects them to be. The alignment of a section can be set explicitly with</p> <pre><code class="language-ld">SECTIONS {
  .super_aligned : ALIGN(16) {
    /* ... */
  }
}
</code></pre> <p>You can also instruct the linker to toss out sections using the special <code class="language-plaintext highlighter-rouge">/DISCARD/</code> output section, which overrides any decisions made at garbage-collection time. I’ve only ever used this to discard debug information that GCC was really excited about keeping around.</p> <p>On the other hand, you can use <code class="language-plaintext highlighter-rouge">KEEP(*(.text.*))</code> to ensure no <code class="language-plaintext highlighter-rouge">.text</code> sections are discarded by garbage-collection. Unfortunately, this doesn’t let you pull in sections from static libraries that weren’t referenced in the input objects.</p> <h3 id="lma-and-vma"><a href="#lma-and-vma">LMA and VMA</a></h3> <p>Every section has three addresses associated with it. The simplest is the file offset: how far from the start of the file to find the section.</p> <p>The <em>virtual memory address</em>, or VMA, is where the program expects to find the section at runtime. This is the address that is used by pointers and the program counter.</p> <p>The <em>load memory address</em>, or LMA, is where the loader (be it a runtime loader or <code class="language-plaintext highlighter-rouge">objcpy</code>) must place the code. This is almost always the same as the VMA. Later on, in <a href="#rom-ram-lma">Using Symbols and LMAs</a>, I’ll explain a place where this is actually useful.</p> <p>When declaring a new section, the VMA and LMA are both set to the value<sup id="fnref:dot-align" role="doc-noteref"><a href="#fn:dot-align" class="footnote" rel="footnote">12</a></sup> of the <em>location counter</em>, which has the <em>extremely</em> descriptive name <code class="language-plaintext highlighter-rouge">.</code><sup id="fnref:dot-in-asm" role="doc-noteref"><a href="#fn:dot-in-asm" class="footnote" rel="footnote">13</a></sup>. This counter is automatically incremented as data is copied from the input</p> <p>We can explicitly specify the VMA of a section by putting an expression before the colon, and the LMA by putting an expression in the <code class="language-plaintext highlighter-rouge">AT(lma)</code> specifier <em>after</em> the colon:</p> <pre><code class="language-ld">SECTIONS {
  .text 0x10008000: AT(0x40008000) {
    /* ... */
  }
}
</code></pre> <p>This will modify the location counter; you could also write it as</p> <pre><code class="language-ld">SECTIONS {
  . = 0x10008000;
  .text : AT(0x40008000) {
    /* ... */
  }
}
</code></pre> <p>Within <code class="language-plaintext highlighter-rouge">SECTIONS</code>, the location counter can be set at any point, even while in the middle of declaring a section (though the linker will probably complain if you do something rude like move it backwards).</p> <p>The location counter is incremented automatically as sections are added, so it’s rarely necessary to fuss with it directly.</p> <h2 id="memory-regions-and-section-allocation"><a href="#memory-regions-and-section-allocation">Memory Regions and Section Allocation</a></h2> <p>By default, the linker will simply allocate sections starting at address <code class="language-plaintext highlighter-rouge">0</code>. The <code class="language-plaintext highlighter-rouge">MEMORY</code> statement can be used to define <em>memory regions</em> for more finely controlling how VMAs and LMAs are allocated without writing them down explicitly.</p> <p>A classic example of a <code class="language-plaintext highlighter-rouge">MEMORY</code> block separates the address space into ROM and RAM:</p> <pre><code class="language-ld">MEMORY {
  rom (rx)   : ORIGIN = 0x8000,     LENGTH = 16K
  ram (rw!x) : ORIGIN = 0x10000000, LENGTH = 256M
}
</code></pre> <p>A region is a block of memory with a name and some attributes. The name is irrelevant beyond the scope of the linker script. The attributes in parens are used to specify what sections could conceivably go in that region. A section is compatible if it has any of the attributes before the <code class="language-plaintext highlighter-rouge">!</code>, and none which come after the <code class="language-plaintext highlighter-rouge">!</code>. (This filter mini-language isn’t very expressive.)</p> <p>The attributes are the ones we mentioned earlier: <code class="language-plaintext highlighter-rouge">rwxal</code> are readonly, read/write, executable, allocated, and loadable<sup id="fnref:attrs-in-asm" role="doc-noteref"><a href="#fn:attrs-in-asm" class="footnote" rel="footnote">14</a></sup>.</p> <p>When allocating a section a VMA, the linker will try to pick the best memory region that matches the filter using a heuristic. I don’t really trust the heuristic, but you can instead write <code class="language-plaintext highlighter-rouge">&gt; region</code> to put something into a specific region. Thus,</p> <pre><code class="language-ld">SECTION {
  .data {
    /* ... */
  } &gt; ram AT&gt; rom
}
</code></pre> <p><code class="language-plaintext highlighter-rouge">AT&gt;</code> is the “obvious” of <code class="language-plaintext highlighter-rouge">AT()</code> and <code class="language-plaintext highlighter-rouge">&gt;</code>, and sets which region to allocate the LMA from.</p> <p>The origin and length of a region can be obtained with the <code class="language-plaintext highlighter-rouge">ORIGIN(region)</code> and <code class="language-plaintext highlighter-rouge">LENGTH(region)</code> functions.</p> <h2 id="other-stuff-to-put-in-sections"><a href="#other-stuff-to-put-in-sections">Other Stuff to Put In Sections</a></h2> <p>Output sections can hold more than just input sections. Arbitrary data can be placed into sections using the <code class="language-plaintext highlighter-rouge">BYTE</code>, <code class="language-plaintext highlighter-rouge">SHORT</code>, <code class="language-plaintext highlighter-rouge">LONG</code> and <code class="language-plaintext highlighter-rouge">QUAD</code> for placing literal 8, 16, 32, and 64-bit unsigned integers into the section:</p> <pre><code class="language-ld">SECTIONS {
  .screams_internally : { LONG(0xaaaaaaaa) }
}
</code></pre> <p>Numeric literals in linker script may, conveniently, be given the suffixes <code class="language-plaintext highlighter-rouge">K</code> or <code class="language-plaintext highlighter-rouge">M</code> to specify a kilobyte or megabyte quantity. E.g., <code class="language-plaintext highlighter-rouge">4K</code> is sugar for <code class="language-plaintext highlighter-rouge">4096</code>.</p> <h3 id="fill"><a href="#fill">Fill</a></h3> <p>You can fill the unused portions of a section by using the <code class="language-plaintext highlighter-rouge">FILL</code> command, which sets the “fill pattern” from that point onward. For example, we can create four kilobytes of <code class="language-plaintext highlighter-rouge">0xaa</code> using <code class="language-plaintext highlighter-rouge">FILL</code> and the location counter:</p> <pre><code class="language-ld">SECTIONS {
  .scream_page : {
    FILL(0xaa)
    . += 4K;
  }
}
</code></pre> <p>The “fill pattern” is used to fill any unspecified space, such as alignment padding or jumping around with the location counter. We can use multiple FILLs to vary the fill pattern, such as if we wanted half the page to be <code class="language-plaintext highlighter-rouge">0x0a</code> and half <code class="language-plaintext highlighter-rouge">0xa0</code>:</p> <pre><code class="language-ld">SECTIONS {
  .scream_page : {
    FILL(0x0a)
    . += 2K;
    FILL(0xa0)
    . += 2K;
  }
}
</code></pre> <p>When using one fill pattern for the whole section, you can just write <code class="language-plaintext highlighter-rouge">= fill;</code> at the end of the section. For example,</p> <pre><code class="language-ld">SECTIONS {
  .scream_page : {
    . += 4K;
  } = 0xaa;
}
</code></pre> <h3 id="linker-symbols"><a href="#linker-symbols">Linker Symbols</a></h3> <p>Although the linker needs to resolve all symbols using the input <code class="language-plaintext highlighter-rouge">.o</code> and <code class="language-plaintext highlighter-rouge">.a</code> files, you can also declare symbols directly in linker script; this is the absolute latest that symbols can be provided. For example:</p> <pre><code class="language-ld">SECTIONS {
  my_cool_symbol = 5;
}
</code></pre> <p>This will define a new symbol with value <code class="language-plaintext highlighter-rouge">5</code>. If we then wrote <code class="language-plaintext highlighter-rouge">extern char my_cool_symbol;</code>, we can access the value placed by the linker. However, note that the value of a symbol is an <em>address</em>! If you did</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">char</span> <span class="n">my_cool_symbol</span><span class="p">;</span>

<span class="kt">uintptr_t</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">my_cool_symbol</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>the processor would be very confused about why you just dereferenced a pointer with address <code class="language-plaintext highlighter-rouge">5</code>. The <em>correct</em> way to extract a linker symbol’s value is to write</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">char</span> <span class="n">my_cool_symbol</span><span class="p">;</span>

<span class="kt">uintptr_t</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">my_cool_symbol</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>It seems a bit silly to take the address of the global and use that as some kind of magic value, but that’s just how it works. The exact same mechanism works in Rust, too:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="nd">#[link_name</span> <span class="nd">=</span> <span class="s">"my_cool_symbol"</span><span class="nd">]</span>
    <span class="k">static</span> <span class="n">SYM</span><span class="p">:</span> <span class="nb">u8</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">addr_of!</span><span class="p">(</span><span class="n">SYM</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div> <p>The most common use of this mechanism is percolating information not known until link time. For example, a common idiom is</p> <pre><code class="language-ld">SECTIONS {
  .text : {
    __text_start = .;
    /* stuff */
    __text_end = .;
  }
}
</code></pre> <p>This allows initialization code to find the section’s address and length; in this case, the pointer values are actually meaningful!</p> <blockquote> <h3 id="wunderbars"><a href="#wunderbars">Wunderbars</a></h3> <p>It’s common practice to lead linker symbols with two underscores, because C declares a surprisingly large class of symbols reserved for the implementation, so normal user code won’t call them. These include names like <code class="language-plaintext highlighter-rouge">__text_start</code>, which start with two underscores, and names starting with an underscore and an uppercase letter, like <code class="language-plaintext highlighter-rouge">_Atomic</code>.</p> <p>However, libc and STL headers will totally use the double underscore symbols to make them resistant to tampering by users (which they are entitled to), so beware!</p> </blockquote> <p>Symbol assignments can even go inside of a section, to capture the location counter’s value between input sections:</p> <pre><code class="language-ld">SECTIONS {
  .text : {
    *(.text)
    text_middle = .;
    *(.text.*)
  }
}
</code></pre> <p>Symbol names are not limited to C identifiers, and may contain dashes, periods, dollar signs, and other symbols. They may even be quoted, like <code class="language-plaintext highlighter-rouge">"this symbol has spaces"</code>, which C will never be able to access as an <code class="language-plaintext highlighter-rouge">extern</code>.</p> <p>There is a mini-language of expressions that symbols can be assigned to. This includes:</p> <ul> <li>Numeric literals like <code class="language-plaintext highlighter-rouge">42</code>, <code class="language-plaintext highlighter-rouge">0xaa</code>, and <code class="language-plaintext highlighter-rouge">4K</code>.</li> <li>The location counter, <code class="language-plaintext highlighter-rouge">.</code>.</li> <li>Other symbols.</li> <li>The usual set of C operators, such as arithmetic and bit operations. Xor is curiously missing.</li> <li>A handful of builtin functions, described below.</li> </ul> <p>There are some fairly complicated rules around how symbols may be given relative addresses to the start of a section, which are only relevant when dealing with position-independent code: <a href="https://sourceware.org/binutils/docs/ld/Expression-Section.html">https://sourceware.org/binutils/docs/ld/Expression-Section.html</a></p> <p>Functions belong to one of two board categories: getters for properties of sections, memory regions, and other linker structures; and arithmetic. Useful functions include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">ADDR</code>, <code class="language-plaintext highlighter-rouge">LOADADDR</code>, <code class="language-plaintext highlighter-rouge">SIZEOF</code>, and <code class="language-plaintext highlighter-rouge">ALIGNOF</code>, which produce the VMA, LMA, size, and alignment of a previously defined section.</li> <li><code class="language-plaintext highlighter-rouge">ORIGIN</code> and <code class="language-plaintext highlighter-rouge">LENGTH</code>, which produce the start address and length of a memory region.</li> <li><code class="language-plaintext highlighter-rouge">MAX</code>, <code class="language-plaintext highlighter-rouge">MIN</code> are obvious; <code class="language-plaintext highlighter-rouge">LOG2CEIL</code> computes the base-2 log, rounded up.</li> <li><code class="language-plaintext highlighter-rouge">ALIGN(expr, align)</code> rounds <code class="language-plaintext highlighter-rouge">expr</code> to the next multiple of <code class="language-plaintext highlighter-rouge">align</code>. <code class="language-plaintext highlighter-rouge">ALIGN(align)</code> is roughly equivalent to <code class="language-plaintext highlighter-rouge">ALIGN(., align)</code> with some subtleties around PIC. <code class="language-plaintext highlighter-rouge">. = ALIGN(align);</code> will align the location counter to <code class="language-plaintext highlighter-rouge">align</code>.</li> </ul> <p>Some other builtins can be found at <a href="https://sourceware.org/binutils/docs/ld/Builtin-Functions.html">https://sourceware.org/binutils/docs/ld/Builtin-Functions.html</a>.</p> <p>A symbol definition can be wrapped in the <code class="language-plaintext highlighter-rouge">PROVIDEO()</code> function to make it “weak”, analogous to the “weak symbol” feature found in Clang. This means that the linker will not use the definition if any input object defines it.</p> <h3 id="rom-ram-lma"><a href="#rom-ram-lma">Using Symbols and LMAs</a></h3> <p>As mentioned before, it is extremely rare for the LMA and VMA to be different. The most common situation where this occurs is when you’re running on a system, like a microcontroller, where memory is partitioned into two pieces: ROM and RAM. The ROM has the executable burned into it, and RAM starts out full of random garbage.</p> <p>Most of the contents of the linked executable are read-only, so their VMA can be in ROM. However, the <code class="language-plaintext highlighter-rouge">.data</code> and <code class="language-plaintext highlighter-rouge">.bss</code> sections need to lie in RAM, because they’re writable. For <code class="language-plaintext highlighter-rouge">.bss</code> this is easy, because it doesn’t have loadable content. For <code class="language-plaintext highlighter-rouge">.data</code>, though, we need to separate the VMA and LMA: the VMA must go in RAM, and the LMA in ROM.</p> <p>This distinction is important for the code that initializes the RAM: while for <code class="language-plaintext highlighter-rouge">.bss</code> all it has to do is zero it, for <code class="language-plaintext highlighter-rouge">.data</code>, it has to copy from ROM to RAM! The LMA lets us distinguish the copy source and the copy destination.</p> <p>This has the important property that it tells the loader (usually <code class="language-plaintext highlighter-rouge">objcopy</code> in this case) to use the ROM addresses for actually loading the section to, but to link the code as if it were at a RAM address (which is needed for things like PC-relative loads to work correctly).</p> <p>Here’s how we’d do it in linker script:</p> <pre><code class="language-ld">MEMORY {
  rom : /* ... */
  ram : /* ... */
}

SECTIONS {
  /* .text and .rodata just go straight into the ROM. We don't need
     to mutate them ever. */
  .text : { *(.text) } &gt; rom
  .rodata : { *(.rodata) } &gt; rom

  /* .bss doesn't have any "loadable" content, so it goes straight
     into RAM. We could include `AT&gt; rom`, but because the sections
     have no content, it doesn't matter. */
  .bss : { *(.bss) } &gt; ram

  /* As described above, we need to get a RAM VMA but a ROM LMA;
     the &gt; and AT&gt; operators achieve this. */
  .data : { *(.data) } &gt; ram AT&gt; rom
}

/* The initialization code will need some symbols to know how to
   zero the .bss and copy the initial .data values. We can use the
   functions from the previous section for this! */

bss_start = ADDR(.bss);
bss_end = bss_start + SIZEOF(.bss);

data_start = ADDR(.data);
data_end = data_start + SIZEOF(.data);

rom_data_start = LOADADDR(.data);
</code></pre> <p>Although we would normally write the initialization code in assembly (since it’s undefined behavior to execute C before initializing the <code class="language-plaintext highlighter-rouge">.bss</code> and <code class="language-plaintext highlighter-rouge">.data</code> sections), I’ve written it in C for illustrative purposes:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">bss_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">bss_end</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">data_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">data_end</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">rom_data_start</span><span class="p">[];</span>

<span class="kt">void</span> <span class="nf">init_sections</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Zero the .bss.</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">bss_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bss_end</span> <span class="o">-</span> <span class="n">bss_start</span><span class="p">);</span>

  <span class="c1">// Copy the .data values from ROM to RAM.</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">data_start</span><span class="p">,</span> <span class="n">rom_data_start</span><span class="p">,</span> <span class="n">data_end</span> <span class="o">-</span> <span class="n">data_start</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="misc-linker-script-features"><a href="#misc-linker-script-features">Misc Linker Script Features</a></h2> <p>Linker script includes a bunch of other commands that don’t fit into a specific category:</p> <ul> <li><code class="language-plaintext highlighter-rouge">ENTRY()</code> sets the program entry-point, either as a symbol or a raw address. The <code class="language-plaintext highlighter-rouge">-e</code> flag can be used to override it. The <code class="language-plaintext highlighter-rouge">ld</code> docs assert that there are fallbacks if an entry-point can’t be found, but in my experience you can sometimes get errors here. <code class="language-plaintext highlighter-rouge">ENTRY(_start)</code> would use the <code class="language-plaintext highlighter-rouge">_start</code> symbol, for example<sup id="fnref:not-main" role="doc-noteref"><a href="#fn:not-main" class="footnote" rel="footnote">15</a></sup>.</li> <li><code class="language-plaintext highlighter-rouge">INCLUDE "path/to/file.ld"</code> is <code class="language-plaintext highlighter-rouge">#include</code> but for linker script.</li> <li><code class="language-plaintext highlighter-rouge">INPUT(foo.o)</code> will add <code class="language-plaintext highlighter-rouge">foo.o</code> as a linker input, as if it was passed at the commandline. <code class="language-plaintext highlighter-rouge">GROUP</code> is similar, but with the semantics of <code class="language-plaintext highlighter-rouge">--start-group</code>.</li> <li><code class="language-plaintext highlighter-rouge">OUTPUT()</code> overrides the usual <code class="language-plaintext highlighter-rouge">a.out</code> default output name.</li> <li><code class="language-plaintext highlighter-rouge">ASSERT()</code> provides static assertions.</li> <li><code class="language-plaintext highlighter-rouge">EXTERN(sym)</code> causes the linker to behave as if an undefined reference to <code class="language-plaintext highlighter-rouge">sym</code> existed in an input object.</li> </ul> <p>(Other commands are documented, but I’ve never needed them in practice.)</p> <h2 id="real-linker-scripts"><a href="#real-linker-scripts">Real Linker Scripts</a></h2> <p>It may be useful to look at some real-life linker scripts.</p> <p>If you wanna see what Clang, Rust, and the like all ultimately use, run <code class="language-plaintext highlighter-rouge">ld --verbose</code>. This will print the default linker script for your machine; this is a really intense script that uses basically every feature available in linker script (and, since it’s GNU, is very poorly formatted).</p> <p>The Linux kernel also has linker scripts, which are differently intense, because they use the C preprocessor. For example, the one for amd64: <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S">https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S</a>.</p> <p>Tock OS, a secure operating system written in Rust, has some pretty solid linker scripts, with lots of comments: <a href="https://github.com/tock/tock/blob/master/boards/kernel_layout.ld">https://github.com/tock/tock/blob/master/boards/kernel_layout.ld</a>. I recommend taking a look to see what a “real” but not too wild linker script looks like. There’s a fair bit of toolchain-specific stuff in there, too, that should give you an idea of what to expect.</p> <p>Happy linking!</p> <hr/> <h2 id="appendix"><a href="#appendix">Appendix: A Linker Playground</a></h2> <p>tl;dr: If you don’t wanna try out any examples, skip this section.</p> <p>I want you to be able to try out the examples above, but there’s no Godbolt for linker scripts (yet!). Unlike normal code, you can’t just run linker script through a compiler, you’re gonna need some objects to link, too! Let’s set up a very small C project for testing your linker scripts.</p> <blockquote> <p>Note: I’m assuming you’re on Linux, with x86_64, and using Clang. If you’re on a Mac (even M1), you can probably make <code class="language-plaintext highlighter-rouge">ld64</code> do the right thing, but this is outside of what I’m an expert on.</p> <p>If you’re on Windows, use WSL. I have no idea how MSCV does linker scripts at all.</p> </blockquote> <p>First, we want a very simple static library:</p> <p>```c filename:extern.c godbolt: int lib_call(const char* str) { // Discard <code class="language-plaintext highlighter-rouge">str</code>, we just want to take any argument. (void)str;</p> <p>// This will go in <code class="language-plaintext highlighter-rouge">.bss</code>. static int count; return count++; }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Compile `extern.c` into a static library like so:

```shell
clang -c extern.c
ar rc libextern.a extern.o
</code></pre></div></div> <p>We can check out that we got something reasonable by using <code class="language-plaintext highlighter-rouge">nm</code>. The <code class="language-plaintext highlighter-rouge">nm</code> program shows you all the symbols a library or object defines.</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>nm libextern.a
<span class="go">extern.o:
0000000000000000 T lib_call
0000000000000000 b lib_call.count
</span></code></pre></div></div> <p>This shows us the address, section type, and name of each symbol; <code class="language-plaintext highlighter-rouge">man nm</code> tells us that <code class="language-plaintext highlighter-rouge">T</code> means <code class="language-plaintext highlighter-rouge">.text</code> and <code class="language-plaintext highlighter-rouge">b</code> means <code class="language-plaintext highlighter-rouge">.bss</code>. Capital letters mean that the symbol is <em>exported</em>, so the linker can use it to resolve a symbol reference or a relocation. In C/C++, symbols declared <code class="language-plaintext highlighter-rouge">static</code> or in an unnamed namespace are “hidden”, and can’t be referenced outside of the object. This is sometimes called internal vs external linkage.</p> <p>Next, we need a C program that uses the library:</p> <p>```c filename:run.c godbolt: extern int lib_call(const char* str);</p> <p>// We’re gonna use a custom entrypoint. This code will never run anyways, we // just care about the linker output. void run(void) { // This will go in <code class="language-plaintext highlighter-rouge">.data</code>, because it’s initialized to non-zero. static int data = 5;</p> <p>// The string-constant will go into <code class="language-plaintext highlighter-rouge">.rodata</code>. data = lib_call(“Hello from .rodata!”); }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Compile it with `clang -c run.c`. We can inspect the symbol table with `nm` as
before:

```terminal
$ nm run.o
                 U lib_call
0000000000000000 T run
0000000000000000 d run.data
</code></pre></div></div> <p>As you might guess, <code class="language-plaintext highlighter-rouge">d</code> is just <code class="language-plaintext highlighter-rouge">.data</code>. However, <code class="language-plaintext highlighter-rouge">U</code> is interesting: it’s an undefined symbol, meaning the linker will need to perform a symbol resolution! In fact, if we ask Clang to link this for us (it just shells out to a linker like <code class="language-plaintext highlighter-rouge">ld</code>):</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>clang run.o
<span class="go">/usr/bin/ld: /somewhere/crt1.o: in function `_start':
(.text+0x20): undefined reference to `main'
/usr/bin/ld: run.o: in function `run':
run.c:(.text+0xf): undefined reference to `lib_call'
</span></code></pre></div></div> <p>The linker also complains that there’s no <code class="language-plaintext highlighter-rouge">main()</code> function, and that some object we didn’t provide called <code class="language-plaintext highlighter-rouge">crt1.o</code> wants it. This is the startup code for the C runtime; we can skip linking it with <code class="language-plaintext highlighter-rouge">-nostartfiles</code>. This will result in the linker picking an entry point for us.</p> <p>We can resolve the missing symbol by linking against our library. <code class="language-plaintext highlighter-rouge">-lfoo</code> says to search for the library <code class="language-plaintext highlighter-rouge">libfoo.a</code>; <code class="language-plaintext highlighter-rouge">-L.</code> says to include the current directory for searching for libraries.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang run.o <span class="nt">-L</span><span class="nb">.</span> <span class="nt">-lextern</span> <span class="nt">-nostartfiles</span>
</code></pre></div></div> <p>This gives us our binary, <code class="language-plaintext highlighter-rouge">a.out</code>, which we can now <code class="language-plaintext highlighter-rouge">objdump</code>:</p> <div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-d</span> <span class="nt">-Mintel</span> a.out
<span class="go">
a.out:     file format elf64-x86-64


Disassembly of section .text:

</span><span class="gp">0000000000401000 &lt;run&gt;</span>:
<span class="go">  401000:  55                      push   rbp
  401001:  48 89 e5                mov    rbp,rsp
  401004:  48 bf 00 20 40 00 00    movabs rdi,0x402000
  40100b:  00 00 00 
</span><span class="gp">  40100e:  e8 0d 00 00 00          call   401020 &lt;lib_call&gt;</span><span class="w">
</span><span class="go">  401013:  89 04 25 00 40 40 00    mov    DWORD PTR ds:0x404000,eax
  40101a:  5d                      pop    rbp
  40101b:  c3                      ret    
  40101c:  0f 1f 40 00             nop    DWORD PTR [rax+0x0]

</span><span class="gp">0000000000401020 &lt;lib_call&gt;</span>:
<span class="go">  401020:  55                      push   rbp
  401021:  48 89 e5                mov    rbp,rsp
  401024:  48 89 7d f8             mov    QWORD PTR [rbp-0x8],rdi
  401028:  8b 04 25 04 40 40 00    mov    eax,DWORD PTR ds:0x404004
  40102f:  89 c1                   mov    ecx,eax
  401031:  83 c1 01                add    ecx,0x1
  401034:  89 0c 25 04 40 40 00    mov    DWORD PTR ds:0x404004,ecx
  40103b:  5d                      pop    rbp
  40103c:  c3                      ret    
</span></code></pre></div></div> <p>Let’s write up the simplest possible linker script for all this:</p> <p>```ld filename:link.ld ENTRY(run) SECTIONS { .text : { <em>(.text); *(.text.</em>) } .bss : { <em>(.bss); *(.bss.</em>) } .data : { <em>(.data); *(.data.</em>) } .rodata : { <em>(.rodata); *(.rodata.</em>) } }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Let's link! We'll also want to make sure that the system libc doesn't get in
the way, using `-nostdlib`[^libgcc_s].

[^libgcc_s]:
    If you include libc, you will get bizarre errors involving something called
    "`gcc_s`". `libgcc` (and `libgcc_s`) is GCC's *compiler runtime* library.
    Where `libc` exposes high-level operations on the C runtime and utilities
    for manipulating common objects, `libgcc` provides even lower-level support,
    including:
    - Polyfills for arithmetic operations not available on the target. For
      example, dividing two 64-bit integers on most 32-bit targets will emit a
      reference to the a symbol like `__udivmoddi4` (they all have utterly
      incomprehensible names like this one).
    - Soft-float implementations, i.e., IEEE floats implemented in software for
      targets without an FPU.
    - Bits of unwinding (e.g. exceptions and panics) support (the rest is in
      `libunwind`).
    - Miscellaneous runtime support code, such as the code that calls C++ static
      initializers.

    Clang's version, `libcompiler-rt`, is ABI-compatible with `libgcc` and
    provides various support for profiling, sanitizers, and many, many other
    things the compiler needs available for compiling code.

```shell
clang run.o -L. -lextern -nostartfiles -nostdlib -Wl,-T,link.ld
</code></pre></div></div> <p>At this point, you can use <code class="language-plaintext highlighter-rouge">objdump</code> to inspect <code class="language-plaintext highlighter-rouge">a.out</code> at your leisure! You’ll notice there are a few other sections, like <code class="language-plaintext highlighter-rouge">.eh_frame</code>. Clang adds these by default, but you can throw them out using <code class="language-plaintext highlighter-rouge">/DISCARD/</code>.</p> <p>It’s worth it to run the examples in the post through the linker using this “playground”. You can actually control the sections Clang puts symbols into using the <code class="language-plaintext highlighter-rouge">__attribute__((section("blah")))</code> compiler extension. The Rust equivalent is <code class="language-plaintext highlighter-rouge">#[link_section = "blah"]</code>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:linker-flag" role="doc-endnote"> <p>Blame GCC for this. <code class="language-plaintext highlighter-rouge">-Wl</code> feeds arguments through to the linker, and <code class="language-plaintext highlighter-rouge">-T</code> is <code class="language-plaintext highlighter-rouge">ld</code>’s linker script input flag. Thankfully, rustc is far more sensible here: <code class="language-plaintext highlighter-rouge">-Clink-args=-Wl,-T,foo.ld</code> (when GCC/Clang is your linker frontend). <a href="#fnref:linker-flag" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:etymology-of-s" role="doc-endnote"> <p>Correction, 2022-09-11. I have really been bothered by not knowing if this is actually true, and have periodically asked around about it. I asked Russ Cox, who was actually <em>at</em> Bell Labs back in the day, and he asked Ken Thompson, who confirms: it’s genuinely <code class="language-plaintext highlighter-rouge">.s</code> for source, because it was the only source they had back then.</p> <p>I am glad I got this from the horse’s mouth. :) <a href="#fnref:etymology-of-s" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:clang-languages" role="doc-endnote"> <p>And many other things, like Objective-C. <a href="#fnref:clang-languages" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:object-what" role="doc-endnote"> <p>Completely and utterly unrelated to the objects of object-oriented programming. Best I can tell, the etymology is lost to time. <a href="#fnref:object-what" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:aout" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">a.out</code> is <em>also</em> an object file format, like ELF, but toolchains live and die by tradition, so that’s the name given to the linker’s output by default. <a href="#fnref:aout" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rust-objects" role="doc-endnote"> <p>Rust does not compile each <code class="language-plaintext highlighter-rouge">.rs</code> file into an object, and its “crates” are much larger than the average C++ translation unit. However, the Rust compiler will nonetheless produce many object files for a single crate, precisely for the benefit of this compilation model. <a href="#fnref:rust-objects" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:bare-metal-loading" role="doc-endnote"> <p>Operating systems are loaded by a bootloader. Bootloaders are themselves loaded by other bootloaders, such as the BIOS. At the bottom of the turtles is the mask ROM, which is a tiny bootloader permanently burned into the device. <a href="#fnref:bare-metal-loading" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:text-section" role="doc-endnote"> <p>No idea on the etymology. This isn’t ASCII text! <a href="#fnref:text-section" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:bss-section" role="doc-endnote"> <p>Back in the 50s, this stood for “block started by symbol”. <a href="#fnref:bss-section" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:order-sorting" role="doc-endnote"> <p>Yes, yes, you can write <code class="language-plaintext highlighter-rouge">SORT_BY_NAME(*)(.text)</code> but that’s not really something you ever wind up needing.</p> <p>See <a href="https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html">https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html</a> for more information on this. <a href="#fnref:order-sorting" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:comment-syntax" role="doc-endnote"> <p>You only get <code class="language-plaintext highlighter-rouge">/* */</code> comment syntax because that’s the lowest common denominator. <a href="#fnref:comment-syntax" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:dot-align" role="doc-endnote"> <p>Well, <code class="language-plaintext highlighter-rouge">.</code> actually gets increased to the alignment of the section first. If you insist on an unaligned section, the syntax is, obviously,</p> <pre><code class="language-ld">SECTIONS {
  .unaligned .: {
    /* ... */
  }
}
</code></pre> <p>(That was sarcasm. It must be stressed that this is not a friendly language.) <a href="#fnref:dot-align" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:dot-in-asm" role="doc-endnote"> <p>This symbol is also available in assembly files. <code class="language-plaintext highlighter-rouge">jmp .</code> is an overly-cute idiom for an infinity busy loop. It is even more terse in ARM and RISC-V, where it’s written <code class="language-plaintext highlighter-rouge">b .</code> and <code class="language-plaintext highlighter-rouge">j .</code>, respectively.</p> <p>Personally, I prefer the obtuse clarity of <code class="language-plaintext highlighter-rouge">loop_forever: j loop_forever</code>. <a href="#fnref:dot-in-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:attrs-in-asm" role="doc-endnote"> <p>These are the same characters used to declare a section in assembly. If I wanted to place my code in a section named <code class="language-plaintext highlighter-rouge">.crt0</code> but wanted it to be placed into a readonly, executable memory block, use the the assembler directive <code class="language-plaintext highlighter-rouge">.section .crt0, rxal</code> <a href="#fnref:attrs-in-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:not-main" role="doc-endnote"> <p>Note that the entry point is almost never a function called <code class="language-plaintext highlighter-rouge">main()</code>. In the default configuration of most toolchains, an object called <code class="language-plaintext highlighter-rouge">crt0.o</code> is provided as part of the libc, which provides a <code class="language-plaintext highlighter-rouge">_start()</code> function that itself calls <code class="language-plaintext highlighter-rouge">main()</code>. CRT stands for “C runtime”; thus, <code class="language-plaintext highlighter-rouge">crt0.o</code> initializes the C runtime.</p> <p>This file contains the moral equivalent of the following C code, which varies according to target:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
<span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">init_libc</span><span class="p">();</span>    <span class="c1">// Initializes global libc state.</span>
  <span class="n">run_ctors</span><span class="p">();</span>    <span class="c1">// Runs all library constructors.</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">main</span><span class="p">(</span><span class="n">get_argc</span><span class="p">(),</span> <span class="n">get_argv</span><span class="p">());</span>
  <span class="n">run_dtors</span><span class="p">();</span>    <span class="c1">// Runs all library destructors.</span>
  <span class="n">cleanup_libc</span><span class="p">();</span> <span class="c1">// Deinitializes the libc.</span>
  
  <span class="n">exit</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="c1">// Asks the OS to gracefully destroy the process.</span>
<span class="p">}</span>
</code></pre></div> </div> <p>This behavior can be disabled with <code class="language-plaintext highlighter-rouge">-nostartfiles</code> in Clang. The OSDev wiki has some on this topic: <a href="https://wiki.osdev.org/Creating_a_C_Library#Program_Initialization">https://wiki.osdev.org/Creating_a_C_Library#Program_Initialization</a>. <a href="#fnref:not-main" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>