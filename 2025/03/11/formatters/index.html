<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> The Art of Formatting Code &middot; mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="The Art of Formatting Code &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/formatters-6c183fc5d8dd37d976bb091548435c4e72dc6e5e.png"> <meta property="og:title" content="The Art of Formatting Code &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/formatters-6c183fc5d8dd37d976bb091548435c4e72dc6e5e.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2025/03/11/formatters/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2025-03-11 • 3738 words • 31 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> • <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> • <a href="https://mcyoung.xyz/tags.html#frontend">#frontend</a> </span> <h1><a href="/2025/03/11/formatters/"> The Art of Formatting Code </a></h1> </div> <div class="post"> <p>Every modern programming language needs a <em>formatter</em> to make your code look pretty and consistent. Formatters are source-transformation tools that parse source code and re-print the resulting AST in some canonical form that normalizes whitespace and optional syntactic constructs. They remove the tedium of matching indentation and brace placement to match a style guide.</p> <p>Go is particularly well-known for providing a formatter as part of its toolchain from day one. It is not a <em>good</em> formatter, though, because it cannot enforce a maximum column width. Later formatters of the 2010s, such as rustfmt and clang-format, do provide this feature, which ensure that individual lines of code don’t get too long.</p> <p>The reason Go doesn’t do this is because the naive approach to formatting code makes it intractable to do so. There are many approaches to implementing this, which can make it seem like a very complicated layout constraint solving problem.</p> <p>So what’s so tricky about formatting code? Aren’t you just printing out an AST?</p> <h2 id="just-an-ast"><a href="#just-an-ast">“Just” an AST</a></h2> <p>An AST<sup id="fnref:pronunciation" role="doc-noteref"><a href="#fn:pronunciation" class="footnote" rel="footnote">1</a></sup> (abstract syntax tree) is a graph representation of a program’s syntax. Let’s consider something like JSON, whose naively-defined AST type might look something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The AST for the document <code class="language-plaintext highlighter-rouge">{"foo": null, "bar": 42}</code> might look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_doc</span> <span class="o">=</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Object</span><span class="p">([</span>
  <span class="p">(</span><span class="s">"foo"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span><span class="p">),</span>
  <span class="p">(</span><span class="s">"bar"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mi">42</span><span class="p">)),</span>
<span class="p">]</span><span class="nf">.into</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This AST has some pretty major problems. A formatter must <em>not</em> change the syntactic structure of the program (beyond removing things like redundant braces). Formatting must also be deterministic.</p> <p>First off, <code class="language-plaintext highlighter-rouge">Json::Object</code> is a <code class="language-plaintext highlighter-rouge">HashMap</code>, which is unordered. So it will immediately discard the order of the keys. <code class="language-plaintext highlighter-rouge">Json::String</code> does not retain the escapes from the original string, so <code class="language-plaintext highlighter-rouge">"\n"</code> and <code class="language-plaintext highlighter-rouge">"\u000a"</code> are indistinguishable. <code class="language-plaintext highlighter-rouge">Json::Number</code> will destroy information: JSON numbers can specify values outside of the <code class="language-plaintext highlighter-rouge">f64</code> representable range, but converting to <code class="language-plaintext highlighter-rouge">f64</code> will quantize to the nearest float.</p> <p>Now, JSON doesn’t have comments, but if it did, our AST has no way to record it! So it would destroy all comment information! Plus, if someone has a document that separates keys into stanzas<sup id="fnref:stanza" role="doc-noteref"><a href="#fn:stanza" class="footnote" rel="footnote">2</a></sup>, as shown below, this information is lost too.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"this"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my first stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"second"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="p">,</span><span class="w">

  </span><span class="nl">"here"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my second stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fourth"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Truth is, the AST for virtually all competent toolchains are much more complicated than this. Here’s some important properties an AST needs to have to be useful.</p> <ol> <li> <p>Retain <em>span</em> information. Every node in the graph remembers what piece of the file it was parsed from.</p> </li> <li> <p>Retain whitespace information. “Whitespace” typically includes both whitespace characters, and comments.</p> </li> <li> <p>Retain ordering information. The children of each node need to be stored in ordered containers.</p> </li> </ol> <p>The first point is achieved in a number of ways, but boils down to somehow associating to each token a pair of integers<sup id="fnref:offsets" role="doc-noteref"><a href="#fn:offsets" class="footnote" rel="footnote">3</a></sup>, identifying the start and end offsets of the token in the input file.</p> <p>Given the span information for each token, we can then define the span for each node to be the <em>join</em> of its tokens’ spans, namely the start is the min of its constituent tokens’ starts and its end is the max of the ends. This can be easily calculated recursively.</p> <p>Once we have spans, it’s easy to recover the whitespace between any two adjacent syntactic constructs by calculating the text between them. This approach is more robust than, say, associating each comment with a specific token, because it makes it easier to discriminate stanzas for formatting.</p> <p>Being able to retrieve the comments between any two syntax nodes is crucial. Suppose the user writes the following Rust code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">false</span> <span class="o">&amp;&amp;</span> <span class="c1">// HACK: disable this check.</span>
  <span class="nf">some_complicated_check</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If we’re formatting the binary expression containing the <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, and we can’t query for comments between the LHS and the operator, or the operator and the RHS, the <code class="language-plaintext highlighter-rouge">// HACK</code> comment will get deleted on format, which is pretty bad!</p> <p>An AST that retains this level of information is sometimes called a “concrete syntax tree”. I do not consider this a useful distinction, because any useful AST must retain span and whitespace information, and it’s kind of pointless to implement the same AST more than once. To me, an AST without spans is incomplete.</p> <h3 id="updating-our-json-ast"><a href="#updating-our-json-ast">Updating Our JSON AST</a></h3> <p>With all this in mind, the bare minimum for a “good” AST is gonna be something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are various layout optimizations we can do: for example, the vast majority of strings exist literally in the original file, so there’s no need to copy them into a <code class="language-plaintext highlighter-rouge">String</code>; it’s only necessary if the string contains escapes. My <code class="language-plaintext highlighter-rouge">byteyarn</code> crate, which I wrote about <a href="https://mcyoung.xyz/2023/08/09/yarns">here</a>, is meant to make handling this case easy. So we might rewrite this to be lifetime-bound to the original file.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>But wait, there’s some things that don’t have spans here. We need to include spans for the braces of <code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">Object</code>, their commas, and the colons on object keys. So what we actually get is something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Span</span> <span class="p">{</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>

  <span class="n">Array</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ArrayEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ObjectEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ArrayEntry</span> <span class="p">{</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ObjectEntry</span> <span class="p">{</span>
  <span class="n">key</span><span class="p">:</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Implementing an AST is one of my least favorite parts of writing a toolchain, because it’s tedious to ensure all of the details are recorded and properly populated.</p> <h2 id="just-printing-an-ast"><a href="#just-printing-an-ast">“Just” Printing an AST</a></h2> <p>In Rust, you can easily get a nice recursive print of any struct using the <code class="language-plaintext highlighter-rouge">#[derive(Debug)]</code> construct. This is implemented by recursively calling <code class="language-plaintext highlighter-rouge">Debug::fmt()</code> on the elements of a struct, but passing modified <code class="language-plaintext highlighter-rouge">Formatter</code> state to each call to increase the indentation level each time.</p> <p>This enables printing nested structs in a way that looks like Rust syntax when using the <code class="language-plaintext highlighter-rouge">{:#?}</code> specifier.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Foo</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">baz</span><span class="p">:</span> <span class="n">Baz</span> <span class="p">{</span>
    <span class="n">quux</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We can implement a very simple formatter for our JSON AST by walking it recursively.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="p">,</span> <span class="n">json</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Json</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="o">&amp;</span><span class="n">json</span><span class="py">.kind</span> <span class="p">{</span>
    <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="c1">// Preserve the input exactly.</span>
      <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">json</span><span class="py">.span.start</span><span class="o">..</span><span class="n">json</span><span class="py">.span.end</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'['</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">']'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'{'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Preserve the key exactly.</span>
        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">entry</span><span class="py">.key_span.start</span><span class="o">..</span><span class="n">entry</span><span class="py">.key_span.end</span><span class="p">]);</span>

        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">": "</span><span class="p">);</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'}'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is essentially what every JSON serializer’s “pretty” mode looks like. It’s linear, it’s simple. But it has one big problem: small lists.</p> <p>If I try to format the document <code class="language-plaintext highlighter-rouge">{"foo": []}</code> using this routine, the output will be</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>This is pretty terrible, but easy to fix by adding a special case:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">entries</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"[]"</span><span class="p">);</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this doesn’t handle the similar case of a small but non-empty list. <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> formats as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="mi">2</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Really, we’d like to keep <code class="language-plaintext highlighter-rouge">"foo": [1, 2]</code> on one line. And now we enter the realm of column wrapping.</p> <h2 id="how-wide-is-a-codepoint"><a href="#how-wide-is-a-codepoint">How Wide Is a Codepoint?</a></h2> <p>The whole point of a formatter is to work with <em>monospaced text</em>, which is text formatted using a monospaced or <em>fixed-width</em> typeface, which means each character is the same width, leading to the measure of the width of lines in <em>columns</em>.</p> <p>So how many columns does the string <code class="language-plaintext highlighter-rouge">cat</code> take up? Three, pretty easy. But we obviously don’t want to count bytes, this isn’t 1971. If we did, <code class="language-plaintext highlighter-rouge">кішка</code>, when UTF-8 encoded, it would be 10, rather than 5 columns wide. So we seem to want to count Unicode characters instead?</p> <p>Oh, but what <em>is</em> a Unicode character? Well, we could say that you’re counting Unicode scalar values (what Rust’s <code class="language-plaintext highlighter-rouge">char</code> and Go’s <code class="language-plaintext highlighter-rouge">rune</code>) types represent. Or you could count grapheme clusters (like Swift’s <code class="language-plaintext highlighter-rouge">Character</code>).</p> <p>But that would give wrong answers. CJK languages’ characters, such as <code class="language-plaintext highlighter-rouge">猫</code>, usually want to be rendered as <em>two</em> columns, even in monospaced contexts. So, you might go to Unicode and discover <a href="https://www.unicode.org/reports/tr11/">UAX#11</a>, and attempt to use it for assigning column widths. But it turns out that the precise rules that monospaced fonts use are not written down in a single place in Unicode. You would also discover that some scripts, such as Arabic, have complex ligature rules that mean that the width of a single character depends on the characters around it.</p> <p>This is a place where you should hunt for a library. <a href="https://docs.rs/unicode-width/latest/unicode_width/#rules-for-determining-width"><code class="language-plaintext highlighter-rouge">unicode_width</code></a> is the one for Rust. Given that Unicode segmentation is a closely associated operation to width, segmentation libraries are a good place to look for a width calculation routine.</p> <p>But most such libraries will still give wrong answers, because of tabs. The tab character <code class="language-plaintext highlighter-rouge">U+0009 CHARACTER TABULATION</code>’s width depends on the width of all characters before it, because a tab is as wide as needed to reach the next <em>tabstop</em>, which is a column position an integer multiple of the <em>tab width</em> (usually 2, 4, or, on most terminals, 8).</p> <p>With a tab width of 4, <code class="language-plaintext highlighter-rouge">"\t"</code>, <code class="language-plaintext highlighter-rouge">"a\t"</code>, and <code class="language-plaintext highlighter-rouge">"abc\t"</code> are all four columns wide. Depending on the context, you will either want to treat tabs as behaving as going to the next tabstop (and thus being variable width), or having a fixed width. The former is necessary for assigning correct column numbers in diagnostics, but we’ll find that the latter is a better match for what we’re doing.</p> <p>The reason for being able to calculate the width of a string is to enable line wrapping. At some point in the 2010s, people started writing a lot of code on laptops, where it is not easy to have two editors side by side on the small screen. This removes the motivation to wrap all lines at 80 columns<sup id="fnref:80-cols" role="doc-noteref"><a href="#fn:80-cols" class="footnote" rel="footnote">4</a></sup>, which in turn results in lines that tend to get arbitrarily long.</p> <p>Line wrapping helps ensure that no matter how wide everyone’s editors are, the code <em>I</em> have to read fits on my very narrow editors.</p> <h2 id="accidentally-quadratic"><a href="#accidentally-quadratic">Accidentally Quadratic</a></h2> <p>A lot of folks’ first formatter recursively formats a node by formatting its children to determine if they fit on one line or not, and based on that, and their length if they are single-line, determine if their parent should break.</p> <p>This is a naive approach, which has several disadvantages. First, it’s very easy to accidentally backtrack, trying to only break smaller and smaller subexpressions until things fit on one line, which can lead to quadratic complexity. The logic for whether a node can break is bespoke per node and that makes it easy to make mistakes.</p> <p>Consider formatting <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>. In our AST, this will look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">ObjectEntry</span> <span class="p">{</span>
      <span class="n">key</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
      <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span>
      <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">5</span> <span class="p">},</span>
      <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">9</span> <span class="p">},</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
          <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">11</span> <span class="p">}),</span>
            <span class="p">},</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">s</span><span class="na">.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">13</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">],</span>
        <span class="p">},</span>
        <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}],</span>
  <span class="p">},</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>To format the whole document, we need to know the width of each field in the object to decide whether the object fits on one line. To do that, we need to calculate the width of each value, and add to it the width of the key, and the width of the <code class="language-plaintext highlighter-rouge">: </code> separating them.</p> <p>How can this be accidentally quadratic? If we simply say “format this node” to obtain its width, that will recursively format all of the children it contains without introducing line breaks, performing work that is linear in how many transitive children that node contains. Having done this, we can now decide if we need to introduce line breaks or not, which increases the indentation at which the children are rendered. This means that the children cannot know ahead of time how much of the line is left for them, so we need to recurse into formatting them again, now knowing the indentation at which the direct children are rendered.</p> <p>Thus, each node performs work equal to the number of nodes beneath it. This has resulted in many slow formatters.</p> <p>Now, you could be more clever and have each node be capable of returning its width based on querying its children’s width directly, but that means you need to do complicated arithmetic for each node that needs to be synchronized with the code that actually formats it. Easy to make mistakes.</p> <p>The solution is to invent some kind of model for your document that specifies how lines should be broken if necessary, and which tracks layout information so that it can be computed in one pass, and then used in a second pass to figure out whether to actually break lines or not.</p> <p>This is actually how HTML works. The markup describes constraints on the layout of the content, and then a layout engine, over several passes, calculates sizes, solves constraints, and finally produces a raster image representing that HTML document. Following the lead of HTML, we can design…</p> <h2 id="a-dom-for-your-code"><a href="#a-dom-for-your-code">A DOM for Your Code</a></h2> <p>The HTML DOM is a markup document: a tree of tags where each tag has a type, such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;hr&gt;</code>, or <code class="language-plaintext highlighter-rouge">&lt;strong&gt;</code>, properties, such as <code class="language-plaintext highlighter-rouge">&lt;a href=...&gt;</code>, and content consisting of nested tags (and bare text, which every HTML engine just handles as a special kind of tag), such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;Hello &lt;em&gt;World&lt;/em&gt;!&lt;/p&gt;</code>.</p> <p>We obviously want to have a tag for text that should be rendered literally. We also want a tag for line breaks that is distinct from the text tag, so that they can be merged during rendering. It might be good to treat text tags consisting of just whitespace, such as whitespace, specially: two newlines <code class="language-plaintext highlighter-rouge">\n\n</code> are a blank line, but we might want to merge consecutive blank lines. Similarly, we might want to merge consecutive spaces to simplify generating the DOM.</p> <p>Consider formatting a language like C++, where a function can have many modifiers on it that can show up in any order, such as <code class="language-plaintext highlighter-rouge">inline</code>, <code class="language-plaintext highlighter-rouge">virtual</code>, <code class="language-plaintext highlighter-rouge">constexpr</code>, and <code class="language-plaintext highlighter-rouge">explicit</code>. We might want to canonicalize the order of these modifiers. We don’t want to accidentally wind up printing <code class="language-plaintext highlighter-rouge">inline constexpr Foo()</code> because we printed an empty string for <code class="language-plaintext highlighter-rouge">virtual</code>. Having special merging for spaces means that all entities are always one space apart if necessary. This is a small convenience in the DOM that multiplies to significant simplification when lowering from AST to DOM.</p> <p>Another useful tag is something like <code class="language-plaintext highlighter-rouge">&lt;indent by=" "&gt;</code>, which increases the indentation level by some string (or perhaps simply a number of spaces; the string just makes supporting tabs easier) for the tags inside of it. This allows control of indentation in a carefully-scoped manner.</p> <p>Finally, we need some way to group tags that are candidates for “breaking”: if the width of all of the tags inside of a <code class="language-plaintext highlighter-rouge">&lt;group&gt;</code> is greater than the maximum width that group can have (determined by indentation and any elements on the same line as that group), we can set that group to “broken”, and… well, what should breaking do?</p> <p>We want breaking to not just cause certain newlines (at strategic locations) to appear, but we also want it to cause an indentation increase, and in languages with trailing commas like Rust and Go, we want (or in the case of Go, <em>need</em>) to insert a trailing comma only when broken into multiple lines. We can achieve this by allowing any tag to be <em>conditioned</em> on whether the enclosing group is broken or not.</p> <p>Taken all together, we can render the AST for our <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> document into this DOM, according to the tags we’ve described above.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">XML</div></div></div> <p>Notice a few things: All of the newlines are set to appear only <code class="language-plaintext highlighter-rouge">if=broken</code>. The space between the two commas only appears if the enclosing group is <em>not</em> broken, that is <code class="language-plaintext highlighter-rouge">if=flat</code>. The groups encompass everything that can move due to a break, which includes the outer braces. This is necessary because if that brace is not part of the group, and it is the only character past the line width limit, it will not cause the group to break.</p> <h3 id="laying-out-your-dom"><a href="#laying-out-your-dom">Laying Out Your DOM</a></h3> <p>The first pass is easy: it measures how wide every node is. But we don’t know whether any groups will break, so how can we measure that without calculating breaks, which depend on indentation, and the width of their children, and…</p> <p>This is one tricky thing about multi-pass graph algorithms (or graph algorithms in general): it can be easy to become overwhelmed trying to factor the dependencies at each node so that they are not cyclic. I struggled with this algorithm, until I realized that the only width we care about is the width <em>if no groups are ever broken</em>.</p> <p>Consider the following logic: if a group needs to break, all of its parents must obviously break, because the group will now contain a newline, so its parents must break no matter what. Therefore, we only consider the width of a node when deciding if a group must break intrinsically, i.e., because all of its children decided not to break. This can happen for a document like the following, where each inner node is quite large, but not large enough to hit the limit.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span><span class="w">
  </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span><span class="w">
  </span><span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">]</span><span class="w">
</span><span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Because we prefer to break outer groups rather than inner groups, we can measure the “widest a single line could be” in one pass, bottom-up: each node’s width is the sum of the width of its children, or its literal contents for <code class="language-plaintext highlighter-rouge">&lt;text&gt;</code> elements. However, we must exclude all text nodes that are <code class="language-plaintext highlighter-rouge">if=broken</code>, because they obviously do not contribute to the single-line length. We can also ignore indentation because indentation never happens in a single line.</p> <p>However, this doesn’t give the full answer for whether a given group should break, because that depends on indentation and what nodes came before on the same line.</p> <p>This means we need to perform a second pass: having laid everything out assuming no group is broken, we must lay things out as they would appear when we render them, taking into account breaking. But now that we know the maximum width of each group if left unbroken, we can make breaking decisions.</p> <p>As we walk the DOM, we keep track of the current column and indentation value. For each group, we decide to break it if either:</p> <ol> <li> <p>Its width, plus the current column value, exceeds the maximum column width.</p> </li> <li> <p>It contains any newlines, something that can be determined in the first pass.</p> </li> </ol> <p>The first case is why we can’t actually treat tabs as if they advance to a tabstop. We cannot know the column at which a node will be placed at the time that we measure its width, so we need to assume the worst case.</p> <p>Whenever we hit a newline, we update the current width to the width induced by indentation, simulating a newline plus indent. We also need to evaluate the condition, if present, on each tag now, since by the time we inspect a non-group tag, we have already made a decision as to whether to break or not.</p> <h3 id="render-it"><a href="#render-it">Render It!</a></h3> <p>Now that everything is determined, rendering is super easy: just walk the DOM and print out all the text nodes that either have no condition or whose condition matches the innermost group they’re inside of.</p> <p>And, of course, this is where we need to be careful with indentation: you don’t want to have lines that end in whitespace, so you should make sure to not print out any spaces until text is written after a newline. This is also a good opportunity to merge adjacent only-newlines text blocks. The merge algorithm I like is to make sure that when <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code> newline blocks are adjacent, print <code class="language-plaintext highlighter-rouge">max(n, m)</code> newlines. This ensures that a DOM node containing <code class="language-plaintext highlighter-rouge">\n\n\n</code> is respected, while deleting a bunch of <code class="language-plaintext highlighter-rouge">\n</code>s in a row that would result in many blank lines.</p> <p>What’s awesome about this approach is that the layout algorithm is highly generic: you can re-use it for whatever compiler frontend you like, without needing to fuss with layout yourself. There is a very direct conversion from AST to DOM, and the result is very declarative.</p> <h3 id="more-complicated-yaml"><a href="#more-complicated-yaml">More Complicated: YAML</a></h3> <p>YAML is a superset of JSON that SREs use to write sentient configuration files. It has a funny list syntax that we might want to use for multi-line lists, but we might want to keep JSON-style lists for short ones.</p> <p>A document of nested lists might look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="pi">-</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">,</span> <span class="nv">4</span><span class="pi">,</span> <span class="nv">5</span><span class="pi">,</span> <span class="nv">6</span><span class="pi">,</span> <span class="nv">7</span><span class="pi">,</span> <span class="nv">8</span><span class="pi">,</span> <span class="nv">9</span><span class="pi">,</span> <span class="nv">10</span><span class="pi">,</span> <span class="nv">11</span><span class="pi">,</span> <span class="nv">12</span><span class="pi">]</span>
<span class="pi">-</span> <span class="pi">[</span><span class="nv">13</span><span class="pi">,</span> <span class="nv">14</span><span class="pi">,</span> <span class="nv">15</span><span class="pi">,</span> <span class="nv">16</span><span class="pi">,</span> <span class="nv">17</span><span class="pi">,</span> <span class="nv">18</span><span class="pi">,</span> <span class="nv">19</span><span class="pi">,</span> <span class="nv">20</span><span class="pi">,</span> <span class="nv">21</span><span class="pi">,</span> <span class="nv">22</span><span class="pi">,</span> <span class="nv">23</span><span class="pi">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">YAML</div></div></div> <p>How might we represent this in the DOM? Starting from our original JSON document <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>, we might go for something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">XML</div></div></div> <p>Here, we’ve made the <code class="language-plaintext highlighter-rouge">[]</code> and the comma only appear in flat mode, while in broken mode, we have a <code class="language-plaintext highlighter-rouge">- </code> prefix for each item. The inserted newlines have also changed somewhat, and the indentation blocks have moved: now only the value is indented, since YAML allows the <code class="language-plaintext highlighter-rouge">-</code>s of list items to be at the same indentation level as the parent value for lists nested in objects. (This is a case where some layout logic is language-specific, but now the output is worrying about declarative markup rather than physical measurements.)</p> <p>There are other enhancements you might want to make to the DOM I don’t describe here. For example, comments want to be word-wrapped, but you might not know what the width is until layout happens. Having a separate tag for word-wrapped blocks would help here.</p> <p>Similarly, a mechanism for “partial breaks”, such as for the document below, could be implemented by having a type of line break tag that breaks if the text that follows overflows the column, which can be easily implemented by tracking the position of the last such break tag.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"very"</span><span class="p">,</span><span class="w"> </span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"list"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"of"</span><span class="p">,</span><span class="w"> </span><span class="s2">"strings"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <h2 id="using-this-yourself"><a href="#using-this-yourself">Using This Yourself</a></h2> <p>I think that a really good formatter is essential for any programming language, and I think that a high-quality library that does most of the heavy-lifting is important to make it easier to demand good formatters.</p> <p><a href="https://github.com/mcy/strings/tree/main/allman">So I wrote a Rust library.</a> I haven’t released it on crates.io because I don’t think it’s quite at the state I want, but it turns out that the layout algorithm is very simple, so porting this to other languages should be EZ.</p> <p>Now you have no excuse. :D</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:pronunciation" role="doc-endnote"> <p>Everyone pronounces this acronym “ay ess tee”, but I have a friend who really like to say <em>ast</em>, rhyming with <em>mast</em>, so I’m making a callout post my twitter dot com. <a href="#fnref:pronunciation" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stanza" role="doc-endnote"> <p>In computing, a group of lines not separated by blank lines is called a stanza, in analogy to the stanzas of a poem, which are typeset with no blank lines between the lines of the stanza. <a href="#fnref:stanza" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:offsets" role="doc-endnote"> <p>You could also just store a string, containing the original text, but storing offsets is necessary for <em>diagnostics</em>, which is the jargon term for a compiler error. Compiler errors are recorded using an AST node as context, and to report the line at which the error occurred, we need to be able to map the node back to its offset in the file.</p> <p>Once we have the offset, we can calculate the line in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time using binary search. Having pre-computed an array of the offset of each <code class="language-plaintext highlighter-rouge">\n</code> byte in the input file, binary search will tell us the index and offset of the <code class="language-plaintext highlighter-rouge">\n</code> before the token; this index is the zero-indexed line number, and the string from that <code class="language-plaintext highlighter-rouge">\n</code> to the offset can be used to calculate the column.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">unicode_width</span><span class="p">::</span><span class="n">UnicodeWidthStr</span><span class="p">;</span>

<span class="cd">/// Returns the index of each newline. Can be pre-computed and re-used</span>
<span class="cd">/// multiple times.</span>
<span class="k">fn</span> <span class="nf">newlines</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">file</span><span class="nf">.bytes</span><span class="p">()</span>
      <span class="nf">.enumerate</span><span class="p">()</span>
      <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// Returns the line and column of the given offset, given the line</span>
<span class="cd">/// tarts of the file.</span>
<span class="k">fn</span> <span class="nf">location</span><span class="p">(</span>
  <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="n">newlines</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
  <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">newlines</span><span class="nf">.binary_search</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Ok means that offset refers to a newline, so this means</span>
    <span class="c1">// we want to return the width of the line that it ends as</span>
    <span class="c1">// the column.</span>
    <span class="c1">//</span>
    <span class="c1">// Err means that this is after the nth newline, except Err(0),</span>
    <span class="c1">// which means it is before the first one.</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><a href="#fnref:offsets" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:80-cols" role="doc-endnote"> <p>The Rust people keep trying to convince me that it should be 100. They are wrong. 80 is perfect. They only think they need 100 because they use the incorrect tab width of four spaces, rather than two. This is the default for clang-format and it’s <em>perfect</em>. <a href="#fnref:80-cols" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-04-14</span> / <h6 style="display:inline"><a href="/2025/04/14/target-triples/">What the Hell Is a Target Triple?</a></h6> <li> <span class="post-meta">2025-04-08</span> / <h6 style="display:inline"><a href="/2025/04/08/protobuf-tip-1/">Protobuf Tip #1: Field Names Are Forever</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2025-03-11 • 3738 words • 31 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> • <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> • <a href="https://mcyoung.xyz/tags.html#frontend">#frontend</a> </span> <h1><a href="/2025/03/11/formatters/"> The Art of Formatting Code </a></h1> </div> <div class="post"> <p>Every modern programming language needs a <em>formatter</em> to make your code look pretty and consistent. Formatters are source-transformation tools that parse source code and re-print the resulting AST in some canonical form that normalizes whitespace and optional syntactic constructs. They remove the tedium of matching indentation and brace placement to match a style guide.</p> <p>Go is particularly well-known for providing a formatter as part of its toolchain from day one. It is not a <em>good</em> formatter, though, because it cannot enforce a maximum column width. Later formatters of the 2010s, such as rustfmt and clang-format, do provide this feature, which ensure that individual lines of code don’t get too long.</p> <p>The reason Go doesn’t do this is because the naive approach to formatting code makes it intractable to do so. There are many approaches to implementing this, which can make it seem like a very complicated layout constraint solving problem.</p> <p>So what’s so tricky about formatting code? Aren’t you just printing out an AST?</p> <h2 id="just-an-ast"><a href="#just-an-ast">“Just” an AST</a></h2> <p>An AST<sup id="fnref:pronunciation" role="doc-noteref"><a href="#fn:pronunciation" class="footnote" rel="footnote">1</a></sup> (abstract syntax tree) is a graph representation of a program’s syntax. Let’s consider something like JSON, whose naively-defined AST type might look something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The AST for the document <code class="language-plaintext highlighter-rouge">{"foo": null, "bar": 42}</code> might look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_doc</span> <span class="o">=</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Object</span><span class="p">([</span>
  <span class="p">(</span><span class="s">"foo"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span><span class="p">),</span>
  <span class="p">(</span><span class="s">"bar"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mi">42</span><span class="p">)),</span>
<span class="p">]</span><span class="nf">.into</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This AST has some pretty major problems. A formatter must <em>not</em> change the syntactic structure of the program (beyond removing things like redundant braces). Formatting must also be deterministic.</p> <p>First off, <code class="language-plaintext highlighter-rouge">Json::Object</code> is a <code class="language-plaintext highlighter-rouge">HashMap</code>, which is unordered. So it will immediately discard the order of the keys. <code class="language-plaintext highlighter-rouge">Json::String</code> does not retain the escapes from the original string, so <code class="language-plaintext highlighter-rouge">"\n"</code> and <code class="language-plaintext highlighter-rouge">"\u000a"</code> are indistinguishable. <code class="language-plaintext highlighter-rouge">Json::Number</code> will destroy information: JSON numbers can specify values outside of the <code class="language-plaintext highlighter-rouge">f64</code> representable range, but converting to <code class="language-plaintext highlighter-rouge">f64</code> will quantize to the nearest float.</p> <p>Now, JSON doesn’t have comments, but if it did, our AST has no way to record it! So it would destroy all comment information! Plus, if someone has a document that separates keys into stanzas<sup id="fnref:stanza" role="doc-noteref"><a href="#fn:stanza" class="footnote" rel="footnote">2</a></sup>, as shown below, this information is lost too.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"this"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my first stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"second"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="p">,</span><span class="w">

  </span><span class="nl">"here"</span><span class="p">:</span><span class="w"> </span><span class="s2">"is my second stanza"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fourth"</span><span class="p">:</span><span class="w"> </span><span class="s2">"line"</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Truth is, the AST for virtually all competent toolchains are much more complicated than this. Here’s some important properties an AST needs to have to be useful.</p> <ol> <li> <p>Retain <em>span</em> information. Every node in the graph remembers what piece of the file it was parsed from.</p> </li> <li> <p>Retain whitespace information. “Whitespace” typically includes both whitespace characters, and comments.</p> </li> <li> <p>Retain ordering information. The children of each node need to be stored in ordered containers.</p> </li> </ol> <p>The first point is achieved in a number of ways, but boils down to somehow associating to each token a pair of integers<sup id="fnref:offsets" role="doc-noteref"><a href="#fn:offsets" class="footnote" rel="footnote">3</a></sup>, identifying the start and end offsets of the token in the input file.</p> <p>Given the span information for each token, we can then define the span for each node to be the <em>join</em> of its tokens’ spans, namely the start is the min of its constituent tokens’ starts and its end is the max of the ends. This can be easily calculated recursively.</p> <p>Once we have spans, it’s easy to recover the whitespace between any two adjacent syntactic constructs by calculating the text between them. This approach is more robust than, say, associating each comment with a specific token, because it makes it easier to discriminate stanzas for formatting.</p> <p>Being able to retrieve the comments between any two syntax nodes is crucial. Suppose the user writes the following Rust code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">false</span> <span class="o">&amp;&amp;</span> <span class="c1">// HACK: disable this check.</span>
  <span class="nf">some_complicated_check</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If we’re formatting the binary expression containing the <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, and we can’t query for comments between the LHS and the operator, or the operator and the RHS, the <code class="language-plaintext highlighter-rouge">// HACK</code> comment will get deleted on format, which is pretty bad!</p> <p>An AST that retains this level of information is sometimes called a “concrete syntax tree”. I do not consider this a useful distinction, because any useful AST must retain span and whitespace information, and it’s kind of pointless to implement the same AST more than once. To me, an AST without spans is incomplete.</p> <h3 id="updating-our-json-ast"><a href="#updating-our-json-ast">Updating Our JSON AST</a></h3> <p>With all this in mind, the bare minimum for a “good” AST is gonna be something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are various layout optimizations we can do: for example, the vast majority of strings exist literally in the original file, so there’s no need to copy them into a <code class="language-plaintext highlighter-rouge">String</code>; it’s only necessary if the string contains escapes. My <code class="language-plaintext highlighter-rouge">byteyarn</code> crate, which I wrote about <a href="https://mcyoung.xyz/2023/08/09/yarns">here</a>, is meant to make handling this case easy. So we might rewrite this to be lifetime-bound to the original file.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="nf">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Json</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>  <span class="c1">// Vec, not HashMap.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>But wait, there’s some things that don’t have spans here. We need to include spans for the braces of <code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">Object</code>, their commas, and the colons on object keys. So what we actually get is something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Span</span> <span class="p">{</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Json</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">JsonKind</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Null</span><span class="p">,</span>
  <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
  <span class="nf">Number</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">),</span>

  <span class="n">Array</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ArrayEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ObjectEntry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ArrayEntry</span> <span class="p">{</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ObjectEntry</span> <span class="p">{</span>
  <span class="n">key</span><span class="p">:</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'src</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
  <span class="n">value</span><span class="p">:</span> <span class="n">Json</span><span class="p">,</span>
  <span class="n">comma</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Span</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Implementing an AST is one of my least favorite parts of writing a toolchain, because it’s tedious to ensure all of the details are recorded and properly populated.</p> <h2 id="just-printing-an-ast"><a href="#just-printing-an-ast">“Just” Printing an AST</a></h2> <p>In Rust, you can easily get a nice recursive print of any struct using the <code class="language-plaintext highlighter-rouge">#[derive(Debug)]</code> construct. This is implemented by recursively calling <code class="language-plaintext highlighter-rouge">Debug::fmt()</code> on the elements of a struct, but passing modified <code class="language-plaintext highlighter-rouge">Formatter</code> state to each call to increase the indentation level each time.</p> <p>This enables printing nested structs in a way that looks like Rust syntax when using the <code class="language-plaintext highlighter-rouge">{:#?}</code> specifier.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Foo</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">baz</span><span class="p">:</span> <span class="n">Baz</span> <span class="p">{</span>
    <span class="n">quux</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We can implement a very simple formatter for our JSON AST by walking it recursively.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="p">,</span> <span class="n">json</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Json</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="o">&amp;</span><span class="n">json</span><span class="py">.kind</span> <span class="p">{</span>
    <span class="nn">Json</span><span class="p">::</span><span class="n">Null</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="nn">Json</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="c1">// Preserve the input exactly.</span>
      <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">json</span><span class="py">.span.start</span><span class="o">..</span><span class="n">json</span><span class="py">.span.end</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'['</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">']'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nn">Json</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'{'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Preserve the key exactly.</span>
        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">entry</span><span class="py">.key_span.start</span><span class="o">..</span><span class="n">entry</span><span class="py">.key_span.end</span><span class="p">]);</span>

        <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">": "</span><span class="p">);</span>
        <span class="nf">fmt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="py">.value</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="py">.comma</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
      <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">indent</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
        <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">out</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'}'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is essentially what every JSON serializer’s “pretty” mode looks like. It’s linear, it’s simple. But it has one big problem: small lists.</p> <p>If I try to format the document <code class="language-plaintext highlighter-rouge">{"foo": []}</code> using this routine, the output will be</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>This is pretty terrible, but easy to fix by adding a special case:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nn">Json</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">entries</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">out</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"[]"</span><span class="p">);</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this doesn’t handle the similar case of a small but non-empty list. <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> formats as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="mi">2</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Really, we’d like to keep <code class="language-plaintext highlighter-rouge">"foo": [1, 2]</code> on one line. And now we enter the realm of column wrapping.</p> <h2 id="how-wide-is-a-codepoint"><a href="#how-wide-is-a-codepoint">How Wide Is a Codepoint?</a></h2> <p>The whole point of a formatter is to work with <em>monospaced text</em>, which is text formatted using a monospaced or <em>fixed-width</em> typeface, which means each character is the same width, leading to the measure of the width of lines in <em>columns</em>.</p> <p>So how many columns does the string <code class="language-plaintext highlighter-rouge">cat</code> take up? Three, pretty easy. But we obviously don’t want to count bytes, this isn’t 1971. If we did, <code class="language-plaintext highlighter-rouge">кішка</code>, when UTF-8 encoded, it would be 10, rather than 5 columns wide. So we seem to want to count Unicode characters instead?</p> <p>Oh, but what <em>is</em> a Unicode character? Well, we could say that you’re counting Unicode scalar values (what Rust’s <code class="language-plaintext highlighter-rouge">char</code> and Go’s <code class="language-plaintext highlighter-rouge">rune</code>) types represent. Or you could count grapheme clusters (like Swift’s <code class="language-plaintext highlighter-rouge">Character</code>).</p> <p>But that would give wrong answers. CJK languages’ characters, such as <code class="language-plaintext highlighter-rouge">猫</code>, usually want to be rendered as <em>two</em> columns, even in monospaced contexts. So, you might go to Unicode and discover <a href="https://www.unicode.org/reports/tr11/">UAX#11</a>, and attempt to use it for assigning column widths. But it turns out that the precise rules that monospaced fonts use are not written down in a single place in Unicode. You would also discover that some scripts, such as Arabic, have complex ligature rules that mean that the width of a single character depends on the characters around it.</p> <p>This is a place where you should hunt for a library. <a href="https://docs.rs/unicode-width/latest/unicode_width/#rules-for-determining-width"><code class="language-plaintext highlighter-rouge">unicode_width</code></a> is the one for Rust. Given that Unicode segmentation is a closely associated operation to width, segmentation libraries are a good place to look for a width calculation routine.</p> <p>But most such libraries will still give wrong answers, because of tabs. The tab character <code class="language-plaintext highlighter-rouge">U+0009 CHARACTER TABULATION</code>’s width depends on the width of all characters before it, because a tab is as wide as needed to reach the next <em>tabstop</em>, which is a column position an integer multiple of the <em>tab width</em> (usually 2, 4, or, on most terminals, 8).</p> <p>With a tab width of 4, <code class="language-plaintext highlighter-rouge">"\t"</code>, <code class="language-plaintext highlighter-rouge">"a\t"</code>, and <code class="language-plaintext highlighter-rouge">"abc\t"</code> are all four columns wide. Depending on the context, you will either want to treat tabs as behaving as going to the next tabstop (and thus being variable width), or having a fixed width. The former is necessary for assigning correct column numbers in diagnostics, but we’ll find that the latter is a better match for what we’re doing.</p> <p>The reason for being able to calculate the width of a string is to enable line wrapping. At some point in the 2010s, people started writing a lot of code on laptops, where it is not easy to have two editors side by side on the small screen. This removes the motivation to wrap all lines at 80 columns<sup id="fnref:80-cols" role="doc-noteref"><a href="#fn:80-cols" class="footnote" rel="footnote">4</a></sup>, which in turn results in lines that tend to get arbitrarily long.</p> <p>Line wrapping helps ensure that no matter how wide everyone’s editors are, the code <em>I</em> have to read fits on my very narrow editors.</p> <h2 id="accidentally-quadratic"><a href="#accidentally-quadratic">Accidentally Quadratic</a></h2> <p>A lot of folks’ first formatter recursively formats a node by formatting its children to determine if they fit on one line or not, and based on that, and their length if they are single-line, determine if their parent should break.</p> <p>This is a naive approach, which has several disadvantages. First, it’s very easy to accidentally backtrack, trying to only break smaller and smaller subexpressions until things fit on one line, which can lead to quadratic complexity. The logic for whether a node can break is bespoke per node and that makes it easy to make mistakes.</p> <p>Consider formatting <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>. In our AST, this will look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">Json</span> <span class="p">{</span>
  <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Object</span> <span class="p">{</span>
    <span class="n">open</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="n">close</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">ObjectEntry</span> <span class="p">{</span>
      <span class="n">key</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
      <span class="n">key_span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span>
      <span class="n">colon</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">5</span> <span class="p">},</span>
      <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="n">Array</span> <span class="p">{</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">9</span> <span class="p">},</span>
          <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
          <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">11</span> <span class="p">}),</span>
            <span class="p">},</span>
            <span class="n">ArrayEntry</span> <span class="p">{</span>
              <span class="n">value</span><span class="p">:</span> <span class="n">Json</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">JsonKind</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">s</span><span class="na">.0</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">13</span> <span class="p">},</span>
              <span class="p">},</span>
              <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">],</span>
        <span class="p">},</span>
        <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">14</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="n">comma</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}],</span>
  <span class="p">},</span>
  <span class="n">span</span><span class="p">:</span> <span class="n">Span</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="mi">15</span> <span class="p">},</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>To format the whole document, we need to know the width of each field in the object to decide whether the object fits on one line. To do that, we need to calculate the width of each value, and add to it the width of the key, and the width of the <code class="language-plaintext highlighter-rouge">: </code> separating them.</p> <p>How can this be accidentally quadratic? If we simply say “format this node” to obtain its width, that will recursively format all of the children it contains without introducing line breaks, performing work that is linear in how many transitive children that node contains. Having done this, we can now decide if we need to introduce line breaks or not, which increases the indentation at which the children are rendered. This means that the children cannot know ahead of time how much of the line is left for them, so we need to recurse into formatting them again, now knowing the indentation at which the direct children are rendered.</p> <p>Thus, each node performs work equal to the number of nodes beneath it. This has resulted in many slow formatters.</p> <p>Now, you could be more clever and have each node be capable of returning its width based on querying its children’s width directly, but that means you need to do complicated arithmetic for each node that needs to be synchronized with the code that actually formats it. Easy to make mistakes.</p> <p>The solution is to invent some kind of model for your document that specifies how lines should be broken if necessary, and which tracks layout information so that it can be computed in one pass, and then used in a second pass to figure out whether to actually break lines or not.</p> <p>This is actually how HTML works. The markup describes constraints on the layout of the content, and then a layout engine, over several passes, calculates sizes, solves constraints, and finally produces a raster image representing that HTML document. Following the lead of HTML, we can design…</p> <h2 id="a-dom-for-your-code"><a href="#a-dom-for-your-code">A DOM for Your Code</a></h2> <p>The HTML DOM is a markup document: a tree of tags where each tag has a type, such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;hr&gt;</code>, or <code class="language-plaintext highlighter-rouge">&lt;strong&gt;</code>, properties, such as <code class="language-plaintext highlighter-rouge">&lt;a href=...&gt;</code>, and content consisting of nested tags (and bare text, which every HTML engine just handles as a special kind of tag), such as <code class="language-plaintext highlighter-rouge">&lt;p&gt;Hello &lt;em&gt;World&lt;/em&gt;!&lt;/p&gt;</code>.</p> <p>We obviously want to have a tag for text that should be rendered literally. We also want a tag for line breaks that is distinct from the text tag, so that they can be merged during rendering. It might be good to treat text tags consisting of just whitespace, such as whitespace, specially: two newlines <code class="language-plaintext highlighter-rouge">\n\n</code> are a blank line, but we might want to merge consecutive blank lines. Similarly, we might want to merge consecutive spaces to simplify generating the DOM.</p> <p>Consider formatting a language like C++, where a function can have many modifiers on it that can show up in any order, such as <code class="language-plaintext highlighter-rouge">inline</code>, <code class="language-plaintext highlighter-rouge">virtual</code>, <code class="language-plaintext highlighter-rouge">constexpr</code>, and <code class="language-plaintext highlighter-rouge">explicit</code>. We might want to canonicalize the order of these modifiers. We don’t want to accidentally wind up printing <code class="language-plaintext highlighter-rouge">inline constexpr Foo()</code> because we printed an empty string for <code class="language-plaintext highlighter-rouge">virtual</code>. Having special merging for spaces means that all entities are always one space apart if necessary. This is a small convenience in the DOM that multiplies to significant simplification when lowering from AST to DOM.</p> <p>Another useful tag is something like <code class="language-plaintext highlighter-rouge">&lt;indent by=" "&gt;</code>, which increases the indentation level by some string (or perhaps simply a number of spaces; the string just makes supporting tabs easier) for the tags inside of it. This allows control of indentation in a carefully-scoped manner.</p> <p>Finally, we need some way to group tags that are candidates for “breaking”: if the width of all of the tags inside of a <code class="language-plaintext highlighter-rouge">&lt;group&gt;</code> is greater than the maximum width that group can have (determined by indentation and any elements on the same line as that group), we can set that group to “broken”, and… well, what should breaking do?</p> <p>We want breaking to not just cause certain newlines (at strategic locations) to appear, but we also want it to cause an indentation increase, and in languages with trailing commas like Rust and Go, we want (or in the case of Go, <em>need</em>) to insert a trailing comma only when broken into multiple lines. We can achieve this by allowing any tag to be <em>conditioned</em> on whether the enclosing group is broken or not.</p> <p>Taken all together, we can render the AST for our <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code> document into this DOM, according to the tags we’ve described above.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">XML</div></div></div> <p>Notice a few things: All of the newlines are set to appear only <code class="language-plaintext highlighter-rouge">if=broken</code>. The space between the two commas only appears if the enclosing group is <em>not</em> broken, that is <code class="language-plaintext highlighter-rouge">if=flat</code>. The groups encompass everything that can move due to a break, which includes the outer braces. This is necessary because if that brace is not part of the group, and it is the only character past the line width limit, it will not cause the group to break.</p> <h3 id="laying-out-your-dom"><a href="#laying-out-your-dom">Laying Out Your DOM</a></h3> <p>The first pass is easy: it measures how wide every node is. But we don’t know whether any groups will break, so how can we measure that without calculating breaks, which depend on indentation, and the width of their children, and…</p> <p>This is one tricky thing about multi-pass graph algorithms (or graph algorithms in general): it can be easy to become overwhelmed trying to factor the dependencies at each node so that they are not cyclic. I struggled with this algorithm, until I realized that the only width we care about is the width <em>if no groups are ever broken</em>.</p> <p>Consider the following logic: if a group needs to break, all of its parents must obviously break, because the group will now contain a newline, so its parents must break no matter what. Therefore, we only consider the width of a node when deciding if a group must break intrinsically, i.e., because all of its children decided not to break. This can happen for a document like the following, where each inner node is quite large, but not large enough to hit the limit.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span><span class="w">
  </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span><span class="w">
  </span><span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">]</span><span class="w">
</span><span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>Because we prefer to break outer groups rather than inner groups, we can measure the “widest a single line could be” in one pass, bottom-up: each node’s width is the sum of the width of its children, or its literal contents for <code class="language-plaintext highlighter-rouge">&lt;text&gt;</code> elements. However, we must exclude all text nodes that are <code class="language-plaintext highlighter-rouge">if=broken</code>, because they obviously do not contribute to the single-line length. We can also ignore indentation because indentation never happens in a single line.</p> <p>However, this doesn’t give the full answer for whether a given group should break, because that depends on indentation and what nodes came before on the same line.</p> <p>This means we need to perform a second pass: having laid everything out assuming no group is broken, we must lay things out as they would appear when we render them, taking into account breaking. But now that we know the maximum width of each group if left unbroken, we can make breaking decisions.</p> <p>As we walk the DOM, we keep track of the current column and indentation value. For each group, we decide to break it if either:</p> <ol> <li> <p>Its width, plus the current column value, exceeds the maximum column width.</p> </li> <li> <p>It contains any newlines, something that can be determined in the first pass.</p> </li> </ol> <p>The first case is why we can’t actually treat tabs as if they advance to a tabstop. We cannot know the column at which a node will be placed at the time that we measure its width, so we need to assume the worst case.</p> <p>Whenever we hit a newline, we update the current width to the width induced by indentation, simulating a newline plus indent. We also need to evaluate the condition, if present, on each tag now, since by the time we inspect a non-group tag, we have already made a decision as to whether to break or not.</p> <h3 id="render-it"><a href="#render-it">Render It!</a></h3> <p>Now that everything is determined, rendering is super easy: just walk the DOM and print out all the text nodes that either have no condition or whose condition matches the innermost group they’re inside of.</p> <p>And, of course, this is where we need to be careful with indentation: you don’t want to have lines that end in whitespace, so you should make sure to not print out any spaces until text is written after a newline. This is also a good opportunity to merge adjacent only-newlines text blocks. The merge algorithm I like is to make sure that when <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code> newline blocks are adjacent, print <code class="language-plaintext highlighter-rouge">max(n, m)</code> newlines. This ensures that a DOM node containing <code class="language-plaintext highlighter-rouge">\n\n\n</code> is respected, while deleting a bunch of <code class="language-plaintext highlighter-rouge">\n</code>s in a row that would result in many blank lines.</p> <p>What’s awesome about this approach is that the layout algorithm is highly generic: you can re-use it for whatever compiler frontend you like, without needing to fuss with layout yourself. There is a very direct conversion from AST to DOM, and the result is very declarative.</p> <h3 id="more-complicated-yaml"><a href="#more-complicated-yaml">More Complicated: YAML</a></h3> <p>YAML is a superset of JSON that SREs use to write sentient configuration files. It has a funny list syntax that we might want to use for multi-line lists, but we might want to keep JSON-style lists for short ones.</p> <p>A document of nested lists might look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="pi">-</span> <span class="pi">[</span><span class="nv">1</span><span class="pi">,</span> <span class="nv">2</span><span class="pi">,</span> <span class="nv">3</span><span class="pi">,</span> <span class="nv">4</span><span class="pi">,</span> <span class="nv">5</span><span class="pi">,</span> <span class="nv">6</span><span class="pi">,</span> <span class="nv">7</span><span class="pi">,</span> <span class="nv">8</span><span class="pi">,</span> <span class="nv">9</span><span class="pi">,</span> <span class="nv">10</span><span class="pi">,</span> <span class="nv">11</span><span class="pi">,</span> <span class="nv">12</span><span class="pi">]</span>
<span class="pi">-</span> <span class="pi">[</span><span class="nv">13</span><span class="pi">,</span> <span class="nv">14</span><span class="pi">,</span> <span class="nv">15</span><span class="pi">,</span> <span class="nv">16</span><span class="pi">,</span> <span class="nv">17</span><span class="pi">,</span> <span class="nv">18</span><span class="pi">,</span> <span class="nv">19</span><span class="pi">,</span> <span class="nv">20</span><span class="pi">,</span> <span class="nv">21</span><span class="pi">,</span> <span class="nv">22</span><span class="pi">,</span> <span class="nv">23</span><span class="pi">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">YAML</div></div></div> <p>How might we represent this in the DOM? Starting from our original JSON document <code class="language-plaintext highlighter-rouge">{"foo": [1, 2]}</code>, we might go for something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;group&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"{"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">'"foo"'</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">":"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;group&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"["</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">","</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">" "</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"- "</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;indent</span> <span class="na">by=</span><span class="s">"  "</span><span class="nt">&gt;</span>
        <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/indent&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"]"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/group&gt;</span>
  <span class="nt">&lt;/indent&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"\n"</span> <span class="na">if=</span><span class="s">broken</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;text</span> <span class="na">s=</span><span class="s">"}"</span> <span class="na">if=</span><span class="s">flat</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/group&gt;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">XML</div></div></div> <p>Here, we’ve made the <code class="language-plaintext highlighter-rouge">[]</code> and the comma only appear in flat mode, while in broken mode, we have a <code class="language-plaintext highlighter-rouge">- </code> prefix for each item. The inserted newlines have also changed somewhat, and the indentation blocks have moved: now only the value is indented, since YAML allows the <code class="language-plaintext highlighter-rouge">-</code>s of list items to be at the same indentation level as the parent value for lists nested in objects. (This is a case where some layout logic is language-specific, but now the output is worrying about declarative markup rather than physical measurements.)</p> <p>There are other enhancements you might want to make to the DOM I don’t describe here. For example, comments want to be word-wrapped, but you might not know what the width is until layout happens. Having a separate tag for word-wrapped blocks would help here.</p> <p>Similarly, a mechanism for “partial breaks”, such as for the document below, could be implemented by having a type of line break tag that breaks if the text that follows overflows the column, which can be easily implemented by tracking the position of the last such break tag.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"very"</span><span class="p">,</span><span class="w"> </span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"list"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"of"</span><span class="p">,</span><span class="w"> </span><span class="s2">"strings"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <h2 id="using-this-yourself"><a href="#using-this-yourself">Using This Yourself</a></h2> <p>I think that a really good formatter is essential for any programming language, and I think that a high-quality library that does most of the heavy-lifting is important to make it easier to demand good formatters.</p> <p><a href="https://github.com/mcy/strings/tree/main/allman">So I wrote a Rust library.</a> I haven’t released it on crates.io because I don’t think it’s quite at the state I want, but it turns out that the layout algorithm is very simple, so porting this to other languages should be EZ.</p> <p>Now you have no excuse. :D</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:pronunciation" role="doc-endnote"> <p>Everyone pronounces this acronym “ay ess tee”, but I have a friend who really like to say <em>ast</em>, rhyming with <em>mast</em>, so I’m making a callout post my twitter dot com. <a href="#fnref:pronunciation" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stanza" role="doc-endnote"> <p>In computing, a group of lines not separated by blank lines is called a stanza, in analogy to the stanzas of a poem, which are typeset with no blank lines between the lines of the stanza. <a href="#fnref:stanza" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:offsets" role="doc-endnote"> <p>You could also just store a string, containing the original text, but storing offsets is necessary for <em>diagnostics</em>, which is the jargon term for a compiler error. Compiler errors are recorded using an AST node as context, and to report the line at which the error occurred, we need to be able to map the node back to its offset in the file.</p> <p>Once we have the offset, we can calculate the line in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time using binary search. Having pre-computed an array of the offset of each <code class="language-plaintext highlighter-rouge">\n</code> byte in the input file, binary search will tell us the index and offset of the <code class="language-plaintext highlighter-rouge">\n</code> before the token; this index is the zero-indexed line number, and the string from that <code class="language-plaintext highlighter-rouge">\n</code> to the offset can be used to calculate the column.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">unicode_width</span><span class="p">::</span><span class="n">UnicodeWidthStr</span><span class="p">;</span>

<span class="cd">/// Returns the index of each newline. Can be pre-computed and re-used</span>
<span class="cd">/// multiple times.</span>
<span class="k">fn</span> <span class="nf">newlines</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">file</span><span class="nf">.bytes</span><span class="p">()</span>
      <span class="nf">.enumerate</span><span class="p">()</span>
      <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// Returns the line and column of the given offset, given the line</span>
<span class="cd">/// tarts of the file.</span>
<span class="k">fn</span> <span class="nf">location</span><span class="p">(</span>
  <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="n">newlines</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
  <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">newlines</span><span class="nf">.binary_search</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Ok means that offset refers to a newline, so this means</span>
    <span class="c1">// we want to return the width of the line that it ends as</span>
    <span class="c1">// the column.</span>
    <span class="c1">//</span>
    <span class="c1">// Err means that this is after the nth newline, except Err(0),</span>
    <span class="c1">// which means it is before the first one.</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">file</span><span class="p">[</span><span class="n">newlines</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">..</span><span class="n">offset</span><span class="p">]</span><span class="nf">.width</span><span class="p">()),</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><a href="#fnref:offsets" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:80-cols" role="doc-endnote"> <p>The Rust people keep trying to convince me that it should be 100. They are wrong. 80 is perfect. They only think they need 100 because they use the incorrect tab width of four spaces, rather than two. This is the default for clang-format and it’s <em>perfect</em>. <a href="#fnref:80-cols" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-04-14</span> / <h6 style="display:inline"><a href="/2025/04/14/target-triples/">What the Hell Is a Target Triple?</a></h6> <li> <span class="post-meta">2025-04-08</span> / <h6 style="display:inline"><a href="/2025/04/08/protobuf-tip-1/">Protobuf Tip #1: Field Names Are Forever</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>