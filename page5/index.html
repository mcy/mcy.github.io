<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2022-07-13 • 2429 words • 20 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#templates">#templates</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <h1><a href="/2022/07/13/tuples-the-hard-way/"> std::tuple the Hard Way </a></h1> </div> <div class="post"> <p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">tuple</span> <span class="p">{</span>
  <span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoidGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVzPlxuY2xhc3MgdHVwbGUg e1xuICBUeXBlcy4uLiB2YWx1ZXM7XG59OyIsImNvbXBpbGVycyI6W10sImV4 ZWN1dG9ycyI6W3siY29tcGlsZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJP dXRwdXRWaXNpYmxlIjp0cnVlLCJjb21waWxlciI6eyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6IiJ9fV19XX0=">godbolt</a><div class="codeblock-button">C++</div></div></div> <p>If you click through to Godbolt, you’ll see it doesn’t: this feature doesn’t exist in C++<sup id="fnref:circle-cxx" role="doc-noteref"><a href="#fn:circle-cxx" class="footnote" rel="footnote">2</a></sup> (normally, you’d do <code class="language-plaintext highlighter-rouge">std::tuple&lt;Types...&gt;</code>, but we need to write down <code class="language-plaintext highlighter-rouge">std::tuple</code> somehow). The usual approach is to use some kind of recursive template, which can tend to generate a lot of code.</p> <p>However, C++ does actually have tuples built into the language, as a C++11 feature… lambdas! As an extra challenge, we’re going to try to minimize the number of templates that the compiler needs to instantiate; <code class="language-plaintext highlighter-rouge">std::tuple</code> is famously bad about this and can lead to very poor build performance.</p> <p>For our tuple library type, we need to solve the following problems:</p> <ul> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple()</code> and <code class="language-plaintext highlighter-rouge">std::tuple(args...)</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::apply</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple_element</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::get</code>?</li> </ul> <h2 id="the-power-of-"><a href="#the-power-of-">The Power of [](){}</a></h2> <p>Alright, let’s back up. In C++11, we got <em>lambdas</em>, which are expressions that expand to anonymous functions. In C++, lambdas are <em>closures</em>, meaning that they capture (“close over”) their environment.</p> <p>This is a lambda in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">// 13</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">3</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <ol> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</p> </li> </ol> <p>We can use this type like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">4</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now, our constructor looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">5</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">6</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now we can see everything in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">7</a></sup>.</p> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:circle-cxx" role="doc-endnote"> <p>The Circle compiler totally laughs in our faces, though, because it <em>has this exact syntax</em>. <a href="https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple">https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple</a> <a href="#fnref:circle-cxx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoiXG4jaW5jbHVkZSA8bmV3PiBcbiNpbmNsdWRlIDx1dGlsaXR5PiBcblxu ICAgIHRlbXBsYXRlIDx0eXBlbmFtZSBUPlxuICAgIGNsYXNzIGFsaWduYXMo VCkgU3RvcmFnZUZvciB7XG4gICAgIHB1YmxpYzpcbiAgICAgIFN0b3JhZ2VG b3IoKSA9IGRlZmF1bHQ7XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4g QXJncz5cbiAgICAgIHZvaWQgSW5pdChBcmdzJiYuLi4gYXJncykge1xuICAg ICAgICBuZXcgKHJlaW50ZXJwcmV0X2Nhc3Q8VCo+KCZkYXRhXykpIFQoXG4g ICAgICAgICAgc3RkOjpmb3J3YXJkPEFyZ3M+KGFyZ3MpLi4uKTtcbiAgICAg IH1cblxuICAgICAgY29uc3QgVCogZ2V0KCkgY29uc3QgeyByZXR1cm4gcmVp bnRlcnByZXRfY2FzdDxjb25zdCBUKj4oJmRhdGFfKTsgfVxuICAgICAgVCog Z2V0KCkgeyByZXR1cm4gcmVpbnRlcnByZXRfY2FzdDxUKj4oJmRhdGFfKTsg fVxuICAgICAgY29uc3QgVCYgb3BlcmF0b3IqKCkgY29uc3QgeyByZXR1cm4g KmdldCgpOyB9XG4gICAgICBUJiBvcGVyYXRvciooKSB7IHJldHVybiAqZ2V0 KCk7IH1cbiAgICAgIGNvbnN0IFQqIG9wZXJhdG9yLT4oKSBjb25zdCB7IHJl dHVybiBnZXQoKTsgfVxuICAgICAgVCogb3BlcmF0b3ItPigpIHsgcmV0dXJu IGdldCgpOyB9XG4gICAgIHByaXZhdGU6XG4gICAgICBjaGFyIGRhdGFfW3Np emVvZihUKV07XG4gICAgfTtcblxuICAgIHRlbXBsYXRlIDx0eXBlbmFtZS4u LiBUeXBlcz5cbiAgICBjbGFzcyBUdXBsZSB7XG4gICAgIHB1YmxpYzpcbiAg ICAgIFR1cGxlKCkge1xuICAgICAgICBsYW1iZGFfKFtdIChTdG9yYWdlRm9y PFR5cGVzPiYuLi4gcGxhY2VzKSB7XG4gICAgICAgICAgKHBsYWNlcy5Jbml0 KCksIC4uLik7XG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgdGVt cGxhdGUgPHR5cGVuYW1lLi4uIEFyZ3MsXG4gICAgICAgICAgICAgICAgZGVj bHR5cGUoKG5ldyAobnVsbHB0cikgVHlwZXMoc3RkOjpkZWNsdmFsPEFyZ3M+ KCkpLCAuLi4pKVxuICAgICAgICAgICAgICAgICAgPSBudWxscHRyPlxuICAg ICAgVHVwbGUoQXJncyYmLi4uIGFyZ3MpIHtcbiAgICAgICAgbGFtYmRhXyhb Jl0gKFN0b3JhZ2VGb3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAg ICAocGxhY2VzLkluaXQoc3RkOjpmb3J3YXJkPGRlY2x0eXBlKGFyZ3MpPihh cmdzKSksIC4uLik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBU dXBsZShjb25zdCBUdXBsZSYgdGhhdCkge1xuICAgICAgICBsYW1iZGFfKFsm XSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRoZXNlKSB7XG4gICAgICAgICAg dGhhdC5sYW1iZGFfKFsmXSAoY29uc3QgU3RvcmFnZUZvcjxUeXBlcz4mLi4u IHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVzZS5nZXQoKSkgVHlw ZXMoKnRob3NlKSwgLi4uKTsgICBcbiAgICAgICAgICB9KTtcbiAgICAgICAg fSk7XG4gICAgICB9XG5cbiAgICAgIFR1cGxlKFR1cGxlJiYgdGhhdCkge1xu ICAgICAgICBsYW1iZGFfKFsmXSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRo ZXNlKSB7XG4gICAgICAgICAgdGhhdC5sYW1iZGFfKFsmXSAoU3RvcmFnZUZv cjxUeXBlcz4mLi4uIHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVz ZSkgVHlwZXMoc3RhdGljX2Nhc3Q8VHlwZXMmJj4oKnRob3NlKSksIC4uLik7 ICAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4g ICAgICB+VHVwbGUoKSB7XG4gICAgICAgIGxhbWJkYV8oW10gKFN0b3JhZ2VG b3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAgICAocGxhY2VzLT5+ VHlwZXMoKSwgLi4uKTtcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAg IHByaXZhdGU6XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4gQXJncz5c biAgICAgIHN0YXRpYyBhdXRvIFR1cGxlTGFtYmRhKEFyZ3MuLi4gYXJncykg e1xuICAgICAgICByZXR1cm4gWz1dIChhdXRvIGNhbGxiYWNrKSBtdXRhYmxl IC0+IGRlY2x0eXBlKGF1dG8pIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJh Y2soYXJncy4uLik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG11 dGFibGUgZGVjbHR5cGUoVHVwbGVMYW1iZGEoU3RvcmFnZUZvcjxUeXBlcz57 fS4uLikpIGxhbWJkYV8gPVxuICAgICAgICBUdXBsZUxhbWJkYShTdG9yYWdl Rm9yPFR5cGVzPnt9Li4uKTtcbiAgICB9O1xuXG4gICAgdGVtcGxhdGUgPHR5 cGVuYW1lLi4uIFR5cGVzPlxuICAgIFR1cGxlKFR5cGVzLi4uKSAtPiBUdXBs ZTxUeXBlcy4uLj47XG4gICAgdGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVz PlxuICAgIFR1cGxlKGNvbnN0IFR1cGxlPFR5cGVzLi4uPiYpIC0+IFR1cGxl PFR5cGVzLi4uPjtcblxuICAgIGludCBtYWluKCkge1xuICAgICAgVHVwbGUg dHVwezEsIDIsIFwiZm9vXCIsIFwiYmFyXCJ9O1xuICAgICAgVHVwbGUgdHVw MiA9IHR1cDtcbiAgICB9IiwiY29tcGlsZXJzIjpbeyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6Ii0tc3RkPWMrKzE3In1dfV19 ">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="cp">#endif
</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>
  
  <span class="cp">#else // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span>  <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cp">#endif // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tup</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="cp">#if USE_CLANG_INTRINSIC
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="cp">#else
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TupleType</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/z/eYeb9Y6cn">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2022-06-07 • 5329 words • 44 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> </span> <h1><a href="/2022/06/07/alkyne-gc/"> The Alkyne GC </a></h1> </div> <div class="post"> <p><a href="https://github.com/mcy/alkyne">Alkyne</a> is a scripting language I built a couple of years ago for generating configuration blobs. Its interpreter is a naive AST walker<sup id="fnref:ast-walker" role="doc-noteref"><a href="#fn:ast-walker" class="footnote" rel="footnote">1</a></sup> that uses ARC<sup id="fnref:arc" role="doc-noteref"><a href="#fn:arc" class="footnote" rel="footnote">2</a></sup> for memory management, so it’s pretty slow, and I’ve been gradually writing a <a href="https://github.com/mcy/alkyne/tree/new-engine">new evaluation engine</a> for it.</p> <p>This post isn’t about Alkyne itself, that’s for another day. For now, I’d like to write down some notes for the GC I wrote<sup id="fnref:src" role="doc-noteref"><a href="#fn:src" class="footnote" rel="footnote">3</a></sup> for it, and more generally provide an introduction to memory allocators (especially those that would want to collude with a GC).</p> <p>This post is intended for people familiar with the basics of low-level programming, such as pointers and syscalls. Alkyne’s GC is intended to be simple while still having reasonable performance. This means that the design contains all the allocator “tropes,” but none of the hairy stuff.</p> <p>My hope is readers new to allocators or GCs will come away with an understanding of these tropes and the roles they play in a modern allocator.</p> <blockquote> <p>Thank you to James Farrell, Manish Goregaokar, Matt Kulukundis, JeanHeyd Meneide, Skye Thompson, and Paul Wankadia for providing feedback on various drafts of this article. This was a tough one to get right. :)</p> </blockquote> <h2 id="trailhead"><a href="#trailhead">Trailhead</a></h2> <p>The Alkyne GC is solving a very specific problem, which allows us to limit what it actually needs to do. Alkyne is an “embeddable” language like JavaScript, so its heap is not intended to be big; in fact, for the benefit of memory usage optimizations, it’s ideal to use 32-bit pointers (a 4 gigabyte address space).</p> <p>The heap needs to be able to manage arbitrarily-large allocations (for lists), and allocations as small as eight bytes (for floats<sup id="fnref:nan-boxing" role="doc-noteref"><a href="#fn:nan-boxing" class="footnote" rel="footnote">4</a></sup>). Allocation should be reasonably quick, but due to the size of the heap, walking the entire heap is totally acceptable.</p> <p>Because we’re managing a fixed-size heap, we can simply ask the operating system for a contiguous block of that size up-front using the <code class="language-plaintext highlighter-rouge">mmap()</code> syscall. An Alkyne pointer is simply a 32-bit offset into this giant allocation, which can be converted to and from a genuine CPU pointer by adding or subtracting the base address of the heap.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text"> 4GB Heap
 +-------------------------------------------------+
 |                x                                |
 +-------------------------------------------------+
 ^                ^
 base             base + ptr_to_x</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>The OS won’t actually reserve 4GB of memory for us; it will only allocate one system page (4KB) at a time. If we read or write to a particular page in the heap for the first time, the OS will only then find physical RAM to back it<sup id="fnref:os-allocator" role="doc-noteref"><a href="#fn:os-allocator" class="footnote" rel="footnote">5</a></sup>.</p> <p>Throughout, we’ll be working with this fixed-size heap, and won’t think too hard about where it came from. For our purposes, it is essentially a <code class="language-plaintext highlighter-rouge">Box&lt;[u8]&gt;</code>, but we’ll call it a <code class="language-plaintext highlighter-rouge">Heap&lt;[u8]&gt;</code> to make it clear this memory we got from the operating system (but, to be clear, the entire discussion applies just as well to an ordinary gigantic <code class="language-plaintext highlighter-rouge">Box&lt;[u8]&gt;</code>)</p> <p>The Alkyne language does not have threads, so we can eschew concurrency. This significantly reduces the problems we will need to solve. Most modern allocators and garbage collectors are violently concurrent by nature, and unfortunately, much too advanced for one article. There are links below to fancier GCs you can poke around in.</p> <h2 id="a-heap-of-trouble"><a href="#a-heap-of-trouble">A Heap of Trouble</a></h2> <p>To build a garbage collector, we first need an allocator. We could “just”<sup id="fnref:load-bearing" role="doc-noteref"><a href="#fn:load-bearing" class="footnote" rel="footnote">6</a></sup> use the system heap as a source of pages, but most garbage collectors collude with the allocator, since they will want to use similar data structures. Thus, if we are building a garbage collector, we might as well build the allocator too.</p> <p>An allocator, or “memory heap” (not to be confused with a min-heap, an unrelated but <em>wicked</em> data structure), services requests for <em>allocations</em>: unique leases of space in the managed heap of various sizes, which last for lifetimes not known until runtime. These allocations may also be called <em>objects</em>, and a heap may be viewed as a general-purpose object pool.</p> <p>The most common API for a heap is:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Allocator</span> <span class="p">{</span>
  <span class="c1">// Returns a *unique pointer* managed by this allocator</span>
  <span class="c1">// to memory as large as requested, and as aligned</span>
  <span class="c1">// as we'd like.</span>
  <span class="c1">// </span>
  <span class="c1">// Returns null on failure.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
  <span class="c1">// Frees a pointer returned by `Alloc` may be called at</span>
  <span class="c1">// most once.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <blockquote> <p>Originally the examples were in C++, which I feel is more accessible (lol) but given that Alkyne itself is written in Rust I felt that would make the story flow better.</p> </blockquote> <p>This is the “malloc” API, which is actually very deficient; ideally, we would do something like Rust’s <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html"><code class="language-plaintext highlighter-rouge">Allocator</code></a>, which requires providing size <em>and</em> alignment to both the allocation <em>and</em> deallocation functions.</p> <p>Unfortunately<sup id="fnref:i-tried" role="doc-noteref"><a href="#fn:i-tried" class="footnote" rel="footnote">7</a></sup>, this means I need to explain alignment.</p> <h3 id="good-pointers-evil-pointers-lawful-pointers-chaotic-pointers"><a href="#good-pointers-evil-pointers-lawful-pointers-chaotic-pointers">Good Pointers, Evil Pointers, Lawful Pointers, Chaotic Pointers</a></h3> <p>“Alignment” is a somewhat annoying property of a pointer. A pointer is aligned to N bytes (always a power of 2) if its address is divisible by N. A pointer is “well-aligned” (or just “aligned”) if its address is aligned to the natural alignment of the thing it points to. For ints, this is <em>usually</em> their size; for structs, it is the maximum alignment among the alignments of the fields of that struct.</p> <p>Performing operations on a pointer requires that it be aligned<sup id="fnref:unaligned" role="doc-noteref"><a href="#fn:unaligned" class="footnote" rel="footnote">8</a></sup>. This is annoying because it requires some math. Specifically we need three functions:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="cd">/// Checks that `ptr` is aligned to an alignment.</span>
<span class="k">fn</span> <span class="nf">is_aligned</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
  <span class="n">ptr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="cd">/// Rounds `ptr` down to a multiple of `align`.</span>
<span class="k">fn</span> <span class="nf">align_down</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="n">ptr</span> <span class="o">&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Rounds `ptr` up to a multiple of `align`.</span>
<span class="k">fn</span> <span class="nf">align_up</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="c1">// (I always look this one up. &gt;_&gt;)</span>
  <span class="nf">align_down</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Computes how much needs to be added to `ptr` to align it.</span>
<span class="k">fn</span> <span class="nf">misalign</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">align_up</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> <span class="o">-</span> <span class="n">ptr</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(Exercise: prove these formulas.)</p> <p>For the rest of the article I will assume I have these three functions available at any time for whatever type of integer I’d like (including raw pointers which are just boutique<sup id="fnref:provenance" role="doc-noteref"><a href="#fn:provenance" class="footnote" rel="footnote">9</a></sup> integers).</p> <p>Also we will treat the <code class="language-plaintext highlighter-rouge">Heap&lt;[u8]&gt;</code> holding our entire heap as being infinitely aligned; i.e. as a pointer it is aligned to all possible alignments that could matter (i.e. page-aligned, 4KB as always). (For an ordinary <code class="language-plaintext highlighter-rouge">Box&lt;[u8]&gt;</code>, this is not true.)</p> <h3 id="the-trivial-heap"><a href="#the-trivial-heap">The Trivial Heap</a></h3> <p>Allocating memory is actually very easy. <em>Arenas</em> are the leanest and meanest in the allocator food chain; they simply don’t bother to free any memory.</p> <p>This means allocation is just incrementing a cursor indicating where the hitherto-unallocated memory is.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text"> +-------------------------------------------------+
 | Allocated        | Free                         |
 +-------------------------------------------------+
                    ^
                    cursor</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Our allocator is as simple as <code class="language-plaintext highlighter-rouge">return ptr++;</code>.</p> <p>This is straightforward to implement in code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Arena</span> <span class="p">{</span>
  <span class="n">heap</span><span class="p">:</span> <span class="n">Heap</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">cursor</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Allocator</span> <span class="k">for</span> <span class="n">Arena</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="c1">// To get an aligned pointer, we need to burn some "alignment</span>
    <span class="c1">// padding". This is one of the places where alignment is</span>
    <span class="c1">// annoying.</span>
    <span class="k">let</span> <span class="n">needed</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="nf">misalign</span><span class="p">(</span><span class="k">self</span><span class="py">.heap</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="n">align</span><span class="p">);</span>

    <span class="c1">// Check that we're not out of memory.</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.heap</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="k">self</span><span class="py">.cursor</span> <span class="o">&lt;</span> <span class="n">needed</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Advance the cursor and cut off the end of the allocated</span>
    <span class="c1">// section.</span>
    <span class="k">self</span><span class="py">.cursor</span> <span class="o">+=</span> <span class="n">needed</span><span class="p">;</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.heap</span><span class="p">[</span><span class="k">self</span><span class="py">.cursor</span> <span class="o">-</span> <span class="n">size</span><span class="p">]</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ayy lmao</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Arenas are very simple, but far from useless! They’re great for holding onto data that exists for the context of a “session”, such as for software that does lots of computations and then exits (a compiler) or software that handles requests from clients, where lots of data lives for the duration of the request and no longer (a webserver).</p> <p>They are not, however, good for long-running systems. Eventually the heap will be exhausted if objects are not recycled.</p> <p>Making this work turns out to be hard<sup>[citation-needed]</sup>. This is the “fundamental theorem” of allocators:</p> <blockquote> <h4 id="fundamental-theorem-of-allocators"><a href="#fundamental-theorem-of-allocators">Fundamental “Theorem” of Allocators</a></h4> <p>Handing out memory is easy. Handing it out <em>repeatedly</em> is hard.</p> </blockquote> <p>Thankfully, over the last fifty years we’ve mostly figured this out. Allocator designs can get pretty gnarly.</p> <h2 id="four-tropes"><a href="#four-tropes">Four Tropes</a></h2> <p>From here, we will gradually augment our allocator with more features to allow it to service all kinds of requests. For this, we will implement four common allocator features:</p> <ol> <li>Blocks and a block cache.</li> <li>Free lists.</li> <li>Block merging and splitting.</li> <li>Slab allocation.</li> </ol> <p>All four of these are present in some form in most modern allocators.</p> <h3 id="blocks"><a href="#blocks">Blocks</a></h3> <p>The first thing we should do is to deal in fixed-size blocks of memory of some minimum size. If you ask <code class="language-plaintext highlighter-rouge">malloc()</code> for a single byte, it will probably give you like 8 bytes on most systems. No one is asking <code class="language-plaintext highlighter-rouge">malloc()</code> for single bytes, so we can quietly round up and not have people care. (Also, Alkyne’s smallest heap objects are eight bytes, anyways.)</p> <p>Blocks are also convenient, because we can keep per-block metadata on each one, as a header before the user’s data:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Block</span> <span class="p">{</span>
  <span class="n">header</span><span class="p">:</span> <span class="n">Header</span><span class="p">,</span>
  <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SIZE</span><span class="p">],</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>To allow blocks to be re-used, we can keep a cache of recently freed blocks. The easiest way to do this is with a stack. Note that the heap is now made of <code class="language-plaintext highlighter-rouge">Block</code>s, not plain bytes.</p> <p>To allocate storage, first we check the stack. If the stack is empty, we revert to being an arena and increment the cursor. To free, we push the block onto the stack, so <code class="language-plaintext highlighter-rouge">alloc()</code> can return it on the next call.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">BlockCache</span> <span class="p">{</span>
  <span class="n">heap</span><span class="p">:</span> <span class="n">Heap</span><span class="o">&lt;</span><span class="p">[</span><span class="n">Block</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">cursor</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">free_stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">Block</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Allocator</span> <span class="k">for</span> <span class="n">BlockCache</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="c1">// Check that the size isn't too big. We don't need to</span>
    <span class="c1">// bother with alignment, because every block is</span>
    <span class="c1">// infinitely-aligned, just like the heap itself.</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">BLOCK_SIZE</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Try to serve a block from the stack.</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free_stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">block</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Fall back to arena mode.</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.cursor</span> <span class="o">==</span> <span class="k">self</span><span class="py">.heap</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="py">.cursor</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.heap</span><span class="p">[</span><span class="k">self</span><span class="py">.cursor</span><span class="p">]</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Use pointer subtraction to find the start of the block.</span>
    <span class="k">let</span> <span class="n">block</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.sub</span><span class="p">(</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Header</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.free_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This allocator has a problem: it relies on the system allocator! <code class="language-plaintext highlighter-rouge">Heap</code> came directly from the OS, but <code class="language-plaintext highlighter-rouge">Vec</code> talks to <code class="language-plaintext highlighter-rouge">malloc()</code> (or something like it). It also adds some pretty big overhead: the <code class="language-plaintext highlighter-rouge">Vec</code> needs to be able to resize, since it grows as more and more things are freed. This can lead to long pauses during <code class="language-plaintext highlighter-rouge">free()</code> as the vector resizes.</p> <p>Cutting out the middleman gives us more control over this overhead.</p> <h3 id="free-lists"><a href="#free-lists">Free Lists</a></h3> <p>Of course, no one has ever heard of a “free stack”; everyone uses free lists! A free list is the cache idea but implemented as an <em>intrusive linked list</em>.</p> <p>A linked list is this data structure:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nb">Nil</span><span class="p">,</span>
  <span class="nf">Cons</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>
  <span class="c1">//   ^~~ oops I allocated again</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the same problem of needing to find an allocator to store the nodes. An intrusive list avoids that by making the nodes <em>part</em> of the elements. The <code class="language-plaintext highlighter-rouge">Header</code> we reserved for ourselves earlier is the perfect place to put it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Header</span> <span class="p">{</span>
  <span class="cd">/// Pointer to the next and previous blocks in whatever</span>
  <span class="cd">/// list the block is in.</span>
  <span class="n">next</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">,</span>
  <span class="n">prev</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In particular we want to make sure block are in doubly-linked lists, which have the property that any element can be removed from them without walking the list.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">   list.root
     |
     v
 +-&gt; Block--------------------------+
 |   | next | null | data data data |
 |   +------------------------------+
 +-----/------+
      /       |
     v        |
 +-&gt; Block--------------------------+
 |   | next | prev | data data data |
 |   +------------------------------+
 +-----/------+
      /       |
     v        |
 +-&gt; Block--------------------------+
 |   | next | prev | data data data |
 |   +------------------------------+
 +-----/------+
      /       |
     v        |
     Block--------------------------+
     | null | prev | data data data |
     +------------------------------+</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>We also introduce a <code class="language-plaintext highlighter-rouge">List</code> container type that holds the root node of a list of blocks, to give us a convenient container-like API. This type looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
  <span class="cd">/// The root is actually a sacrificial block that exists only to</span>
  <span class="cd">/// make it possible to unlink blocks in the middle of a list. This</span>
  <span class="cd">/// needs to exist so that calling unlink() on the "first" element</span>
  <span class="cd">/// of the list has a predecessor to replace itself with.</span>
  <span class="n">root</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">List</span> <span class="p">{</span>
  <span class="cd">/// Pushes a block onto the list.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Block</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">block</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">root</span><span class="py">.header.next</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">root</span><span class="py">.header.next</span><span class="p">;</span>
      <span class="n">block</span><span class="py">.header.next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
      <span class="n">first</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">root</span><span class="py">.header.next</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
    <span class="n">block</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cd">/// Gets the first element of the list, if any.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">first</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">Block</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
    <span class="n">root</span><span class="py">.header.next</span><span class="nf">.as_mut</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We should also make it possible to ask a block whether it is in any list, and if so, remove it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Block</span> <span class="p">{</span>
  <span class="cd">/// Checks if this block is part of a list.</span>
  <span class="k">fn</span> <span class="nf">is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="c1">// Only the prev link is guaranteed to exist; next is</span>
    <span class="c1">// null for the last element in a list. Sacrificial</span>
    <span class="c1">// nodes will never have prev non-null, and can't be</span>
    <span class="c1">// unlinked.</span>
    <span class="o">!</span><span class="k">self</span><span class="py">.header.prev</span><span class="nf">.is_null</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="cd">/// Unlinks this linked block from whatever list it's in.</span>
  <span class="k">fn</span> <span class="nf">unlink</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_linked</span><span class="p">());</span>
    <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.header.next</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.header.next</span><span class="p">;</span>
      <span class="n">next</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="k">self</span><span class="py">.header.prev</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="c1">// This is why we need the sacrificial node.</span>
    <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.header.prev</span><span class="p">;</span>
    <span class="n">prev</span><span class="py">.header.next</span> <span class="o">=</span> <span class="k">self</span><span class="py">.header.next</span><span class="p">;</span>

    <span class="k">self</span><span class="py">.header.prev</span> <span class="o">=</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.header.next</span> <span class="o">=</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Using these abstractions we can upgrade <code class="language-plaintext highlighter-rouge">BlockCache</code> to <code class="language-plaintext highlighter-rouge">FreeList</code>. We only need to rename <code class="language-plaintext highlighter-rouge">free_stack</code> to <code class="language-plaintext highlighter-rouge">free_list</code>, and make a one-line change:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="o">-</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free_stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
<span class="o">+</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free_list</span><span class="nf">.first</span><span class="p">()</span> <span class="p">{</span>
<span class="o">+</span>   <span class="n">block</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">block</span><span class="py">.data</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
 <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Hooray for encapsulation!</p> <p>This is a very early <code class="language-plaintext highlighter-rouge">malloc()</code> design, similar to the one described in the K&amp;R C book. It does have big blind spot: it can only serve up blocks up to a fixed size! It’s also quite wasteful, because all allocations are served the same size blocks: the bigger we make the maximum request, the more wasteful <code class="language-plaintext highlighter-rouge">alloc(8)</code> gets.</p> <h3 id="block-splitting-alkynes-way"><a href="#block-splitting-alkynes-way">Block Splitting (Alkyne’s Way)</a></h3> <p>The next step is to use a block splitting/merging scheme, such as the <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation"><em>buddy system</em></a>. Alkyne does not precisely use a buddy system, but it does something similar.</p> <p>Alkyne does not have fixed-size blocks. Like many allocators, it defines a “page” of memory as the atom that it keeps its data structures. Alkyne defines a page to be 4KB, but other choices are possible: TCMalloc uses 8KB pages.</p> <p>In Alkyne, pages come together to form contiguous, variable-size <em>reams</em> (get it?). These take the place of blocks.</p> <h4 id="page-descriptors"><a href="#page-descriptors">Page Descriptors</a></h4> <p>Merging and splitting makes it hard to keep headers at the start of reams, so Alkyne puts them all in a giant array somewhere else. Each page gets its own “header” called a page descriptor, or <a href="https://github.com/mcy/alkyne/blob/a62ad3b7ee70268625da640c1edeea8ff7116512/src/eval2/gc.rs#L416"><code class="language-plaintext highlighter-rouge">Pd</code></a>.</p> <p>The array of page descriptors lives at the beginning of the heap, and the actual pages follow after that. It turns out that this array has a maximum size, which we can use to pre-compute where the array ends.</p> <p>Currently, each <code class="language-plaintext highlighter-rouge">Pd</code> is 32 bytes, in addition to the 4KB it describes. If we divide 4GB by 32 + 4K, it comes out to around four million pages (4067203 to be precise). Rounded up to the next page boundary, this means that pages begin at the 127102nd 4K boundary after the <code class="language-plaintext highlighter-rouge">Heap&lt;[u8]&gt;</code> base address, or an offset of <code class="language-plaintext highlighter-rouge">0x7c1f400</code> bytes.</p> <p>Having them all in a giant array is also very useful, because it means the GC can trivially find <em>every allocation</em> in the whole heap: just iterate the <code class="language-plaintext highlighter-rouge">Pd</code> array!</p> <p>So! This is our heap:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">+---------------------------------------+  &lt;-- mmap(2)'d region base
| Pd | Pd | Pd | Pd | Pd | Pd | Pd | Pd | \
+---------------------------------------+ |--- Page Descriptors
| Pd | Pd | Pd | Pd | Pd | Pd | Pd | Pd | |    for every page we can
+---------------------------------------+ |    ever allocate.
: ...                                   : |
+---------------------------------------+ |
| Pd | Pd | Pd | Pd | Pd | Pd | Pd | Pd | /
+---------------------------------------+  &lt;-- Heap base address
| Page 0                                | \    = region + 0x7c1f400
|                                       | |
|                                       | |--- 4K pages corresponding
+---------------------------------------+ |    to the Pds above.
| Page 1                                | |    (not to scale)
|                                       | |
|                                       | |
+---------------------------------------+ |
: ...                                   | |
+---------------------------------------+ |
| Page N                                | |
|                                       | |
|                                       | /
+---------------------------------------+
  (not to scale by a factor of about 4)</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Each one of those little <code class="language-plaintext highlighter-rouge">Pd</code>s looks something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Pd</span> <span class="p">{</span>
  <span class="n">gc_bits</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">prev</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
  <span class="n">class</span><span class="p">:</span> <span class="n">SizeClass</span><span class="p">,</span>
  <span class="c1">// More fields...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">prev</code> and <code class="language-plaintext highlighter-rouge">next</code> are the intrusive linked list pointers used for the free lists, but now they are indices into the <code class="language-plaintext highlighter-rouge">Pd</code> array. The other fields will be used for this and the trope that follows.</p> <p>Given a pointer into a page, we can get the corresponding <code class="language-plaintext highlighter-rouge">Pd</code> by <code class="language-plaintext highlighter-rouge">align_down()</code>‘ing to a page boundary, computing the index of the page (relative to the heap base), and then index into the <code class="language-plaintext highlighter-rouge">Pd</code> array. This process can be reversed to convert a pointer to a <code class="language-plaintext highlighter-rouge">Pd</code> into a pointer to a page, so going between the two is very easy.</p> <blockquote> <p>I won’t cover this here, but Alkyne actually wraps <code class="language-plaintext highlighter-rouge">Pd</code> pointers in a special <code class="language-plaintext highlighter-rouge">PdRef</code> type that also carries a reference to the <code class="language-plaintext highlighter-rouge">Heap</code>; this allows implementing functions like <code class="language-plaintext highlighter-rouge">is_linked()</code>, <code class="language-plaintext highlighter-rouge">unlink()</code>, and <code class="language-plaintext highlighter-rouge">data()</code> directly.</p> <p>I won’t show how this is implemented, since it’s mostly boilerplate.</p> </blockquote> <h4 id="reams-of-pages"><a href="#reams-of-pages">Reams of Pages</a></h4> <p>There is one giant free list that contains all of the reams. Reams use their first page’s descriptor to track all of their metadata, including the list pointers for the free list. The <code class="language-plaintext highlighter-rouge">len</code> field additionally tracks how many <em>additional</em> pages are in the ream. <code class="language-plaintext highlighter-rouge">gc_bits</code> is set to 1 if the page is in use and 0 otherwise.</p> <p>To allocate N continuous pages from the free ream list:</p> <ol> <li>We walk through the free ream list, and pick the first one with at least N pages.</li> <li>We “split” it: the first N pages are returned to fulfill the request.</li> <li>The rest of the ream is put back into the free list.</li> <li>If no such ream exists, we allocate a max-sized ream<sup id="fnref:max-size" role="doc-noteref"><a href="#fn:max-size" class="footnote" rel="footnote">10</a></sup> (65536 pages), and split that as above.</li> </ol> <p>In a sense, each ream is an arena that we allocate smaller reams out of; those reams cannot be “freed” back to the ream they came from. Instead, to free a ream, we just stick it back on the main free list.</p> <p>If we ever run out, we turn back into an arena and initialize the next uninitialized <code class="language-plaintext highlighter-rouge">Pd</code> in the big ol’ <code class="language-plaintext highlighter-rouge">Pd</code> array.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">ReamAlloc</span> <span class="p">{</span>
  <span class="n">heap</span><span class="p">:</span> <span class="n">Heap</span><span class="o">&lt;</span><span class="p">[</span><span class="n">Page</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">cursor</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">free_list</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// The offset to the end of the maximally-large Pd array.</span>
<span class="cd">/// This can be computed ahead of time.</span>
<span class="k">const</span> <span class="n">PAGES_START</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Allocator</span> <span class="k">for</span> <span class="n">ReamAlloc</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="c1">// We don't need to bother with alignment, because every page is</span>
    <span class="c1">// already infinitely aligned; we only allocate at the page</span>
    <span class="c1">// boundary.</span>
    <span class="k">let</span> <span class="n">page_count</span> <span class="o">=</span> <span class="nf">align_up</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4096</span><span class="p">;</span>

    <span class="c1">// Find the first page in the list that's big enough.</span>
    <span class="c1">// (Making `List` iterable is an easy exercise.)</span>
    <span class="k">for</span> <span class="n">pd</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">pd</span><span class="py">.len</span> <span class="o">&lt;</span> <span class="n">page_count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">continue</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="n">pd</span><span class="py">.len</span> <span class="o">==</span> <span class="n">page_count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="c1">// No need to split here.</span>
        <span class="n">pd</span><span class="nf">.unlink</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">pd</span><span class="nf">.data</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="c1">// We can chop off the *end* of the ream to avoid needing</span>
      <span class="c1">// to update any pointers.</span>
      <span class="k">let</span> <span class="n">new_ream</span> <span class="o">=</span> <span class="n">pd</span><span class="nf">.add</span><span class="p">(</span><span class="n">page_count</span><span class="p">);</span>
      <span class="n">new_ream</span><span class="py">.len</span> <span class="o">=</span> <span class="n">page_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">pd</span><span class="py">.len</span> <span class="o">-=</span> <span class="n">page_count</span><span class="p">;</span>

      <span class="k">return</span> <span class="n">new_ream</span><span class="nf">.data</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Allocate a new ream. This is more of the same arena stuff.</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Find the Pd corresponding to this page's pointer. This</span>
    <span class="c1">// will always be a ream's first Pd assuming the user</span>
    <span class="c1">// didn't give us a bad pointer.</span>
    <span class="k">let</span> <span class="n">pd</span> <span class="o">=</span> <span class="nn">Pd</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.free_list</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This presents a problem: over time, reams will shrink and never grow, and eventually there will be nothing left but single pages.</p> <p>Top fix this, we can merge reams (not yet implemented in Alkyne). Thus:</p> <ol> <li>Find two adjacent, unallocated reams.</li> <li>Unlink the second ream from the free list.</li> <li>Increase the length of the first ream by the number of pages in the second.</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// `reams()` returns an iterator that walks the `Pd` array using</span>
<span class="c1">// the `len` fields to find the next ream each time.</span>
<span class="k">for</span> <span class="n">pd</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.reams</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">pd</span><span class="py">.gc_bits</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
  <span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pd</span><span class="nf">.add</span><span class="p">(</span><span class="n">pd</span><span class="py">.len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">next</span><span class="py">.gc_bits</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
    <span class="n">next</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="n">pd</span><span class="py">.len</span> <span class="o">+=</span> <span class="n">next</span><span class="py">.len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We don’t need to do anything to the second ream’s <code class="language-plaintext highlighter-rouge">Pd</code>; by becoming part of the first ream, it is subsumed. Walking the heap requires using reams’ lengths to skip over currently-invalid <code class="language-plaintext highlighter-rouge">Pd</code>s, anyways.</p> <p>We have two options for finding mergeable reams. Either we can walk the entire heap, as above, or, when a ream is freed, we can check that the previous and following reams are mergeable (finding the previous ream would require storing the length of a ream at its first <em>and</em> last <code class="language-plaintext highlighter-rouge">Pd</code>).</p> <p>Which merging strategy we use depends on whether we’re implementing an ordinary <code class="language-plaintext highlighter-rouge">malloc</code>-like heap or a garbage collector; in the <code class="language-plaintext highlighter-rouge">malloc</code> case, merging on free makes more sense, but merging in one shot makes more sense for Alkyne’s GC (we’ll see why in a bit).</p> <h3 id="slabs-and-size-classes"><a href="#slabs-and-size-classes">Slabs and Size Classes</a></h3> <p>A <em>slab allocator</em> is a specialized allocator that allocates a single type of object; they are quite popular in kernels as pools of commonly-used object. The crux of a slab allocator is that, because everything is the same size, we <em>don’t</em> need to implement splitting and merging. The <code class="language-plaintext highlighter-rouge">BlockCache</code> above is actually a very primitive slab allocator.</p> <p>Our <code class="language-plaintext highlighter-rouge">Pd</code> array is also kind of like a slab allocator; instead of mixing them in with the variably-sized blocks, they all live together with no gaps in between; entire pages are dedicated just to <code class="language-plaintext highlighter-rouge">Pd</code>s.</p> <p>The Alkyne page allocator cannot allocate pages smaller than 4K, and making them any smaller increases the relative overhead of a <code class="language-plaintext highlighter-rouge">Pd</code>. To cut down on book-keeping, we slab-allocate small objects by defining <em>size classes</em>.</p> <p>A size class is size of smaller-than-a-page object that Alkyne will allocate; other sizes are rounded up to the next size class. Entire pages are dedicated to holding just objects of the same size; these are called small object pages, or simply <em>slabs</em>. The size class is tracked with the <code class="language-plaintext highlighter-rouge">class</code> field of the <code class="language-plaintext highlighter-rouge">Pd</code>.</p> <p>Each size class has its own free list of partially-filled slabs of that size. For slabs, <code class="language-plaintext highlighter-rouge">gc_bits</code> field becomes a bitset that tracks which slots in the page are currently in-use, reducing the overhead for small objects to only a little over a single bit each!</p> <p>In the diagram below, bits set in the 32-bit, little-endian bitset indicate which slots in the slab (no to scale!) are filled with three-letter words. (The user likes cats.)</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">  Pd--------------------------------------------+
  | gc_bits: 0b01010011111010100110000010101011 |
  +---------------------------------------------+

 Page--------------------------------------------+
 | cat | ink |     | hat |     | jug |     | fig |
 +-----------------------------------------------+
 |     |     |     |     |     | zip | net |     |
 +-----------------------------------------------+
 |     | aid |     | yes |     | war | cat | van |
 +-----------------------------------------------+
 | can | cat |     |     | rat |     | urn |     |
 +-----------------------------------------------+</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Allocating an object is a bit more complicated now, but now we have a really, really short fast path for small objects:</p> <ol> <li>Round up to the next highest size class, or else to the next page boundary.</li> <li>If a slab size class… a. Check the pertinent slab list for a partially-filled slab. i. If there isn’t one, allocate a page per the instructions below and initialize it as a slab page. b. Find the next available slot with <code class="language-plaintext highlighter-rouge">(!gc_bits).count_trailing_zeros()</code>, and set that bit. c. Return <code class="language-plaintext highlighter-rouge">page_addr + slab_slot_size * slot</code>.</li> <li>Else, if a single page, allocate from the single-page list. a. If there isn’t one, allocate from the ream list as usual.</li> <li>Else, multiple pages, allocate a ream as usual.</li> </ol> <p>Allocating small objects is very fast, since the slab free lists, if not empty, will always have a spot to fill in <code class="language-plaintext highlighter-rouge">gc_bits</code>. Finding the empty spot in the bitset is a few instructions (a <code class="language-plaintext highlighter-rouge">not</code> plust a <code class="language-plaintext highlighter-rouge">ctz</code> or equivalent on most hardware).</p> <p>Alkyne maintains a separate free list for single free pages to speed up finding such pages to turn into fresh slabs. This also minimizes the need to allocate single pages off of large reams, which limits fragmentation.</p> <p>Alkyne’s size classes are the powers of two from 8 (the smallest possible object) to 2048. For the classes 8, 16, and 32, which would have more than 64 slots in the page, we use up to 56 bytes on the page itself to extend <code class="language-plaintext highlighter-rouge">gc_bits</code>; 8-byte pages can only hold 505 objects, instead of the full 512, a 1% overhead.</p> <p>Directly freeing an object via is now tricky, since we do not a priori know the size.</p> <ol> <li>Round the pointer up to the next page boundary, and obtain that page’s <code class="language-plaintext highlighter-rouge">Pd</code>.</li> <li>If this is a start-of-ream page, stick it into the appropriate free list (single page or ream, depending on the size of the ream).</li> <li>Else, we can look at <code class="language-plaintext highlighter-rouge">class</code> to find the size class, and from that, and the offset of the original pointer into the page, the index of the slot.</li> <li>Clear the slot’s index in <code class="language-plaintext highlighter-rouge">gc_bits</code>.</li> <li>If the page was full before, place it onto the correct slab free list; if it becomes empty, place it into the page free list.</li> </ol> <p>At this point, we know whether the page just became partially full or empty, and can move it to the correct free list.</p> <p>Size classes are an important allocator optimization. TCMalloc takes this to an . These constants are generated by some crazy script based on profiling data.</p> <h2 id="intermission"><a href="#intermission">Intermission</a></h2> <p>Before continuing to the GC part of the article, it’s useful to go over what we learned.</p> <p>A neat thing about this is that most of these tricks are somewhat independent. While giving feedback for an early draft, Matt Kulukundis shared <a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U">this awesome talk</a> that describes how to build complex allocators out of simple ones, and covers many of the same tropes as we did here. This perspective on allocators actually blew my mind.</p> <p>Good allocators don’t just use one strategy; the use many and pick and chose the best one for the job based on expected workloads. For example, Alkyne expects to allocate many small objects; the slab pages were originally only for float objects, but it turned out to simplify a lot of the code to make <em>all</em> small objects be slab-allocated.</p> <p>Even size classes are a deep topic: TCMalloc uses <a href="https://research.google/pubs/pub36575/">GWP telemetry</a> from Google’s fleet to inform its <em>many</em> tuning parameters, including its <a href="https://github.com/google/tcmalloc/blob/master/tcmalloc/size_classes.cc">comically large</a> tables of size classes.</p> <p>At this point, we have a pretty solid allocator. Now, let’s get rid of the free function.</p> <h2 id="throwing-out-the-trash"><a href="#throwing-out-the-trash">Throwing out the Trash</a></h2> <p>Garbage collection is very different from manual memory management in that frees are performed in <em>batches</em> without cue from the user. There are no calls to <code class="language-plaintext highlighter-rouge">free()</code>; instead, we need to figure out which calls to <code class="language-plaintext highlighter-rouge">free()</code> we <em>can</em> make on the user’s behalf that they won’t notice (i.e., without quietly freeing pointers the user can still reach, resulting in a use-after-free bug). We need to do this as fast as we can.</p> <p>Alkyne is a “tracing GC”. Tracing GCs walk the “object graph” from a root set of known-reachable objects. Given an object <code class="language-plaintext highlighter-rouge">a</code>, it will <em>trace</em> through any data in the object that it knows is actually a GC pointer. In the object graph, <code class="language-plaintext highlighter-rouge">b</code> is reachable from <code class="language-plaintext highlighter-rouge">a</code> if one can repeatedly trace through GC pointers to get from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code>.</p> <p>Alkyne uses tracing to implement garbage collection in a two-step process, commonly called “mark-and-sweep”.</p> <p><em>Marking</em> consists of traversing the entire graph from a collection of reachable-by-definition values, such as things on the stack, and recording each object that is visited. Every object <em>not</em> so marked must therefore be definitely unreachable and can be reclaimed; this reclamation is called <em>sweeping</em>.</p> <p>Alkyne reverses the order of operations somewhat: it “sweeps” first and then marks, i.e., it marks every value as dead and then, as it walks the graph, marks every block as alive. It then rebuilds the free lists to reflect the new marks, allowing the blocks to be reallocated. This is sometimes called “mark and don’t sweep”, but fixing up the free lists is effectively a sweeping step.</p> <figure> <img src="https://upload.wikimedia.org/wikipedia/commons/4/4a/Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif"/> <figcaption>Marking and sweeping! (via Wikipedia, CC0)</figcaption> </figure> <p>Alkyne is a “stop-the-world” (STW) GC. It needs to pause all program execution while cleaning out the heap. It is possible to build GCs that do not do this (I believe modern HotSpot GCs very rarely stop the world), but also very difficult. Most GCs are world-stopping to some degree.</p> <p>One thing we do not touch on is <em>when</em> to sweep. This is a more complicated and somewhat hand-wavy tuning topic that I’m going to quietly sweep under the rug by pointing you to <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgcpacer.go">how Go does it</a>.</p> <h3 id="heap-armageddon-and-resurrection"><a href="#heap-armageddon-and-resurrection">Heap Armageddon and Resurrection</a></h3> <p>Delicate freeing of individual objects is quite difficult, but scorching the earth is very easy. To do this, we walk the whole <code class="language-plaintext highlighter-rouge">Pd</code> array (see, I said this would be useful!) and blow away every <code class="language-plaintext highlighter-rouge">gc_bits</code>. This leaves the heap in a broken state where every pointer appears to be dangling. This is “armageddon”.</p> <p>To fix this up, we need to “resurrect” any objects we shouldn’t have killed (oops). The roots are objects in the Alkyne interpreter stack<sup id="fnref:stack-roots" role="doc-noteref"><a href="#fn:stack-roots" class="footnote" rel="footnote">11</a></sup>. To mark an object, we convert a pointer to it into a <code class="language-plaintext highlighter-rouge">Pd</code> via the page-<code class="language-plaintext highlighter-rouge">Pd</code> correspondence, and mark it as alive by “allocating” it.</p> <p>We then use our knowledge<sup id="fnref:interpreter-knowledge" role="doc-noteref"><a href="#fn:interpreter-knowledge" class="footnote" rel="footnote">12</a></sup> of Alkyne objects’ heap layout to find pointers to other objects in the heap (for example, the intepreter <em>knows</em> it’s looking at a list and can <em>just find</em> the list elements within, which are likely pointers themselves). If we trace into an object and find it has been marked as allocated, we don’t recurse; this avoids infinite recursion when encountering cycles.</p> <blockquote> <p>It’s a big hard to give a code example for this, because the “mark” part that’s part of the GC is mixed up with interpreter code, so there isn’t much to show in this case. :(</p> </blockquote> <p>At the end of this process, every reachable object will once again be alive, but anything we couldn’t reach stays dead.</p> <h3 id="instant-apocalypse"><a href="#instant-apocalypse">Instant Apocalypse</a></h3> <p>(Alkyne currently does not make this optimization, but really should.)</p> <p>Rather than flipping every bit, we flip the global <em>convention</em> for whether 0 or 1 means “alive”, implemented by having a global <code class="language-plaintext highlighter-rouge">bool</code> specifying which is which at any given time; this would alternate from sweep to sweep. Thus, killing every living object is now a single operation.</p> <p>This works if the allocated bit of objects in the free lists is never read, and only ever overwritten with the “alive” value when allocated, so that all of the dead objects suddenly becoming alive isn’t noticed. This does not work with slab-allocated small objects: pages may be in a mixed state where they are partially allocated and partially freed.</p> <p>We can still make this optimization by adding a second bit that tracks whether the page contains <em>any</em> living objects, using the same convention. This allows delaying the clear of the allocated bits for small objects to when the page is visited, which also marks the whole page as alive.</p> <p>Pages that were never visited (i.e., still marked as dead) can be reclaimed as usual, ignoring the allocated bits.</p> <h3 id="free-list-reconciliation"><a href="#free-list-reconciliation">Free List Reconciliation</a></h3> <p>At this point, no pointers are dangling, but newly emptied out pages are not in the free lists they should be in. To fix this, we can walk over all <code class="language-plaintext highlighter-rouge">Pd</code>s and put them where they need to go if they’re not full. This is the kinda-but-not-really sweep phase.</p> <p>The code for this is simpler to show than explaining it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">for</span> <span class="n">pd</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.reams</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">pd</span><span class="py">.gc_bits</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">pd</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">pd</span><span class="py">.len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="k">self</span><span class="py">.page_free_list</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="k">self</span><span class="py">.ream_free_list</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">pd</span><span class="nf">.is_full</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// GC can't make a not-full-list become full, so we don't</span>
    <span class="c1">// need to move it.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Non-empty, non-full lists cannot be reams.</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">pd</span><span class="py">.class</span> <span class="o">!=</span> <span class="nn">SizeClass</span><span class="p">::</span><span class="n">Ream</span><span class="p">);</span>

    <span class="n">pd</span><span class="nf">.unlink</span><span class="p">();</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.slab_free_lists</span><span class="p">[</span><span class="n">pd</span><span class="py">.class</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Of course, this will also shuffle around all pages that did not become partially empty or empty while marking. If the “instant apocalypse” optimization is used, this step must still inspect every <code class="language-plaintext highlighter-rouge">Pd</code> and modify the free lists.</p> <p>However, it is a completely separate phase: all it does is find pages that did not survive the previous mark phase. This means that user code can run between the phases, reducing latency. If it turns out to be very expensive to sweep the whole heap, it can even be run less often than mark phases<sup id="fnref:if-quick-kill" role="doc-noteref"><a href="#fn:if-quick-kill" class="footnote" rel="footnote">13</a></sup>.</p> <p>This is also a great chance to merge reams, because we’re inspecting every page anyways; this is why the merging strategy depends on wanting to be a GC’s allocator rather than a normal <code class="language-plaintext highlighter-rouge">malloc()</code>/<code class="language-plaintext highlighter-rouge">free()</code> allocator.</p> <p>…and that’s it! That’s garbage collection. The setup of completely owning the layout of blocks in the allocator allows us to cut down significantly on memory needed to track objects in the heap, while keeping the mark and sweep steps short and sweet. A garbage collector is like any other data structure: you pack in a lot of complexity into the invariants to make the actual operations very quick.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Alkyne’s GC is intended to be super simple because I didn’t want to think too hard about it (even though I clearly did lmao). The GC layouts are a whole ‘nother story I have been swirling around in my head for months, which is described <a href="https://github.com/mcy/alkyne/blob/a62ad3b7ee70268625da640c1edeea8ff7116512/src/eval2/value.rs#L78">here</a>. The choices made there influenced the design of the GC itself.</p> <p>There are still many optimizations to make, but it’s a really simple but realistic GC design, and I’m pretty happy with it!</p> <h3 id="a-note-on-finalizers-tools-of-the-devil"><a href="#a-note-on-finalizers-tools-of-the-devil">A Note on Finalizers (Tools of the Devil!)</a></h3> <p>Alkyne also does not provide finalizers. A finalizer is the GC equivalent of a destructor: it gets run after the GC declares an object dead. Finalizers complicate a GC significantly by their very nature; they are called in unspecified orders and can witness broken GC state; they can stall the entire program (if they are implemented to run during the GC pause in a multi-threaded GC) or else need to be called with a zombie argument that either can’t escape the finalizer or, worse, must be resurrected if it does!</p> <p>If finalizers depend on each other, they can’t be run at all, for the same reason an ARC cycle cannot be broken; this weakness of ARC is one of the major benefits of an omniscient GC.</p> <p>Java’s <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()">documentation for <code class="language-plaintext highlighter-rouge">Object.finalize()</code></a> is a wall of text of lies, damned lies, and ghost stories.</p> <p>I learned earlier (the week before I started writing this article) that Go ALSO has finalizers and that they are <a href="https://pkg.go.dev/runtime#SetFinalizer">similarly cursed</a>. Go does behave somewhat more nicely than Java (finalizers are per-value and avoid zombie problems by unconditionally resurrecting objects with a finalizer).</p> <h3 id="further-reading"><a href="#further-reading">Further Reading</a></h3> <p>Here are some other allocators that I find interesting and worth reading about, some of which have inspired elements of Alkyne’s design.</p> <p><a href="https://google.github.io/tcmalloc/design.html">TCMalloc</a> is Google’s crazy thread-caching allocator. It’s really fast and really cool, but I work for Google, so I’m biased. But it uses radix trees! Radix trees are cool!!!</p> <p>Go <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgc.go">has a garbage collector</a> that has well-known performance properties but does not perform any wild optimizations like moving, and is a world-stopping, incremental GC.</p> <p><a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">Oilpan</a> is the Chronimum renderer’s GC (you know, for DOM elements). It’s actually grafted onto C++ and has a very complex API reflective of the subtleties of GCs as a result.</p> <p><a href="https://www.hboehm.info/gc/">libboehm</a> is another C/C++ GC written by Hans Boehm, one of the world’s top experts on concurrency.</p> <p><a href="https://v8.dev/blog/trash-talk">Orinoco</a> is V8’s GC for the JavaScript heap (i.e., Chronimum’s <em>other</em> GC). It is a <em>generational</em> or <em>moving GC</em> that can defragment the heap over time by moving things around (and updating pointers). It also has a separate sub-GC just for short-lived objects.</p> <p><a href="https://arxiv.org/abs/1902.04738">Mesh</a> is a non-GC allocator that can do compacting via clever use of <code class="language-plaintext highlighter-rouge">mmap(2)</code>.</p> <p><a href="https://github.com/protocolbuffers/upb/blob/1cf8214e4daa1d0dd9777c987697e82c2a3c6584/upb/upb.c#L117"><code class="language-plaintext highlighter-rouge">upb_Arena</code></a> is an arena allocator that uses free-lists to allows fusing arenas together. This part of the μpb Protobuf runtime.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:ast-walker" role="doc-endnote"> <p>In other words, it uses recursion along a syntax tree, instead of a more efficient approach that compiles the program down to bytecode. <a href="#fnref:ast-walker" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:arc" role="doc-endnote"> <p><em>A</em>utomatic <em>R</em>eference <em>C</em>ounting is an automatic memory management technique where every heap allocation contains a counter of how many pointers currently point to it; once pointers go out of scope, they decrement the counter; when the counter hits zero the memory is freed.</p> <p>This is used by Python and Swift as the core memory management strategy, and provided by C++ and Rust via the <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> types, respectively. <a href="#fnref:arc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:src" role="doc-endnote"> <p><a href="https://github.com/mcy/alkyne/blob/a62ad3b7ee70268625da640c1edeea8ff7116512/src/eval2/gc.rs">This is the file.</a> It’s got fairly complete comments, but they’re written for an audience familiar with allocators and garbage collectors. <a href="#fnref:src" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:nan-boxing" role="doc-endnote"> <p>This is a tangent, but I should point out that Alkyne does not do <a href="https://leonardschuetz.ch/blog/nan-boxing/">“NaN boxing”</a>. This is a technique used by some JavaScript runtimes, like Spidermonkey, which represent dynamically typed values as either ordinary floats, or pointers hidden in the mantissas of 64-bit IEEE 754 signaling NaNs.</p> <p>Alkyne instead uses something like V8’s <a href="https://v8.dev/blog/pointer-compression">Smi pointer compression</a>, so our heap values are four bytes, not eight. Non-Smi values that aren’t on the stack (which uses a completely different representation) can only exist as elements of lists or objects. Alkyne’s slab allocator design (described below) is focused on trying to minimize the overhead of all floats being in their own little allocations. <a href="#fnref:nan-boxing" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:os-allocator" role="doc-endnote"> <p>The operating system’s own physical page allocator is actually solving the same problem: given a vast range of memory (in this case, physical RAM), allocate it. The algorithms in this article apply to those, too.</p> <p>Operating system allocators can be slightly fussier because they need to deal with virtual memory mappings, but that is a topic for another time. <a href="#fnref:os-allocator" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:load-bearing" role="doc-endnote"> <p>As you might expect, these scare-quotes are load-bearing. <a href="#fnref:load-bearing" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i-tried" role="doc-endnote"> <p>I tried leaving this out of the first draft, and failed. So many things would be simpler without fussing around with alignment. <a href="#fnref:i-tried" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:unaligned" role="doc-endnote"> <p>Yes yes most architectures can cope with unaligned loads and stores but compilers rather like to pretend that’s not true. <a href="#fnref:unaligned" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:provenance" role="doc-endnote"> <p>Boutique means <a href="https://llvm.org/docs/LangRef.html#pointer-aliasing-rules">provenance</a> in French. <a href="#fnref:provenance" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:max-size" role="doc-endnote"> <p>Currently Alkyne has a rather small max ream size. A better way to approach this would be to treat the entire heap as one gigantic ream at the start, which is always at the bottom of the free list. <a href="#fnref:max-size" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stack-roots" role="doc-endnote"> <p>In GC terms, these are often called “stack roots”. <a href="#fnref:stack-roots" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:interpreter-knowledge" role="doc-endnote"> <p>The interpreter simply <em>knows</em> this and can instruct the GC appropriately.</p> <p>In any tracing GC, the compiler or interpreter must be keenly aware of the layouts of types so that it can generate the appropriate tracing code for each.</p> <p>This is why grafting GCs to non-GC’d languages is non-trivial, even though people have totally done it: <a href="https://www.hboehm.info/gc/">libboehm</a> and <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">Oilpan</a> are good (albeit sometimes controversial) examples of how this can be done. <a href="#fnref:interpreter-knowledge" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:if-quick-kill" role="doc-endnote"> <p>With “instant apocalypse”, this isn’t quite true; after two mark phases, pages from the first mark phase will appear to be alive, since the global “alive” convention has changed twice. Thus, only pages condemned in every other mark phase will be swept; sweeping is most optimal after an odd number of marks. <a href="#fnref:if-quick-kill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2021-12-19 • 1923 words • 16 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#ffi">#ffi</a> </span> <h1><a href="/2021/12/19/move-ctors-2/"> Move Constructors Revisited<br/> </a></h1> </div> <div class="post"> <p>Almost a year ago I developed the <a href="https://github.com/google/moveit"><code class="language-plaintext highlighter-rouge">moveit</code></a> Rust library, which provides primitives for expressing something like C++’s <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> and move constructors while retaining Rust’s so-called “destructive move property”: moving a value transfers ownership, rather than doing a funny copy.</p> <p>In an <a href="https://mcyoung.xyz//2021/04/26/move-ctors">earlier blogpost</a> I described the theory behind this library and some of the motivation, which I feel fairly confident about, especially in how constructors (and their use of pinning) are defined.</p> <p>However, there is a problem.</p> <h2 id="a-not-so-quick-recap"><a href="#a-not-so-quick-recap">A Not-so-Quick Recap</a></h2> <p>The old post is somewhat outdated, since <code class="language-plaintext highlighter-rouge">moveit</code> uses different names for a lot of things that are geared to fit in with the rest of Rust.</p> <p>The core abstraction of <code class="language-plaintext highlighter-rouge">moveit</code> is the constructor, which are types that implement the <code class="language-plaintext highlighter-rouge">New</code> trait:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[must_use]</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">New</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The type to construct.</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

  <span class="cd">/// Construct a new value in-place using the arguments stored</span>
  <span class="cd">/// in `self`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">this</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>A <code class="language-plaintext highlighter-rouge">New</code> type is not what is being constructed; rather, it represents a <em>method</em> of construction, resembling a specialized <code class="language-plaintext highlighter-rouge">Fn</code> trait. The constructed type is given by the associated type <code class="language-plaintext highlighter-rouge">Output</code>.</p> <p>Types that can be constructed are constructed <em>in place</em>, unlike most Rust types. This is a property shared by constructors in C++, allowing values to record their own address at the moment of creation. Explaining why this is useful is a bit long-winded, but let’s assume this is a thing we want to be able to do. Crucially, we need the output of a constructor to be pinned, which is why the <code class="language-plaintext highlighter-rouge">this</code> output parameter is pinned.</p> <p>Calling a constructor requires creating the output location in advance so that we can make it available to it in time:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Create storage for the new value.</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>

<span class="c1">// Pin that storage on the stack; by calling this, we may never move</span>
<span class="c1">// `storage` again, even after this goes out of scope.</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Now we can call the constructor. It's only unsafe because it assumes</span>
<span class="c1">// the provided memory is uninitialized.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this is not quite right. <code class="language-plaintext highlighter-rouge">Pin&lt;P&gt;</code>’s docs are quite clear that we must ensure that, once we create an <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, we must call <code class="language-plaintext highlighter-rouge">T</code>’s destructor before its memory is re-used; since reuse is unavoidable for stack data, and <code class="language-plaintext highlighter-rouge">storage</code> will not do it for us (it’s a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code>, after all), we must somehow run the destructor separately.</p> <h3 id="an-easy-solution"><a href="#an-easy-solution">An “Easy” Solution</a></h3> <p>One trick we could use is to replace <code class="language-plaintext highlighter-rouge">storage</code> with some kind of wrapper over a <code class="language-plaintext highlighter-rouge">MaybeUninit&lt;T&gt;</code> that calls the destructor for us:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">EventuallyInit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.assume_init_mut</span><span class="p">())</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This <em>works</em>, but isn’t ideal, because now we can’t write down something like a C++ move constructor without running into the classic C++ problem: all objects must be destroyed unconditionally, so now you can have moved-from state. Giving up Rust’s moves-transfer-ownership (i.e. <em>affine</em>) property is bad, but it turns out to be avoidable!</p> <p>There are also some scary details around panics here that I won’t get into.</p> <h3 id="t-mut-t--move-t"><a href="#t-mut-t--move-t"><code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">&amp;mut T</code>, … <code class="language-plaintext highlighter-rouge">&amp;move T</code>?</a></h3> <p><code class="language-plaintext highlighter-rouge">moveit</code> instead provides a <a href="https://docs.rs/moveit/latest/moveit/move_ref/struct.MoveRef.html"><code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code></a> type that tries to capture the notion of what an “owning reference” <em>could</em> mean in Rust. An <code class="language-plaintext highlighter-rouge">&amp;move</code> or <code class="language-plaintext highlighter-rouge">&amp;own</code> type has been discussed many times, but implementing it in the full generality it would deserve as a language feature runs into some interesting problems due to how <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>, the heap allocated equivalent, <a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">currently behaves.</a></p> <p>We can think of <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, T&gt;</code> as wrapping the <em>longest-lived</em> <code class="language-plaintext highlighter-rouge">&amp;mut T</code> reference pointing to a particular location in memory. The longest-lived part is crucial, since it means that <code class="language-plaintext highlighter-rouge">MoveRef</code> is entitled to run its pointee’s destructor:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Notice parallels with EventuallyInit&lt;T&gt; above.</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>No reference to the pointee can ever outlive the <code class="language-plaintext highlighter-rouge">MoveRef</code> itself, by definition, so this is safe. The owner of a value is that which is entitled to destroy it, and therefore a <code class="language-plaintext highlighter-rouge">MoveRef</code> <em>literally</em> owns its pointee. Of course, this means we can move out of it (which was the whole point of the original blogpost).</p> <p>Because of this, we are further entitled to arbitrarily pin a <code class="language-plaintext highlighter-rouge">MoveRef</code> with no consequences: pinning it would consume the unpinned <code class="language-plaintext highlighter-rouge">MoveRef</code> (for obvious reasons, <code class="language-plaintext highlighter-rouge">MoveRefs</code> cannot be reborrowed) so no unpinned reference may outlive the pinning operation.</p> <p>This gives us a very natural solution to the problem above: <code class="language-plaintext highlighter-rouge">result</code> should not be a <code class="language-plaintext highlighter-rouge">Pin&lt;&amp;mut T&gt;</code>, but rather a <code class="language-plaintext highlighter-rouge">Pin&lt;MoveRef&lt;'_, T&gt;&gt;</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>

<span class="c1">// This is now safe, since `my_new` initialized the value, so we can</span>
<span class="c1">// do with it what we please.</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pinned</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="n">uninit</span><span class="nf">.map_unchecked_mut</span><span class="p">(|</span><span class="n">mp</span><span class="p">|</span> <span class="n">mp</span><span class="nf">.assume_init_mut</span><span class="p">())</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This messy sequence of steps is nicely wrapped up in a macro provided by the library that ensures safe initialization and eventual destruction:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Allocate storage on the stack, emplace `my_new` onto it, and pin it</span>
<span class="c1">// in an owning reference.</span>
<span class="nd">moveit!</span><span class="p">(</span><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">MoveRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">my_new</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There is also some reasonably complex machinery that allows us to do something like an owning <code class="language-plaintext highlighter-rouge">Deref</code>, which I’ll come back to in a bit.</p> <p>However, there is a small wrinkle that I did not realize when I first designed <code class="language-plaintext highlighter-rouge">MoveRef</code>: what happens if I <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">MoveRef</code>?</p> <h2 id="undefined-behavior-obviously"><a href="#undefined-behavior-obviously">Undefined Behavior, Obviously</a></h2> <p>Quashing destruction isn’t new to Rust: we can <code class="language-plaintext highlighter-rouge">mem::forget</code> just about anything, leaking all kinds of resources. And that’s ok! Destructors alone cannot be used in type design to advert <code class="language-plaintext highlighter-rouge">unsafe</code> catastrophe, a well-understood limitation of the language that we have experience designing libraries around, such as <a href="https://doc.rust-lang.org/nomicon/leaking.html#drain"><code class="language-plaintext highlighter-rouge">Vec::drain()</code></a>.</p> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s design creates a contradiction:</p> <ul> <li><code class="language-plaintext highlighter-rouge">MoveRef</code> is an owning smart pointer, and therefore can be safely pinned, much like <code class="language-plaintext highlighter-rouge">Box::into_pinned()</code> enables. Constructors, in particular, are <em>designed</em> to generate pinned <code class="language-plaintext highlighter-rouge">MoveRef</code>s!</li> <li>Forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code> will cause the pointee destructor to be suppressed, but its storage will still be freed and eventually re-used, a violation of the <code class="language-plaintext highlighter-rouge">Pin</code> drop guarantee.</li> </ul> <p>This would <em>appear</em> to mean that a design like <code class="language-plaintext highlighter-rouge">MoveRef</code> is not viable at all, and that this sort of “stack box” strategy is always unsound.</p> <blockquote> <h3 id="what-about-box"><a href="#what-about-box">What About <code class="language-plaintext highlighter-rouge">Box</code>?</a></h3> <p>What about it? Even though we can trivially create a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;i32&gt;&gt;</code> via <code class="language-plaintext highlighter-rouge">Box::pin()</code>, this is a red herring. When we <code class="language-plaintext highlighter-rouge">mem::forget</code> a <code class="language-plaintext highlighter-rouge">Box</code>, we also forget about its storage too. Because its storage has been leaked unrecoverably, we are still, <em>technically</em>, within the bounds of the <code class="language-plaintext highlighter-rouge">Pin</code> contract. Only barely, but we’re inside the circle.</p> </blockquote> <p>Interestingly, the Rust language has to deal with a similar problem; perhaps it suggests a way out?</p> <h2 id="drop-flags-and-dynamic-ownership-transfer"><a href="#drop-flags-and-dynamic-ownership-transfer">Drop Flags and Dynamic Ownership Transfer</a></h2> <p>Carefully crafted Rust code emits some very interesting assembly. I’ve annotated the key portion of the output with a play-by-play below.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[inline(never)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// What goes in here isn't important,it just needs to</span>
  <span class="c1">// be an optimizer black-box.</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">maybe_drop</span><span class="p">(</span><span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
  <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span>
    <span class="nf">someone_elses_problem</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6IiNbaW5saW5lKG5ldmVyKV1cbnB1YiBmbiBzb21lb25lX2Vsc2VzX3By b2JsZW0oXzogQm94PGkzMj4pIHtcbiAgLy8gV2hhdCBnb2VzIGluIGhlcmUg aXNuJ3QgaW1wb3J0YW50LGl0IGp1c3QgbmVlZHMgdG9cbiAgLy8gYmUgYW4g b3B0aW1pemVyIGJsYWNrLWJveC5cbn1cblxucHViIGZuIG1heWJlX2Ryb3Ao ZmxhZzogYm9vbCkge1xuICBsZXQgeCA9IEJveDo6bmV3KDQyKTtcbiAgaWYg ZmxhZyB7XG4gICAgc29tZW9uZV9lbHNlc19wcm9ibGVtKHgpXG4gIH1cbn0i LCJjb21waWxlcnMiOlt7ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiItTyJ9XX1d fQ== ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// See Godbolt widget above for full disassembly.</span>
<span class="n">example</span><span class="o">::</span><span class="n">maybe_drop</span><span class="o">:</span>
  <span class="c1">// ...</span>

  <span class="c1">// Allocate memory.</span>
  <span class="n">call</span>    <span class="n">__rust_alloc</span>

  <span class="c1">// Check if allocation failed; panic if so.</span>
  <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">scream</span>

  <span class="c1">// Write a 42 to the memory.</span>
  <span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>

  <span class="c1">// Check the flag argument (LLVM decided to put it in rbx). If</span>
  <span class="c1">// true, we go free the memory ourselves.</span>
  <span class="n">test</span>    <span class="n">bl</span><span class="p">,</span> <span class="n">bl</span>
  <span class="n">je</span>      <span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">actually_our_problem</span>

  <span class="c1">// Otherwise, make it someone else's problem; they get to</span>
  <span class="c1">// free the memory for themselves. </span>
  <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">pop</span>     <span class="n">rbx</span>
  <span class="n">jmp</span>     <span class="n">example</span><span class="o">::</span><span class="n">someone_elses_problem</span>

  <span class="c1">// ...</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>The upshot is that <code class="language-plaintext highlighter-rouge">maybe_drop</code> conditions the destructor of <code class="language-plaintext highlighter-rouge">x</code> on a <em>flag</em>, which is allocated next to it on the stack. Rust flips this flag when the value is moved into another function, and only runs the destructor when the flag is left alone. In this case, LLVM folded the flag into the <code class="language-plaintext highlighter-rouge">bool</code> argument, so this isn’t actually a meaningful perf hit.</p> <p>These “drop flags” are key to Rust’s ownership model. Since ownership may be transferred dynamically due to reasonably complex control flow, it needs to leave breadcrumbs for itself to figure out whether the value wound up getting moved away or not. This is unique to Rust: in C++, every object is always destroyed, so no such faffing about is necessary.</p> <p>Similarly, <code class="language-plaintext highlighter-rouge">moveit</code> can close this soundness hole by leaving itself breadcrumbs to determine if safe code is trying to undermine its guarantees.</p> <p>In other words: in Rust, it is not sufficient to manage a pointer to manage a memory location; it is necessary to manage an explicit or implicit drop flag as well.</p> <h2 id="a-flagged-moveref"><a href="#a-flagged-moveref">A Flagged <code class="language-plaintext highlighter-rouge">MoveRef</code></a></h2> <p>We can extend <code class="language-plaintext highlighter-rouge">MoveRef</code> to track an explicit drop flag:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>

  <span class="c1">// Set to `false` once the destructor runs.</span>
  <span class="n">drop_flag</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'frame</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Wrapping it in a <code class="language-plaintext highlighter-rouge">Cell</code> is convenient and doesn’t cost us anything, since a <code class="language-plaintext highlighter-rouge">MoveRef</code> can never be made <code class="language-plaintext highlighter-rouge">Send</code> or <code class="language-plaintext highlighter-rouge">Sync</code> anyways. Inside of its destructor, we can flip the flag, much like Rust flips a drop flag when transferring ownership to another function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.drop_flag</span><span class="nf">.set</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>But, how should we use it? The easiest way is to change the definition of <code class="language-plaintext highlighter-rouge">moveit!()</code> to construct a <em>flag trap</em>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">storage</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="n">uninit</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">storage</span><span class="p">);</span>

<span class="c1">// Create a *trapped flag*, which I'll describe below.</span>
<span class="k">let</span> <span class="n">trap</span> <span class="o">=</span> <span class="nn">TrappedFlag</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// Run the constructor as before and construct a MoveRef.</span>
<span class="n">my_new</span><span class="nf">.new</span><span class="p">(</span><span class="n">uninit</span><span class="nf">.as_mut</span><span class="p">());</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
  <span class="nn">Pin</span><span class="p">::</span><span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">uninit</span><span class="p">)</span><span class="nf">.assume_init_mut</span><span class="p">(),</span>
  <span class="n">trap</span><span class="nf">.flag</span><span class="p">(),</span>  <span class="c1">// Creating a MoveRef now requires</span>
                <span class="c1">// passing in a flag in addition to </span>
                <span class="c1">// a reference to the owned value itself.</span>
<span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The trap is a deterrent against forgetting a <code class="language-plaintext highlighter-rouge">MoveRef</code>: because the <code class="language-plaintext highlighter-rouge">MoveRef</code>’s destructor flips the flag, the trap’s destructor will notice if this <em>doesn’t</em> happen, and take action accordingly.</p> <blockquote> <p>Note: in <code class="language-plaintext highlighter-rouge">moveit</code>, this is actually implemented by having the <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code> type carry a reference to the trap, created in the <code class="language-plaintext highlighter-rouge">slot!()</code> macro. However, this is not a crucial detail for the design.</p> </blockquote> <h3 id="an-earth-shattering-kaboom"><a href="#an-earth-shattering-kaboom">An Earth-Shattering Kaboom</a></h3> <p>The trap is another RAII type that basically looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="nf">TrappedFlag</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">TrappedFlag</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">()</span> <span class="p">{</span> <span class="nf">abort</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The trap is simple: if the contained drop flag is not flipped, it crashes the program. Because <code class="language-plaintext highlighter-rouge">moveit!()</code> allocates it on the stack where uses cannot <code class="language-plaintext highlighter-rouge">mem::forget</code> it, its destructor is guaranteed to run before <code class="language-plaintext highlighter-rouge">storage</code>’s destructor runs (although Rust does not guarantee destructors run, it <em>does</em> guarantee their order).</p> <p>If a <code class="language-plaintext highlighter-rouge">MoveRef</code> is forgotten, it won’t have a chance to flip the flag, which the trap will detect. Once the trap’s destructor notices this, it cannot return, either normally or by panic, since this would cause <code class="language-plaintext highlighter-rouge">storage</code> to be freed. Crashing the program is the only<sup id="fnref:or-we-could-drop-it" role="doc-noteref"><a href="#fn:or-we-could-drop-it" class="footnote" rel="footnote">1</a></sup> acceptable response.</p> <p>Some of <code class="language-plaintext highlighter-rouge">MoveRef</code>’s functions need to be adapted to this new behavior: for example, <code class="language-plaintext highlighter-rouge">MoveRef::into_inner()</code> still needs to flip the flag, since moving out of the <code class="language-plaintext highlighter-rouge">MoveRef</code> is equivalent to running the destructor for the purposes of drop flags.</p> <h2 id="a-safer-derefmove"><a href="#a-safer-derefmove">A Safer <code class="language-plaintext highlighter-rouge">DerefMove</code></a></h2> <p>In order for <code class="language-plaintext highlighter-rouge">MoveRef</code> to be a proper “new” reference type, and not just a funny smart pointer, we also need a <code class="language-plaintext highlighter-rouge">Deref</code> equivalent:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// An "uninitialized" version of `Self`.</span>
  <span class="k">type</span> <span class="n">Uninit</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>
  
  <span class="cd">/// "Deinitializes" `self`, producing an opaque type that will</span>
  <span class="cd">/// destroy the storage of `*self` without calling the pointee</span>
  <span class="cd">/// destructor.</span>
  <span class="k">fn</span> <span class="nf">deinit</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a `MoveRef` that owns its</span>
  <span class="cd">/// contents.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">deref_move</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Uninit</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is the <em>original</em> design for <code class="language-plaintext highlighter-rouge">DerefMove</code>, which had a two-phase operation: first <code class="language-plaintext highlighter-rouge">deinit()</code> was used to create a destructor-suppressed version of the smart pointer that would only run the destructor for the storage (e.g., for <code class="language-plaintext highlighter-rouge">Box</code>, only the call to <code class="language-plaintext highlighter-rouge">free()</code>). Then, <code class="language-plaintext highlighter-rouge">deref_move()</code> would extract the “inner pointee” out of it as a <code class="language-plaintext highlighter-rouge">MoveRef</code>. This had the effect of splitting the smart pointer’s destructor, much like we did above on the stack.</p> <p>This has a number of usability problems. Not only does it <em>need</em> to be called through a macro, but <code class="language-plaintext highlighter-rouge">deinit()</code> isn’t actually safe: failing to call <code class="language-plaintext highlighter-rouge">deref_move()</code> is just as bad as calling <code class="language-plaintext highlighter-rouge">mem::forget</code> on the result. Further, it’s not clear where to plumb the drop flags through.</p> <p>After <a href="https://github.com/google/moveit/pull/23#issuecomment-963549869">many attempts</a> to graft drop flags onto this design, I replaced it with a completely new interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">DerefMove</span><span class="p">:</span> <span class="n">DerefMut</span> <span class="o">+</span> <span class="nb">Sized</span> <span class="p">{</span>
  <span class="cd">/// The "pure storage" form of `Self`, which owns the storage</span>
  <span class="cd">/// but not the pointee.</span>
  <span class="k">type</span> <span class="n">Storage</span><span class="p">:</span> <span class="nb">Sized</span><span class="p">;</span>

  <span class="cd">/// Moves out of `this`, producing a [`MoveRef`] that owns</span>
  <span class="cd">/// its contents.</span>
  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Storage</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Uninit</code> has been given the clearer name of <code class="language-plaintext highlighter-rouge">Storage</code>: a type that owns <em>just</em> the storage of the moved-from pointer. The two functions were merged into a single, <em>safe</em> function that performs everything in one step, emitting the storage as an out-parameter.</p> <p>The new <code class="language-plaintext highlighter-rouge">DroppingSlot&lt;T&gt;</code> is like a <code class="language-plaintext highlighter-rouge">Slot&lt;T&gt;</code>, but closer to a safe version of the <code class="language-plaintext highlighter-rouge">EventuallyInit&lt;T&gt;</code> type from earlier: its contents are not necessarily initialized, but if they are, it destroys them, and it only does so when its drop flag is set.</p> <p><code class="language-plaintext highlighter-rouge">Box</code> is the most illuminating example of this trait:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">storage</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// Dismantle the incoming Box into the "storage-only part".</span>
    <span class="k">let</span> <span class="n">this</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span>
    <span class="p">};</span>

    <span class="c1">// Put the Box into the provided storage area. Note that we</span>
    <span class="c1">// don't need to set the drop flag; `DroppingSlot` does</span>
    <span class="c1">// that automatically for us.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="o">=</span> <span class="n">storage</span><span class="nf">.put</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

    <span class="c1">// Construct a new MoveRef, converting `storage` from </span>
    <span class="c1">// `&amp;mut Box&lt;MaybeUninit&lt;T&gt;&gt;` into `&amp;mut T`.</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">MoveRef</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span><span class="n">storage</span><span class="nf">.assume_init_mut</span><span class="p">(),</span> <span class="n">drop_flag</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">MoveRef</code>’s own implementation illustrates the need for the explicit lifetime bound:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMove</span> <span class="k">for</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Storage</span> <span class="o">=</span> <span class="p">();</span>

  <span class="k">fn</span> <span class="n">deref_move</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">self</span><span class="p">,</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">DroppingSlot</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MoveRef</span><span class="o">&lt;</span><span class="nv">'frame</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="k">Self</span><span class="p">:</span> <span class="nv">'frame</span>
  <span class="p">{</span>
    <span class="c1">// We can just return directly; this is a mere lifetime narrowing.</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Since this is fundamentally a lifetime narrowing, this can only compile if we insist that <code class="language-plaintext highlighter-rouge">'a: 'frame</code>, which is implied by <code class="language-plaintext highlighter-rouge">Self: 'frame</code>. Earlier iterations of this design enforced it via a <code class="language-plaintext highlighter-rouge">MoveRef&lt;'frame, Self&gt;</code> receiver, which turned out to be unnecessary.</p> <h2 id="conclusions"><a href="#conclusions">Conclusions</a></h2> <p>As of writing, I’m still in the process of self-reviewing <a href="https://github.com/google/moveit/pull/25">this change</a>, but at this point I feel <em>reasonably</em> confident that it’s correct; this article is, in part, written to convince myself that I’ve done this correctly.</p> <p>The new design will also enable me to finally complete my implementation of a constructor and pinning-friendly vector type; this issue came up in part because the vector type needs to manipulate drop flags in a complex way. For this reason, the <em>actual</em> implementation of drop flags actually uses a counter, not a single boolean.</p> <p>I doubt this is the last issue I’ll need to chase down in <code class="language-plaintext highlighter-rouge">moveit</code>, but for now, we’re ever-closer to true owning references in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:or-we-could-drop-it" role="doc-endnote"> <p>Arguably, running the skipped destructor is <em>also</em> a valid remediation strategy. However, this is incompatible with what the user requested: they asked for the destructor to be supressed, not for it to be run at a later date. This would be somewhat surprising behavior, which we could warn about for the benefit of <code class="language-plaintext highlighter-rouge">unsafe</code> code, but ultimately the incorrect choice for non-stack storage, such as a <code class="language-plaintext highlighter-rouge">MoveRef</code> referring to the heap. <a href="#fnref:or-we-could-drop-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div> <div class="pagination post-footer"> <a class="pagination-item newer" href="https://mcyoung.xyz/page4">&lt; Prev</a> • <a class="pagination-item older" href="https://mcyoung.xyz/page6">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>