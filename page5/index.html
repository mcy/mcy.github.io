<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-08-09 • 2854 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/08/09/yarns/"> I Wrote A String Type<br/> </a></h1> </div> <div class="post"> <p>I write compilers for fun. I can’t help it. Consequently, I also write a lot of parsers. In systems programming, it’s usually a good idea to try to share memory rather than reuse it, so as such my AST types tend to look like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">enum</span> <span class="n">Expr</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">Int</span><span class="p">(</span><span class="nb">u32</span><span class="p">)</span>
  <span class="nf">Ident</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'src</span> <span class="nb">str</span><span class="p">),</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Whenever we parse an identifier, rather than copy its name into a fresh <code class="language-plaintext highlighter-rouge">String</code>, we borrow from the input source string. This avoids an extra allocation, an extra copy, and saves a word in the representation. Compilers can be memory-hungry, so it helps to pick a lean representation.</p> <p>Unfortunately, it’s not so easy for quoted strings. Most strings, like <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code>, are “literally” in the original source, like an identifier. But strings with escapes aren’t: <code class="language-plaintext highlighter-rouge">\n</code> is encoded in the source code with the bytes <code class="language-plaintext highlighter-rouge">[0x5c, 0x6e]</code>, but the actual “decoded” value of a string literal replaces each escape with a single <code class="language-plaintext highlighter-rouge">0x0a</code>.</p> <p>The usual solution is a <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code></a>. In the more common, escape-less verison, we can use <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code>, which avoids the extra allocation and copy, and in the escaped version, we decode the escapes into a <code class="language-plaintext highlighter-rouge">String</code> and wrap it in a <code class="language-plaintext highlighter-rouge">Cow::Owned</code>.</p> <p>For example, suppose that we’re writing a parser for a language that has quoted strings with escapes. The string <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code> can be represented as a byte string that borrows the input source code, so we’d use the <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code> variant. This is most strings in any language: escapes tend to be rare.</p> <p>For example, if we have the string <code class="language-plaintext highlighter-rouge">"not UTF-8 \xff"</code>, the actual byte string value is different from that in the source code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">// Bytes in the source.
hex:   6e 6f 74 20 55 54 46 2d 38 20 5c 78 66 66
ascii: n  o  t     U  T  F  -  8     \  x  f  f

// Bytes represented by the string.
hex:   6e 6f 74 20 55 54 46 2d 38 20 ff
ascii: n  o  t     U  T  F  -  8</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Escapes are relatively rare, so most strings processed by the parser do not need to pay for an allocation.</p> <p>However, we still pay for that extra word, since <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> is 24 bytes (unless otherwise specified, all byte counts assume a 64-bit system), which is eight more than our <code class="language-plaintext highlighter-rouge">&amp;str</code>. Even worse, this is bigger than the string data itself, which is 11 bytes.</p> <p>If most of your strings are small (which is not uncommon in an AST parser), you will wind up paying for significant overhead.</p> <p>Over the years I’ve implemented various optimized string types to deal with this use-case, in various contexts. I finally got around to putting all of the tricks I know into a library, which I call <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a>. It advertises the following nice properties.</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>I’d like to share how these properties are achieved through careful layout optimization.</p> <h2 id="assumptions"><a href="#assumptions">Assumptions</a></h2> <p>We’re going to start by stating assumptions about how our strings will be used:</p> <ol> <li>Most strings are not mutated most of the time.</li> <li>Most strings are small.</li> <li>Most strings are substrings.</li> </ol> <h3 id="most-strings-are-immutable"><a href="#most-strings-are-immutable">Most Strings are Immutable</a></h3> <p><code class="language-plaintext highlighter-rouge">String</code> is modeled after C++’s <code class="language-plaintext highlighter-rouge">std::string</code>, which is a growable buffer that implements amortized linear-time append. This means that if we are appending <code class="language-plaintext highlighter-rouge">n</code> bytes to the buffer, we only pay for <code class="language-plaintext highlighter-rouge">n</code> bytes of <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>This is a useful but often unnecessary property. For example, Go strings are immutable, and when building up a large string, you are expected to use <code class="language-plaintext highlighter-rouge">strings.Builder</code>, which is implemented as essentially a Rust <code class="language-plaintext highlighter-rouge">String</code>. Java also as a similar story for strings, which allows for highly compact representations of <code class="language-plaintext highlighter-rouge">java.lang.String</code>s.</p> <p>In Rust, this kind of immutable string is represented by a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>, which is eight bytes smaller than <code class="language-plaintext highlighter-rouge">String</code>. Converting from <code class="language-plaintext highlighter-rouge">String</code> to <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is just a call to <code class="language-plaintext highlighter-rouge">realloc()</code> to resize the underlying allocation (which is often cheap<sup id="fnref:size-classes" role="doc-noteref"><a href="#fn:size-classes" class="footnote" rel="footnote">1</a></sup>) from being <code class="language-plaintext highlighter-rouge">capacity</code> bytes long to <code class="language-plaintext highlighter-rouge">len</code> bytes long.</p> <p>Thus, this assumption means we only need to store a pointer and a length, which puts our memory footprint floor at 16 bytes.</p> <h3 id="most-strings-are-substrings"><a href="#most-strings-are-substrings">Most Strings are Substrings</a></h3> <p>Suppose again that we’re parsing some textual format. Many structural elements will be verbatim references into the textual input. Not only string literals without escapes, but also identifiers.</p> <p><code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> cannot hold borrowed data, because it will always instruct the allocator to free its pointer when it goes out of scope. <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>, as we saw above, allows us to handle maybe-owned data uniformly, but has a minimum 24 byte overhead. This can’t be made any smaller, because a <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> can contain a 24-byte <code class="language-plaintext highlighter-rouge">String</code> value.</p> <p>But, we don’t want to store a capacity. Can we avoid the extra word of overhead in <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>?</p> <h3 id="most-strings-are-small"><a href="#most-strings-are-small">Most Strings are Small</a></h3> <p>Consider a string that is not a substring but which is small. For example, when parsing a string literal like <code class="language-plaintext highlighter-rouge">"Hello, world!\n"</code>, the trailing <code class="language-plaintext highlighter-rouge">\n</code> (bytes <code class="language-plaintext highlighter-rouge">0x5c 0x6e</code>) must be replaced with a newline byte (<code class="language-plaintext highlighter-rouge">0x0a</code>). This means we must handle a tiny heap allocation, 14 bytes long, that is smaller than a <code class="language-plaintext highlighter-rouge">&amp;str</code> referring to it.</p> <p>This is worse for single character<sup id="fnref:character" role="doc-noteref"><a href="#fn:character" class="footnote" rel="footnote">2</a></sup> strings. The overhead for a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is large.</p> <ul> <li>The <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> struct itself has a pointer field (eight bytes), and a length field (also eight bytes). Spelled out to show all the stored bits, the length is <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0001</code>. That’s a lot of zeroes!</li> <li>The pointer itself points to a heap allocation, which will not be a single byte! Allocators are not in the business of handing out such small pieces of memory. Instead, the allocation is likely costing us another eight bytes!</li> </ul> <p>So, the string <code class="language-plaintext highlighter-rouge">"a"</code>, whose data is just a <em>single byte</em>, instead takes up 24 bytes of memory.</p> <p>It turns out that for really small strings we can avoid the allocation altogether, <em>and</em> make effective use of all those zeroes in the <code class="language-plaintext highlighter-rouge">len</code> field.</p> <h2 id="stealing-bits"><a href="#stealing-bits">Stealing Bits</a></h2> <p>Let’s say we want to stick to a budget of 16 bytes for our <code class="language-plaintext highlighter-rouge">Yarn</code> type. Is there any extra space left for data in a <code class="language-plaintext highlighter-rouge">(*mut u8, usize)</code> pair?</p> <p><em>*cracks Fermi estimation knuckles*</em></p> <p>A <code class="language-plaintext highlighter-rouge">usize</code> is 64 bits, which means that the length of an <code class="language-plaintext highlighter-rouge">&amp;str</code> can be anywhere from zero to 18446744073709551615, or around 18 exabytes. For reference, “hundreds of exabytes” is a reasonable ballpark guess for how much RAM exists in 2023 (consider: 4 billion smartphones with 4GB each). More practically, the largest quantity of RAM you can fit in a server blade is measured in terabytes (much more than your measly eight DIMs on your gaming rig).</p> <p>If we instead use one less bit, 63 bits, this halves the maximum representable memory to nine exabytes. If we take another, it’s now four exabytes. Much more memory than you will ever <em>ever</em> want to stick in a string. <a href="https://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia#Size_of_the_English_Wikipedia_database">Wikpedia asserts</a> that Wikimedia Commons contains around 428 terabytes of media (the articles’ text with history is a measly 10 TB).</p> <p>Ah, but you say you’re programming for a 32-bit machine (today, this likely means either a low-end mobile phone, an embedded micro controller, or WASM).</p> <p>On a 32-bit machine it’s a little bit harrier: Now <code class="language-plaintext highlighter-rouge">usize</code> is 32 bits, for a maximum string size of 4 gigabytes (if you remember the 32-bit era, this limit may sound familiar). “Gigabytes” is an amount of memory that you can actually imagine having in a string.</p> <p>Even then, 1 GB of memory (if we steal two bits) on a 32-bit machine is a lot of data. You can only have four strings that big in a single address space, and every 32-bit allocator in the universe will refuse to serve an allocation of that size. If your strings are comparable in size to the whole address space, you should build your own string type.</p> <p>The upshot is that every <code class="language-plaintext highlighter-rouge">&amp;str</code> contains two bits we can reasonably assume are not used. <em>Free real-estate.</em><sup id="fnref:isize" role="doc-noteref"><a href="#fn:isize" class="footnote" rel="footnote">3</a></sup></p> <h3 id="a-hand-written-niche-optimization"><a href="#a-hand-written-niche-optimization">A Hand-Written Niche Optimization</a></h3> <p>Rust has the concept of <em>niches</em>, or invalid bit-patterns of a particular type, which it uses for automatic layout optimization of <code class="language-plaintext highlighter-rouge">enum</code>s. For example, references cannot be null, so the pointer bit-pattern of <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0000</code> is never used; this bit-pattern is called a “niche”. Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">),</span>
  <span class="n">Second</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>An <code class="language-plaintext highlighter-rouge">enum</code> of this form will not need any “extra” space to store the value that discriminates between the two variants: if a <code class="language-plaintext highlighter-rouge">Foo</code>’s bits are all zero, it’s <code class="language-plaintext highlighter-rouge">Foo::Second</code>; otherwise it’s a <code class="language-plaintext highlighter-rouge">Foo::First</code> and the payload is formed from <code class="language-plaintext highlighter-rouge">Foo</code>’s bit-pattern. This, incidentally, is what makes <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code> a valid representation for a “nullable pinter”.</p> <p>There are more general forms of this: <code class="language-plaintext highlighter-rouge">bool</code> is represented as a single byte, of which two bit are valid; the other 254 potential bit-patterns are niches. In Recent versions of Rust, <code class="language-plaintext highlighter-rouge">RawFd</code> has a niche for the all-ones bit-pattern, since POSIX file descriptors are always non-negative <code class="language-plaintext highlighter-rouge">int</code>s.</p> <p>By stealing two bits off of the length, we have given ourselves four niches, which essentially means we’ll have a hand-written version of something like this <code class="language-plaintext highlighter-rouge">enum</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Yarn</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Second</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Third</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Fourth</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>For reasons that will become clear later, we will specifically steal the <em>high</em> bits of the length, so that to recover the length, we do two shifts<sup id="fnref:two-shifts" role="doc-noteref"><a href="#fn:two-shifts" class="footnote" rel="footnote">4</a></sup> to shift in two high zero bits. Here’s some code that actually implements this for the low level type our string type will be built on.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">,</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the kind back out.</span>
  <span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="k">as</span> <span class="nb">u8</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that I’ve made this type <code class="language-plaintext highlighter-rouge">Copy</code>, and some functions take it by value. This is for two reasons.</p> <ol> <li> <p>There is a type of <code class="language-plaintext highlighter-rouge">Yarn</code> that is itself <code class="language-plaintext highlighter-rouge">Copy</code>, although I’m not covering it in this article.</p> </li> <li> <p>It is a two-word struct, which means that on most architectures it is eligible to be passed in a pair of registers. Passing it by value in the low-level code helps promote keeping it in registers. This isn’t always possible, as we will see when we discuss “SSO”.</p> </li> </ol> <p>Let’s chose kind <code class="language-plaintext highlighter-rouge">0</code> to mean “this is borrowed data”, and kind <code class="language-plaintext highlighter-rouge">1</code> to be “this is heap-allocated data”. We can use this to remember whether we need to call a destructor.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">raw</span><span class="p">:</span> <span class="n">RawYarn</span><span class="p">,</span>
  <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">BORROWED</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">HEAP</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// SAFETY: initialized either from uniquely-owned data,</span>
      <span class="c1">// or borrowed data of lifetime 'a that outlives self.</span>
      <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_slice</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">HEAP</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">dropped</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
        <span class="c1">// SAFETY: This is just reconstituting the box we dismantled</span>
        <span class="c1">// in Yarn::owned().</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_mut_slice</span><span class="p">())</span>
      <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// Same thing as as_slice, basically. This is just to make</span>
    <span class="c1">// Box::from_raw() above typecheck.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This gives us a type that strongly resembles <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> with only half of the bytes. We can even write code to extend the lifetime of a <code class="language-plaintext highlighter-rouge">Yarn</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Removes the bound lifetime from the yarn, allocating if</span>
  <span class="cd">/// necessary.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">immortalize</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">BORROWED</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.as_slice</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
      <span class="k">self</span> <span class="o">=</span> <span class="nn">Yarn</span><span class="p">::</span><span class="nf">owned</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// We need to be careful that we discard the old yarn, since its</span>
    <span class="c1">// destructor may run and delete the heap allocation we created</span>
    <span class="c1">// above.</span>
    <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">;</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
    <span class="nn">Yarn</span><span class="p">::</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">,</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The remaining two niches can be put to use for optimizing small strings.</p> <h2 id="small-string-optimization"><a href="#small-string-optimization">Small String Optimization</a></h2> <p>C++’s <code class="language-plaintext highlighter-rouge">std::string</code> also makes the “most strings are small” assumption. In the <code class="language-plaintext highlighter-rouge">libc++</code> implementation of the standard library, <code class="language-plaintext highlighter-rouge">std::string</code>s of up to 23 bytes never hit the heap!</p> <p>C++ implementations do this by using most of the pointer, length, and capacity fields as a storage buffer for small strings, the so-called “small string optimization” (SSO). In <code class="language-plaintext highlighter-rouge">libc++</code>, in SSO mode, a <code class="language-plaintext highlighter-rouge">std::string</code>’s length fits in one byte, so the other 23 bytes can be used as storage. The capacity isn’t stored at all: an SSO string always has a capacity of 23.</p> <p><code class="language-plaintext highlighter-rouge">RawYarn</code> still has another two niches, so let’s dedicate one to a “small” representation. In small mode, the kind will be 2, and only the 16th byte will be the length.</p> <p>This is why we used the two <em>high</em> bits of <code class="language-plaintext highlighter-rouge">len</code> for our scratch space: no matter what mode it’s in, we can easily extract these bits<sup id="fnref:big-endian" role="doc-noteref"><a href="#fn:big-endian" class="footnote" rel="footnote">5</a></sup>. Some of the existing <code class="language-plaintext highlighter-rouge">RawYarn</code> methods need to be updated, though.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">SMALL</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">adjust</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">SMALL</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.assume_init</span><span class="p">(),</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">adjust</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In the non-<code class="language-plaintext highlighter-rouge">SMALL</code> case, we shift twice as before, but in the <code class="language-plaintext highlighter-rouge">SMALL</code> case, we need to get the high byte of the <code class="language-plaintext highlighter-rouge">len</code> field, so we need to shift down by an additional <code class="language-plaintext highlighter-rouge">usize::BITS - 8</code>. No matter what we’ve scribbled on the low bytes of <code class="language-plaintext highlighter-rouge">len</code>, we will always get just the length this way.</p> <p>We also need to use a different pointer value depending on whether we’re in <code class="language-plaintext highlighter-rouge">SMALL</code> mode. This is why <code class="language-plaintext highlighter-rouge">as_slice</code> needs to take a reference argument, since the slice data may be <em>directly</em> in <code class="language-plaintext highlighter-rouge">self</code>!</p> <p>Also, <code class="language-plaintext highlighter-rouge">ptr</code> is a <code class="language-plaintext highlighter-rouge">MaybeUninit</code> now, which will become clear in the next code listing.</p> <p>We should also provide a way to construct small strings.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">SSO_LEN</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Create a new small yarn. `data` must be valid for `len` bytes</span>
  <span class="cd">/// and `len` must be smaller than `SSO_LEN`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RawYarn</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span><span class="p">);</span>

    <span class="c1">// Create a yarn with an uninitialized pointer value (!!)</span>
    <span class="c1">// and a length whose high byte is packed with `small` and</span>
    <span class="c1">// `len`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">yarn</span> <span class="o">=</span> <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">(),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">SMALL</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span> <span class="p">|</span> <span class="n">len</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// Memcpy the data to the new yarn.</span>
    <span class="c1">// We write directly onto the `yarn` variable. We won't</span>
    <span class="c1">// overwrite the high-byte length because `len` will</span>
    <span class="c1">// never be &gt;= 16.</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">copy_nonoverlapping</span><span class="p">(</span>
      <span class="n">data</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="k">mut</span> <span class="n">yarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">RawYarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
      <span class="n">data</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="n">yarn</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The precise maximum size of an SSO string is a bit more subtle than what’s given above, but it captures the spirit. The <code class="language-plaintext highlighter-rouge">RawYarn::from_small</code> illustrates why the pointer value is hidden in a <code class="language-plaintext highlighter-rouge">MaybeUninit</code>: we’re above to overwrite it with garbage, and in that case it won’t be a pointer at all.</p> <p>We can update our public <code class="language-plaintext highlighter-rouge">Yarn</code> type to use the new small representation whenever possible.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">())</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>It’s also possible to construct a <code class="language-plaintext highlighter-rouge">Yarn</code> directly from a character now, too!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_char</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.encode_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(Note that we do not need to update <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code>; why?)</p> <p>What we have now is a maybe-owned string that does not require an allocation for small strings. However, we still have an extra niche…</p> <h2 id="string-constants"><a href="#string-constants">String Constants</a></h2> <p>String constants in Rust are interesting, because we can actually detect them at compile-time<sup id="fnref:leaks" role="doc-noteref"><a href="#fn:leaks" class="footnote" rel="footnote">6</a></sup>.</p> <p>We can use the last remaining niche, 3, to represent data that came from a string constant, which means that it does not need to be boxed to be immortalized.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">STATIC</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_static</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">STATIC</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This function is identical to <code class="language-plaintext highlighter-rouge">Yarn::borrowed</code>, except that <code class="language-plaintext highlighter-rouge">data</code> most now have a static lifetime, and we pass <code class="language-plaintext highlighter-rouge">STATIC</code> to <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code>.</p> <p>Because of how we’ve written all of the prior code, this does not require any special support in <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code> or in the low-level <code class="language-plaintext highlighter-rouge">RawYarn</code> code.</p> <p>The actual <code class="language-plaintext highlighter-rouge">byteyarn</code> library provides a <code class="language-plaintext highlighter-rouge">yarn!()</code> macro that has the same syntax as <code class="language-plaintext highlighter-rouge">format!()</code>. This is the primary way in which yarns are created. It is has been carefully written so that <code class="language-plaintext highlighter-rouge">yarn!("this is a literal")</code> always produces a <code class="language-plaintext highlighter-rouge">STATIC</code> string, rather than a heap-allocated string.</p> <h2 id="an-extra-niche-as-a-treat"><a href="#an-extra-niche-as-a-treat">An extra niche, as a treat?</a></h2> <p>Unfortunately, because of how we’ve written it, <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is 24 bytes, a whole word larger than a <code class="language-plaintext highlighter-rouge">Yarn</code>. However, there’s still a little gap where we can fit the <code class="language-plaintext highlighter-rouge">None</code> variant. It turns out that because of how we’ve chosen the discriminants, <code class="language-plaintext highlighter-rouge">len</code> is zero if and only if it is an empty <code class="language-plaintext highlighter-rouge">BORROWED</code> string. But this is not the only zero: if the high byte is <code class="language-plaintext highlighter-rouge">0x80</code>, this is an empty <code class="language-plaintext highlighter-rouge">SMALL</code> string. If we simply require that no other empty string is ever constructed (by marking <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code> as unsafe and specifying it should not be passed a length of zero), we can guarantee that <code class="language-plaintext highlighter-rouge">len</code> is <em>never</em> zero.</p> <p>Thus, we can update <code class="language-plaintext highlighter-rouge">len</code> to be a <code class="language-plaintext highlighter-rouge">NonZeroUsize</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="n">NonZeroUsize</span><span class="p">,</span>  <span class="c1">// (!!)</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a *nonzero* length, and a pointer.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="nn">NonZeroUsize</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
        <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is a type especially known to the Rust compiler to have a niche bit-pattern of all zeros, which allows <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> to be 16 bytes too. This also has the convenient property that the all zeros bit-pattern for <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is <code class="language-plaintext highlighter-rouge">None</code>.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>The <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a> blurb describes what we’ve built:</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>There are, of course, some trade-offs. Not only do we need the assumptions we made originally to hold, but we also need to relatively care more about memory than cycle-count performance, since basic operations like reading the length of the string require more math (but no extra branching).</p> <p>The actual implementation of <code class="language-plaintext highlighter-rouge">Yarn</code> is a bit more complicated, partly to keep all of the low-level book-keeping in one place, and partly to offer an ergonomic API that makes <code class="language-plaintext highlighter-rouge">Yarn</code> into a mostly-drop-in replacement for <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>.</p> <p>I hope this peek under the hood has given you a new appreciation for what can be achieved by clever layout-hacking.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:size-classes" role="doc-endnote"> <p>Allocators rarely serve you memory with precisely the size you asked for. Instead, they will have some notion of a “size class” that allows them to use more efficient allocation techniques, <a href="https://mcyoung.xyz//2022/06/07/alkyne-gc">which I have written about</a>.</p> <p>As a result, if the size change in a <code class="language-plaintext highlighter-rouge">realloc()</code> would not change the size class, it becomes a no-op, especially if the allocator can take advantage of the current-size information Rust provides it. <a href="#fnref:size-classes" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:character" role="doc-endnote"> <p>Here and henceforth “character” means “32-bit Unicode scalar”. <a href="#fnref:character" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:isize" role="doc-endnote"> <p>Now, you might also point out that Rust and C do not allow an allocation whose size is larger than the pointer offset type (<code class="language-plaintext highlighter-rouge">isize</code> and <code class="language-plaintext highlighter-rouge">ptrdiff_t</code>, respectively). In practice this means that the high bit is <em>always</em> zero according to the language’s own rules.</p> <p>This is true, but we need to steal two bits, and I wanted to demonstrate that this is an extremely reasonable desire. 64-bit integers are so comically large. <a href="#fnref:isize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:two-shifts" role="doc-endnote"> <p>Interestingly, LLVM will compile <code class="language-plaintext highlighter-rouge">(x &lt;&lt; 2) &gt;&gt; 2</code> to</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">movabs</span> <span class="n">rax</span><span class="p">,</span><span class="mh">0x3fffffffffffffff</span>
<span class="n">and</span>    <span class="n">rax</span><span class="p">,</span><span class="n">rdi</span>
<span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>If we want to play the byte-for-byte game, this costs 14 bytes when encoded in the Intel variable-length encoding. You would think that two shifts would result in marginally smaller code, but no, since the input comes in in <code class="language-plaintext highlighter-rouge">rdi</code> and needs to wind up in <code class="language-plaintext highlighter-rouge">rax</code>.</p> <p>On RISC-V, though, it seems to decide that two shifts is in fact cheaper, and will even optimize <code class="language-plaintext highlighter-rouge">x &amp; 0x3fff_ffff_ffff_ffff</code> back into two shifts. <a href="#fnref:two-shifts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:big-endian" role="doc-endnote"> <p>This only works on little endian. Thankfully all computers are little endian. <a href="#fnref:big-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:leaks" role="doc-endnote"> <p>Technically, a <code class="language-plaintext highlighter-rouge">&amp;'static str</code> may also point to leaked memory. For our purposes, there is no essential difference. <a href="#fnref:leaks" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-08-01 • 5263 words • 43 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <h1><a href="/2023/08/01/llvm-ir/"> A Gentle Introduction to LLVM IR<br/> </a></h1> </div> <div class="post"> <p>The other day, I saw <a href="https://twitter.com/burntsushi5/status/1684204136571478021?s=20">this tweet</a>. In it, Andrew Gallant argues that reaching for LLVM IR, instead of assembly, is a useful tool for someone working on performance. Unfortunately, learning material on LLVM is usually aimed at compiler engineers, not generalist working programmers.</p> <p>Now, <em>I’m</em> a compiler engineer, so my answer is <em>of course</em> you should know your optimizer’s IR. But I do think there’s a legitimate reason to be able to read it, in the same way that being able to read assembly to understand what your processor is doing is a powerful tool. I wrote an <a href="https://mcyoung.xyz//2021/11/29/assembly-1">introduction to assembly</a> over a year ago (still have to finish the followups… 💀), which I recommend reading first.</p> <p>Learning LLVM IR is similar, but it helps you understand what your <em>compiler</em> is doing to create highly optimized code. LLVM IR is very popular, and as such well-documented and reasonably well-specified, to the point that we can just treat it as a slightly weird programming language.</p> <p>In this article, I want to dig into what LLVM IR <em>is</em> and how to read it.</p> <h2 id="whats-llvm-ir"><a href="#whats-llvm-ir">What’s LLVM IR?</a></h2> <p>“LLVM” is an umbrella name for a number of software components that can be used to build compilers. If you write performance-critical code, you’ve probably heard of it.</p> <p>Its flagship product is Clang, a high-end C/C++/Objective-C compiler. Clang follows the orthodox compiler architecture: a frontend that parses source code into an AST and lowers it into an <em>intermediate representation</em>, an “IR”; an optimizer (or “middle-end”) that transforms IR into better IR, and a backend that converts IR into machine code for a particular platform.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">                               optimizer (opt)
                                    ___
                                   |   v
          .c file  --&gt;  AST  --&gt;  LLVM IR  --&gt;  assembly
                    ^         ^             ^
                 parser    lowering    backend (llc)

         \____________________/  \_____________________/
             Clang Frontend                LLVM</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button"></div></div></div> <p>LLVM often also refers to just the optimizer and backend parts of Clang; this is can be thought of as a compiler for the “LLVM language” or “LLVM assembly”. Clang, and other language frontends like Rust, essentially compile to LLVM IR, which LLVM then compiles to machine code.</p> <p>LLVM IR is well documented and… <em>somewhat</em> stable, which makes it a very good compilation target, since language implementers can re-use the thousands of engineer hours poured into LLVM already. The source of truth for “what is LLVM IR?” is the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>.</p> <p>LLVM IR is also binary format (sometimes called “bitcode”), although we will be working exclusively with its text format (which uses the <code class="language-plaintext highlighter-rouge">.ll</code> extension).</p> <p>LLVM-targeting compilers will have debugging flags to make them emit IR instead of their final output. For Clang, this is e.g. <code class="language-plaintext highlighter-rouge">clang++ -S -emit-llvm foo.cc</code>, while for Rust this is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir foo.rs</code>. Godbolt will also respect these options and correctly display LLVM IR output.</p> <h2 id="back-to-basic-blocks"><a href="#back-to-basic-blocks">Back to Basic Blocks</a></h2> <p>LLVM IR can be quite intimidating to read, since it contains much more ancillary information than an assembly dump. Consider this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>If you click on the “Godbolt” widget, it will take you to a Godbolt that lowers it to LLVM IR. Most of that code is just metadata, but it’s really intimidating!</p> <p>Starting from compiler output will have a steep difficulty curve, because we have to face the full complexity of LLVM IR. For Rust, this will likely mean encountering exception-handling, which is how panics are implemented, and function attributes that forward Rust’s guarantees (e.g. non-null pointers) to LLVM.</p> <p>Instead, we’ll start by introducing the basic syntax of LLVM IR, and <em>then</em> we’ll tackle reading compiler output.</p> <h3 id="a-trivial-function"><a href="#a-trivial-function">A Trivial Function</a></h3> <p>The meat of LLVM IR is function definitions, introduced with a <code class="language-plaintext highlighter-rouge">define</code>. There is also <code class="language-plaintext highlighter-rouge">declare</code>, which has exactly the same purpose as a function without a body in C: it brings an external symbol into scope.</p> <p>For example, the following function takes no arguments and returns immediately:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_nothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The return type of the function (<code class="language-plaintext highlighter-rouge">void</code>) immediately follows the <code class="language-plaintext highlighter-rouge">define</code> keyword; the name of the function starts with an <code class="language-plaintext highlighter-rouge">@</code>, which introduces us to the concept of <em>sigils</em>: every user-defined symbol starts with a sigil, indicating what kind of symbol it is. <code class="language-plaintext highlighter-rouge">@</code> is used for global and functions: things you can take the address of (when used as a value, they are always <code class="language-plaintext highlighter-rouge">ptr</code>-typed).</p> <p>The body of a function resembles assembly: a list of labels and instructions. Unlike ordinary assembly, however, there are significant restrictions on the structure of these instructions.</p> <p>In this case, there is only one instruction: a <code class="language-plaintext highlighter-rouge">void</code>-typed return. Unlike most assembly languages, LLVM IR is strongly typed, and requires explicit type annotations almost everywhere.</p> <p>Here is another trivial function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_not_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">unreachable</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function will trigger undefined behavior upon being called: the <code class="language-plaintext highlighter-rouge">unreachable</code> instruction represents a codepath that the compiler can assume is never executed; this is unlike e.g. the unimplemented <code class="language-plaintext highlighter-rouge">ud2</code> instruction in x86, which is guaranteed to issue a fault.</p> <p>This is an important distinction between LLVM IR and an assembly language: some operations are explicitly left undefined to leave room for potential optimizations. For example, LLVM can reason that, because <code class="language-plaintext highlighter-rouge">@do_not_call</code> immediately triggers undefined behavior, all calls to <code class="language-plaintext highlighter-rouge">@do_not_call</code> are also unreachable (and propagate unreachability from there).</p> <h3 id="purely-scalar-code"><a href="#purely-scalar-code">Purely Scalar Code</a></h3> <p>Let’s start with basic functions that only operate on integers. Consider the following function, that squares a 32-bit integer:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function takes arguments and has multiple instructions.</p> <p>The argument is specified as <code class="language-plaintext highlighter-rouge">i32 %x</code>. Names a <code class="language-plaintext highlighter-rouge">%</code> sigil are sort of like local variables, but with some restrictions that make them more optimization-friendly; as we’ll see later, they’re not really “variable” at all. LLVM sometimes calls them <em>registers</em>; in a sense, LLVM IR is assembly for an abstract machine with an infinite number of registers. I’ll be calling <code class="language-plaintext highlighter-rouge">%</code>-prefixed names “registers” throughout this article.</p> <p><code class="language-plaintext highlighter-rouge">i32</code> is a primitive integer types. All integer types in LLVM are of the form <code class="language-plaintext highlighter-rouge">iN</code>, for any <code class="language-plaintext highlighter-rouge">N</code> (even non-multiples of eight). There are no signed or unsigned types; instead, instructions that care about signedness will specify which semantic they use.</p> <p>The first instruction is a <code class="language-plaintext highlighter-rouge">mul i32</code>, which multiples the two <code class="language-plaintext highlighter-rouge">i32</code> operands together, and returns a value; we assign this to the new register <code class="language-plaintext highlighter-rouge">%1</code><sup id="fnref:numeric-names" role="doc-noteref"><a href="#fn:numeric-names" class="footnote" rel="footnote">1</a></sup>. The next instruction returns this value.</p> <p>The other arithmetic operations have the names you expect: <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">shl</code> (shift left). There are two division and remainder instructions, signed (<code class="language-plaintext highlighter-rouge">sdiv</code>, <code class="language-plaintext highlighter-rouge">srem</code>) and unsigned (<code class="language-plaintext highlighter-rouge">udiv</code>, <code class="language-plaintext highlighter-rouge">urem</code>). There two shift right instructions, again signed (<code class="language-plaintext highlighter-rouge">ashr</code>) and unsigned (<code class="language-plaintext highlighter-rouge">lshr</code>).</p> <blockquote> <p>Exercise for the reader: why are <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">%</code>, and <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> the only operations with signed and unsigned versions?</p> </blockquote> <p>We can also convert from one integer type to another using <code class="language-plaintext highlighter-rouge">trunc</code>, <code class="language-plaintext highlighter-rouge">zext</code>, and <code class="language-plaintext highlighter-rouge">sext</code>, which truncate, zero-extend, and sign-extend, respectively (<code class="language-plaintext highlighter-rouge">sext</code> and <code class="language-plaintext highlighter-rouge">zext</code> are another signed/unsigned pair). For example, if we wanted the <code class="language-plaintext highlighter-rouge">square</code> function to never overflow, we could write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">sext</span> <span class="kt">i32</span> <span class="nv">%x</span> <span class="k">to</span> <span class="kt">i64</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%1</span><span class="p">,</span> <span class="nv">%1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we cast <code class="language-plaintext highlighter-rouge">%x</code> to <code class="language-plaintext highlighter-rouge">i64</code> by sign-extension (since we’ve decided we’re squaring signed integers) and then square the result. <code class="language-plaintext highlighter-rouge">trunc</code> and <code class="language-plaintext highlighter-rouge">zext</code> both have the same syntax as <code class="language-plaintext highlighter-rouge">sext</code>.</p> <h3 id="ill-be-back"><a href="#ill-be-back">“I’ll Be Back”</a></h3> <p>Of course, interesting functions have <em>control flow</em>. Suppose we want a safe division function: division by zero is UB, so we need to handle it explicitly. Perhaps something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try doing this using <code class="language-plaintext highlighter-rouge">select</code>, LLVM’s “ternary” operation.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">select</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">-1</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%2</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>However, this has a problem: division by zero is UB<sup id="fnref:divz" role="doc-noteref"><a href="#fn:divz" class="footnote" rel="footnote">2</a></sup>, and <code class="language-plaintext highlighter-rouge">select</code> is not short-circuiting: its semantics are closer to that of <code class="language-plaintext highlighter-rouge">cmov</code> in x86.</p> <p>To compile this correctly, need to use the <code class="language-plaintext highlighter-rouge">br</code> instruction, which represents a general branch operation<sup id="fnref:br-on-real-machines" role="doc-noteref"><a href="#fn:br-on-real-machines" class="footnote" rel="footnote">3</a></sup>. In C terms, a <code class="language-plaintext highlighter-rouge">br i1 %cond, label %a, label %b</code> is equivalent to <code class="language-plaintext highlighter-rouge">if (cond) goto a; else goto b;</code>.</p> <p>This is how we might write that:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%iszero</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%nonzero</span>

<span class="nl">iszero:</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="m">-1</span>

<span class="nl">nonzero:</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function has labels, which are used by the <code class="language-plaintext highlighter-rouge">br</code> instruction as jump targets.</p> <p>In the first block, we do the <code class="language-plaintext highlighter-rouge">d == 0</code> check, implemented by an <code class="language-plaintext highlighter-rouge">icmp eq</code> instruction. This returns an <code class="language-plaintext highlighter-rouge">i1</code> (the type LLVM uses for booleans). We then pass the result into a <code class="language-plaintext highlighter-rouge">br</code> instruction, which jumps to the first label if it’s zero, otherwise to the second if it isn’t.</p> <p>The second block is the early-return; it returns the “sentinel” value; the third block is self-explanatory.</p> <p>Each of these blocks is a “basic block”: a sequence of non-control flow operations, plus an instruction that moves control flow away from the block. These blocks form the control flow graph (CFG) of the function.</p> <p>There are a few other “block terminator” instructions. The one-argument form of <code class="language-plaintext highlighter-rouge">br</code> takes a single label, and is a simple unconditional <code class="language-plaintext highlighter-rouge">goto</code>. There’s also <code class="language-plaintext highlighter-rouge">switch</code>, which is similar to a C <code class="language-plaintext highlighter-rouge">switch</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">switch</span> <span class="kt">i32</span> <span class="nv">%value</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%default</span> <span class="p">[</span>
  <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_zero</span>
  <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_one</span><span class="p">,</span>
  <span class="c1">; etc</span>
<span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The type of the <code class="language-plaintext highlighter-rouge">switch</code> must be an integer type. Although you could represent this operation with a chain of <code class="language-plaintext highlighter-rouge">br</code>s, a separate <code class="language-plaintext highlighter-rouge">switch</code> instruction makes it easier for LLVM to generate jump tables.</p> <p><code class="language-plaintext highlighter-rouge">unreachable</code>, which we saw before, is a special terminator that does not trigger control flow per se, but which can terminate a block because reaching it is undefined behavior; it is equivalent to e.g. <code class="language-plaintext highlighter-rouge">std::unreachable()</code> in C++.</p> <blockquote> <h4 id="llvm-deleted-my-code"><a href="#llvm-deleted-my-code">LLVM Deleted My Code!</a></h4> <p>The <code class="language-plaintext highlighter-rouge">unreachable</code> instruction provides a good example of why LLVM uses a basic block CFG: a naive dead code elimination (DCE) optimization pass can be implemented as follows:</p> <ol> <li>Fill a set with every block that ends in <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>For every block, if its terminator references a block in the unreachable set, delete that label from the terminator. For example, if we have <code class="language-plaintext highlighter-rouge">br i1 %c, label %a, label %b</code>, and the unreachable set contains <code class="language-plaintext highlighter-rouge">%a</code>, we can replace this with a <code class="language-plaintext highlighter-rouge">br label %b</code>.</li> <li>If every outgoing edge from a block is deleted in (2), replace the terminator with <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>Delete all blocks in the unreachable set.</li> <li>Repeat from (1) as many times as desired.</li> </ol> <p>Intuitively, <code class="language-plaintext highlighter-rouge">unreachable</code>s bubble <em>upwards</em> in the CFG, dissolving parts of the CFG among them. Other passes can generate <code class="language-plaintext highlighter-rouge">unreachable</code>s to represent UB: interplay between this and DCE results in the “the compiler <em>will</em> delete your code” outcome from UB.</p> <p>The actual DCE pass is much more complicated, since function calls make it harder to decide if a block is “pure” and thus transparently deletable.</p> </blockquote> <p>But, what if we want to implement something more complicated, like <code class="language-plaintext highlighter-rouge">a / b + 1</code>? This expression needs the intermediate result, so we can’t use two return statements as before.</p> <p>Working around this is not so straightforward: if we try to assign the same register in different blocks, the IR verifier will complain. This brings us to the concept of static single assignment.</p> <h3 id="phony-phony"><a href="#phony-phony">Phony! Phony!</a></h3> <p>LLVM IR is a <em>static single assignment form</em> (SSA) IR. LLVM was actually started at the turn of the century to create a modern SSA optimizer as an academic project. These days, SSA is extremely fashionable for optimizing imperative code.</p> <p>SSA form means that every register is assigned by at most one instruction per function. Different executions of the same block in the same function may produce different values for particular registers, but we cannot <em>mutate</em> already-assigned registers.</p> <p>In other words:</p> <ol> <li>Every register is guaranteed to be initialized by a single expression.</li> <li>Every register depends only on the values of registers assigned before its definition.</li> </ol> <p>This has many useful properties for writing optimizations: for example, within a basic block, every use of a particular register <code class="language-plaintext highlighter-rouge">%x</code> always refers to the same value, which makes optimizations like <a href="https://en.wikipedia.org/wiki/Value_numbering">global value numbering</a> and constant-folding much simpler to write, since the state of a register throughout a block doesn’t need to be tracked separately.</p> <p>In SSA, we reinterpret mutation as many <em>versions</em> of a single variable. Thus, we might lower <code class="language-plaintext highlighter-rouge">x += y</code> as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x.1</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%x.0</span><span class="p">,</span> <span class="nv">%y.0</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we’ve used a <code class="language-plaintext highlighter-rouge">var.n</code> convention to indicate which version of a variable a specific register represents (LLVM does not enforce any naming conventions).</p> <p>However, when loops enter the mix, it’s not clear how to manage versions. The number of registers in a function is static, but the number of loop iterations is dynamic.</p> <p>Concretely, how do we implement this function?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">y</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>  <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>   <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>But there’s a problem! What are the original definitions of <code class="language-plaintext highlighter-rouge">%r</code> and <code class="language-plaintext highlighter-rouge">%i</code>? The IR verifier will complain that these registers depend directly on themselves, which violates SSA form. What’s the “right” way to implement this function?</p> <p>One option is to ask LLVM! We’ll implement the function poorly, and let the optimizer clean it up for us.</p> <p>First, let’s write the function using memory operations, like <code class="language-plaintext highlighter-rouge">load</code>s and <code class="language-plaintext highlighter-rouge">store</code>s, to implement mutation. We can use the <code class="language-plaintext highlighter-rouge">alloca</code> instruction to create statically-sized stack slots; these instructions return a <code class="language-plaintext highlighter-rouge">ptr</code>[^clang-codegen].</p> <blockquote> <h4 id="clang-makes-a-mess-llvm-cleans-it-up"><a href="#clang-makes-a-mess-llvm-cleans-it-up">Clang Makes a Mess, LLVM Cleans It Up</a></h4> <p>Incidentally, this is how Clang and Rust both generate LLVM IR: stack variables are turned into <code class="language-plaintext highlighter-rouge">alloca</code>s and manipulated through loads and stores; temporaries are mostly turned into <code class="language-plaintext highlighter-rouge">%regs</code>s, but the compiler will sometimes emit extra allocas to avoid thinking too hard about needing to create <code class="language-plaintext highlighter-rouge">phi</code> instructions.</p> <p>This is pretty convenient, because it avoids needing to think very hard about SSA form outside of LLVM, and LLVM can trivially eliminate unnecessary allocas. The code I wrote for the codegen of <code class="language-plaintext highlighter-rouge">@pow</code> is very similar to what Rust would send to LLVM (although because we used an iterator, there’s a lot of extra junk Rust emits that LLVM has to work to eliminate).</p> </blockquote> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">; Create slots for r and the index, and initialize them.</span>
  <span class="c1">; This is equivalent to something like</span>
  <span class="c1">;   int i = 0, r = 1;</span>
  <span class="c1">; in C.</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="c1">; Load the index and check if it equals y.</span>
  <span class="nv">%i.check</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.check</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="c1">; r *= x</span>
  <span class="nv">%r.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.old</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%r.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>

  <span class="c1">; i += 1</span>
  <span class="nv">%i.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.old</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%i.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>

  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="nv">%r.ret</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.ret</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Next, we can pass this into the LLVM optimizer. The command <code class="language-plaintext highlighter-rouge">opt</code>, which is part of the LLVM distribution, runs specific optimizer passes on the IR. In our case, we want <code class="language-plaintext highlighter-rouge">opt -p mem2reg</code>, which runs a single “memory to register” pass. We can also just run <code class="language-plaintext highlighter-rouge">opt --O2</code> or similar to get similar<sup id="fnref:frontend-optimization" role="doc-noteref"><a href="#fn:frontend-optimization" class="footnote" rel="footnote">4</a></sup> optimizations to the ones <code class="language-plaintext highlighter-rouge">clang -O2</code> runs.</p> <p>This is the result.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; After running through `opt -p mem2reg`</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="nv">%i.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%i.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%r.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%r.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.0</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.0</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">alloca</code>s are gone, but now we’re faced with a new instruction: <code class="language-plaintext highlighter-rouge">phi</code>. “φ node” is jargon from the original SSA paper; the greek letter φ means “phoney”. These instructions select a value from a list based on which basic block we jumped to the block from.</p> <p>For example, <code class="language-plaintext highlighter-rouge">phi i32 [0, %start], [%i.new, %loop]</code> says “this value should be 0 if we came from the <code class="language-plaintext highlighter-rouge">start</code> block; otherwise <code class="language-plaintext highlighter-rouge">%i.new</code> if it came from <code class="language-plaintext highlighter-rouge">%loop</code>”.</p> <p>Unlike all other instructions, <code class="language-plaintext highlighter-rouge">phi</code> can refer to values that are not defined in all blocks that dominate the current block. This lets us have a dynamic number of versions of a variable! Here’s what that looks like in a dynamic execution context.</p> <blockquote> <p>A block <code class="language-plaintext highlighter-rouge">%a</code> is said to dominate a block <code class="language-plaintext highlighter-rouge">%b</code> if each of its predecessors is either <code class="language-plaintext highlighter-rouge">%a</code> or a block dominated by <code class="language-plaintext highlighter-rouge">%a</code>. In other words, every path from the first block to <code class="language-plaintext highlighter-rouge">%b</code> passes through <code class="language-plaintext highlighter-rouge">%a</code>. In general instructions can only refer to values defined in previous instructions in the current block or values from blocks that dominate it.</p> </blockquote> <ol> <li> <p><code class="language-plaintext highlighter-rouge">%start</code> directly jumps into <code class="language-plaintext highlighter-rouge">%loop_start</code>. The first block cannot be a jump target, since it cannot have <code class="language-plaintext highlighter-rouge">phi</code> nodes because its predecessors include function’s callsite.</p> </li> <li> <p>In <code class="language-plaintext highlighter-rouge">%loop_start</code>, since we’ve entered from <code class="language-plaintext highlighter-rouge">%start</code>, <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are selected to be the first versions of the (platonic) <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code> variables, i.e., their initial values; we jump to <code class="language-plaintext highlighter-rouge">%loop</code>.</p> </li> <li> <p>Then, <code class="language-plaintext highlighter-rouge">%loop</code> is dominated by <code class="language-plaintext highlighter-rouge">%loop_start</code> so we can use <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> there directly; these are the <code class="language-plaintext highlighter-rouge">*=</code> and <code class="language-plaintext highlighter-rouge">+=</code> operations. Then we jump back to <code class="language-plaintext highlighter-rouge">%loop_start</code>.</p> </li> <li> <p>Back in <code class="language-plaintext highlighter-rouge">%loop_start</code>, the <code class="language-plaintext highlighter-rouge">phi</code>s now select <code class="language-plaintext highlighter-rouge">%i.new</code> and <code class="language-plaintext highlighter-rouge">%r.new</code>, so now <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are the <em>second</em> versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>. By induction, the nth execution of <code class="language-plaintext highlighter-rouge">%loop_start</code> has the nth versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>.</p> </li> <li> <p>When we finally get sent to <code class="language-plaintext highlighter-rouge">%exit</code>, we can use <code class="language-plaintext highlighter-rouge">%r.0</code> (since <code class="language-plaintext highlighter-rouge">%loop_start</code> dominates <code class="language-plaintext highlighter-rouge">%r.0</code>), which will be the <code class="language-plaintext highlighter-rouge">%y</code>th version of <code class="language-plaintext highlighter-rouge">r</code>; this is our return value.</p> </li> </ol> <p>This is a good place to stop and think about what we’ve done so far. SSA, domination, and <code class="language-plaintext highlighter-rouge">phi</code>s can be hard to wrap your head around, and are not absolutely necessary for reading most IR. However, it is absolutely worth trying to understand, because it captures essential facts about how compilers like to reason about code<sup id="fnref:block-args" role="doc-noteref"><a href="#fn:block-args" class="footnote" rel="footnote">5</a></sup>.</p> <p>With <code class="language-plaintext highlighter-rouge">phi</code> and <code class="language-plaintext highlighter-rouge">br</code>, we can build arbitrarily complicated control flow within a function<sup id="fnref:viz" role="doc-noteref"><a href="#fn:viz" class="footnote" rel="footnote">6</a></sup>.</p> <h2 id="types-and-aggregates"><a href="#types-and-aggregates">Types and Aggregates</a></h2> <p>Now that we have basic scalar functions, let’s review LLVM’s type system.</p> <p>We’ve seen <code class="language-plaintext highlighter-rouge">i32</code> and its friends; these are arbitrary-bit-with integers. <code class="language-plaintext highlighter-rouge">i1</code> is special because it is used as the boolean type. LLVM optimizations have been known to generate integer types with non-power-of-two sizes.</p> <p>LLVM also has <code class="language-plaintext highlighter-rouge">float</code> and <code class="language-plaintext highlighter-rouge">double</code>, and some exotic float types like <code class="language-plaintext highlighter-rouge">bfloat</code>; these use their own arithmetic instructions with different options. I’ll pass on them in this explainer; see <code class="language-plaintext highlighter-rouge">fadd</code> and friends in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> for more.</p> <p>We’ve also seen <code class="language-plaintext highlighter-rouge">void</code>, which is only used as a return value, and <code class="language-plaintext highlighter-rouge">ptr</code>, which is an untyped<sup id="fnref:typed-pointers" role="doc-noteref"><a href="#fn:typed-pointers" class="footnote" rel="footnote">7</a></sup> pointer.</p> <p>We’ve also seen the <code class="language-plaintext highlighter-rouge">label</code> pseudo-type, which represents a block label. It does not appear directly at runtime and has limited uses; the <code class="language-plaintext highlighter-rouge">token</code> and <code class="language-plaintext highlighter-rouge">metadata</code> types are similar.</p> <p>Arrays are spelled <code class="language-plaintext highlighter-rouge">[n x T]</code>; the number must be an integer and the type must have a definite size. E.g., <code class="language-plaintext highlighter-rouge">[1024 x i8]</code>. Zero-sized arrays are supported.</p> <p>Structs are spelled <code class="language-plaintext highlighter-rouge">{T1, T2, ...}</code>. E.g., <code class="language-plaintext highlighter-rouge">{i64, ptr}</code> is a Rust slice. Struct fields do not have names and are indexed, instead. The form <code class="language-plaintext highlighter-rouge">&lt;{...}&gt;</code> is a <em>packed</em> struct, which removes inter-field padding. E.g. <code class="language-plaintext highlighter-rouge">#[repr(packed)]</code> compiles down to this.</p> <p>Vectors are like arrays but spelled <code class="language-plaintext highlighter-rouge">&lt;n x T&gt;</code>. These are used to represent types used in SIMD operations. For example, adding two <code class="language-plaintext highlighter-rouge">&lt;4 x i32&gt;</code> would lower to an AVX2 vector add on x86. I will not touch on SIMD stuff beyond this, although at higher optimization levels LLVM will merge scalar operations into vector operations, so you may come across them.</p> <p>Type aliases can be created at file scope with the syntax</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Slice</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This means that <code class="language-plaintext highlighter-rouge">%T</code> can be either a type or a register/label inside of a function, depending on syntactic position.</p> <h3 id="operations-on-aggregates"><a href="#operations-on-aggregates">Operations on Aggregates</a></h3> <p>The <code class="language-plaintext highlighter-rouge">insertvalue</code> and <code class="language-plaintext highlighter-rouge">extractvalue</code> can be used with struct or array types to statically access a field. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%MyStruct</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i32</span><span class="p">,</span> <span class="p">{[</span><span class="m">5</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">],</span> <span class="kt">i64</span><span class="p">}}</span>

<span class="c1">; In Rust-like syntax, this is `let v = s.1.0[4];`</span>
<span class="nv">%v</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><code class="language-plaintext highlighter-rouge">insertvalue</code> is the reverse: it produces a copy of the aggregate with a specific field changed. It <em>does not</em> mutate in-place, because SSA forbids that.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; In Rust-like syntax, this is</span>
<span class="c1">;   let s2 = { let mut s = s; s2.1.1 = 42; s };</span>
<span class="nv">%s2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>There are similar operations called <code class="language-plaintext highlighter-rouge">insertelement</code> and <code class="language-plaintext highlighter-rouge">extractelement</code> work on vectors, but have slightly different syntax and semantics.</p> <p>Finally, there’s <code class="language-plaintext highlighter-rouge">getelementptr</code>, the “pointer arithmetic instruction”, often abbreviated to GEP. A GEP can be used to calculate an offset pointer into a struct. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="err">ptr</span> <span class="vg">@get_inner_in_array</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%q</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%MyStruct</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="err">ptr</span> <span class="nv">%q</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function takes in a pointer, ostensibly pointing to an array of <code class="language-plaintext highlighter-rouge">%MyStruct</code>s, and an index. This returns a pointer to the <code class="language-plaintext highlighter-rouge">i64</code> field of the <code class="language-plaintext highlighter-rouge">%idx</code>th element of <code class="language-plaintext highlighter-rouge">%p</code>.</p> <p>A few important differences between GEP and <code class="language-plaintext highlighter-rouge">extractvalue</code>:</p> <ol> <li>It takes an untyped pointer instead of a value of a particular struct/array type.</li> <li>There is an extra parameter that specifies an index; from the perspective of GEP, every pointer is a pointer to an array of unspecified bound. When operating on a pointer that does not (at runtime) point to an array, an index operand of <code class="language-plaintext highlighter-rouge">0</code> is still required. (Alternatively, you can view a pointer to <code class="language-plaintext highlighter-rouge">T</code> as being a pointer to a one-element array.)</li> <li>The index parameters need explicit types.</li> </ol> <p>LLVM provides a helpful<sup id="fnref:sarcasm" role="doc-noteref"><a href="#fn:sarcasm" class="footnote" rel="footnote">8</a></sup> FAQ on the GEP instruction: <a href="https://llvm.org/docs/GetElementPtr.html">https://llvm.org/docs/GetElementPtr.html</a>.</p> <h2 id="other-operations"><a href="#other-operations">Other Operations</a></h2> <p>Some other operations are very relevant for reading IR, but don’t fit into any specific category. As always, the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> provides a full description of what all of these instructions do.</p> <h3 id="function-calls"><a href="#function-calls">Function Calls</a></h3> <p><code class="language-plaintext highlighter-rouge">call</code>, which calls any <code class="language-plaintext highlighter-rouge">ptr</code> as a function. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; Arguments are passed in parentheses.</span>
<span class="nv">%r</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@my_func</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Note that this could have been a <code class="language-plaintext highlighter-rouge">%reg</code> instead of a <code class="language-plaintext highlighter-rouge">@global</code>, which indicates a function pointer call.</p> <p>Sometimes you will see <code class="language-plaintext highlighter-rouge">invoke</code>, which is used to implement “call a function inside of a C++ <code class="language-plaintext highlighter-rouge">try {}</code> block”. This is rare in Rust, but can occur in some C++ code.</p> <p>Function calls are often noisy areas of IR, because they will be very heavily annotated.</p> <h3 id="synchronization"><a href="#synchronization">Synchronization</a></h3> <p>The <code class="language-plaintext highlighter-rouge">load</code> and <code class="language-plaintext highlighter-rouge">store</code> instructions we’ve already seen can be annotated as <code class="language-plaintext highlighter-rouge">atomic</code>, which is used to implement e.g. <code class="language-plaintext highlighter-rouge">AtomicU32::load</code> in Rust; this requires that an atomic ordering be specified, too. E.g.,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%v</span> <span class="p">=</span> <span class="k">load</span> <span class="k">atomic</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span> <span class="k">acquire</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">fence</code> operation is a general memory fence operation corresponding to e.g. Rust’s <code class="language-plaintext highlighter-rouge">std::sync::atomic::fence</code> function.</p> <p><code class="language-plaintext highlighter-rouge">cmpxchg</code> provides the CAS (compare-and-swap) primitive. It returns a <code class="language-plaintext highlighter-rouge">{T, i1}</code> containing the old value and whether the CAS succeeded. <code class="language-plaintext highlighter-rouge">cmpxchg weak</code> implements the spuriously-failing “weak CAS” primitive.</p> <p>Finally, <code class="language-plaintext highlighter-rouge">atomicrmw</code> performs a read-modify-write (e.g., <code class="language-plaintext highlighter-rouge">*p = op(*p, val)</code>) atomically. This is used to implement things like <code class="language-plaintext highlighter-rouge">AtomicU32::fetch_add</code> and friends.</p> <p>All of these operations, except for <code class="language-plaintext highlighter-rouge">fence</code>, can also be marked as <code class="language-plaintext highlighter-rouge">volatile</code>. In LLVM IR, much like in Rust but unlike in C/C++, individual loads and stores are volatile (i.e., have compiler-invisible side-effects). <code class="language-plaintext highlighter-rouge">volatile</code> <em>can</em> be combined with atomic operations (e.g. <code class="language-plaintext highlighter-rouge">load atomic volatile</code>), although most languages don’t provide access to these (except older C++ versions).</p> <h3 id="reinterpret-shenanigans"><a href="#reinterpret-shenanigans">Reinterpret Shenanigans</a></h3> <p><code class="language-plaintext highlighter-rouge">bitcast</code> is what <code class="language-plaintext highlighter-rouge">mem::transmute</code> and <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> in Rust and C++, respectively, ultimately compile into. It can convert any non-aggregate type (integers, vectors) to any other type of the same bit width. For example, it can be used to get at the bits of a floating-point value:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%bits</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span> <span class="nv">%fp</span> <span class="k">to</span> <span class="kt">i64</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>It also used to be what was used to cast pointer types (e.g. <code class="language-plaintext highlighter-rouge">i32*</code> to <code class="language-plaintext highlighter-rouge">i8*</code>). Pointers are now all untyped (<code class="language-plaintext highlighter-rouge">ptr</code>) so this use is no longer present.</p> <p>However, <code class="language-plaintext highlighter-rouge">bitcast</code> cannot cast between pointer and integer data. For this we must use the <code class="language-plaintext highlighter-rouge">inttoptr</code> and <code class="language-plaintext highlighter-rouge">ptrtoint</code><sup id="fnref:i2p" role="doc-noteref"><a href="#fn:i2p" class="footnote" rel="footnote">9</a></sup> instructions. These have the same syntax, but interact with the sketchy semantics of pointer-to-integer conversion and pointer provenance. This part of LLVM’s semantics is a bit of an ongoing trashfire; see <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">Ralf Jung’s post</a> for an introduction to this problem.</p> <h3 id="intrinsics"><a href="#intrinsics">Intrinsics</a></h3> <p>There is also a vast collection of LLVM intrinsics, which are specified in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>. For example, if we need a particular built-in memcpy, we can bring it into scope with a <code class="language-plaintext highlighter-rouge">declare</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ptr %dst, ptr %src, i64 %len, i1 %volatile</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.memcpy.p0.p0.i64</span><span class="p">(</span><span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>All of the LLVM intrinsics are functions that start with <code class="language-plaintext highlighter-rouge">llvm.</code>; diving into all of them is far beyond what we can do here.</p> <p>I’m also leaving out discussion of floating point, SIMD, and exception handling, each of which would require their own articles!</p> <h2 id="undefined-behavior"><a href="#undefined-behavior">Undefined Behavior</a></h2> <p>LLVM exists to generate optimized code, and optimizations require that we declare certain machine states “impossible”, so that we can detect when we can simplify what the programmer has said. This is “undefined behavior”.</p> <p>For example, we’ve already encountered <code class="language-plaintext highlighter-rouge">unreachable</code>, which LLVM assumes cannot be executed. Division by zero and accessing memory out of bounds is also undefined.</p> <p>Most LLVM UB factors through the concept of “poisoned values”. A poison value can be thought of as “taking on every value at once”, whichever is convenient for the current optimization pass with no respect to any other passes. This also means that if optimizations <em>don’t</em> detect a use of poison, it is ok from LLVM’s perspective to give you a garbage value. This is most visible at <code class="language-plaintext highlighter-rouge">-O0</code>, which performs minimal optimization.</p> <p>Using a poison value as a pointer in a <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">store</code>, or <code class="language-plaintext highlighter-rouge">call</code> must be UB, because LLVM can choose it to be a null pointer. It also can’t be the denominator of a <code class="language-plaintext highlighter-rouge">udiv</code> or similar, because LLVM can choose it to be zero, which is UB. Passing poison into a <code class="language-plaintext highlighter-rouge">br</code> or a <code class="language-plaintext highlighter-rouge">switch</code> is also defined to be UB.</p> <p>LLVM can perform dataflow analysis to try to determine what operations a poisonous value that was used in a UB way came from, and thus assume those operations cannot produce poison. Because all operations (other than <code class="language-plaintext highlighter-rouge">select</code> and <code class="language-plaintext highlighter-rouge">phi</code>) with a poison input produce poison, backwards reasoning allows LLVM to propagate UB forward. This is where so-called “time traveling UB” comes from.</p> <p>Many operations generate poison. For example, in C, signed overflow is UB, so addition lowers to an <code class="language-plaintext highlighter-rouge">add nsw</code> (<code class="language-plaintext highlighter-rouge">nsw</code> stands for no signed wrap). Instead of wrapping on overflow, the instruction produces poison. There is also an unsigned version of the annotation, <code class="language-plaintext highlighter-rouge">nuw</code>.</p> <p>Many other operations have “less defined” versions, which are either generated by optimizations, or inserted directly by the compiler that invokes LLVM when the language rules allow it (see C above). More examples include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">udiv</code> and friends have an <code class="language-plaintext highlighter-rouge">exact</code> annotation, which requires that the division have a zero remainder, else poison.</li> <li><code class="language-plaintext highlighter-rouge">getelementptr</code> has an <code class="language-plaintext highlighter-rouge">inbounds</code> annotation, which produces poison if the access is actually out of bounds. This changes it from a pure arithmetic operation to one more closely matching C’s pointer arithmetic restrictions. GEP without <code class="language-plaintext highlighter-rouge">inbounds</code> corresponds to Rust’s <code class="language-plaintext highlighter-rouge">&lt;*mut T&gt;::wrapping_offset()</code> function.</li> <li>Floating point operations marked with <code class="language-plaintext highlighter-rouge">nnan</code> and <code class="language-plaintext highlighter-rouge">ninf</code> will produce poison instead of a NaN or an infinite value, respectively (or when a NaN or infinity is an argument).</li> </ul> <p>Creating poison is <em>not</em> UB; only using it is. This is weaker than the way UB works in most languages; in C, overflow is instantly UB, but in LLVM overflow that is never “witnessed” is simply ignored. This is a simpler operational semantics for reasoning about the validity of optimizations: UB must often be viewed as a side-effect, because the compiler will generate code that puts the program into a broken state. For example, division by zero will cause a fault in many architectures. This means UB-causing operations cannot always be reordered soundly. Replacing “causes UB” with “produces poison” ensures the vast majority of operations are pure and freely reorderable.</p> <h2 id="reading-some-codegen"><a href="#reading-some-codegen">Reading Some Codegen</a></h2> <p>Let’s go back to our original Rust example!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This is the output, with metadata redacted and some things moved around for readability.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">source_filename</span> <span class="p">=</span> <span class="s">"example.b6eb2c7a6b40b4d2-cgu.0"</span>
<span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"</span>
<span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">"x86_64-unknown-linux-gnu"</span>

<span class="c1">; example::square</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@_ZN7example6square17hb32bcde4463f37c3E</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span>
  <span class="nv">%_2.0</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%_2.1</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span> <span class="nv">%_2.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="k">false</span><span class="p">)</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%panic</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb1</span>

<span class="nl">bb1:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%_2.0</span>

<span class="nl">panic:</span>
  <span class="c1">; core::panicking::panic</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span> <span class="vg">@str.0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="m">33</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span> <span class="vg">@alloc_1368addac7d22933d93af2809439e507</span>
  <span class="p">)</span>
  <span class="k">unreachable</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">)</span> <span class="vg">#1</span>
<span class="k">declare</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span> <span class="vg">#2</span>

<span class="c1">; core::panicking::panic</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span><span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#3</span>

<span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"/app/example.rs"</span> <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">1</span>

<span class="vg">@alloc_1368addac7d22933d93af2809439e507</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="err">ptr</span><span class="p">,</span> <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span> <span class="p">&lt;{</span>
    <span class="err">ptr</span> <span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span><span class="p">,</span>
    <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"\0F\00\00\00\00\00\00\00\02\00\00\00\03\00\00\00"</span>
  <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">8</span>

<span class="vg">@str.0</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">33</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"attempt to multiply with overflow"</span>

<span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#1</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">speculatable</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#2</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#3</span> <span class="p">=</span> <span class="p">{</span> <span class="k">cold</span> <span class="k">noinline</span> <span class="k">noreturn</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The main function is <code class="language-plaintext highlighter-rouge">@_ZN7example6square17hb32bcde4463f37c3E</code>, which is the mangled name of <code class="language-plaintext highlighter-rouge">example::square</code>. Because this code was compiled in debug mode, overflow panics, so we need to generate code for that. The first operation is a <code class="language-plaintext highlighter-rouge">call</code> to the LLVM intrinsic for “multiply and tell us if it overflowed”. This returns the equivalent of a <code class="language-plaintext highlighter-rouge">(i32, bool)</code>; we extract both value out of it with <code class="language-plaintext highlighter-rouge">extractvalue</code>. We then pass the bool through <code class="language-plaintext highlighter-rouge">@llvm.expect</code>, which is used to tell the optimizer to treat the panicking branch as “cold”. The success branch goes to a return, which returns the product; otherwise, we go to a function that calls <code class="language-plaintext highlighter-rouge">core::panicking::panic()</code> to panic the current thread. This function never returns, so we can terminate the block with an <code class="language-plaintext highlighter-rouge">unreachable</code>.</p> <p>The rest of the file consists of:</p> <ul> <li><code class="language-plaintext highlighter-rouge">declare</code>s for the llvm intrinsics we used.</li> <li>A <code class="language-plaintext highlighter-rouge">declare</code> for <code class="language-plaintext highlighter-rouge">core::panicking::panic</code>. Any external function we call needs to be <code class="language-plaintext highlighter-rouge">declare</code>d. This also gives us a place to hang attributes for the function off of.</li> <li>Global constants for a <code class="language-plaintext highlighter-rouge">core::panic::Location</code> and a panic message.</li> <li>Attributes for the functions above.</li> </ul> <p>This is a good place to mention attributes: LLVM has all kinds of attributes that can be placed on functions (and function calls) to record optimization-relevant information. For example, <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code> is annotated as <code class="language-plaintext highlighter-rouge">willreturn</code>, which means this function will eventually return; this means that, for example, any UB that comes after the function is guaranteed to occur after finite time, so LLVM can conclude that the code is unreachable despite the call to <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code>. The full set of attributes is vast, but the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> documents all of them!</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>LLVM IR is huge, bigger than any individual ISA, because it is intended to capture <em>every</em> interesting operation. It also has a rich annotation language, so passes can record information for future passes to make use of. Its operational semantics attempt to leave enough space for optimizations to occur, while ensuring that multiple sound optimizations in sequence are not unsound (this last part is a work in progress).</p> <p>Being able to read assembly reveals what will happen, exactly, when code is executed, but reading IR, before and after optimization, shows how the compiler is <em>thinking</em> about your code. Using <code class="language-plaintext highlighter-rouge">opt</code> to run individual optimization passes can also help further this understanding (in fact, “bisecting on passes” is a powerful debugging technique in compiler development).</p> <p>I got into compilers by reading LLVM IR. Hopefully this article inspires you to learn more, too!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:numeric-names" role="doc-endnote"> <p>Registers within a function may have a numeric name. They must be defined in order: you must define <code class="language-plaintext highlighter-rouge">%0</code> (either as a register or a label), then <code class="language-plaintext highlighter-rouge">%1</code>, then <code class="language-plaintext highlighter-rouge">%2</code>, etc. These are often used to represent “temporary results”.</p> <p>If a function does not specify names for its parameters, they will be given the names <code class="language-plaintext highlighter-rouge">%0</code>, <code class="language-plaintext highlighter-rouge">%1</code>, etc implicitly, which affect what the first explicit numeric register name you can use is. Similarly, if the function does not start with a label, it will be implicitly be given the next numeric name.</p> <p>This can result in significant confusion, because if we have <code class="language-plaintext highlighter-rouge">define void @foo(i32, i32) { ... }</code>, the arguments will be <code class="language-plaintext highlighter-rouge">%0</code> and <code class="language-plaintext highlighter-rouge">%1</code>, but if we tried to write <code class="language-plaintext highlighter-rouge">%2 = add i32 %0, %1</code>, we would get an extremely confusing parser error, because <code class="language-plaintext highlighter-rouge">%2</code> is already taken as the name of the first block. <a href="#fnref:numeric-names" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:divz" role="doc-endnote"> <p>For some reason, the optimizer can’t figure out that the <code class="language-plaintext highlighter-rouge">select</code> is redundant? Alive2 (an SMT-solver correctness checker for optimizations) <a href="https://alive2.llvm.org/ce/z/7nLDRe">seems to agree</a> this is a valid optimization.</p> <p><a href="https://github.com/llvm/llvm-project/issues/64240">So I’ve filed a bug.</a> :D <a href="#fnref:divz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:br-on-real-machines" role="doc-endnote"> <p>If you read my assembly article, you’ll recall that there are many branch instructions. On RV, we have <code class="language-plaintext highlighter-rouge">beq</code>, <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">bgt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>. Later on in the compilation process, after the optimizer runs, LLVM will perform <em>instruction selection</em> (isel) to choose the best machine instruction(s) to implement a particular LLVM instruction (or sequence), which is highly context-dependent: for example, we want to fuse an <code class="language-plaintext highlighter-rouge">icmp eq</code> followed by a <code class="language-plaintext highlighter-rouge">br</code> on the result into a <code class="language-plaintext highlighter-rouge">beq</code>.</p> <p>Isel is far outside my wheelhouse, and doing it efficiently and profitably is an active area of academic research. <a href="#fnref:br-on-real-machines" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:frontend-optimization" role="doc-endnote"> <p>Not exactly the same: language frontends like Clang and Rust will perform their own optimizations. For example, I have an <a href="https://github.com/llvm/llvm-project/issues/59484">open bug</a> for LLVM being unable to convert <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> into <code class="language-plaintext highlighter-rouge">&amp;</code> in some cases; this was never noticed, because Clang performs this optimization while lowering from C/C++ to LLVM, but Rust does not do the equivalent optimization. <a href="#fnref:frontend-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:block-args" role="doc-endnote"> <p>A more intuitive model is used in more modern IRs, like MLIR. In MLIR, you cannot use variables defined in other blocks; instead, each block takes a set of <em>arguments</em>, just like a function call. This is equivalent to <code class="language-plaintext highlighter-rouge">phi</code> instructions, except that now instead of selecting which value we want in the target, each predecessor specifies what it wants to send to the target.</p> <p>If we instead treat each block as having “arguments”, we can rewrite it in the following fantasy syntax where register names are scoped to their block.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">;; Not actual LLVM IR! ;;</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">)</span>

<span class="err">loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="nv">%exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">),</span> <span class="nv">%loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><a href="#fnref:block-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:viz" role="doc-endnote"> <p>What does the CFG look like? LLVM contains “optimization” passes that print the CFG as a file as a <code class="language-plaintext highlighter-rouge">.dot</code> file, which can be rendered with the <code class="language-plaintext highlighter-rouge">dot</code> command. For <code class="language-plaintext highlighter-rouge">@safe_div</code>, we get something like the following.</p> <figure style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/safe_div.svg" alt=""/></p> </figure> <p>This is useful for understanding complex functions. Consider this Rust hex-parsing function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// hex.rs</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">parse_hex</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0u64</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.bytes</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">digit</span> <span class="o">=</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'f'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'F'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'A'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_mul</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_add</span><span class="p">(</span><span class="n">digit</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Then, we can generate our CFG with some shell commands.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>rustc <span class="nt">-O</span> <span class="nt">--crate-type</span> lib <span class="nt">--emit</span> llvm-ir hex.rs
<span class="nv">$ </span>opt <span class="nt">-p</span> dot-cfg <span class="nt">-o</span> /dev/null hex.ll
Writing <span class="s1">'.parse_hex.dot'</span>...
<span class="nv">$ </span>dot <span class="nt">-Tsvg</span> .parse_hex.dot <span class="nt">-o</span> parse_hex.svg</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Shell</div></div></div> <p>The result is this mess.</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex.svg" alt=""/></p> </div> <p>Without optimizations, we get a bigger mess (most optimization passes are various CFG cleanups).</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex_unopt.svg" alt=""/></p> </div> <p>Exercise: try to trace through what each basic block is doing. You will want to open the SVGs in a separate tab to do that. I recommend following the optimized version, since it is much less noisy.</p> <p>Comparing optimized vs. unoptimized is a good way to see how much the compiler does to simplify the stuff the language frontend gives it. At -O0? All allocas. At -O2? No allocas! <a href="#fnref:viz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:typed-pointers" role="doc-endnote"> <p>Once upon a time we had typed pointers, like <code class="language-plaintext highlighter-rouge">i32*</code>. These turned out to generate more problems than they solved, requiring frequent casts in IR in exchange for mediocre type safety. See <a href="https://llvm.org/docs/OpaquePointers.html">https://llvm.org/docs/OpaquePointers.html</a> for a more complete history. <a href="#fnref:typed-pointers" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:sarcasm" role="doc-endnote"> <p>Sarcasm. <a href="#fnref:sarcasm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i2p" role="doc-endnote"> <p>I quietly judge LLVM for having instructions named <code class="language-plaintext highlighter-rouge">inttoptr</code> when <code class="language-plaintext highlighter-rouge">int2ptr</code> just reads so much nicer. <a href="#fnref:i2p" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-05-11 • 2075 words • 17 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/2023/05/11/sam-closures/"> Single Abstract Method Traits </a></h1> </div> <div class="post"> <p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Java gets a bad rap but the core language does have some interesting features in it. A very handy one is an <em>anonymous class</em>.</p> <p>Let’s suppose I want to pass a callback into something. In Java 6, which I grew up on, you did it like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Interface() {...}</code> syntax mints a new class on the spot that implements <code class="language-plaintext highlighter-rouge">Interface</code>. You provide a standard class body between the braces, after the name of the type. You can also do this with a class type too.</p> <p>Now, this is a bit tedious: I need to re-type the signature of the one method. This is fine if I need to implement a bunch of methods, but it’s a little annoying in the one-method case.</p> <p>In Java 8 we got lambdas (syntax: <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>). Java made the interesting choice of not adding a <code class="language-plaintext highlighter-rouge">Function</code> type to be “the type of lambdas”. For a long time I thought this was a weird cop-out but I have since come to regard it as a masterclass in language design.</p> <p>Instead, Java’s lambdas are a sort of syntax sugar over this anonymous class syntax.<sup id="fnref:invokedynamic" role="doc-noteref"><a href="#fn:invokedynamic" class="footnote" rel="footnote">1</a></sup> Instead, you need to assign a lambda to an interface type with a single abstract method, and it will use the body of the lambda to implement that one method.</p> <p>Interfaces compatible with lambdas are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation, which must satisfy the following constraints:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the aforementioned <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts and no GATs.</li> <li>All of its supertraits are <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, or <code class="language-plaintext highlighter-rouge">Sync</code>.</li> </ol> <p>These restrictions are chosen so that we have a shot at actually implementing the entire trait.</p> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, ordinary closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate.</p> <p>None of these traits are SAM, so we can safely allow them to be automatically derived for SAM closures to, under the same rules as for ordinary closures.</p> </blockquote> <p>To request a SAM closure, I will use the tentative syntax of <code class="language-plaintext highlighter-rouge">impl Trait |args| expr</code>. This syntax is unambiguously an expression rather than an <code class="language-plaintext highlighter-rouge">impl</code> item, because a <code class="language-plaintext highlighter-rouge">|</code> cannot appear in a path-in-type, and <code class="language-plaintext highlighter-rouge">impl $path</code> must be followed by <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">where</code>. The precise syntax is unimportant.</p> <p>Applied to the <code class="language-plaintext highlighter-rouge">call_many</code> example above, we get this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="n">Callback</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compiler rewrites this into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">CallbackImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CallbackImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CallbackImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This rewrite can happen relatively early, before we need to infer a type for <code class="language-plaintext highlighter-rouge">x</code>. We also need to verify that this trait’s captures are compatible with an <code class="language-plaintext highlighter-rouge">&amp;self</code> receiver The same rules for when a trait implements <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code> would decide which of the three receiver types the closure is compatible with.</p> <p>Note that SAM closures WOULD NOT implement any <code class="language-plaintext highlighter-rouge">Fn</code> traits.</p> <h3 id="more-complicated-examples"><a href="#more-complicated-examples">More Complicated Examples</a></h3> <p>We are required to name the trait we want but its type parameters can be left up in the air. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Out</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Display</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Out</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// We can infer `T = i32` and `Tr::Out = String`.</span>
<span class="k">let</span> <span class="n">tr</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In general, unspecified parameters and associated types result in inference variables, which are resolved in the same way as the parameters of the <code class="language-plaintext highlighter-rouge">Fn</code> closures are.</p> <p>In fact, we can emulate ordinary closures using SAM closures.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.map</span><span class="p">(</span><span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">_</span> <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that because <code class="language-plaintext highlighter-rouge">Fn</code> and <code class="language-plaintext highlighter-rouge">FnMut</code> have non-trival supertraits we can’t make them out of SAM closures.</p> <p>One application is to completely obsolete <code class="language-plaintext highlighter-rouge">std::iter::from_fn</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">u64</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Copy</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Or, if you need a quick helper implementation of <code class="language-plaintext highlighter-rouge">Debug</code>…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="n">f</span><span class="nf">.debug_list</span><span class="p">()</span>
    <span class="nf">.entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">impl</span> <span class="n">Debug</span> <span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"something something {}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.next_thingy</span><span class="p">())</span>
    <span class="p">})</span>
    <span class="nf">.finish</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are probably additional restrictions we will want to place on the SAM trait, but it’s not immediately clear what the breadth of those are. For example, we probably shouldn’t try to make this work:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">UniversalFactory</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">make</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">UniversalFactory</span> <span class="p">||</span> <span class="p">{</span>
  <span class="c1">// How do I name T so that I can pass it to size_of?</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are definitely clever tricks you <em>can</em> play to make this work, but the benefit seems slim.</p> <h2 id="future-work"><a href="#future-work">Future Work</a></h2> <p>There’s two avenues for how we could extend this concept. The first is straightforward and desireable; the second is probably unimplementable.</p> <h3 id="anonymous-trait-impls"><a href="#anonymous-trait-impls">Anonymous Trait Impls</a></h3> <p>Backing up from the Java equivalent of lambdas, it seems not unreasonable to have a full-fledged expression version of <code class="language-plaintext highlighter-rouge">impl</code> that can make captures.</p> <p>Syntactically, I will use <code class="language-plaintext highlighter-rouge">impl Trait for { ... }</code>. This is currently unambiguous, although I think that making it so that <code class="language-plaintext highlighter-rouge">{</code> cannot start a type is probably a non-starter.</p> <p>Let’s pick something mildly complicated… like <code class="language-plaintext highlighter-rouge">Iterator</code> with an overriden method. Then we might write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">[</span><span class="o">...</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iterator</span> <span class="o">=</span> <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="o">*</span><span class="n">my_list</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">my_list</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The contents of the braces after <code class="language-plaintext highlighter-rouge">for</code> is an item list, except that variables from the outside are available, having the semantics of captures; they are, in effect, accesses of <code class="language-plaintext highlighter-rouge">self</code> without the <code class="language-plaintext highlighter-rouge">self.</code> prefix.</p> <p>Hammering out precisely how this would interact with the self types of the functions in the body seems… complicated. Pretty doable, just fussy. There are also awkward questions about what <code class="language-plaintext highlighter-rouge">Self</code> is here and to what degree you’re allowed to interact with it.</p> <h3 id="trait-inference"><a href="#trait-inference">Trait Inference</a></h3> <p>Suppose that we could instead “just” write <code class="language-plaintext highlighter-rouge">impl |x| x * x</code> and have the compiler figure out what trait we want (to say nothing of making this the default behavior and dropping the leading <code class="language-plaintext highlighter-rouge">impl</code> keyword).</p> <p>This means that I could just write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We get into trouble fast.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <p>Currently, rustc does not have to produce impls “on demand”; the trait solver has a finite set of impls to look at. What we are asking the trait solver to do is to, for certain types, attempt to reify impls based on <em>usage</em>. I.e., I have my opaque closure type <code class="language-plaintext highlighter-rouge">T</code> and I the compiler decided it needed to prove a <code class="language-plaintext highlighter-rouge">T: Foo</code> bound so now it gets to perform type checking to validate whether it has an <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>This seems unimplementable with how the solver currently works. It is not insurmountable! But it would be very hard.</p> <p>It is possible that there are relaxations of this that are not insane to implement, e.g. the <code class="language-plaintext highlighter-rouge">impl ||</code> expression is used to initialize an argument to a function that happens to be generic, so we can steal the bounds off of that type variable and hope it’s SAM. But realistically, this direction is more trouble than its worth.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:invokedynamic" role="doc-endnote"> <p>Except for the part where they are extremely not. Where <code class="language-plaintext highlighter-rouge">new T() {}</code> mints a brand new class and accompanying <code class="language-plaintext highlighter-rouge">.class</code> file, Java lambdas use this complicated machinery from Java 7 to generate method handles on the fly, via the <code class="language-plaintext highlighter-rouge">invokedynamic</code> JVM instruction. This, I’m told, makes them much easier to optimize. <a href="#fnref:invokedynamic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div> <div class="pagination post-footer"> <a class="pagination-item newer" href="https://mcyoung.xyz/page4">&lt; Prev</a> • <a class="pagination-item older" href="https://mcyoung.xyz/page6">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>