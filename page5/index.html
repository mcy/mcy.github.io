<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> • <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/feed"> <img style="height: 0.8em; transform: translate(0.07em, 0.15em);" src="https://mcyoung.xyz/public/images/rss.svg"></a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-12 • 2804 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/12/go-abi/"> Things You Never Wanted To Know About Go Interfaces </a></h1> </div> <div class="post"> <p>Lately I’ve been finding myself writing a bit of Go, and I’ve picked up various fun “layout secrets” that help inform how I write code to minimize hidden allocations, and generally be kind to the optimizer. This article is a series of notes on the topic.</p> <p>This post is about Go implementation details, so they can probably break you at any time if you rely on it. On the other hand, Hyrum’s law is a bitch, so taking your chances may not be that bad. After all, they’re probably never going to be able to properly clean up the mess people made with <code class="language-plaintext highlighter-rouge">//go:linkname</code> with runtime symbols…</p> <p>As with many of my other posts, I’ll assume a basic familiarity with being able to read assembly. I’m using x86 for this post, but it’s worth looking at my <a href="https://mcyoung.xyz//2021/11/09/assembly-1">RISC-V post</a> for a refresher.</p> <h2 id="gc-shapes"><a href="#gc-shapes">GC Shapes</a></h2> <p>The most basic Go-specific concept when it comes to type layouts is the <em>shape</em> of a type. This is an implementation detail of Go’s garbage collector that leaks through the <code class="language-plaintext highlighter-rouge">unsafe</code> package.</p> <p>Like in most native programming languages, every Go type has a size (the number of bytes that type takes up in memory) and an alignment (a power of two that every pointer to that type must be divisible by). Go, like most other languages, requires that size be divisible by the alignment: that is, the size is equal to the stride of an array of that type.</p> <p>The size an alignment of a type can be queried by the intrinsics <a href="https://pkg.go.dev/unsafe#Sizeof"><code class="language-plaintext highlighter-rouge">unsafe.Sizeof</code></a> and <a href="https://pkg.go.dev/unsafe#Alignof"><code class="language-plaintext highlighter-rouge">unsafe.Alignof</code></a>. These are very unwieldy in generic code, so I like to define a couple of helpers<sup id="fnref:constants" role="doc-noteref"><a href="#fn:constants" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Size</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Align</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Together, these two quantities are called the <em>layout</em> of a type (a term common to many native languages). However, the <em>shape</em> of a type also records what pieces thereof contain <em>pointers</em>. This is because memory visible to the GC (such as globals, heap memory, or stack roots) is typed, and the GC needs to know which parts of those types are pointers that it needs to trace through.</p> <p>Because all pointers have the same size and alignment (4 or 8 bytes depending on the system) the pointer words of a type can be represented as a bitset, one bit for every 4 or 8 bytes in the type. This, in fact, is the representation used by the GC<sup id="fnref:gc-programs" role="doc-noteref"><a href="#fn:gc-programs" class="footnote" rel="footnote">2</a></sup>.</p> <p>In particular, this means that whether a field is to be interpreted as an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code> or as a <code class="language-plaintext highlighter-rouge">uintptr</code> is a static property of the type. As we will see when we discuss interfaces, this restriction prevents a few layout optimizations.</p> <h2 id="slices-and-strings"><a href="#slices-and-strings">Slices and Strings</a></h2> <p>Go is very public about the layout of slices and strings. A slice is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">slice</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span>     <span class="o">*</span><span class="n">T</span>
  <span class="nb">len</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">len</code> and <code class="language-plaintext highlighter-rouge">cap</code> are extracted by their eponymous builtins, and <code class="language-plaintext highlighter-rouge">data</code> can be obtained using <code class="language-plaintext highlighter-rouge">unsafe.SliceData</code> (or <code class="language-plaintext highlighter-rouge">&amp;s[0]</code> if the slice is nonempty, but that costs a bounds-check).</p> <p>A string has the same layout as a <code class="language-plaintext highlighter-rouge">[]byte</code>, except for a capacity:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="kt">string</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
  <span class="nb">len</span>  <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Despite essentially being slices, Go treats strings subtly differently. Strings are <code class="language-plaintext highlighter-rouge">comparable</code>, so they can be used as map keys. They are also immutable, which enables a handful of optimizations. Immutability is also why they are <code class="language-plaintext highlighter-rouge">comparable</code>: Go made the mistake of not keeping <code class="language-plaintext highlighter-rouge">const</code> from C, but they really want map keys to be <code class="language-plaintext highlighter-rouge">const</code>.</p> <p>There is nothing stopping us from aliasing strings to data pointed to by a slice: after all, <code class="language-plaintext highlighter-rouge">strings.Builder</code> does it to avoid a copy in <code class="language-plaintext highlighter-rouge">String()</code>. We can implement this easily enough with some <code class="language-plaintext highlighter-rouge">unsafe</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">StringAlias</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Doing this is perfectly safe, so long as data is not mutated while the returned string is accessible. This allows virtually any slice type to be used as a key in a map, with some caveats.</p> <ol> <li> <p>Types which contain alignment padding cannot be used, because Go does not promise that it zeros memory returned by <code class="language-plaintext highlighter-rouge">new</code>.</p> </li> <li> <p>Types which contain pointers will cause those pointers to become unreachable if the only reference is the aliased string; this is because the pointed to data’s shape contains no pointer words.</p> </li> <li> <p>Incomparable types and interfaces will be compared by address (that is, maps, channels and funcs).</p> </li> </ol> <h3 id="dynamic-arrays-with-reflection"><a href="#dynamic-arrays-with-reflection">Dynamic Arrays with Reflection</a></h3> <p>Now, this isn’t the only to accomplish this: you can create dynamically-sized array types using reflection, like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Slice2Array</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span>

  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="n">elem</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">elem</span><span class="p">)</span>

  <span class="c">// NOTE: NewAt will return a reflect.Value containing a</span>
  <span class="c">// pointer, not an array!</span>
  <span class="n">refl</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">NewAt</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
  <span class="n">refl</span> <span class="o">=</span> <span class="n">refl</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span> <span class="c">// Dereference to get a pointer-to-array.</span>
  <span class="k">return</span> <span class="n">refl</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This will return an <code class="language-plaintext highlighter-rouge">any</code> whose type is <code class="language-plaintext highlighter-rouge">[len(s)]T</code>. You can even type assert it for static array sizes. This any is suitable for placing into a <code class="language-plaintext highlighter-rouge">map[any]T</code>, just as if we had built it with e.g. <code class="language-plaintext highlighter-rouge">any([...]byte("foo"))</code></p> <p>However, and this is not at all obvious from the code here, calling <code class="language-plaintext highlighter-rouge">refl.Interface()</code> will perform a copy of the whole array. <code class="language-plaintext highlighter-rouge">Interface()</code> delegates through a few functions until it calls <code class="language-plaintext highlighter-rouge">reflect.packEface()</code>.</p> <p>The code this function (<a href="https://cs.opensource.google/go/go/+/master:src/reflect/value.go;l=119?q=packEface&amp;ss=go%2Fgo">found here</a>) is reproduced below:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">reflect</span>

<span class="c">// packEface converts v to the empty interface.</span>
<span class="k">func</span> <span class="n">packEface</span><span class="p">(</span><span class="n">v</span> <span class="n">Value</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">typ</span><span class="p">()</span>
	<span class="k">var</span> <span class="n">i</span> <span class="n">any</span>
	<span class="n">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">abi</span><span class="o">.</span><span class="n">EmptyInterface</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span>
	<span class="c">// First, fill in the data portion of the interface.</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">t</span><span class="o">.</span><span class="n">IfaceIndir</span><span class="p">()</span><span class="o">:</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">"bad indir"</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c">// Value is indirect, and so is the interface we're making.</span>
		<span class="n">ptr</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagAddr</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">:=</span> <span class="n">unsafe_New</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
			<span class="n">typedmemmove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">c</span>
		<span class="p">}</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">ptr</span>
	<span class="k">case</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">!=</span> <span class="m">0</span><span class="o">:</span>
		<span class="c">// Value is indirect, but interface is direct. We need</span>
		<span class="c">// to load the data at v.ptr into the interface data word.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="c">// Value is direct, and so is the interface.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
	<span class="p">}</span>
	<span class="c">// Now, fill in the type portion. We're very careful here not</span>
	<span class="c">// to have any operation between the e.word and e.typ assignments</span>
	<span class="c">// that would let the garbage collector observe the partially-built</span>
	<span class="c">// interface value.</span>
	<span class="n">e</span><span class="o">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">t</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The switch determines precisely how the interface data pointer is computed. It turns out that (almost all) array types return true for <code class="language-plaintext highlighter-rouge">t.IfaceIndr()</code>, so the first case is selected, which triggers a copy (that being the call to <code class="language-plaintext highlighter-rouge">unsafe_New()</code> followed by a <code class="language-plaintext highlighter-rouge">typedmemmove</code>). This copy is to ensure that the value of the resulting interface cannot be mutated.</p> <p>Now, if only we knew the layout of Go’s interfaces, we might be able to get somewhere here…</p> <h2 id="the-layout-of-gos-interfaces"><a href="#the-layout-of-gos-interfaces">The Layout of Go’s Interfaces</a></h2> <p>Oh, yes, that’s what this article is about. So, if we look at the <code class="language-plaintext highlighter-rouge">runtime2.go</code> file in the runtime (yes, that’s what it’s called), nestled among the giant scheduler types for Gs, Ps, and Ms, we’ll find a couple of structs that really elucidate what’s going on:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">iface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">tab</span>  <span class="o">*</span><span class="n">itab</span>
	<span class="n">data</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">eface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">_type</span> <span class="o">*</span><span class="n">_type</span>
	<span class="n">data</span>  <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">funcval</code> is the layout of a <code class="language-plaintext highlighter-rouge">func()</code>, more on that later. <code class="language-plaintext highlighter-rouge">iface</code> is the layout of your “usual” interface, consisting of an <code class="language-plaintext highlighter-rouge">itab</code> (an interface table, or what Go calls a vtable) and a pointer to some data. <code class="language-plaintext highlighter-rouge">eface</code> is the layout of <code class="language-plaintext highlighter-rouge">any</code> (the artist formerly known as <code class="language-plaintext highlighter-rouge">interface{}</code>, hence the name: <em>e</em>mpty inter<em>face</em>).</p> <p><code class="language-plaintext highlighter-rouge">eface</code> having its own layout is an optimization. Because <code class="language-plaintext highlighter-rouge">any</code> exists to be downcast from dynamically, storing the type directly cuts out a pointer load when doing a type switch on an <code class="language-plaintext highlighter-rouge">any</code> specifically. If we look at what an <code class="language-plaintext highlighter-rouge">itab</code> is (which is “just” an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/iface.go;l=14"><code class="language-plaintext highlighter-rouge">abi.ITab</code></a>):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="c">// The first word of every non-empty interface type contains an *ITab.</span>
<span class="c">// It records the underlying concrete type (Type), the interface type</span>
<span class="c">// it is implementing (Inter), and some ancillary information.</span>
<span class="c">//</span>
<span class="c">// allocated in non-garbage-collected memory</span>
<span class="k">type</span> <span class="n">ITab</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Inter</span> <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">Type</span>  <span class="o">*</span><span class="n">Type</span>
	<span class="n">Hash</span>  <span class="kt">uint32</span>     <span class="c">// copy of Type.Hash. Used for type switches.</span>
	<span class="n">Fun</span>   <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c">// fun[0]==0 means Type does not implement Inter.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <h3 id="codegen-for-interface-operations"><a href="#codegen-for-interface-operations">Codegen for Interface Operations</a></h3> <p>An <code class="language-plaintext highlighter-rouge">ITab</code> contains the same type it would have as an <code class="language-plaintext highlighter-rouge">any</code>, which makes the generated code for a function that upcasts an interface to <code class="language-plaintext highlighter-rouge">any</code> very simple<sup id="fnref:asm" role="doc-noteref"><a href="#fn:asm" class="footnote" rel="footnote">3</a></sup>:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Upcast</span><span class="p">(</span><span class="n">i</span> <span class="n">MyIface</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">F</span><span class="o">:</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>In the register ABI, the x86 argument (and return) registers are <code class="language-plaintext highlighter-rouge">rax</code>, <code class="language-plaintext highlighter-rouge">rbx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, <code class="language-plaintext highlighter-rouge">r10</code> and <code class="language-plaintext highlighter-rouge">r11</code> (with <code class="language-plaintext highlighter-rouge">rdx</code> reserved for passing a closure capture, more on that later; <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the currently running G).</p> <p>The <code class="language-plaintext highlighter-rouge">*ITab</code> comes in on <code class="language-plaintext highlighter-rouge">rax</code> and the data pointer on <code class="language-plaintext highlighter-rouge">rbx</code>. First, we need to check if this is the nil interface, identified by having a nil itab (or type, in the case of <code class="language-plaintext highlighter-rouge">any</code>). If it is nil, we just return: <code class="language-plaintext highlighter-rouge">rax:rbx</code> already contain the data of a nil <code class="language-plaintext highlighter-rouge">any</code>. Otherwise, we load <code class="language-plaintext highlighter-rouge">ITab.Type</code>, at offset 8, into <code class="language-plaintext highlighter-rouge">rax</code>, and return.</p> <p>How do interface function calls work?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span><span class="n">m</span> <span class="n">MyIface</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">Method</span><span class="p">(</span><span class="m">42</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rsp</span><span class="p">,</span> <span class="n">rbp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="mi">42</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="n">nop</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">morestack_noctxt</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>This function seems to be doing a lot more than it actually is. Part of it is that its prologue has to do a call to <code class="language-plaintext highlighter-rouge">runtime.morestack_noctxt()</code>, which is simply a call to <code class="language-plaintext highlighter-rouge">runtime.morestack</code> that clobbers <code class="language-plaintext highlighter-rouge">rdx</code>, the closure capture parameter. The meat of it comes when it loads <code class="language-plaintext highlighter-rouge">[rax + 24]</code>, the first element of <code class="language-plaintext highlighter-rouge">ITab.Fun</code>. It then moves the data pointer in <code class="language-plaintext highlighter-rouge">rbx</code> to <code class="language-plaintext highlighter-rouge">rax</code>, the argument into <code class="language-plaintext highlighter-rouge">rbx</code>, and issues the call.</p> <p>What about upcasts? An upcast to a concrete type is quite simple: simply compare the type in the interface (either directly or in the <code class="language-plaintext highlighter-rouge">*ITab</code>) to a particular statically-known one. Downcasting to an interface (sometimes called a <em>sidecast</em>) is much more complicated, because it essentially requires a little bit of reflection.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Downcast</span><span class="p">(</span><span class="n">m</span> <span class="n">any</span><span class="p">)</span> <span class="n">MyIface</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="p">(</span><span class="n">MyIface</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">hashProbe</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rsi</span>
    <span class="n">and</span>     <span class="n">rsi</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">shl</span>     <span class="n">rsi</span><span class="p">,</span> <span class="mi">4</span>
    <span class="n">mov</span>     <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jeq</span>     <span class="n">found</span>
    <span class="n">lea</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">test</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jnz</span>     <span class="n">hashProbe</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">leq</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">typeAssert</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">done</span>
<span class="n">found</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">done</span><span class="o">:</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="n">foo</span><span class="p">.</span><span class="n">MyIface</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicnildottype</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as it was in foo.Call above.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>When we request an interface downcast, the Go compiler synthesizes a symbol of type <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code>. Its definition is reproduced below.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="k">type</span> <span class="n">TypeAssert</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Cache</span>   <span class="o">*</span><span class="n">TypeAssertCache</span>
	<span class="n">Inter</span>   <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">CanFail</span> <span class="kt">bool</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCache</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Mask</span>    <span class="kt">uintptr</span>
	<span class="n">Entries</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="n">TypeAssertCacheEntry</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCacheEntry</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// type of source value (a *runtime._type)</span>
	<span class="n">Typ</span> <span class="kt">uintptr</span>
	<span class="c">// itab to use for result (a *runtime.itab)</span>
	<span class="c">// nil if CanFail is set and conversion would fail.</span>
	<span class="n">Itab</span> <span class="kt">uintptr</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The first thing this function does is check if <code class="language-plaintext highlighter-rouge">rax</code> contains 0, i.e., if this is a nil <code class="language-plaintext highlighter-rouge">any</code>, and panics if that’s the case (that’s a call to <code class="language-plaintext highlighter-rouge">runtime.panicnildottype</code>). It then loads <code class="language-plaintext highlighter-rouge">foo..typeAssert0</code>, a synthetic global variable containing an <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code> value. It loads the <code class="language-plaintext highlighter-rouge">Cache</code> field, as well as the <code class="language-plaintext highlighter-rouge">Hash</code> field of the <code class="language-plaintext highlighter-rouge">abi.Type</code> attached to the <code class="language-plaintext highlighter-rouge">any</code>. It masks off the low bits using <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Mask</code>, and uses that to start probing the very simple open-addressed hash table located in <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Entries</code>.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with the type we’re looking for (compared by address), we’ve found it. We load that entry’s <code class="language-plaintext highlighter-rouge">Itab</code> value into <code class="language-plaintext highlighter-rouge">rax</code> to change the value from being an <code class="language-plaintext highlighter-rouge">any</code> to being a <code class="language-plaintext highlighter-rouge">MyIface</code>, and we’re done.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with a nil <code class="language-plaintext highlighter-rouge">Typ</code> pointer, we’re forced to hit the slow path, implemented at <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code>. This dynamically builds an itab by searching the method set of the type inside the <code class="language-plaintext highlighter-rouge">any</code>.</p> <p>This then calls the reflection code in <code class="language-plaintext highlighter-rouge">runtime.getitab()</code>, which is what actually performs the messy search through the method set, comparing the names and signatures of methods with those in the interface, to produce an itab at runtime.</p> <p>Then, it shoves this the resulting itab into the global itab cache, which is protected by a global lock! There are lots of scary atomics in this code. There are many places where this can potentially panic, bubbling up a type assertion failure to the user.</p> <p>When <code class="language-plaintext highlighter-rouge">runtime.getitab()</code> returns, <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code> will <em>maybe</em><sup id="fnref:maybe-update" role="doc-noteref"><a href="#fn:maybe-update" class="footnote" rel="footnote">4</a></sup> update the type assertion cache, and return the new itab. This allows the code in our function to return directly, without needing to take another trip into the <code class="language-plaintext highlighter-rouge">hashProbe</code> loop.</p> <p>In theory, PGO could be used to pre-fill the cache, but I couldn’t find any code in the compiler that indicates that this is something they do. In the meantime, you can optimize a hot type assert ahead of time by asserting to a known common type:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">rs</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span>
  <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Check for a known implementation first. This only costs</span>
    <span class="c">// a pointer comparison with the *abi.Type in the itab.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Do an interface type assertion. This would eventually</span>
    <span class="c">// learn os.File, but the branch above skips that "warmup"</span>
    <span class="c">// time. It also lets the hardware branch predictor allocate</span>
    <span class="c">// a prediction slot just for os.File.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// ...</span>
  <span class="p">}</span>
<span class="p">}</span> </code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Type switches, incidentally, use a very similar caching mechanism for switches that include interface types among the cases.</p> <h3 id="what-was-that-about-indirect-interfaces"><a href="#what-was-that-about-indirect-interfaces">What Was That About Indirect Interfaces?</a></h3> <p>Back when we were hacking arrays into existence with reflection, there was some trouble in <code class="language-plaintext highlighter-rouge">reflect.Value.Interface()</code>, where it would do a seemingly unnecessary copy.</p> <p>This is because an interface’s data pointer must be a pointer. If you cram, say, an <code class="language-plaintext highlighter-rouge">int</code> into an <code class="language-plaintext highlighter-rouge">any</code>, Go will spill it to the heap. This is often called <em>boxing</em>, but the Go runtime refers to it as an “indirect interface”.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">push</span>     <span class="n">rbp</span>
  <span class="n">mov</span>      <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
  <span class="n">call</span>     <span class="n">runtime</span><span class="p">.</span><span class="n">convT64</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">pop</span>      <span class="n">rbp</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Like many other managed languages, Go will skip boxing very small values by instead returning pointers into some global array.</p> <p>Now, this boxing could be avoided: after all, an <code class="language-plaintext highlighter-rouge">int</code> is no larger than a pointer, so we could cram it into the data pointer field directly. However, the GC <em>really</em> doesn’t like that: the GC assumes it can trace through any pointer. Now, the GC <em>could</em> treat interfaces differently, and look at the type/itab pointer to determine if the data value pointer or a scalar. However, this would add significant complexity to both the representation of shapes, and to the tracing code in the GC, resulting in more branches and slower tracing.</p> <p>However, if the type being wrapped in an interface happens to be a pointer, it can just use that pointer value directly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Any type that has the same shape as a pointer will be indirect. This includes maps, channels, and funcs. It also includes one element arrays of such types, such as <code class="language-plaintext highlighter-rouge">[1]*int</code> and <code class="language-plaintext highlighter-rouge">[1]chan error</code>, and single-field structs of such types. Curiously, this does not include structs which contain a zero-sized field before the pointer-sized field, even though those have the same shape as a pointer.</p> <p>This means it’s generally not safe to play games with forging an interface out of a pointer to some type: whether that type is indirect in an interface is a subtle implementation detail of the compiler.</p> <p>And of course, it’s important to remember that if you want to return a value by interface, you had best hope it can get inlined, so the compiler can promote the heap allocation to the stack.</p> <h2 id="function-pointers"><a href="#function-pointers">Function Pointers</a></h2> <p>The last thing to look at are Go’s function pointers. For the longest time, I assumed they had the same layout as an interface: a pointer to closure data, and a hardware function pointer.</p> <p>It turns out the layout is weirder: let’s revisit the <code class="language-plaintext highlighter-rouge">runtime.funcval</code> we found in <code class="language-plaintext highlighter-rouge">runtime2.go</code> earlier.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This unusual layout is best understood by looking at the generated assembly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span>
  <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span>
  <span class="n">x</span> <span class="kt">int</span><span class="p">,</span>
<span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>To call <code class="language-plaintext highlighter-rouge">f</code>, first we interpret it as a <code class="language-plaintext highlighter-rouge">*funcval</code> and load <code class="language-plaintext highlighter-rouge">f.fn</code> into a temporary. That is, the first word pointed to by <code class="language-plaintext highlighter-rouge">rax</code> (which holds <code class="language-plaintext highlighter-rouge">f</code> on function entry). Then, we place <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">rdx</code>, the closure context register. The reason for using this extra magic register will become clear shorter. Then, we arrange the rest of the arguments in their usual registers, and we jump to the address stored in <code class="language-plaintext highlighter-rouge">f.fn</code>.</p> <p>Inside of <code class="language-plaintext highlighter-rouge">f</code>, captures are accessed by offsetting from <code class="language-plaintext highlighter-rouge">rdx</code>. What does one of those closures look like?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">imul</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rcx</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>All <code class="language-plaintext highlighter-rouge">Capture</code> is doing is allocating a <code class="language-plaintext highlighter-rouge">funcval</code> with a single <code class="language-plaintext highlighter-rouge">int</code> capture; that’s the <code class="language-plaintext highlighter-rouge">{ F uintptr; X0 int }</code> in the code above. It then places the address of <code class="language-plaintext highlighter-rouge">Capture.func1</code>, which implements the callback, into <code class="language-plaintext highlighter-rouge">F</code>, and the argument of <code class="language-plaintext highlighter-rouge">Capture</code> into <code class="language-plaintext highlighter-rouge">X0</code>.</p> <p>What about when returning a reference to a function? In that case, all that happens is it returns a reference to a global containing the address of the function.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Id</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Id</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="p">]</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="o">:</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="o">:</span>
    <span class="p">.</span><span class="n">quad</span> <span class="n">foo</span><span class="p">.</span><span class="n">Id</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Because we pass the closure arguments in an extra register not used by regular functions, we don’t need to create a thunk for this case.</p> <p>Unfortunately, we do need to create a thunk for methods, even methods with a pointer receiver. This is because of the following incompatible constraints:</p> <ol> <li> <p>The receiver pointer for a method must point exactly to the value the method is called on. It can’t be a fixed offset before, because that would create an out-of-bounds pointer, which the GC does not tolerate.</p> </li> <li> <p>The closure pointer must point to the start of the funcval, <em>not</em> its captures, because adjusting the pointer to point to the captures would cause it to point one-past-the-end of a value, which the GC <em>also</em> does not tolerate!</p> </li> </ol> <p>Thus, <em>even</em> if methods accepted a pointer receiver via <code class="language-plaintext highlighter-rouge">rdx</code>, closures and methods disagree about where that pointer should be passed.</p> <p>Of course, there are adjustments we can make to fix this problem. For example, we could require that all <code class="language-plaintext highlighter-rouge">funcval</code> values have at least one capture. No-capture <code class="language-plaintext highlighter-rouge">funcvals</code> would have a synthetic <code class="language-plaintext highlighter-rouge">_ byte</code> field. This is not unlike how a non-empty struct whose final field is empty will be padded with an extra <code class="language-plaintext highlighter-rouge">_ byte</code> field: this is specifically to avoid a pointer to that field being a past-the-end pointer. The cost is that every non-capturing closure costs twice as much binary size.</p> <p>Another fix is to make the GC blind to the pointer in <code class="language-plaintext highlighter-rouge">rdx</code>. This will never be the only pointer by which a value is reachable, so it would be safe to replace <code class="language-plaintext highlighter-rouge">mov rdx, rax</code> with a <code class="language-plaintext highlighter-rouge">lea rdx, [rax + 8]</code>. The GC would never know!</p> <p>Until then, beware that writing <code class="language-plaintext highlighter-rouge">return foo.Method</code> secretly allocates 16 bytes or so. (Aside: I used to sit next to the Go team at Google, and I remember having a conversation with Austin Clements about this. Apparently I misremembered, because until recently I thought Go already implemented this optimization!)</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>If you made it this far this is probably you right now:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/stickers/dizzy.png" alt="Miguel as a Whimsicott, dizzy with register names."/></p> </figure> <p>This isn’t intended to be as polished as most of my articles, but there’s been enough things I’ve come across that I wanted to write this all up for my own reference.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:constants" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Sizeof</code> and <code class="language-plaintext highlighter-rouge">Alignof</code> are intrinsics, so the compiler will turn them into constants. However, they are only constants if the type being measured is not generic, so wrapping them in a function like this doesn’t actually hurt in generic code. <a href="#fnref:constants" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:gc-programs" role="doc-endnote"> <p>Except for very large types that would have more words than can be recorded by an array of size <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/type.go;l=803;bpv=0"><code class="language-plaintext highlighter-rouge">abi.MaxPtrmaskBytes</code></a>. For larger types, we use GC programs! A GC program is an LZ-compressed bitset serving the same purpose as the pointer bitset most smaller types use. See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/cmd/internal/gcprog/gcprog.go">gcprog.go</a>.</p> <p>In fact, <code class="language-plaintext highlighter-rouge">reflection</code> knows how to create programs on the fly for most types! See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/reflect/type.go;l=2658">reflect/type.go</a>. <a href="#fnref:gc-programs" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:asm" role="doc-endnote"> <p>I will be writing assembly examples in Intel-syntax x86. Go’s assembly syntax is horrible and an impediment to the point I’m making. <a href="#fnref:asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:maybe-update" role="doc-endnote"> <p>Maybe? Well, the cache will only get updated about 0.1% of the time. This is to amortize the costs of growing the cache. I assume they benchmarked this, and found that the cost of growing the cache makes it only worthwhile when that assertion is getting hammered. <a href="#fnref:maybe-update" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-10 • 2588 words • 21 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> • <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> </span> <h1><a href="/2024/12/10/json-sucks/"> Nobody Gets Fired for Picking JSON, but Maybe They Should? </a></h1> </div> <div class="post"> <p>JSON is extremely popular but deeply flawed. This article discusses the details of JSON’s design, how it’s used (and misused), and how seemingly helpful “human readability” features cause headaches instead. Crucially, you rarely find JSON-based tools (except dedicated tools like <code class="language-plaintext highlighter-rouge">jq</code>) that can safely handle arbitrary JSON documents without a schema—common corner cases can lead to data corruption!</p> <h2 id="what-is-json"><a href="#what-is-json">What is JSON?</a></h2> <p>JSON is famously simple. In fact, you can <a href="https://www.flickr.com/photos/equanimity/3763158824/in/photostream/">fit the entire grammar on the back of a business card</a>. It’s so omnipresent in REST APIs that you might assume you already know JSON quite well. It has decimal numbers, quoted strings, arrays with square brackets, and key-value maps (called “objects”) with curly braces. A JSON document consists of any of these constructs: <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">42</code>, and <code class="language-plaintext highlighter-rouge">{"foo":"bar"}</code> are all valid JSON documents.</p> <p>However, the formal definition of JSON is quite complicated. JSON is defined by the IETF document <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC8259</a> (if you don’t know what the IETF is, it’s the standards body for Internet protocols). However, it’s <em>also</em> normatively defined by <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a>, which is from ECMA, the standards body that defines JavaScript[^json.org].</p> <p>[^json.org]: Of course, some wise guy will probably want to cite <json.org>. I should underscore: <json.org> is __NOT__ a standard. It is __NOT__ normative. the documents produced by the IETF and by ECMA, which are international standards organizations that represent the industry __ARE__ normative. When a browser implementer wants to implement JSON to the letter, they go to ECMA, not to some dude's 90's ass website.</json.org></json.org></p> <p>JavaScript? Yes, JSON (JavaScript Object Notation) is closely linked with JavaScript and is, in fact, (almost) a subset of it. While JSON’s JavaScript ancestry is the main source of its quirks, several other poor design decisions add additional unforced errors.</p> <p>However, the biggest problem with JSON isn’t any specific design decision but rather the incredible diversity of parser behavior and non-conformance across and within language ecosystems. RFC8259 goes out of its way to call this out:</p> <blockquote> <p>Note, however, that ECMA-404 allows several practices that this specification recommends avoiding in the interests of maximal interoperability.</p> </blockquote> <p>The RFC makes many observations regarding interoperability elsewhere in the document. Probably the most glaring—and terrifying—is how numbers work.</p> <h2 id="everything-is-implementation-defined"><a href="#everything-is-implementation-defined">Everything is Implementation-Defined</a></h2> <p>JSON numbers are encoded in decimal, with an optional minus sign, a fractional part after a decimal point, and a scientific notation exponent. This is similar to how many programming languages define their own numeric literals.</p> <p>Presumably, JSON numbers are meant to be floats, right?</p> <p>Wrong.</p> <p>RFC8259 reveals that the answer is, unfortunately, “whatever you want.”</p> <blockquote> <p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">binary64</code> is the “standards-ese” name for the type usually known as <code class="language-plaintext highlighter-rouge">double</code> or <code class="language-plaintext highlighter-rouge">float64</code>. Floats have great dynamic range but often can’t represent exact values. For example, <code class="language-plaintext highlighter-rouge">1.1</code> isn’t representable as a float because all floats are fractions of the form <code class="language-plaintext highlighter-rouge">n / 2^m</code> for integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code>, but <code class="language-plaintext highlighter-rouge">1.1 = 11/10</code>, which has a factor of 5 in its denominator. The closest <code class="language-plaintext highlighter-rouge">float64</code> value is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">2476979795053773 / 2^51 = 1.100000000000000088817841970012523233890533447265625</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Of course, you might think to declare “all JSON values map to their closest <code class="language-plaintext highlighter-rouge">float64</code> value”. Unfortunately, this value might not be unique. For example, the value <code class="language-plaintext highlighter-rouge">900000000000.00006103515625</code> isn’t representable as a <code class="language-plaintext highlighter-rouge">float64</code>, and it’s precisely between two exact <code class="language-plaintext highlighter-rouge">float64</code> values. Depending on the rounding mode, this rounds to either or <code class="language-plaintext highlighter-rouge">900000000000</code> or <code class="language-plaintext highlighter-rouge">900000000000.0001220703125</code> .</p> <p>IEEE 754 recommends “round ties to even” as the default rounding mode, so for almost all software, the result is <code class="language-plaintext highlighter-rouge">900000000000</code>. But remember, floating-point state is a global variable implemented in hardware, and might just happen to be clobbered by some dependency that calls <code class="language-plaintext highlighter-rouge">fesetround()</code> or a similar system function.</p> <h2 id="data-loss-data-loss"><a href="#data-loss-data-loss">Data Loss! Data Loss!</a></h2> <p>You’re probably thinking, “I don’t care about such fussy precision stuff. None of my numbers have any fractional parts—and there is where you would be wrong. The <code class="language-plaintext highlighter-rouge">n</code> part of <code class="language-plaintext highlighter-rouge">n / 2^m</code> only has 53 bits available, but <code class="language-plaintext highlighter-rouge">int64</code> values fall outside of that range. This means that for very large 64-bit integers, such as randomly generated IDs, a JSON parser that converts integers into floats results in <em>data loss.</em> Go’s <code class="language-plaintext highlighter-rouge">encoding/json</code> package does this, for example.</p> <p>How often does this actually happen for randomly-generated numbers? We can do a little Monte Carlo simulation to find out.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
	<span class="s">"math/big"</span>
	<span class="s">"math/rand"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">trials</span> <span class="o">=</span> <span class="m">5</span><span class="n">_000_000</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">misses</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">err</span> <span class="n">big</span><span class="o">.</span><span class="n">Float</span>
	<span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
		<span class="n">y</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c">// Round-trip through binary64.</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
			<span class="n">misses</span><span class="o">++</span>
			<span class="n">err</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span><span class="o">.</span><span class="n">Quo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">trials</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"misses: %d/%d, avg: %f"</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">trials</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// misses: 4970572/5000000, avg: 170.638499</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>It turns out that almost all randomly distributed <code class="language-plaintext highlighter-rouge">int64</code> values are affected by round-trip data loss. Roughly, the only numbers that are safe are those with at most 16 digits (although not exactly: 9,999,999,999,999,999, for example, gets rounded up to a nice round 10 quadrillion).</p> <p>How does this affect you? Suppose you have a JSON document somewhere that includes a user ID and a transcript of their private messages with another user. Data loss due to rounding would result in the wrong user ID being associated with the private messages, which could result in leaking PII or incorrect management of privacy consent (such as GDPR requirements).</p> <p>This isn’t just about <em>your</em> user IDs, mind you. Plenty of other vendors’ IDs are nice big integers, which the JSON grammar can technically accommodate and which random tools will mangle. Some examples:</p> <ul> <li> <p>License keys: for example, Adobe uses 24 digits for <a href="https://helpx.adobe.com/x-productkb/global/invalid-revoked-serial-numbers.html">their serial numbers</a>, which may be tempting to store as an integer.</p> </li> <li> <p>Barcode IDs like the unique serial numbers of medical devices, <a href="https://www.fda.gov/medical-devices/unique-device-identification-system-udi-system/udi-basics">which are tightly regulated</a>.</p> </li> <li> <p>Visa and Mastercard credit card numbers <em>happen</em> to fit in the “safe” range for <code class="language-plaintext highlighter-rouge">binary64</code> , which may lull you into a false sense of security, since they’re so common. But not all credit cards have 16 digit numbers: <a href="https://en.wikipedia.org/wiki/Payment_card_number#Structure">some now support 19</a>.</p> </li> </ul> <p>These are pretty bad compliance consequences purely due to a data serialization format.</p> <p>This problem is avoidable with care. After all, Go can parse JSON into any arbitrary type using reflection. For example, if we replace the inner loop of the Monte Carlo simulation with something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
	<span class="k">var</span> <span class="n">v</span> <span class="k">struct</span><span class="p">{</span> <span class="n">N</span> <span class="kt">int64</span> <span class="p">}</span>
	<span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">`{"N":%d}`</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
	<span class="n">y</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">N</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
		<span class="c">// ...</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>We suddenly see that <code class="language-plaintext highlighter-rouge">x == y</code> in every trial. This is because with type information, Go’s JSON library knows exactly what the target precision is. If we were parsing to an <code class="language-plaintext highlighter-rouge">any</code> instead of to a <code class="language-plaintext highlighter-rouge">struct { N int64 }</code>, we’d be in deep trouble: the outer object would be parsed into a <code class="language-plaintext highlighter-rouge">map[string]any</code>, and the <code class="language-plaintext highlighter-rouge">N</code> field would become a <code class="language-plaintext highlighter-rouge">float64</code>.</p> <p>This means that your system probably can’t safely handle JSON documents with unknown fields. Tools like <code class="language-plaintext highlighter-rouge">jq</code> must be extremely careful about number handling to avoid data loss. This is an easy mistake for third-party tools to make.</p> <p>But again, <code class="language-plaintext highlighter-rouge">float64</code> isn’t the standard—there is no standard. Some implementations might only have 32-bit floats available, making the problem worse. Some implementations might try to be clever, using a <code class="language-plaintext highlighter-rouge">float64</code> for fractional values and an <code class="language-plaintext highlighter-rouge">int64</code> for integer values; however, this still imposes arbitrary limits on the parsed values, potentially resulting in data loss.</p> <p>Some implementations such as Python use bignums, so they appear not to have this problem. However, this can lead to a false sense of security where issues are not caught until it’s too late: some database now contains ostensibly valid but non-interoperable JSON.</p> <p>Protobuf is forced to deal with this in a pretty non-portable way. To avoid data loss, large 64-bit integers are serialized as quoted strings when serializing to JSON. So, instead of writing <code class="language-plaintext highlighter-rouge">{"foo":6574404881820635023}</code>, it emits <code class="language-plaintext highlighter-rouge">{"foo":"6574404881820635023"}</code>. This solves the data loss issue but does not work with other JSON libraries such as Go’s, producing errors like this one:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">json: cannot unmarshal string into Go struct field .N of type int64</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <h3 id="non-finite-values"><a href="#non-finite-values">Non-Finite Values</a></h3> <p>The special floating point values <code class="language-plaintext highlighter-rouge">Infinity</code>, <code class="language-plaintext highlighter-rouge">-Infinity</code>, and <code class="language-plaintext highlighter-rouge">NaN</code> are not representable: it’s the wild west as to what happens when you try to serialize the equivalent of <code class="language-plaintext highlighter-rouge">{x:1.0/0.0}</code>.</p> <ul> <li>Go refuses to serialize, citing <code class="language-plaintext highlighter-rouge">json: unsupported value: +Inf</code>.</li> <li>Protobuf serializes it as <code class="language-plaintext highlighter-rouge">{"x":"inf"}</code> (or should—it’s unclear which implementations get it right).</li> <li>JavaScript won’t even bother trying: <code class="language-plaintext highlighter-rouge">JSON.stringify({x:Infinity})</code> prints <code class="language-plaintext highlighter-rouge">{"x":null}.</code></li> <li>Python is arguably the worst offender: <code class="language-plaintext highlighter-rouge">json.dumps({"x":float("inf")})</code> prints <code class="language-plaintext highlighter-rouge">{"x":Infinity}</code>, which isn’t even valid JSON per RFC8259.</li> </ul> <p>NaN is arguably an even worse offender, because the NaN payload (yes, <a href="https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns">NaNs have a special payload</a>) is discarded when converting to <code class="language-plaintext highlighter-rouge">"nan"</code> or however your library represents it.</p> <p>Does this affect you? Well, if you’re doing anything with floats, you’re one division-by-zero or overflow away from triggering serialization errors. At best, it’s “benign” data corruption (JavaScript). At worst, when the data is partially user-controlled, it might result in crashes or unparseable output, which is the making of a DoS vector.</p> <p>In comparison, Protobuf serialization can’t fail except due to non-UTF-8 <code class="language-plaintext highlighter-rouge">string</code> fields or cyclic message references, both of which are comparatively unlikely to a NaN popping up in a calculation.</p> <p>The upshot is that all the parsers end up parsing a bunch of crazy things for the special floating-point values over time because of <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s law</a>. RFC8259 makes no effort to provide suggestions for dealing with such real-world situations beyond “tough luck, not interoperable.”</p> <h2 id="text-encodings-and-invalid-unicode"><a href="#text-encodings-and-invalid-unicode">Text Encodings and Invalid Unicode</a></h2> <p>JSON strings are relatively tame, with some marked (but good) divergence from JavaScript. Specifically, JavaScript, being a language of a certain age (along with Java), uses UTF-16 as its Unicode text encoding. Most of the world has realized this is a bad idea (it doubles the size of ASCII text, which makes up almost all of Internet traffic), so JSON uses UTF-8 instead. RFC8259 actually specifies that the whole document MUST be encoded in UTF-8.</p> <p>But when we go to read about Unicode characters in §8.2, we are disappointed: it merely says that it’s <em>really great</em> when all quoted strings consist entirely of Unicode characters, which means that unpaired surrogates are allowed. In effect, the spec merely requires that JSON strings be <a href="https://en.wikipedia.org/wiki/UTF-8#Surrogates">WTF-8</a>: UTF-8 that permits unpaired surrogates.</p> <p>What’s an unpaired surrogate? It’s any encoded Unicode 32-bit value in the range <code class="language-plaintext highlighter-rouge">U+D800</code> to <code class="language-plaintext highlighter-rouge">U+DFFF</code> , which form a gap in the Unicode codepoint range. UTF-8’s variable-length integer encoding can encode them, but their presence in a bytestream makes it invalid UTF-8. WTF-8 is UTF-8 but permitting the appearance of these values.</p> <p>So, who actually supports parsing (or serializing) these? Consider the document <code class="language-plaintext highlighter-rouge">{"x":"\udead"}</code>, which contains an unpaired surrogate, <code class="language-plaintext highlighter-rouge">U+DEAD</code>.</p> <ul> <li> <p>Go gladly deserializes AND serializes it (Go’s strings are arbitrary byte strings, not UTF-8). However, Go serializes a non-UTF-8 string such as <code class="language-plaintext highlighter-rouge">"\xff"</code> as <code class="language-plaintext highlighter-rouge">"\ufffd"</code>, having replaced the invalid byte with a <code class="language-plaintext highlighter-rouge">U+FFFD</code> replacement character (this thing: �).</p> </li> <li> <p>Most Java parsers seem to follow the same behavior as Go, but there are many different parsers available, and we’ve already learned that different JSON parsers may behave differently.</p> </li> <li> <p>JavaScript and Python similarly gladly parse unpaired surrogates, but they also serialize them back without converting them into <code class="language-plaintext highlighter-rouge">U+FFFD</code>.</p> </li> <li> <p>Different Protobuf runtimes may not handle this identically, but the reference C++ implementation (whose JSON codec I wrote!) refuses to parse unpaired surrogates.</p> </li> </ul> <p>There are other surprising pitfalls around strings: are <code class="language-plaintext highlighter-rouge">"x"</code> and <code class="language-plaintext highlighter-rouge">“\x78"</code> the same string? RFC8259 feels the need to call out that they are, for the purposes of checking that object keys are equal. The fact that they feel the need to call it out indicates that this is also a source of potential problems.</p> <h2 id="byte-strings"><a href="#byte-strings">Byte Strings</a></h2> <p>What if I don’t want to send text? A common type of byte blob to send is a cryptographic hash that identifies a document in a content-addressed blobstore, or perhaps a digital signature (an encrypted hash). JSON has no native way of representing byte strings.</p> <p>You could send a quoted string full of ASCII and <code class="language-plaintext highlighter-rouge">\xNN</code> escapes (for bytes which are not in the ASCII range), but this is wasteful in terms of bandwidth, and has serious interoperability problems (as noted above, Go actively destroys data in this case). You could also encode it as an array of JSON numbers, which is much worse for bandwidth and serialization speed.</p> <p>What everyone winds up doing, one way or another, is to rely on base64 encoding. Protobuf, for example, encodes <code class="language-plaintext highlighter-rouge">bytes</code> fields into base64 strings in JSON. This has the unfortunate side-effect of defeating JSON’s human-readable property: if the blob contains mostly ASCII, a human reader can’t tell.</p> <p>Because this isn’t part of JSON, virtually no JSON codec does this decoding for you, particularly because in a schema-less context, there’s nothing to distinguish a byte blob encoded with base64 from an actual textual string that <em>happens</em> to contain valid base64, such as an alphanumeric username.</p> <p>Compared to other problems, this is more like a paper cut, but it’s unnecessary and adds complexity and interop problems. <a href="https://en.wikipedia.org/wiki/Base64#Variants_summary_table">By the way, did you know there are multiple incompatible Base64 alphabets?</a></p> <h1 id="streaming-doesnt-work"><a href="#streaming-doesnt-work">Streaming Doesn’t Work</a></h1> <p>A less obvious problem with JSON is that it can’t be streamed. Almost all JSON documents are objects or arrays and are therefore <em>incomplete</em> until they reach the closing <code class="language-plaintext highlighter-rouge">}</code> or <code class="language-plaintext highlighter-rouge">]</code>, respectively. This means you can’t send a stream of JSON documents that form a part of a larger document without some additional protocol for combining them in post-processing.</p> <p><a href="https://jsonlines.org/">JSONL</a> is the world’s silliest spec that “solves” this problem in the simplest way possible: a JSONL document is a sequence of JSON documents separated by newlines. JSONL <em>is</em> streamable, but because it’s done in the simplest way possible, it only supports streaming a giant array. You can’t, for example, stream an object field-by-field or stream an array within that object.</p> <p>Protobuf doesn’t have this problem: in a nutshell, the Protobuf wire format is as if we removed the braces and brackets from the top-level array or object of a document, and made it so that values with the same key get merged. In the wire format, the equivalent of the JSONL document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>is automatically “merged” into the single document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w"> </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>This forms the basis of the “message merge” operation, which is intimately connected to how the wire format was designed. We’ll dive into this fundamental operation in a future article.</p> <h1 id="canonicalization-leads-to-data-loss"><a href="#canonicalization-leads-to-data-loss">Canonicalization Leads to Data Loss</a></h1> <p>Thanks to <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC7519</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC7515</a>, which define JSON Web Tokens (JWT) and JSON Web Signatures (JWS), digitally signing JSON documents is a very common operation. However, digital signatures can only sign specific byte blobs and are sensitive to things that JSON isn’t, such as whitespace and key ordering.</p> <p>This results in specifications like <a href="https://datatracker.ietf.org/doc/html/rfc8785">RFC8785</a> for <em>canonicalization</em> of JSON documents. This introduces a new avenue by which existing JSON documents, which accidentally happen to contain non-interoperable (or, thanks to non-conforming implementations such as Python’s) invalid JSON that must be manipulated and reformatted by third-party tools. RFC8785 itself references ECMA-262 (the JavaScript standard) for how to serialize numbers, meaning that it’s <em>required</em> to induce data loss for 64-bit numerical values!</p> <h1 id="is-json-fixable"><a href="#is-json-fixable">Is JSON Fixable?</a></h1> <p>Plainly? No. JSON can’t be fixed because of how extremely popular it is. Common mistakes are baked into the format. Are comments allowed? Trailing commas? Number formats? Nobody knows!</p> <p>What tools are touching your JSON? Are they aware of all of the rakes they can step on? Do they emit invalid JSON (like Python does)? How do you even begin to audit that?</p> <p>Thankfully, you don’t have to use JSON. There are alternatives—BSON, UBJSON, MessagePack, and CBOR are just a few binary formats that try to replicate JSON’s data model. Unfortunately, many of them have their own problems.</p> <p>Protobuf, however, has none of these problems, because it was <em>designed</em> to fulfill needs JSON couldn’t meet. Using a strongly-typed schema system, like Protobuf, makes all of these problems go away.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-04-17 • 3689 words • 30 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2024/04/17/calling-convention/"> The Rust Calling Convention We Deserve </a></h1> </div> <div class="post"> <p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified0- calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>However, we are too conservative. We get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>Not only does clang produce patently <em>bad</em> code for passing things by value, but it also knows how to do it better, if you request a standard calling convention! We could be generating <em>way</em> better code than Clang, but we don’t!</p> <p>Hereforth, I will describe how to do it.</p> <h3 id="-zcallconv"><a href="#-zcallconv"><code class="language-plaintext highlighter-rouge">-Zcallconv</code></a></h3> <p>Let’s suppose that we keep the current calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code><sup id="fnref:just-use-extern-c" role="doc-noteref"><a href="#fn:just-use-extern-c" class="footnote" rel="footnote">1</a></sup>, but we add a flag <code class="language-plaintext highlighter-rouge">-Zcallconv</code> that sets the calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code> when compiling a crate. The supported values will be <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> for the current one, and <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for the one we’re going to design. We could even let <code class="language-plaintext highlighter-rouge">-O</code> set <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> automatically.</p> <p>Why keep the old calling convention? Although I did sweep debugability under the rug, one nice property <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> will not have is that it does not place arguments in the C ABI order, which means that a reader replying on the “Diana’s silk dress cost $89” mnemonic on x86 will get fairly confused.</p> <p>I am also assuming we may not even support <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for some targets, like WASM, where there is no concept of “registers” and “spilling”. It may not even make sense to enable it for for debug builds, because it will produce much worse code with optimizations turned off.</p> <p>There is also a mild wrinkle with function pointers, and <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code> blocks. Because this flag is per-crate, even though functions can advertise which version of <code class="language-plaintext highlighter-rouge">extern "Rust"</code> they use, function pointers have no such luxury. However, calling through a function pointer is slow and rare, so we can simply force them to use <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. We can generate a shim to translate calling conventions as needed.</p> <p>Similarly, we can, in principle, call any Rust function like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">secret_call</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">my_func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">my_func</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this mechanism can only be used to call unmangled symbols. Thus, we can simply force <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> symbols to use the legacy calling convention.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following procedure.</p> <ol> <li> <p>First, determine, for a given target triple, the maximum number of values that can be passed “by register”. I will explain how to do this below.</p> </li> <li> <p>Decide how to pass the return value. It will either fit in the output registers, or it will need to be returned “by reference”, in which case we pass an extra <code class="language-plaintext highlighter-rouge">ptr</code> argument to the function (tagged with the <code class="language-plaintext highlighter-rouge">sret</code> attribute) and the actual return value of the function is that pointer.</p> </li> <li> <p>Decide which arguments that have been passed by value need to be demoted to being passed by reference. This will be a heuristic, but generally will be approximately “arguments larger than the by-register space”. For example, on x86, this comes out to 176 bytes.</p> </li> <li> <p>Decide which arguments get passed by register, so as to maximize register space usage. This problem is NP-hard (it’s the knapsack problem) so it will require a heuristic. All other arguments are passed on the stack.</p> </li> <li> <p>Generate the function signature in LLVM IR. This will be all of the arguments that are passed by register encoded as various non-aggregates, such as <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">ptr</code>, <code class="language-plaintext highlighter-rouge">double</code>, and <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>. What valid choices are for said non-aggregates depends on the target, but the above are what you will generally get on a 64-bit architecture. Arguments passed on the stack will follow the “register inputs”.</p> </li> <li> <p>Generate a function prologue. This is code to decode each Rust-level argument from the register inputs, so that there are <code class="language-plaintext highlighter-rouge">%ssa</code> values corresponding to those that would be present when using <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This allows us to generate the same code for the body of the function regardless of calling convention. Redundant decoding code will be eliminated by DCE passes.</p> </li> <li> <p>Generate a function exit block. This is a block that contains a single <code class="language-plaintext highlighter-rouge">phi</code> instruction for the return type as it would be for <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This block will encode it into the requisite output format and then <code class="language-plaintext highlighter-rouge">ret</code> as appropriate. All exit paths through the function should <code class="language-plaintext highlighter-rouge">br</code> to this block instead of <code class="language-plaintext highlighter-rouge">ret</code>-ing.</p> </li> <li> <p>If a non-polymorphic, non-inline function may have its address taken (as a function pointer), either because it is exported out of the crate or the crate takes a function pointer to it, generate a shim that uses <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> and immediately tail-calls the real implementation. This is necessary to preserve function pointer equality.</p> </li> </ol> <p>The main upshot here is that we need to cook up heuristics for figuring out what goes in registers (since we allow reordering arguments to get better throughput). This is equivalent to the knapsack problem; knapsack heuristics are beyond the scope of this article. This should happen early enough that this information can be stuffed into <code class="language-plaintext highlighter-rouge">rmeta</code> to avoid needing to recompute it. We may want to use different, faster heuristics depending on <code class="language-plaintext highlighter-rouge">-Copt-level</code>. Note that correctness requires that we forbid linking code generated by multiple different Rust compilers, which is already the case, since Rust breaks ABI from release to release.</p> <h3 id="what-is-llvm-willing-to-do"><a href="#what-is-llvm-willing-to-do">What Is LLVM Willing to Do?</a></h3> <p>Assuming we do that, how do we actually get LLVM to pass things in the way we want it to? We need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of<sup id="fnref:doubles-and-vectors" role="doc-noteref"><a href="#fn:doubles-and-vectors" class="footnote" rel="footnote">2</a></sup>).</p> <p>The above values are for x86<sup id="fnref:official-support" role="doc-noteref"><a href="#fn:official-support" class="footnote" rel="footnote">3</a></sup>. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>I recommend that <em>every function</em> have the same number of by-register arguments. So on x86, EVERY <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> function’s signature should look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">declare</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span> <span class="vg">@my_func</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span><span class="p">,</span>
  <span class="c1">; other args...</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When passing pointers, the appropriate <code class="language-plaintext highlighter-rouge">i64</code>s should be replaced by <code class="language-plaintext highlighter-rouge">ptr</code>, and when passing <code class="language-plaintext highlighter-rouge">double</code>s, they replace <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>s.</p> <p>But you’re probably saying, “Miguel, that’s crazy! Most functions don’t pass 176 bytes!” And you’d be right, if not for the magic of LLVM’s very well-specified <code class="language-plaintext highlighter-rouge">poison</code> semantics.</p> <p>We can get away with not doing extra work if every argument we do not use is passed <code class="language-plaintext highlighter-rouge">poison</code>. Because <code class="language-plaintext highlighter-rouge">poison</code> is equal to “the most convenient possible value at the present moment”, when LLVM sees <code class="language-plaintext highlighter-rouge">poison</code> passed into a function via register, it decides that the most convenient value is “whatever happens to be in the register already”, and so it doesn’t have to touch that register!</p> <p>For example, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we would generate the following code.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; This is a -Zcallconv=fast-style function.</span>
<span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@load_rcx</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%load</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%load</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="nv">%1</span><span class="p">,</span>     <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span>  <span class="n">rax</span>
  <span class="n">mov</span>   <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span>  <span class="n">malloc</span>
  <span class="n">mov</span>   <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>  <span class="n">load_rcx</span>
  <span class="n">add</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">pop</span>   <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any proscribed way. And as we see, <code class="language-plaintext highlighter-rouge">load_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into the other thirteen registers compiles down to nothing<sup id="fnref:requires-opt" role="doc-noteref"><a href="#fn:requires-opt" class="footnote" rel="footnote">4</a></sup>, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, it is not total. In an ideal world, the same registers are used for input and output, to allow easier pipelining of calls without introducing extra register traffic. This is true on ARM and RISC-V, but not x86. However, because register ordering is merely a suggestion for us, we can choose to allocate the return registers in whatever order we want. For example, we can pretend the order registers should be allocated in is <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code> for inputs, and <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rax</code> for outputs.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%sq</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%sq</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">ARM Assembly</div></div></div> </div> <h3 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h3> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>First, return values. This is relatively straightforward, since there is only one value to pass. The amount of data we need to return is <em>not</em> the size of the struct. For example, <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code> measures 32 bytes wide. However, eight of those bytes are padding! We do not need to preserve padding when returning by value, so we can flatten the struct into <code class="language-plaintext highlighter-rouge">(u64, u32, u64, u32)</code> and sort by size into <code class="language-plaintext highlighter-rouge">(u64, u64, u32, u32)</code>. This has no padding and is 24 bytes wide, which fits into the three return registers LLVM gives us on x86. We define the <em>effective size</em> of a type to be the number of non-<code class="language-plaintext highlighter-rouge">undef</code> bits it occupies. For <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code>, this is 192 bits, since it excludes the padding. For <code class="language-plaintext highlighter-rouge">bool</code>, this is one. For <code class="language-plaintext highlighter-rouge">char</code> this is technically 21, but it’s simpler to treat <code class="language-plaintext highlighter-rouge">char</code> as an alias for <code class="language-plaintext highlighter-rouge">u32</code>.</p> <p>The reason for counting bits this way is that it permits significant compaction. For example, returning a struct full of bools can simply bit-pack the bools into a single register.</p> <p>So, a return value is converted to a by-ref return if its effective size is smaller than the output register space (on x86, this is three integer registers and four SSE registers, so we get 88 bytes total, or 704 bits).</p> <p>Argument registers are much harder, because we hit the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, which is NP-hard. The following relatively naive heuristic is where I would start, but it can be made infinitely smarter over time.</p> <p>First, demote to by-ref any argument whose effective size is larget than the total by-register input space (on x86, 176 bytes or 1408 bits). This means we get a pointer argument instead. This is beneficial to do first, since a single pointer might pack better than the huge struct.</p> <p>Enums should be replaced by the appropriate discriminant-union pair. For example, <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> is, internally, <code class="language-plaintext highlighter-rouge">(union { i32, () }, i1)</code>, while <code class="language-plaintext highlighter-rouge">Option&lt;Option&lt;i32&gt;&gt;</code> is <code class="language-plaintext highlighter-rouge">(union { i32, (), () }, i2)</code>. Using a small non-power-of-two integer improves our ability to pack things, since enum discriminants are often quite tiny.</p> <p>Next, we need to handle unions. Because mucking about with unions’ uninitialized bits behind our backs is allowed, we need to either pass it as an array of <code class="language-plaintext highlighter-rouge">u8</code>, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">5</a></sup>.</p> <p>Now, we can proceed to flatten everything. All of the converted arguments are flattened into their most primitive components: pointers, integers, floats, and bools. Every field should be no larger than the smallest argument register; this may require splitting large types such as <code class="language-plaintext highlighter-rouge">u128</code> or <code class="language-plaintext highlighter-rouge">f64</code>.</p> <p>This big list of primitives is next sorted by effective size, from smallest to largest. We take the largest prefix of this that will fit in the available register space; everything else goes on the stack.</p> <p>If part of a Rust-level input is sent to the stack in this way, and that part is larger than a small multiple of the pointer size (e.g., 2x), it is demoted to being passed by pointer-on-the-stack, to minimize memory traffic. Everything else is passed directly on the stack in the order those inputs were before the sort. This helps keep regions that need to be copied relatively contiguous, to minimize calls to <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>The things we choose to pass in registers are allocated to registers in reverse size order, so e.g. first 64-bit things, then 32-bit things, etc. This is the same layout algorithm that <code class="language-plaintext highlighter-rouge">repr(Rust)</code> structs use to move all the padding into the tail. Once we get to the <code class="language-plaintext highlighter-rouge">bool</code>s, those are bit-packed, 64 to a register.</p> <p>Here’s a relatively complicated example. My Rust function is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Context</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_thing</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">6</span><span class="p">],</span>
                <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">op_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">op_count</span> <span class="p">{</span>
    <span class="n">context</span><span class="nf">.check</span><span class="p">(</span><span class="n">op_count</span><span class="p">,</span> <span class="n">options</span><span class="py">.colorize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">code</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">suf</span><span class="p">))</span> <span class="o">=</span> <span class="n">name</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">suf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="s">"idk"</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The codegen for this function is quite complex, so I’ll only cover the prologue and epilogue. After sorting and flattening, our raw argument LLVM types are something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nl">gprs:</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm0:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm1:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Everything fits in registers! So, what does the LLVM function look like on x86?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@do_thing</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="c1">; Unused.</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">; First, unpack all the primitives.</span>
  <span class="nv">%r9.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%r9.1.i64</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span> <span class="m">32</span>
  <span class="nv">%r9.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9.1.i64</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%xmm0.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm0.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm0.2</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%xmm0.3</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span>
  <span class="nv">%xmm1.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm1.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.1.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.1.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.2.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%xmm1.1.2</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.2.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.3.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%xmm1.1.3</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.3.i32</span> <span class="k">to</span> <span class="kt">i1</span>

  <span class="c1">; Next, reassemble them into concrete values as needed.</span>
  <span class="nv">%op_count.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%op_count</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%op_count.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%context.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%context</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="nv">%context.0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%name.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%name</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="nv">%name.0</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%code.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.0</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.1</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.0</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%code.3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.2</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%code.4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.3</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.2</span><span class="p">,</span> <span class="m">4</span>
  <span class="nv">%code</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.4</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.3</span><span class="p">,</span> <span class="m">5</span>
  <span class="nv">%options.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm1.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%options.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%options.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.2</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%options</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.2</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.3</span><span class="p">,</span> <span class="m">3</span>

  <span class="c1">; Codegen as usual.</span>
  <span class="c1">; ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Above, <code class="language-plaintext highlighter-rouge">!dbg</code> metadata for the argument values should be attached to the instruction that actually materializes it. This ensures that gdb does something halfway intelligent when you ask it to print argument values.</p> <p>On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what returns <em>could</em> look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does)! When we’re generating the ABI that all callers will see (for <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code>), we can look at the function body. This means that a crate can advertise the <em>precise</em> ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABIs. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it.</p> <p>Another example: suppose that we know that an <code class="language-plaintext highlighter-rouge">&amp;T</code> argument is not retained (a question the borrow checker can answer at this point in the compiler) and is never converted to a raw pointer (or written to memory a raw pointer is taken of, etc). We also know that <code class="language-plaintext highlighter-rouge">T</code> is fairly small, and <code class="language-plaintext highlighter-rouge">T: Freeze</code>. Then, we can replace the reference with the pointee directly, passed by value.</p> <p>The most obvious candidates for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is a step further. We might know that some arguments are hotter than others, which might cause them to be prioritized in the register allocation order.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find really frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. But <code class="language-plaintext highlighter-rouge">-Zcallconv</code> is intended to only be used with optimizations turned on, so I don’t think this is a meaningful complaint. Nor do I think the project’s Goodhartization of compilation time as a metric is healthy… but I do not think this is ultimately a relevant drawback.</p> <p>I, unfortunately, do not have the spare time to dive into fixing rustc’s ABI code, but I do know LLVM really well, and I know that this is a place where Rust has a low bus factor. For that reason, I am happy to provide the Rust compiler team expert knowledge on getting LLVM to do the right thing in service of making optimized code faster.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:just-use-extern-c" role="doc-endnote"> <p>Or just switch it to the codepath for <code class="language-plaintext highlighter-rouge">extern "C"</code> or <code class="language-plaintext highlighter-rouge">extern "fastcall"</code> since those are clearly better. We will always need to know how to generate code for the non-<code class="language-plaintext highlighter-rouge">extern "Rust"</code> calling conventions. <a href="#fnref:just-use-extern-c" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:doubles-and-vectors" role="doc-endnote"> <p>It’s Complicated. Passing a <code class="language-plaintext highlighter-rouge">double</code> burns a whole <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code> slot. This seems bad, but it can be beneficial since keeping a <code class="language-plaintext highlighter-rouge">double</code> in vector registers reduces register traffic, since usually, fp instructions use the vector registers (or the fp registers shadow the vector registers, like on ARM). <a href="#fnref:doubles-and-vectors" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:official-support" role="doc-endnote"> <p>On the one hand, you might say this “extended calling convention” isn’t an explicitly supported part of LLVM’s <code class="language-plaintext highlighter-rouge">ccc</code> calling convention. On the other hand, <a href="hyrumslaw.com">Hyrum’s Law</a> cuts both ways: Rust is big enough of an LLVM user that LLVM cannot simply miscompile all Rust programs at this point, and the IR I propose Rust emits is extremely reasonable.</p> <p>If Rust causes LLVM to misbehave, that’s an LLVM bug, and we should fix LLVM bugs, not work around them. <a href="#fnref:official-support" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-opt" role="doc-endnote"> <p>Only on <code class="language-plaintext highlighter-rouge">-O1</code> or higher, bizarrely. At <code class="language-plaintext highlighter-rouge">-O0</code>, LLVM decides that all of the <code class="language-plaintext highlighter-rouge">poison</code>s must have the same value, so it copies a bunch of registers around needlessly. This seems like a bug? <a href="#fnref:requires-opt" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div> <div class="pagination post-footer"> <a class="pagination-item newer" href="https://mcyoung.xyz/page4">&lt; Prev</a> • <a class="pagination-item older" href="https://mcyoung.xyz/page6">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>