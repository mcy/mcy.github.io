<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> std::tuple the Hard Way &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="std::tuple the Hard Way &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/tuples-the-hard-way-c8b76e388f5c87531f37510d968d18773389475a.png"> <meta property="og:title" content="std::tuple the Hard Way &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/tuples-the-hard-way-c8b76e388f5c87531f37510d968d18773389475a.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2022/07/13/tuples-the-hard-way/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2022-07-13 • 2429 words • 13 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#templates">#templates</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <h1><a href="/2022/07/13/tuples-the-hard-way/"> std::tuple the Hard Way </a></h1> </div> <div class="post"> <p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">tuple</span> <span class="p">{</span>
  <span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoidGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVzPlxuY2xhc3MgdHVwbGUg e1xuICBUeXBlcy4uLiB2YWx1ZXM7XG59OyIsImNvbXBpbGVycyI6W10sImV4 ZWN1dG9ycyI6W3siY29tcGlsZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJP dXRwdXRWaXNpYmxlIjp0cnVlLCJjb21waWxlciI6eyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6IiJ9fV19XX0=">godbolt</a><div class="codeblock-button">C++</div></div></div> <p>If you click through to Godbolt, you’ll see it doesn’t: this feature doesn’t exist in C++<sup id="fnref:circle-cxx" role="doc-noteref"><a href="#fn:circle-cxx" class="footnote" rel="footnote">2</a></sup> (normally, you’d do <code class="language-plaintext highlighter-rouge">std::tuple&lt;Types...&gt;</code>, but we need to write down <code class="language-plaintext highlighter-rouge">std::tuple</code> somehow). The usual approach is to use some kind of recursive template, which can tend to generate a lot of code.</p> <p>However, C++ does actually have tuples built into the language, as a C++11 feature… lambdas! As an extra challenge, we’re going to try to minimize the number of templates that the compiler needs to instantiate; <code class="language-plaintext highlighter-rouge">std::tuple</code> is famously bad about this and can lead to very poor build performance.</p> <p>For our tuple library type, we need to solve the following problems:</p> <ul> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple()</code> and <code class="language-plaintext highlighter-rouge">std::tuple(args...)</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::apply</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple_element</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::get</code>?</li> </ul> <h2 id="the-power-of-"><a href="#the-power-of-">The Power of [](){}</a></h2> <p>Alright, let’s back up. In C++11, we got <em>lambdas</em>, which are expressions that expand to anonymous functions. In C++, lambdas are <em>closures</em>, meaning that they capture (“close over”) their environment.</p> <p>This is a lambda in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">// 13</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">3</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <ol> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</p> </li> </ol> <p>We can use this type like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">4</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now, our constructor looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">5</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">6</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now we can see everything in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">7</a></sup>.</p> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:circle-cxx" role="doc-endnote"> <p>The Circle compiler totally laughs in our faces, though, because it <em>has this exact syntax</em>. <a href="https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple">https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple</a> <a href="#fnref:circle-cxx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoiXG4jaW5jbHVkZSA8bmV3PiBcbiNpbmNsdWRlIDx1dGlsaXR5PiBcblxu ICAgIHRlbXBsYXRlIDx0eXBlbmFtZSBUPlxuICAgIGNsYXNzIGFsaWduYXMo VCkgU3RvcmFnZUZvciB7XG4gICAgIHB1YmxpYzpcbiAgICAgIFN0b3JhZ2VG b3IoKSA9IGRlZmF1bHQ7XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4g QXJncz5cbiAgICAgIHZvaWQgSW5pdChBcmdzJiYuLi4gYXJncykge1xuICAg ICAgICBuZXcgKHJlaW50ZXJwcmV0X2Nhc3Q8VCo+KCZkYXRhXykpIFQoXG4g ICAgICAgICAgc3RkOjpmb3J3YXJkPEFyZ3M+KGFyZ3MpLi4uKTtcbiAgICAg IH1cblxuICAgICAgY29uc3QgVCogZ2V0KCkgY29uc3QgeyByZXR1cm4gcmVp bnRlcnByZXRfY2FzdDxjb25zdCBUKj4oJmRhdGFfKTsgfVxuICAgICAgVCog Z2V0KCkgeyByZXR1cm4gcmVpbnRlcnByZXRfY2FzdDxUKj4oJmRhdGFfKTsg fVxuICAgICAgY29uc3QgVCYgb3BlcmF0b3IqKCkgY29uc3QgeyByZXR1cm4g KmdldCgpOyB9XG4gICAgICBUJiBvcGVyYXRvciooKSB7IHJldHVybiAqZ2V0 KCk7IH1cbiAgICAgIGNvbnN0IFQqIG9wZXJhdG9yLT4oKSBjb25zdCB7IHJl dHVybiBnZXQoKTsgfVxuICAgICAgVCogb3BlcmF0b3ItPigpIHsgcmV0dXJu IGdldCgpOyB9XG4gICAgIHByaXZhdGU6XG4gICAgICBjaGFyIGRhdGFfW3Np emVvZihUKV07XG4gICAgfTtcblxuICAgIHRlbXBsYXRlIDx0eXBlbmFtZS4u LiBUeXBlcz5cbiAgICBjbGFzcyBUdXBsZSB7XG4gICAgIHB1YmxpYzpcbiAg ICAgIFR1cGxlKCkge1xuICAgICAgICBsYW1iZGFfKFtdIChTdG9yYWdlRm9y PFR5cGVzPiYuLi4gcGxhY2VzKSB7XG4gICAgICAgICAgKHBsYWNlcy5Jbml0 KCksIC4uLik7XG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgdGVt cGxhdGUgPHR5cGVuYW1lLi4uIEFyZ3MsXG4gICAgICAgICAgICAgICAgZGVj bHR5cGUoKG5ldyAobnVsbHB0cikgVHlwZXMoc3RkOjpkZWNsdmFsPEFyZ3M+ KCkpLCAuLi4pKVxuICAgICAgICAgICAgICAgICAgPSBudWxscHRyPlxuICAg ICAgVHVwbGUoQXJncyYmLi4uIGFyZ3MpIHtcbiAgICAgICAgbGFtYmRhXyhb Jl0gKFN0b3JhZ2VGb3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAg ICAocGxhY2VzLkluaXQoc3RkOjpmb3J3YXJkPGRlY2x0eXBlKGFyZ3MpPihh cmdzKSksIC4uLik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBU dXBsZShjb25zdCBUdXBsZSYgdGhhdCkge1xuICAgICAgICBsYW1iZGFfKFsm XSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRoZXNlKSB7XG4gICAgICAgICAg dGhhdC5sYW1iZGFfKFsmXSAoY29uc3QgU3RvcmFnZUZvcjxUeXBlcz4mLi4u IHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVzZS5nZXQoKSkgVHlw ZXMoKnRob3NlKSwgLi4uKTsgICBcbiAgICAgICAgICB9KTtcbiAgICAgICAg fSk7XG4gICAgICB9XG5cbiAgICAgIFR1cGxlKFR1cGxlJiYgdGhhdCkge1xu ICAgICAgICBsYW1iZGFfKFsmXSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRo ZXNlKSB7XG4gICAgICAgICAgdGhhdC5sYW1iZGFfKFsmXSAoU3RvcmFnZUZv cjxUeXBlcz4mLi4uIHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVz ZSkgVHlwZXMoc3RhdGljX2Nhc3Q8VHlwZXMmJj4oKnRob3NlKSksIC4uLik7 ICAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4g ICAgICB+VHVwbGUoKSB7XG4gICAgICAgIGxhbWJkYV8oW10gKFN0b3JhZ2VG b3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAgICAocGxhY2VzLT5+ VHlwZXMoKSwgLi4uKTtcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAg IHByaXZhdGU6XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4gQXJncz5c biAgICAgIHN0YXRpYyBhdXRvIFR1cGxlTGFtYmRhKEFyZ3MuLi4gYXJncykg e1xuICAgICAgICByZXR1cm4gWz1dIChhdXRvIGNhbGxiYWNrKSBtdXRhYmxl IC0+IGRlY2x0eXBlKGF1dG8pIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJh Y2soYXJncy4uLik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG11 dGFibGUgZGVjbHR5cGUoVHVwbGVMYW1iZGEoU3RvcmFnZUZvcjxUeXBlcz57 fS4uLikpIGxhbWJkYV8gPVxuICAgICAgICBUdXBsZUxhbWJkYShTdG9yYWdl Rm9yPFR5cGVzPnt9Li4uKTtcbiAgICB9O1xuXG4gICAgdGVtcGxhdGUgPHR5 cGVuYW1lLi4uIFR5cGVzPlxuICAgIFR1cGxlKFR5cGVzLi4uKSAtPiBUdXBs ZTxUeXBlcy4uLj47XG4gICAgdGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVz PlxuICAgIFR1cGxlKGNvbnN0IFR1cGxlPFR5cGVzLi4uPiYpIC0+IFR1cGxl PFR5cGVzLi4uPjtcblxuICAgIGludCBtYWluKCkge1xuICAgICAgVHVwbGUg dHVwezEsIDIsIFwiZm9vXCIsIFwiYmFyXCJ9O1xuICAgICAgVHVwbGUgdHVw MiA9IHR1cDtcbiAgICB9IiwiY29tcGlsZXJzIjpbeyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6Ii0tc3RkPWMrKzE3In1dfV19 ">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="cp">#endif
</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>
  
  <span class="cp">#else // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span>  <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cp">#endif // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tup</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="cp">#if USE_CLANG_INTRINSIC
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="cp">#else
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TupleType</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/z/eYeb9Y6cn">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> <li> <span class="post-meta">2024-12-10</span> / <h6 style="display:inline"><a href="/2024/12/10/json-sucks/">Nobody Gets Fired for Picking JSON, but Maybe They Should?</a></h6> <li> <span class="post-meta">2024-04-17</span> / <h6 style="display:inline"><a href="/2024/04/17/calling-convention/">The Rust Calling Convention We Deserve</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2022-07-13 • 2429 words • 13 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#templates">#templates</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <h1><a href="/2022/07/13/tuples-the-hard-way/"> std::tuple the Hard Way </a></h1> </div> <div class="post"> <p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">tuple</span> <span class="p">{</span>
  <span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoidGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVzPlxuY2xhc3MgdHVwbGUg e1xuICBUeXBlcy4uLiB2YWx1ZXM7XG59OyIsImNvbXBpbGVycyI6W10sImV4 ZWN1dG9ycyI6W3siY29tcGlsZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJP dXRwdXRWaXNpYmxlIjp0cnVlLCJjb21waWxlciI6eyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6IiJ9fV19XX0=">godbolt</a><div class="codeblock-button">C++</div></div></div> <p>If you click through to Godbolt, you’ll see it doesn’t: this feature doesn’t exist in C++<sup id="fnref:circle-cxx" role="doc-noteref"><a href="#fn:circle-cxx" class="footnote" rel="footnote">2</a></sup> (normally, you’d do <code class="language-plaintext highlighter-rouge">std::tuple&lt;Types...&gt;</code>, but we need to write down <code class="language-plaintext highlighter-rouge">std::tuple</code> somehow). The usual approach is to use some kind of recursive template, which can tend to generate a lot of code.</p> <p>However, C++ does actually have tuples built into the language, as a C++11 feature… lambdas! As an extra challenge, we’re going to try to minimize the number of templates that the compiler needs to instantiate; <code class="language-plaintext highlighter-rouge">std::tuple</code> is famously bad about this and can lead to very poor build performance.</p> <p>For our tuple library type, we need to solve the following problems:</p> <ul> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple()</code> and <code class="language-plaintext highlighter-rouge">std::tuple(args...)</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::apply</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple_element</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::get</code>?</li> </ul> <h2 id="the-power-of-"><a href="#the-power-of-">The Power of [](){}</a></h2> <p>Alright, let’s back up. In C++11, we got <em>lambdas</em>, which are expressions that expand to anonymous functions. In C++, lambdas are <em>closures</em>, meaning that they capture (“close over”) their environment.</p> <p>This is a lambda in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">// 13</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">3</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <ol> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</p> </li> </ol> <p>We can use this type like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">4</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now, our constructor looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">5</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">6</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now we can see everything in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">7</a></sup>.</p> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:circle-cxx" role="doc-endnote"> <p>The Circle compiler totally laughs in our faces, though, because it <em>has this exact syntax</em>. <a href="https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple">https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple</a> <a href="#fnref:circle-cxx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoiXG4jaW5jbHVkZSA8bmV3PiBcbiNpbmNsdWRlIDx1dGlsaXR5PiBcblxu ICAgIHRlbXBsYXRlIDx0eXBlbmFtZSBUPlxuICAgIGNsYXNzIGFsaWduYXMo VCkgU3RvcmFnZUZvciB7XG4gICAgIHB1YmxpYzpcbiAgICAgIFN0b3JhZ2VG b3IoKSA9IGRlZmF1bHQ7XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4g QXJncz5cbiAgICAgIHZvaWQgSW5pdChBcmdzJiYuLi4gYXJncykge1xuICAg ICAgICBuZXcgKHJlaW50ZXJwcmV0X2Nhc3Q8VCo+KCZkYXRhXykpIFQoXG4g ICAgICAgICAgc3RkOjpmb3J3YXJkPEFyZ3M+KGFyZ3MpLi4uKTtcbiAgICAg IH1cblxuICAgICAgY29uc3QgVCogZ2V0KCkgY29uc3QgeyByZXR1cm4gcmVp bnRlcnByZXRfY2FzdDxjb25zdCBUKj4oJmRhdGFfKTsgfVxuICAgICAgVCog Z2V0KCkgeyByZXR1cm4gcmVpbnRlcnByZXRfY2FzdDxUKj4oJmRhdGFfKTsg fVxuICAgICAgY29uc3QgVCYgb3BlcmF0b3IqKCkgY29uc3QgeyByZXR1cm4g KmdldCgpOyB9XG4gICAgICBUJiBvcGVyYXRvciooKSB7IHJldHVybiAqZ2V0 KCk7IH1cbiAgICAgIGNvbnN0IFQqIG9wZXJhdG9yLT4oKSBjb25zdCB7IHJl dHVybiBnZXQoKTsgfVxuICAgICAgVCogb3BlcmF0b3ItPigpIHsgcmV0dXJu IGdldCgpOyB9XG4gICAgIHByaXZhdGU6XG4gICAgICBjaGFyIGRhdGFfW3Np emVvZihUKV07XG4gICAgfTtcblxuICAgIHRlbXBsYXRlIDx0eXBlbmFtZS4u LiBUeXBlcz5cbiAgICBjbGFzcyBUdXBsZSB7XG4gICAgIHB1YmxpYzpcbiAg ICAgIFR1cGxlKCkge1xuICAgICAgICBsYW1iZGFfKFtdIChTdG9yYWdlRm9y PFR5cGVzPiYuLi4gcGxhY2VzKSB7XG4gICAgICAgICAgKHBsYWNlcy5Jbml0 KCksIC4uLik7XG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgdGVt cGxhdGUgPHR5cGVuYW1lLi4uIEFyZ3MsXG4gICAgICAgICAgICAgICAgZGVj bHR5cGUoKG5ldyAobnVsbHB0cikgVHlwZXMoc3RkOjpkZWNsdmFsPEFyZ3M+ KCkpLCAuLi4pKVxuICAgICAgICAgICAgICAgICAgPSBudWxscHRyPlxuICAg ICAgVHVwbGUoQXJncyYmLi4uIGFyZ3MpIHtcbiAgICAgICAgbGFtYmRhXyhb Jl0gKFN0b3JhZ2VGb3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAg ICAocGxhY2VzLkluaXQoc3RkOjpmb3J3YXJkPGRlY2x0eXBlKGFyZ3MpPihh cmdzKSksIC4uLik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBU dXBsZShjb25zdCBUdXBsZSYgdGhhdCkge1xuICAgICAgICBsYW1iZGFfKFsm XSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRoZXNlKSB7XG4gICAgICAgICAg dGhhdC5sYW1iZGFfKFsmXSAoY29uc3QgU3RvcmFnZUZvcjxUeXBlcz4mLi4u IHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVzZS5nZXQoKSkgVHlw ZXMoKnRob3NlKSwgLi4uKTsgICBcbiAgICAgICAgICB9KTtcbiAgICAgICAg fSk7XG4gICAgICB9XG5cbiAgICAgIFR1cGxlKFR1cGxlJiYgdGhhdCkge1xu ICAgICAgICBsYW1iZGFfKFsmXSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRo ZXNlKSB7XG4gICAgICAgICAgdGhhdC5sYW1iZGFfKFsmXSAoU3RvcmFnZUZv cjxUeXBlcz4mLi4uIHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVz ZSkgVHlwZXMoc3RhdGljX2Nhc3Q8VHlwZXMmJj4oKnRob3NlKSksIC4uLik7 ICAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4g ICAgICB+VHVwbGUoKSB7XG4gICAgICAgIGxhbWJkYV8oW10gKFN0b3JhZ2VG b3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAgICAocGxhY2VzLT5+ VHlwZXMoKSwgLi4uKTtcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAg IHByaXZhdGU6XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4gQXJncz5c biAgICAgIHN0YXRpYyBhdXRvIFR1cGxlTGFtYmRhKEFyZ3MuLi4gYXJncykg e1xuICAgICAgICByZXR1cm4gWz1dIChhdXRvIGNhbGxiYWNrKSBtdXRhYmxl IC0+IGRlY2x0eXBlKGF1dG8pIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJh Y2soYXJncy4uLik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG11 dGFibGUgZGVjbHR5cGUoVHVwbGVMYW1iZGEoU3RvcmFnZUZvcjxUeXBlcz57 fS4uLikpIGxhbWJkYV8gPVxuICAgICAgICBUdXBsZUxhbWJkYShTdG9yYWdl Rm9yPFR5cGVzPnt9Li4uKTtcbiAgICB9O1xuXG4gICAgdGVtcGxhdGUgPHR5 cGVuYW1lLi4uIFR5cGVzPlxuICAgIFR1cGxlKFR5cGVzLi4uKSAtPiBUdXBs ZTxUeXBlcy4uLj47XG4gICAgdGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVz PlxuICAgIFR1cGxlKGNvbnN0IFR1cGxlPFR5cGVzLi4uPiYpIC0+IFR1cGxl PFR5cGVzLi4uPjtcblxuICAgIGludCBtYWluKCkge1xuICAgICAgVHVwbGUg dHVwezEsIDIsIFwiZm9vXCIsIFwiYmFyXCJ9O1xuICAgICAgVHVwbGUgdHVw MiA9IHR1cDtcbiAgICB9IiwiY29tcGlsZXJzIjpbeyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6Ii0tc3RkPWMrKzE3In1dfV19 ">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="cp">#endif
</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>
  
  <span class="cp">#else // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span>  <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cp">#endif // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tup</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="cp">#if USE_CLANG_INTRINSIC
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="cp">#else
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TupleType</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/z/eYeb9Y6cn">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> <li> <span class="post-meta">2024-12-10</span> / <h6 style="display:inline"><a href="/2024/12/10/json-sucks/">Nobody Gets Fired for Picking JSON, but Maybe They Should?</a></h6> <li> <span class="post-meta">2024-04-17</span> / <h6 style="display:inline"><a href="/2024/04/17/calling-convention/">The Rust Calling Convention We Deserve</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>