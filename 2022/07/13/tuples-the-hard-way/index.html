<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> std::tuple the Hard Way &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="std::tuple the Hard Way &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/tuples-the-hard-way-c8b76e388f5c87531f37510d968d18773389475a.png"> <meta property="og:title" content="std::tuple the Hard Way &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/tuples-the-hard-way-c8b76e388f5c87531f37510d968d18773389475a.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2022/07/13/tuples-the-hard-way/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz/posts"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/posts"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2022-07-13 • 2223 words • 12 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#templates">#templates</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <h1><a href="/2022/07/13/tuples-the-hard-way/"> std::tuple the Hard Way </a></h1> </div> <div class="post"> <p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <p>```cpp godbolt:e template <typename... Types=""> class tuple { Types... values; };</typename...></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
If you click through to Godbolt, you'll see it doesn't: this feature doesn't
exist in C++[^circle-cxx] (normally, you'd do `std::tuple&lt;Types...&gt;`, but we
need to write down `std::tuple` somehow). The usual approach is to use some kind
of recursive template, which can tend to generate a lot of code.

[^circle-cxx]:
    The Circle compiler totally laughs in our faces, though, because it
    *has this exact syntax*.
    &lt;https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple&gt;

However, C++ does actually have tuples built into the language, as a C++11
feature... lambdas! As an extra challenge, we're going to try to minimize the
number of templates that the compiler needs to instantiate; `std::tuple` is
famously bad about this and can lead to very poor build performance.

For our tuple library type, we need to solve the following problems:
- How do we implement `std::tuple()` and `std::tuple(args...)`?
- How do we implement `std::apply`?
- How do we implement `std::tuple_element`?
- How do we implement `std::get`?

## The Power of \[\](){}

Alright, let's back up. In C++11, we got *lambdas*, which are expressions that
expand to anonymous functions. In C++, lambdas are *closures*, meaning that they
capture ("close over") their environment.

This is a lambda in action:

```cpp
int x = 5;
auto add = [x] (int y) { return x + y; }
int z = add(8);  // 13
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">2</a></sup>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>
</code></pre></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
<span class="o">*</span><span class="n">x</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</li> </ol> <p>We can use this type like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span>
</code></pre></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>
</code></pre></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">3</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>Now, our constructor looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">4</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">5</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <p>#include <new> #include <utility></utility></new></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T&gt;
class alignas(T) StorageFor {
 public:
  StorageFor() = default;
  template &lt;typename... Args&gt;
  void Init(Args&amp;&amp;... args) {
    new (reinterpret_cast&lt;T*&gt;(&amp;data_)) T(
      std::forward&lt;Args&gt;(args)...);
  }

  const T* get() const { return reinterpret_cast&lt;const T*&gt;(&amp;data_); }
  T* get() { return reinterpret_cast&lt;T*&gt;(&amp;data_); }
  const T&amp; operator*() const { return *get(); }
  T&amp; operator*() { return *get(); }
  const T* operator-&gt;() const { return get(); }
  T* operator-&gt;() { return get(); }
 private:
  char data_[sizeof(T)];
};

template &lt;typename... Types&gt;
class Tuple {
 public:
  Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(), ...);
    }); 
  }

  template &lt;typename... Args,
            decltype((new (nullptr) Types(std::declval&lt;Args&gt;()), ...))
              = nullptr&gt;
  Tuple(Args&amp;&amp;... args) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(std::forward&lt;decltype(args)&gt;(args)), ...);
    });
  }

  Tuple(const Tuple&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... those) {
        (new (these.get()) Types(*those), ...);   
      });
    });
  }

  Tuple(Tuple&amp;&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... those) {
        (new (these) Types(static_cast&lt;Types&amp;&amp;&gt;(*those)), ...);   
      });
    });
  }

  ~Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places-&gt;~Types(), ...);
    }); 
  }

 private:
  template &lt;typename... Args&gt;
  static auto TupleLambda(Args... args) {
    return [=] (auto callback) mutable -&gt; decltype(auto) {
      return callback(args...);
    };
  }

  mutable decltype(TupleLambda(StorageFor&lt;Types&gt;{}...)) lambda_ =
    TupleLambda(StorageFor&lt;Types&gt;{}...);
};

template &lt;typename... Types&gt;
Tuple(Types...) -&gt; Tuple&lt;Types...&gt;;
template &lt;typename... Types&gt;
Tuple(const Tuple&lt;Types...&gt;&amp;) -&gt; Tuple&lt;Types...&gt;;

int main() {
  Tuple tup{1, 2, "foo", "bar"};
  Tuple tup2 = tup;
}
```
</code></pre></div></div> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
</code></pre></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>
</code></pre></div></div> <p>Now we can see everything in action:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">6</a></sup>.</p> <p>#include <cstddef> #include <cstdio> #include <functional> #include <new> #include <type_traits> #include <utility></utility></type_traits></new></functional></cstdio></cstddef></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T&gt;
class alignas(T) StorageFor {
 public:
  StorageFor() = default;
  template &lt;typename... Args&gt;
  void Init(Args&amp;&amp;... args) {
    new (reinterpret_cast&lt;T*&gt;(&amp;data_)) T(
      std::forward&lt;Args&gt;(args)...);
  }

  const T* get() const { return reinterpret_cast&lt;const T*&gt;(&amp;data_); }
  T* get() { return reinterpret_cast&lt;T*&gt;(&amp;data_); }
  const T&amp; operator*() const { return *get(); }
  T&amp; operator*() { return *get(); }
  const T* operator-&gt;() const { return get(); }
  T* operator-&gt;() { return get(); }
 private:
  char data_[sizeof(T)];
};


template &lt;size_t&gt;
struct Sink {
  template &lt;typename T&gt;
  Sink(T&amp;&amp;) {}
};

template &lt;typename... Types&gt;
class Tuple {
  #if USE_CLANG_INTRINSIC
  template &lt;size_t i&gt;
  using type = __type_pack_element&lt;i, Types...&gt;;
  #endif

 public:
  Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(), ...);
    }); 
  }

  template &lt;typename... Args,
            decltype((new (nullptr) Types(std::declval&lt;Args&gt;()), ...))
              = nullptr&gt;
  Tuple(Args&amp;&amp;... args) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(std::forward&lt;decltype(args)&gt;(args)), ...);
    });
  }

  Tuple(const Tuple&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... those) {
        (new (these.get()) Types(*those), ...);   
      });
    });
  }

  Tuple(Tuple&amp;&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... those) {
        (new (these) Types(static_cast&lt;Types&amp;&amp;&gt;(*those)), ...);   
      });
    });
  }

  ~Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places-&gt;~Types(), ...);
    }); 
  }

  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) const&amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), *places...);
    });
  }
  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) &amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), *places...);
    });
  }
  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) const&amp;&amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), 
        static_cast&lt;const Types&amp;&amp;&gt;(*places)...);
    });
  }
  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) &amp;&amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), 
        static_cast&lt;Types&amp;&amp;&gt;(*places)...);
    });
  }

  template &lt;typename F, typename Tup&gt;
  friend decltype(auto) apply(F&amp;&amp; f, Tup&amp;&amp; t) {
    return std::forward&lt;Tup&gt;(t).apply(std::forward&lt;F&gt;(f));
  }

  #if USE_CLANG_INTRINSIC
  template &lt;size_t i&gt;
  const type&lt;i&gt;&amp; get() const&amp; {
    return lambda_([] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      const void* erased[] = {places.get()...};
      return *reinterpret_cast&lt;const type&lt;i&gt;*&gt;(erased[i]);
    });
  }

  template &lt;size_t i&gt;
  type&lt;i&gt;&amp; get() &amp; {
    return lambda_([] (StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      void* erased[] = {places.get()...};
      return *reinterpret_cast&lt;type&lt;i&gt;*&gt;(erased[i]);
    });
  }

  template &lt;size_t i&gt;
  const type&lt;i&gt;&amp;&amp; get() const&amp;&amp; {
    return lambda_([] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      const void* erased[] = {places.get()...};
      return static_cast&lt;const type&lt;i&gt;&amp;&amp;&gt;(
        *reinterpret_cast&lt;const type&lt;i&gt;*&gt;(erased[i]));
    });
  }

  template &lt;size_t i&gt;
  type&lt;i&gt;&amp;&amp; get() &amp;&amp; {
    return lambda_([] (StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      void* erased[] = {places.get()...};
      return static_cast&lt;type&lt;i&gt;&amp;&amp;&gt;(
        *reinterpret_cast&lt;type&lt;i&gt;*&gt;(erased[i]));
    });
  }
  
  #else // USE_CLANG_INTRINSIC

  template &lt;size_t i&gt;
  const auto&amp; get() const&amp; {
    return GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
  }

  template &lt;size_t i&gt;
  auto&amp; get() &amp; {
    return GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
  }

  template &lt;size_t i&gt;
  const auto&amp;&amp; get() const&amp;&amp; {
    auto&amp; val = GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
    return static_cast&lt;decltype(val)&amp;&amp;&gt;(val);
  }

  template &lt;size_t i&gt;
  auto&amp;&amp; get() &amp;&amp; {
    auto&amp; val =  GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
    return static_cast&lt;decltype(val)&amp;&amp;&gt;(val);
  }

  #endif // USE_CLANG_INTRINSIC

  template &lt;size_t i, typename Tup&gt;
  friend decltype(auto) get(Tup&amp;&amp; t) {
    return std::forward&lt;Tup&gt;(t).template get&lt;i&gt;();
  }

 private:
  template &lt;typename... Args&gt;
  static auto TupleLambda(Args... args) {
    return [=] (auto callback) mutable -&gt; decltype(auto) {
      return callback(args...);
    };
  }

  template &lt;typename Tup, size_t... less_than_i&gt;
  friend decltype(auto) GetImpl(Tup&amp;&amp; t, std::index_sequence&lt;less_than_i...&gt;) {
    return std::forward&lt;Tup&gt;(t).lambda_(
      [] (Sink&lt;less_than_i&gt;..., auto&amp; the_one, auto...) -&gt; auto&amp; {
        return the_one;
      });
  }

  mutable decltype(TupleLambda(StorageFor&lt;Types&gt;{}...)) lambda_ =
    TupleLambda(StorageFor&lt;Types&gt;{}...);
};

#if USE_CLANG_INTRINSIC
template &lt;typename Tuple, size_t i&gt;
using TupleType = typename Tuple::template Type&lt;i&gt;;
#else
template &lt;typename Tuple, size_t i&gt;
using TupleType = std::remove_reference_t&lt;
  decltype(std::declval&lt;Tuple&gt;().template get&lt;i&gt;())&gt;;
#endif

template &lt;typename... Types&gt;
Tuple(Types...) -&gt; Tuple&lt;Types...&gt;;
template &lt;typename... Types&gt;
Tuple(const Tuple&lt;Types...&gt;&amp;) -&gt; Tuple&lt;Types...&gt;;

namespace std {
template &lt;typename... Types&gt;
struct tuple_size&lt;Tuple&lt;Types...&gt;&gt;
    : std::integral_constant&lt;size_t, sizeof...(Types)&gt; {};
template &lt;size_t i, typename... Types&gt;
struct tuple_element&lt;i, Tuple&lt;Types...&gt;&gt; {
  using type = TupleType&lt;Tuple&lt;Types...&gt;, i&gt;;
};
}  // namespace std

int main() {
  Tuple tup{1, 2, "foo", "bar", nullptr};
  tup.apply([](auto, auto, auto a, auto b, auto) {
    std::printf("%s %s\n", a, b);
  });

  auto [a, b, c, d, e] = tup;
  std::printf("%d %d\n", a, b);
}
```
</code></pre></div></div> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div> </div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <p>```cpp godbolt:o=–std=c++17,o:-O <a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <p>```cpp godbolt:l=https://godbolt.org/z/eYeb9Y6cn <a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2022-07-13 • 2223 words • 12 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> • <a href="https://mcyoung.xyz/tags.html#templates">#templates</a> • <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <h1><a href="/2022/07/13/tuples-the-hard-way/"> std::tuple the Hard Way </a></h1> </div> <div class="post"> <p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <p>```cpp godbolt:e template <typename... Types=""> class tuple { Types... values; };</typename...></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
If you click through to Godbolt, you'll see it doesn't: this feature doesn't
exist in C++[^circle-cxx] (normally, you'd do `std::tuple&lt;Types...&gt;`, but we
need to write down `std::tuple` somehow). The usual approach is to use some kind
of recursive template, which can tend to generate a lot of code.

[^circle-cxx]:
    The Circle compiler totally laughs in our faces, though, because it
    *has this exact syntax*.
    &lt;https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple&gt;

However, C++ does actually have tuples built into the language, as a C++11
feature... lambdas! As an extra challenge, we're going to try to minimize the
number of templates that the compiler needs to instantiate; `std::tuple` is
famously bad about this and can lead to very poor build performance.

For our tuple library type, we need to solve the following problems:
- How do we implement `std::tuple()` and `std::tuple(args...)`?
- How do we implement `std::apply`?
- How do we implement `std::tuple_element`?
- How do we implement `std::get`?

## The Power of \[\](){}

Alright, let's back up. In C++11, we got *lambdas*, which are expressions that
expand to anonymous functions. In C++, lambdas are *closures*, meaning that they
capture ("close over") their environment.

This is a lambda in action:

```cpp
int x = 5;
auto add = [x] (int y) { return x + y; }
int z = add(8);  // 13
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div> </div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">2</a></sup>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>
</code></pre></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
<span class="o">*</span><span class="n">x</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</li> </ol> <p>We can use this type like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span>
</code></pre></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>
</code></pre></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">3</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>Now, our constructor looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">4</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">5</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <p>#include <new> #include <utility></utility></new></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T&gt;
class alignas(T) StorageFor {
 public:
  StorageFor() = default;
  template &lt;typename... Args&gt;
  void Init(Args&amp;&amp;... args) {
    new (reinterpret_cast&lt;T*&gt;(&amp;data_)) T(
      std::forward&lt;Args&gt;(args)...);
  }

  const T* get() const { return reinterpret_cast&lt;const T*&gt;(&amp;data_); }
  T* get() { return reinterpret_cast&lt;T*&gt;(&amp;data_); }
  const T&amp; operator*() const { return *get(); }
  T&amp; operator*() { return *get(); }
  const T* operator-&gt;() const { return get(); }
  T* operator-&gt;() { return get(); }
 private:
  char data_[sizeof(T)];
};

template &lt;typename... Types&gt;
class Tuple {
 public:
  Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(), ...);
    }); 
  }

  template &lt;typename... Args,
            decltype((new (nullptr) Types(std::declval&lt;Args&gt;()), ...))
              = nullptr&gt;
  Tuple(Args&amp;&amp;... args) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(std::forward&lt;decltype(args)&gt;(args)), ...);
    });
  }

  Tuple(const Tuple&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... those) {
        (new (these.get()) Types(*those), ...);   
      });
    });
  }

  Tuple(Tuple&amp;&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... those) {
        (new (these) Types(static_cast&lt;Types&amp;&amp;&gt;(*those)), ...);   
      });
    });
  }

  ~Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places-&gt;~Types(), ...);
    }); 
  }

 private:
  template &lt;typename... Args&gt;
  static auto TupleLambda(Args... args) {
    return [=] (auto callback) mutable -&gt; decltype(auto) {
      return callback(args...);
    };
  }

  mutable decltype(TupleLambda(StorageFor&lt;Types&gt;{}...)) lambda_ =
    TupleLambda(StorageFor&lt;Types&gt;{}...);
};

template &lt;typename... Types&gt;
Tuple(Types...) -&gt; Tuple&lt;Types...&gt;;
template &lt;typename... Types&gt;
Tuple(const Tuple&lt;Types...&gt;&amp;) -&gt; Tuple&lt;Types...&gt;;

int main() {
  Tuple tup{1, 2, "foo", "bar"};
  Tuple tup2 = tup;
}
```
</code></pre></div></div> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
</code></pre></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>
</code></pre></div></div> <p>Now we can see everything in action:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">6</a></sup>.</p> <p>#include <cstddef> #include <cstdio> #include <functional> #include <new> #include <type_traits> #include <utility></utility></type_traits></new></functional></cstdio></cstddef></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T&gt;
class alignas(T) StorageFor {
 public:
  StorageFor() = default;
  template &lt;typename... Args&gt;
  void Init(Args&amp;&amp;... args) {
    new (reinterpret_cast&lt;T*&gt;(&amp;data_)) T(
      std::forward&lt;Args&gt;(args)...);
  }

  const T* get() const { return reinterpret_cast&lt;const T*&gt;(&amp;data_); }
  T* get() { return reinterpret_cast&lt;T*&gt;(&amp;data_); }
  const T&amp; operator*() const { return *get(); }
  T&amp; operator*() { return *get(); }
  const T* operator-&gt;() const { return get(); }
  T* operator-&gt;() { return get(); }
 private:
  char data_[sizeof(T)];
};


template &lt;size_t&gt;
struct Sink {
  template &lt;typename T&gt;
  Sink(T&amp;&amp;) {}
};

template &lt;typename... Types&gt;
class Tuple {
  #if USE_CLANG_INTRINSIC
  template &lt;size_t i&gt;
  using type = __type_pack_element&lt;i, Types...&gt;;
  #endif

 public:
  Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(), ...);
    }); 
  }

  template &lt;typename... Args,
            decltype((new (nullptr) Types(std::declval&lt;Args&gt;()), ...))
              = nullptr&gt;
  Tuple(Args&amp;&amp;... args) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... places) {
      (places.Init(std::forward&lt;decltype(args)&gt;(args)), ...);
    });
  }

  Tuple(const Tuple&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... those) {
        (new (these.get()) Types(*those), ...);   
      });
    });
  }

  Tuple(Tuple&amp;&amp; that) {
    lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... these) {
      that.lambda_([&amp;] (StorageFor&lt;Types&gt;&amp;... those) {
        (new (these) Types(static_cast&lt;Types&amp;&amp;&gt;(*those)), ...);   
      });
    });
  }

  ~Tuple() {
    lambda_([] (StorageFor&lt;Types&gt;&amp;... places) {
      (places-&gt;~Types(), ...);
    }); 
  }

  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) const&amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), *places...);
    });
  }
  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) &amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), *places...);
    });
  }
  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) const&amp;&amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), 
        static_cast&lt;const Types&amp;&amp;&gt;(*places)...);
    });
  }
  template &lt;typename F&gt;
  decltype(auto) apply(F&amp;&amp; f) &amp;&amp; {
    lambda_([&amp;] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      return std::invoke(std::forward&lt;F&gt;(f), 
        static_cast&lt;Types&amp;&amp;&gt;(*places)...);
    });
  }

  template &lt;typename F, typename Tup&gt;
  friend decltype(auto) apply(F&amp;&amp; f, Tup&amp;&amp; t) {
    return std::forward&lt;Tup&gt;(t).apply(std::forward&lt;F&gt;(f));
  }

  #if USE_CLANG_INTRINSIC
  template &lt;size_t i&gt;
  const type&lt;i&gt;&amp; get() const&amp; {
    return lambda_([] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      const void* erased[] = {places.get()...};
      return *reinterpret_cast&lt;const type&lt;i&gt;*&gt;(erased[i]);
    });
  }

  template &lt;size_t i&gt;
  type&lt;i&gt;&amp; get() &amp; {
    return lambda_([] (StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      void* erased[] = {places.get()...};
      return *reinterpret_cast&lt;type&lt;i&gt;*&gt;(erased[i]);
    });
  }

  template &lt;size_t i&gt;
  const type&lt;i&gt;&amp;&amp; get() const&amp;&amp; {
    return lambda_([] (const StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      const void* erased[] = {places.get()...};
      return static_cast&lt;const type&lt;i&gt;&amp;&amp;&gt;(
        *reinterpret_cast&lt;const type&lt;i&gt;*&gt;(erased[i]));
    });
  }

  template &lt;size_t i&gt;
  type&lt;i&gt;&amp;&amp; get() &amp;&amp; {
    return lambda_([] (StorageFor&lt;Types&gt;&amp;... places) -&gt; decltype(auto) {
      void* erased[] = {places.get()...};
      return static_cast&lt;type&lt;i&gt;&amp;&amp;&gt;(
        *reinterpret_cast&lt;type&lt;i&gt;*&gt;(erased[i]));
    });
  }
  
  #else // USE_CLANG_INTRINSIC

  template &lt;size_t i&gt;
  const auto&amp; get() const&amp; {
    return GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
  }

  template &lt;size_t i&gt;
  auto&amp; get() &amp; {
    return GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
  }

  template &lt;size_t i&gt;
  const auto&amp;&amp; get() const&amp;&amp; {
    auto&amp; val = GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
    return static_cast&lt;decltype(val)&amp;&amp;&gt;(val);
  }

  template &lt;size_t i&gt;
  auto&amp;&amp; get() &amp;&amp; {
    auto&amp; val =  GetImpl(*this, std::make_index_sequence&lt;i&gt;{});
    return static_cast&lt;decltype(val)&amp;&amp;&gt;(val);
  }

  #endif // USE_CLANG_INTRINSIC

  template &lt;size_t i, typename Tup&gt;
  friend decltype(auto) get(Tup&amp;&amp; t) {
    return std::forward&lt;Tup&gt;(t).template get&lt;i&gt;();
  }

 private:
  template &lt;typename... Args&gt;
  static auto TupleLambda(Args... args) {
    return [=] (auto callback) mutable -&gt; decltype(auto) {
      return callback(args...);
    };
  }

  template &lt;typename Tup, size_t... less_than_i&gt;
  friend decltype(auto) GetImpl(Tup&amp;&amp; t, std::index_sequence&lt;less_than_i...&gt;) {
    return std::forward&lt;Tup&gt;(t).lambda_(
      [] (Sink&lt;less_than_i&gt;..., auto&amp; the_one, auto...) -&gt; auto&amp; {
        return the_one;
      });
  }

  mutable decltype(TupleLambda(StorageFor&lt;Types&gt;{}...)) lambda_ =
    TupleLambda(StorageFor&lt;Types&gt;{}...);
};

#if USE_CLANG_INTRINSIC
template &lt;typename Tuple, size_t i&gt;
using TupleType = typename Tuple::template Type&lt;i&gt;;
#else
template &lt;typename Tuple, size_t i&gt;
using TupleType = std::remove_reference_t&lt;
  decltype(std::declval&lt;Tuple&gt;().template get&lt;i&gt;())&gt;;
#endif

template &lt;typename... Types&gt;
Tuple(Types...) -&gt; Tuple&lt;Types...&gt;;
template &lt;typename... Types&gt;
Tuple(const Tuple&lt;Types...&gt;&amp;) -&gt; Tuple&lt;Types...&gt;;

namespace std {
template &lt;typename... Types&gt;
struct tuple_size&lt;Tuple&lt;Types...&gt;&gt;
    : std::integral_constant&lt;size_t, sizeof...(Types)&gt; {};
template &lt;size_t i, typename... Types&gt;
struct tuple_element&lt;i, Tuple&lt;Types...&gt;&gt; {
  using type = TupleType&lt;Tuple&lt;Types...&gt;, i&gt;;
};
}  // namespace std

int main() {
  Tuple tup{1, 2, "foo", "bar", nullptr};
  tup.apply([](auto, auto, auto a, auto b, auto) {
    std::printf("%s %s\n", a, b);
  });

  auto [a, b, c, d, e] = tup;
  std::printf("%d %d\n", a, b);
}
```
</code></pre></div></div> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div> </div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <p>```cpp godbolt:o=–std=c++17,o:-O <a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <p>```cpp godbolt:l=https://godbolt.org/z/eYeb9Y6cn <a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2023-11-27</span> / <h6 style="display:inline"><a href="/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a></h6> <li> <span class="post-meta">2023-09-29</span> / <h6 style="display:inline"><a href="/2023/09/29/what-is-a-matrix/">What is a Matrix? A Miserable Pile of Coefficients!</a></h6> <li> <span class="post-meta">2023-08-09</span> / <h6 style="display:inline"><a href="/2023/08/09/yarns/">I Wrote A String Type </a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>