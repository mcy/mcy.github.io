<!DOCTYPE html> <html lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <a href="https://mcyoung.xyz/"> <img src="https://mcyoung.xyz/public/avatar.png" alt="Yeah, I drew this. Check out my art blog." class="hide-if-mobile"/> </a> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/"> mcyoung </a></h1> <p class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </p> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/">Home</a> • <a class="sidebar-nav-item" href="/about.html">About</a> • <a class="sidebar-nav-item" href="/posts.html">Posts</a> • <a class="sidebar-nav-item" href="/tags.html">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://art.mcyoung.xyz/">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GH</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> </nav> <br class="hide-if-mobile"/> <p class="hide-if-mobile"><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota</p> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post"> <span class="post-meta"> <span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> <a href="https://mcyoung.xyz/tags.html#concurrency">#concurrency</a> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <span> 2023-03-29 </span> </span> <h1 class="post-title"><a href="/2023/03/29/rseq-checkout/"> Atomicless Concurrency </a></h1> <span class="post-meta", style="font-size: 80%;"> <span> <em> 2768 words • 15 minutes </em> </span> </span> <p>Let’s say we’re building an allocator. Good allocators need to serve many threads simultaneously, and as such any lock they take is going to be highly contended. One way to work around this, pioneered by TCMalloc, is to have thread-local caches of blocks (hence, the “TC” - thread cached).</p> <p>Unfortunately threads can be ephemeral, so book-keeping needs to grow dynamically, and large, complex programs (like the Google Search ranking server) can have tens of thousands of threads, so per-thread cost can add up. Also, any time a thread context-switches and resumes, its CPU cache will contain different cache lines – likely the wrong ones. This is because either another thread doing something compeltely different executed on that CPU, or the switched thread <em>migrated</em> to execute on a different core.</p> <p>These days, instead of caching per-thread, TCMalloc uses <em>per-CPU</em> data. This means that book-keeping is fixed, and this is incredibly friendly to the CPU’s cache: in the steady-state, each piece of the data will only ever be read or written to by a single CPU. It also has the amazing property that <em>there are no atomic operations involved</em> in the fast path, because operations on per-CPU data, by definition, do not need to be synchronized with other cores.</p> <p>This post gives an overview of how to build a CPU-local data structure on modern Linux. The exposition will be for x86, but other than the small bits of assembly you need to write, the technique is architecture-independent.</p> <h2 id="the-kernel-primitive"><a href="#the-kernel-primitive">The Kernel Primitive</a></h2> <p>Concurrency primitives require cooperating with the kernel, which is responsible for global scheduling decisions on the system. However, making syscalls is quite expensive; to alieviate this, there has been a trend in Linux to use shared memory as a kernelspace/userspace communication channel.</p> <p><a href="https://en.wikipedia.org/wiki/Futex">Futexes</a> are the classic “cas-with-the-kernel” syscall (I’m assuming basic knowledge of atomic operations like cas in this article). In the happy path, we just need to cas on some memory to lock a futex, and only make a syscall if we need to go to sleep because of contention. The kernel will perform its own cas on this variable if necessary.</p> <p><em>Restartable sequences</em> are another such proto-primitive, which are used for per-CPUuprogramming. The relevant syscall for us, <code class="language-plaintext highlighter-rouge">rseq(2)</code>, was added in Linux 4.18. Its manpage reads</p> <blockquote> <p>A restartable sequence is a sequence of instructions guaranteed to be executed atomically with respect to other threads and signal handlers on the current CPU. If its execution does not complete atomically, the kernel changes the execution flow by jumping to an abort handler defined by userspace for that restartable sequence.</p> </blockquote> <p>A restartable sequence, or “rseq” is a special kind of critical section that the kernel guarantees executes from start to finish without any kind of preemption. If preemption <em>does</em> happen (because of a signal or whatever), userspace observes this as a jump to a special handler for that critical section. Conceptually it’s like handling an exception:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">try</span> <span class="p">{</span>
  <span class="c1">// Per-CPU code here.</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">PremptionException</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Handle having been preempted, which usally just means</span>
  <span class="c1">// "try again".</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>These critical sections are usually of the following form:</p> <ol> <li>Read the current CPU index (the rseq mechanism provides a way to do this).</li> <li>Index into some data structure and do something to it.</li> <li>Complete the operation with a single memory write. This is the “commit”.</li> </ol> <p>All the kernel tells us is that we couldn’t finish successfully. We can always try again, but the critical section needs to be such that executing any prefix of it, up to the commit, has no effect on the data structure. We get no opportunity to perform “partial rollbacks”.</p> <p>In other words, the critical section must be a <em>transaction</em>.</p> <h3 id="enabling-rseq"><a href="#enabling-rseq">Enabling <code class="language-plaintext highlighter-rouge">rseq</code></a></h3> <p>Using rseqs requires turning on support for it for a particular thread; this is what calling <code class="language-plaintext highlighter-rouge">rseq(2)</code> (the syscall) accomplishes.</p> <p>The signature for this syscall looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// This type is part of Linux's ABI.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="n">cpu_id_start</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">cpu_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">crit_sec</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Note: this is a syscall, not an actual Rust function.</span>
<span class="k">fn</span> <span class="nf">rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The syscall registers “the” <code class="language-plaintext highlighter-rouge">Rseq</code> struct for the current thread; there can be at most one, per thread.</p> <p><code class="language-plaintext highlighter-rouge">rseq</code> is a pointer to this struct. <code class="language-plaintext highlighter-rouge">len</code> should be <code class="language-plaintext highlighter-rouge">size_of::&lt;Rseq&gt;()</code>, and <code class="language-plaintext highlighter-rouge">signature</code> can be any 32-bit integer (more on this later). For our purposes, we can ignore <code class="language-plaintext highlighter-rouge">flags</code> on the struct.</p> <p><code class="language-plaintext highlighter-rouge">flags</code> on the syscall, on the other hand, is used to indicate whether we’re unregistering the struct; this is explained below.</p> <p>In the interest of exposition, we’ll call the syscall directly. If you’ve never seen how a Linux syscall is done (on x86), you load the syscall number into <code class="language-plaintext highlighter-rouge">rax</code>, then up to six arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">r10</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code><sup id="fnref:mnemonic" role="doc-noteref"><a href="#fn:mnemonic" class="footnote" rel="footnote">1</a></sup>. We only need the first four.</p> <p>The return value comes out in <code class="language-plaintext highlighter-rouge">rax</code>, which is 0 on success, and a negative of an <code class="language-plaintext highlighter-rouge">errno</code> code otherwise. In particular, we need to check for <code class="language-plaintext highlighter-rouge">EINTR</code> to deal with syscall interruption. (every Linux syscall can be interrupted).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">unregister</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Perform an open-coded Linux syscall.</span>
  <span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rax</span> <span class="o">=</span> <span class="mi">334</span><span class="p">;</span>  <span class="c1">// rseq(2) syscall number; x86-specific.</span>
    <span class="nd">asm!</span> <span class="p">{</span>
      <span class="s">"syscall"</span><span class="p">,</span>
      <span class="nf">inout</span><span class="p">(</span><span class="s">"rax"</span><span class="p">)</span> <span class="n">rax</span><span class="p">,</span>
      <span class="cm">/* rseq:      */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdi"</span><span class="p">)</span> <span class="n">rseq</span><span class="p">,</span>
      <span class="cm">/* len:       */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rsi"</span><span class="p">)</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;</span><span class="p">(),</span>
      <span class="cm">/* flags:     */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdx"</span><span class="p">)</span> <span class="n">unregister</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">,</span>
      <span class="cm">/* signature: */</span> <span class="k">in</span><span class="p">(</span><span class="s">"r10"</span><span class="p">)</span> <span class="n">signature</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">match</span> <span class="n">rax</span> <span class="p">{</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>      <span class="c1">// Success, we're done.</span>
      <span class="o">-</span><span class="mi">4</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>  <span class="c1">// EINTR, try again.</span>
      <span class="n">errno</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"error calling rseq(2): {}"</span><span class="p">,</span> <span class="o">-</span><span class="n">errno</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note the <code class="language-plaintext highlighter-rouge">unregister</code> parameter: this is used to tear down <code class="language-plaintext highlighter-rouge">rseq</code> support on the way out of a thread. Generally, <code class="language-plaintext highlighter-rouge">rseq</code> will be a thread-local, and registration happens at thread startup. Glibc will do this and has a mechanism for acquiring the <code class="language-plaintext highlighter-rouge">rseq</code> pointer. Unfortunately, the glibc I have isn’t new enough to know to do this, so I hacked up something to register my own thread local.</p> <p>I had the bright idea of putting my <code class="language-plaintext highlighter-rouge">Rseq</code> struct in a box, which triggered an interesting bug: when a thread exits, it destroys all of the thread local variables, including the box to hold our <code class="language-plaintext highlighter-rouge">Rseq</code>. But if the thread then syscalls to deallocate its stack, when the kernel goes to resume, it will attempt to write the current CPU index to the <code class="language-plaintext highlighter-rouge">rseq.cpu_id</code> field.</p> <p>This presents a problem, because the kernel is probably going to write to a garbage location. This is all but guaranteed to result in a segfault. Debuggers observe this as a segfault on the instruction right after the <code class="language-plaintext highlighter-rouge">syscall</code> instruction; I spent half an hour trying to figure out what was causing a call to <code class="language-plaintext highlighter-rouge">madvise(2)</code> to segfault.</p> <p>Hence, we need to wrap our thread local in something that will call <code class="language-plaintext highlighter-rouge">rseq(2)</code> to unregister the struct. Putting everything together we get something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">current_thread_rseq</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="c1">// This has to be its own struct so we can run a thread-exit destructor.</span>
  <span class="k">pub</span> <span class="k">struct</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;&gt;</span><span class="p">);</span>
  <span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">RseqBox</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="k">true</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nd">thread_local!</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">RSEQ</span><span class="p">:</span> <span class="n">RseqBox</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// Has to be in a box, since we need pointer stability.</span>
      <span class="k">let</span> <span class="n">rseq</span> <span class="o">=</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Rseq</span> <span class="p">{</span>
        <span class="n">cpu_id_start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">cpu_id</span><span class="p">:</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">crit_sec</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="p">})));</span>

      <span class="c1">// Register it!!!</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
      <span class="n">rseq</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="n">RSEQ</span><span class="nf">.with</span><span class="p">(|</span><span class="n">ra</span><span class="p">|</span> <span class="n">ra</span><span class="na">.0</span><span class="nf">.get</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Per Rust’s semantics, this will execute the first time we access this thread local, instead of at thread startup. Not <em>ideal</em>, since now we pay for an (uncontended) atomic read every time we touch RSEQ, but it will do.</p> <h3 id="creating-a-critical-section"><a href="#creating-a-critical-section">Creating a Critical Section</a></h3> <p>To set up and execute a restartable sequence, we need to assemble a struct that describes it. The following struct is also defined by Linux’s syscall ABI:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CritSec</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">abort_handler</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">start</code> is the address of the first instruction in the sequence, and <code class="language-plaintext highlighter-rouge">len</code> is the length of the sequence in bytes. <code class="language-plaintext highlighter-rouge">abort_handler</code> is the address of the abort handler. <code class="language-plaintext highlighter-rouge">version</code> must be 0 and we can ignore <code class="language-plaintext highlighter-rouge">flags</code>.</p> <p>Once we have a value of this struct (on the stack or as a constant), we grab <code class="language-plaintext highlighter-rouge">RSEQ</code> and atomically store the address of our <code class="language-plaintext highlighter-rouge">CritSec</code> to <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code>. This needs to be atomic because the kernel may decide to look at this pointer from a different CPU core, but it likely will not be contended.</p> <p>Note that <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> should be null before we do this; restartable sequences can’t nest.</p> <p>Next time the kernel preempts our thread (and later gets ready to resume it), it will look at <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to decide if it preempted a restartable sequence and, if so, jump to the abort handler.</p> <p>Once we finish our critical section, we must reset <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to 0.</p> <blockquote> <h4 id="labels-and-constants-oh-my"><a href="#labels-and-constants-oh-my">Labels and Constants, Oh My</a></h4> <p>There is a wrinkle: we would like for our <code class="language-plaintext highlighter-rouge">CritSec</code> value to be a constant, but Rust doesn’t provide us with a way to initialize the <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">abort_handler</code> fields directly, since it doesn’t have a way to refer<sup id="fnref:relocations" role="doc-noteref"><a href="#fn:relocations" class="footnote" rel="footnote">2</a></sup> to the labels (jump targets) inside the inline assembly. The simplest way to get around this is to assemble (lol) the <code class="language-plaintext highlighter-rouge">CritSec</code> on the stack, with inline assembly. The overhead is quite minimal.</p> </blockquote> <p>On x86, this is what our boilerplate will look like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">cs</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">CritSec</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nd">asm!</span> <span class="p">{</span><span class="s">r"
  // We meed to do `rip`-relative loads so that this code is PIC;
  // otherwise we'll get linker errors. Thus, we can't `mov`
  // directly; we need to compute the address with a `lea`
  // first.

  // Initialize the first two fields to zero.
  mov qword ptr [{_cs}], 0

  // Load `90f` into `cs.start`. Note that this is 'forward
  // reference' to the jump target `90:` below.
  lea {_pc}, [90f + rip]
  mov qword ptr [{_cs} + 8], {_pc}

  // We need to get the difference `91f - 90f` into `cs.len`.
  // To do that, we write `-90f` to it, and then add `91f`.
  neg {_pc}
  mov qword ptr [{_cs} + 16], {_pc}
  lea {_pc}, [91f + rip]
  add qword ptr [{_cs} + 16], {_pc}

  // Same as the first line, but loading `cs.abort_handler`.
  lea {_pc}, [92f + rip]
  mov qword ptr [{_cs} + 24], {_pc}

  // Write `&amp;cs` to `RSEQ.crit_sec`. This turns on
  // restartable sequence handling.
  mov qword ptr [{rseq} + 8], {_cs}

90:
  // Do something cool here (coming soon).

91:
  // Jump over the abort handler.
  jmp 93f

  .int 0x53053053  // The signature!
92:
  // Nothing special, just zero `ok` to indicate this was a failure.
  // This is written this way simply because we can't early-return
  // out of inline assembly.
  xor {_ok:e}, {_ok:e}

93:
  // Clear `RSEQ.crit_sec`, regardless of which exit path
  // we took.
  mov qword ptr [{rseq} + 8], 0
  "</span><span class="p">,</span>
  <span class="n">_pc</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
  <span class="n">_ok</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ok</span><span class="p">,</span>
  <span class="n">_cs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cs</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CritSec</span><span class="p">,</span>
  <span class="n">rseq</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="nf">current_thread_rseq</span><span class="p">(),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>A few things to note:</p> <ol> <li>Because this is inline assembly, we need to use numeric labels. I’ve chosen labels in the 90s for no particular reason. <code class="language-plaintext highlighter-rouge">90:</code> declares a jump target, and <code class="language-plaintext highlighter-rouge">90f</code> is a forward reference to that instruction address.</li> <li>Most of this assembly is just initalizing a struct<sup id="fnref:cs-init" role="doc-noteref"><a href="#fn:cs-init" class="footnote" rel="footnote">3</a></sup>. It’s not until the <code class="language-plaintext highlighter-rouge">mov</code> right before <code class="language-plaintext highlighter-rouge">90:</code> (the critical section start) that anything interesting happens.</li> <li>Immediately before <code class="language-plaintext highlighter-rouge">92:</code> (the abort handler) is an <code class="language-plaintext highlighter-rouge">.int</code> directive that emits the same four-byte signature we passed to <code class="language-plaintext highlighter-rouge">rseq(2)</code> into the instruction stream. This <em>must</em> be here, otherwise the kernel will issue a segfault to the thread. This is a very basic control-flow integrity feature.</li> <li>We clear <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> at the very end.</li> </ol> <p>This is a lot of boilerplate. In an ideal world, we could have something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">run_rseq</span><span class="p">(</span><span class="n">cs</span><span class="p">:</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">unsafe</span> <span class="k">fn</span><span class="p">(</span><span class="nb">u32</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this is very hard to do, because the constraints on restartable sequences are draconian:</p> <ul> <li>Can’t jump out of the critical section until it completes or aborts. This means you can’t call functions or make syscalls!</li> <li>Last instruction must be the commit, which is a memory store operation, <em>not</em> a return.</li> </ul> <p>This means that you can’t have the compiler generating code for you; it might outline things or move things around in ways you don’t want. In something like ASAN mode, it might inject function calls that will completely break the primitive.</p> <p>This means we muyst write our critical section in assembly. That assembly also almost unavoidably needs to be part of the boilerplate given above, and it means it can’t participate in ASAN or TSAN instrumentation.</p> <p>In the interest of exposition, we can build a wrapper over this inline assembly boilerplate that looks something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
    // Assembly for our critical section...
  "</span><span class="p">,</span>
  <span class="c1">// Inline asm constraints.</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>When I wrote the snippet above, I chose numeric labels in the 90s to avoid potential conflicts with whatever assembly gets pasted here. This is also why I used a leading <code class="language-plaintext highlighter-rouge">_</code> on the names of some of the assembly constraints; thise are private to the macro. <code class="language-plaintext highlighter-rouge">rseq</code> isn’t, though, since callers will want to access the CPU id in it.</p> <p>The intent is for the assembly string to be pasted over the <code class="language-plaintext highlighter-rouge">// Do something cool here</code> comment, and for the constraints to be tacked on after the boilerplate’s constraints.</p> <p>But with that we now have access to the full rseq primitive, in slightly sketchy macro form. Let’s use it to build a CPU-local data structure.</p> <h2 id="a-checkout-desk"><a href="#a-checkout-desk">A Checkout Desk</a></h2> <p>Let’s say we have a pool of objects that are needed to perform an allocation, our putative page caches. Let’s say we have the following interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">FreeList</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">get_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">return_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">get_cache()</code> grabs a cache of pages off the global free list. This requires taking a lock or traversing a lockless linked list, so it’s pretty expensive. <code class="language-plaintext highlighter-rouge">return_cache()</code> returns a cache back to the global free list for re-use; it is a similarly expensive operation. Both of these operations are going to be contended like crazy, so we want to memoize them.</p> <p>To achieve this, we want one slot for every CPU to hold the cache it (or rather, a thread running on it) most recently acquired, so that it can be reused. These slots will have “checkout desk” semantics: if you take a thing, you must put something in its place, even if it’s just a sign that says you took the thing.</p> <figure> <p><img src="https://mcyoung.xyz/public/golden-idol.gif" alt=""/></p> </figure> <p><a href="https://fowles.github.io/">Matthew Kulukundis</a> came up with this idea, and he’d totally put this gif in a slide deck about this data structure.</p> <p>As a function signature, this is what it looks like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We can then use it like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">free_list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FreeList</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">per_cpu</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">PageCache</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">iou</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>

<span class="c1">// Check out this CPU's cache pointer, and replace it with</span>
<span class="c1">// an IOU note (a null pointer).</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">iou</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">==</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// If we got an IOU ourselves, this means another thread that</span>
  <span class="c1">// was executing on this CPU took the cache and left *us* with</span>
  <span class="c1">// a null, so we need to perform the super-expensive operation</span>
  <span class="c1">// to acquire a new one.</span>
  <span class="n">cache</span> <span class="o">=</span> <span class="n">free_list</span><span class="nf">.get_cache</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Do stuff with `cache` here. We have unique access to it.</span>
<span class="n">cache</span><span class="nf">.alloc_page</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

<span class="c1">// Return the pointer to the checkout desk.</span>
<span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">!=</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// Usually, we expect to get back the IOU we put into the cache.</span>
  <span class="c1">// If we don't, that probably means another thread (or</span>
  <span class="c1">// hundreds) are hammering this slot and fighting for page caches.</span>
  <span class="c1">// If this happens, we need to throw away the cache.</span>
  <span class="n">free_list</span><span class="nf">.return_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The semantics of <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> is that it is an array of <code class="language-plaintext highlighter-rouge">nprocs</code> (the number of logical cores on the system) pointers, all initialized to null. <code class="language-plaintext highlighter-rouge">checkout()</code> swaps the pointer stored in the current CPU’s slot in the <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> with the replacement argument.</p> <h3 id="building-the-checkout-desk"><a href="#building-the-checkout-desk">Building the Checkout Desk</a></h3> <p>The implementation of this type is relatively simple, but the devil is in the details. Naively, you’d think you literally want an array of pointers:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this is cache-hostile. We expect that (depending on how <code class="language-plaintext highlighter-rouge">ptrs</code> is aligned in memory) for eight CPUs’ checkout pointers to be on the same cache line. This means eight separate cores are going to be writing to the same cache line, which is going to result in a lot of cache thrash. This memory wants to be in L1 cache, but will probably wind up mostly in shared L3 cache.</p> <p>This effect is called “false sharing”, and is a fundamental part of the design of modern processors. We have to adjust for this.</p> <p>Instead, we want to give each core a full cache line (64 bytes aligned to a 64-byte boundary) for it to store its pointer in. This sounds super wasteful (56 of those bytes will go unused), but this is the right call for a perf-sensitive primitive.</p> <p>This amount of memory can add up pretty fast (two whole pages of memory for a 128-core server!), so we’ll want to lazilly initialize them. Our cache-friendly struct will look more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">AtomicPtr</span><span class="o">&lt;</span><span class="n">CacheLine</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// This struct wraps a T and forces it to take up an entire cache line.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">64</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CacheLine</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Initializing it requires finding out how many cores there are on the machine. This is a… fairly platform-specific affair. Rust <em>does</em> offer a “maximum paralellism” query in its standard library, but it is intended as a hint for how many worker threads to spawn, as opposed to a hard upper bound on the number of CPU indices.</p> <p>Instead, we call <code class="language-plaintext highlighter-rouge">get_nprocs_conf()</code>, which is fine since we’re already extremely non-portable already. This is a GNU libc extension.</p> <p>In code…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
      <span class="c1">// #include &lt;sys/sysinfo.h&gt;</span>
      <span class="c1">//</span>
      <span class="c1">// This function returns the maximum number of cores the</span>
      <span class="c1">// kernel knows of for the current machine. This function</span>
      <span class="c1">// is very expensive to call, so we need to cache it.</span>
      <span class="k">fn</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">mut</span> <span class="n">NPROCS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">INIT</span><span class="p">:</span> <span class="n">Once</span> <span class="o">=</span> <span class="nn">Once</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">INIT</span><span class="nf">.call_once</span><span class="p">(||</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">NPROCS</span> <span class="o">=</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">NPROCS</span> <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="p">{</span>
      <span class="n">ptrs</span><span class="nf">.push</span><span class="p">(</span><span class="nn">AtomicPtr</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span> <span class="n">ptrs</span><span class="p">:</span> <span class="n">ptrs</span><span class="nf">.into_boxed_slice</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(I’m not going to implement <code class="language-plaintext highlighter-rouge">Drop</code> for this type. That’s an exercise for the reader.)</p> <h3 id="implementing-checkout"><a href="#implementing-checkout">Implementing <code class="language-plaintext highlighter-rouge">checkout()</code></a></h3> <p>Now’s the moment we’ve all be waiting for: writing our restartable sequence. As critical sections go, this one’s pretty simple:</p> <ol> <li>Index into the <code class="language-plaintext highlighter-rouge">ptrs</code> array to get this CPU’s pointer-to-cache-line.</li> <li>If that pointer is null, bail out of the rseq and initialize a fresh cache line (and then try again).</li> <li>If it’s not null, swap <code class="language-plaintext highlighter-rouge">replacement</code> with the value in the cache line.</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
    <span class="c1">// We need to try this operation in a loop, to deal with</span>
    <span class="c1">// rseq aborts.</span>
    <span class="k">loop</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="nf">.as_ptr</span><span class="p">();</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">vcpu</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">need_alloc</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
        // Load the current CPU number.
        mov {vcpu:e}, dword ptr [{rseq} + 4]

        // Load the `vcpu`th pointer from `ptrs`.
        // On x86, `mov` is atomic. The only threads we might
        // be condending with are those that are trying to
        // initialize this pointer if it's null.
        mov {scratch}, qword ptr [{ptrs} + 8 * {vcpu:r}]

        // If null, exit early and trigger an allocation
        // for this vcpu.
        test {scratch}, {scratch}
        jz 1f

        // Make sure the outer code knows not to allocate
        // a new cache line.
        xor {need_alloc:e}, {need_alloc:e}

        // Commit the checkout by exchanging `replacement`.
        xchg {ptr}, qword ptr [{scratch}]
      1:
        "</span><span class="p">,</span>
        <span class="n">ptrs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ptrs</span><span class="p">,</span>
        <span class="n">scratch</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">replacement</span><span class="p">,</span>
        <span class="n">vcpu</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">vcpu</span><span class="p">,</span>
        <span class="n">need_alloc</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">need_alloc</span><span class="p">,</span>
      <span class="p">};</span>

      <span class="c1">// We got preempted, so it's time to try again.</span>
      <span class="k">if</span> <span class="n">result</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>

      <span class="c1">// If we don't need to allocate, we're done.</span>
      <span class="k">if</span> <span class="n">need_alloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="n">replacement</span> <span class="p">}</span>

      <span class="c1">// Otherwise, allocate a new cache line and cas it into</span>
      <span class="c1">// place. This is Atomics 101, nothing fancy.</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache_line</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">CacheLine</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
      <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cas</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="p">[</span><span class="n">vcpu</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span><span class="nf">.compare_exchange_weak</span><span class="p">(</span>
          <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span> <span class="n">cache_line</span><span class="nf">.as_mut</span><span class="p">(),</span>
          <span class="nn">Ordering</span><span class="p">::</span><span class="n">AcqRel</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="k">match</span> <span class="n">cas</span> <span class="p">{</span>
          <span class="nf">Ok</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Successful allocation.</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_null</span><span class="p">());</span>
            <span class="c1">// Make sure to stop `cache_line`'s memory</span>
            <span class="c1">// from being freed by `Box`'s dtor.</span>
            <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">cache_line</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Try again: this is a spurious failure.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="nf">.is_null</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
          <span class="c1">// Someone got here first; we can just discard</span>
          <span class="c1">// `Box`.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This code listing is a lot to take in. It can be broken into two parts: the restartable sequence itself, and the allocation fallback if the pointer-to-cache-line happens to be null.</p> <p>The restartable sequence is super short. It looks at the pointer-to-cache-line, bails if its null (this triggers the later part of the function) and then does an <code class="language-plaintext highlighter-rouge">xchg</code> between the actual <code class="language-plaintext highlighter-rouge">*mut T</code> in the per-CPU cache line, and the replacement.</p> <p>If the rseq aborts, we just try again. This is short enough that preemption in the middle of the rseq is quite rare. Then, if <code class="language-plaintext highlighter-rouge">need_alloc</code> was zeroed, that means we successfully committed, so we’re done.</p> <p>Otherwise we need to allocate a cache line for this CPU. We’re now outside of the rseq, so we’re back to needing atomics. Many threads might be racing to be the thread that initializes the pointer-to-cache-line; we use a basic cas loop to make sure that we only initialize from null, and if someone beats us to it, we don’t leak the memory we had just allocated. This is an RMW operation, so we want both acquire and release ordering. Atomics 101!</p> <p>Then, we try again. Odds are good we won’t have migrated CPUs when we execute again, so we won’t need to allocate again. Eventually all of the pointers in the <code class="language-plaintext highlighter-rouge">ptrs</code> array will be non-null, so in the steady state this <code class="language-plaintext highlighter-rouge">needs_alloc</code> case doesn’t need to happen.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is just a glimpse of what per-CPU concurrent programming looks like. I’m pretty new to it myself, and this post was motivated by building an end-to-end example in Rust. You can read more about how TCMalloc makes use of restartable sequences <a href="https://google.github.io/tcmalloc/rseq.html">here</a>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:mnemonic" role="doc-endnote"> <p>This is annoyingly <em>different</em> from the function calling convention, which passes arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, with the mnemonic “Diana’s silk dress cost $89.” I don’t know a cute mnemonic for the syscall registers. <a href="#fnref:mnemonic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:relocations" role="doc-endnote"> <p>It’s actually worse than that. You’d think you could do</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">jmp</span> <span class="n">foo</span>
<span class="n">pointers</span><span class="o">:</span>
  <span class="p">.</span><span class="kt">int</span> <span class="n">foo</span>

<span class="n">foo</span><span class="o">:</span>
  <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">pointers</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>but this makes the resulting code non-position-independent on x86. What this means is that the code must know at link time what address it will be loaded at, which breaks the position-independent requirement of many modern platforms.</p> <p>Indeed, this code will produce a linker error like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">= note: /usr/bin/ld: /home/mcyoung/projects/cpulocal/target/debug/deps/cpulocal-a7eeabaf0b1f2c43.2l48u2rfiak1q1ik.rcgu.o:
      relocation R_X86_64_32 against `.text._ZN8cpulocal15PerCpu$LT$T$GT$8checkout17h42fde3ce3bd0180aE'
      can not be used when making a PIE object; recompile with -fPIE
      collect2: error: ld returned 1 exit status</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Not only is <code class="language-plaintext highlighter-rouge">.int foo</code> a problem, but so is referring to <code class="language-plaintext highlighter-rouge">pointers</code>. Instead we must write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">lea</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">pointers</span> <span class="o">+</span> <span class="n">rip</span><span class="p">]</span>
<span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>to be able to load the address of <code class="language-plaintext highlighter-rouge">pointers</code> at all. This <em>can</em> be worked around if you’re smart; after all, it is possible to put the addresses of functions into static variables and not have the linker freak out. It’s too hard to do in inline assembly tho. <a href="#fnref:relocations" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:cs-init" role="doc-endnote"> <p>Basically this code, which can’t be properly-expressed in Rust.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">CrtiticalSection</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="cm">/* &amp;90f */</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="cm">/* &amp;91f - &amp;90f */</span><span class="p">,</span>
  <span class="n">abort</span><span class="p">:</span> <span class="cm">/* &amp;92f */</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><a href="#fnref:cs-init" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post"> <span class="post-meta"> <span> <a href="https://mcyoung.xyz/tags.html#etc">#etc</a> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> </span> <span> 2022-07-24 </span> </span> <h1 class="post-title"><a href="/2022/07/24/curta/"> 3Hz Computer, Hold the Transistors<br/> </a></h1> <span class="post-meta", style="font-size: 80%;"> <span> <em> 2777 words • 15 minutes </em> </span> </span> <p>I’m not really one to brag publicly about expensive toys, but a few weeks ago I managed to get one that’s really something special. It is a <em>Curta Type II</em>, a mechanical digital<sup id="fnref:mech-digital" role="doc-noteref"><a href="#fn:mech-digital" class="footnote" rel="footnote">1</a></sup> calculator manufactured in Liechtenstein between the 50s and 70s, before solid-state calculators killed them and the likes of slide-rules.</p> <p>I have wanted one since I was a kid, and I managed to win an eBay auction for one.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/with_case.jpg" alt="The Curta"/></p> <figcaption>The Curta Type II (and Solomon the cat)</figcaption> </figure> <p>It’s a funny looking device, somewhere between a peppermill and a scifi grenade. Mine has serial number 544065, for those keeping score, and comes in a cute little bakelite pod (which has left hand thread?!).</p> <p>I wanna talk about this thing because unlike something like a slide rule, it shares many features with modern computers. It has operations, flags, and registers. Its core primitive is an adder, but many other operations can be built on top of it: it is very much a platform for complex calculations.</p> <p>I’m the sort of person who read <em>Hacker’s Delight</em> for fun, so I really like simple numerical algorithms. This article is a survey of the operation of a Curta calculator and algorithms you can implement on it, from the perspective of a professional assembly programmer.</p> <p>Many of the algorithms I’m going to describe here exist online, but I’ve found them to be a bit difficult to wrap my head around, so this article is also intended as a reference card for myself.</p> <p>Let’s dive in!</p> <h2 id="a-well-lubricated-alu"><a href="#a-well-lubricated-alu">A Well-Lubricated ALU</a></h2> <p>There are two Curta models, Type I and Type II, which primarily differ in the sizes of their registers. I have a Type II, so I will focus on the layout of that one.</p> <p>The Curta is not a <em>stored program</em> computer like the one you’re reading this article on. An operator needs to manually execute operations. It is as if we had taken a CPU and pared it down to two of its most basic components: a register file and an arithmetic logic unit (ALU).</p> <h3 id="the-register-file"><a href="#the-register-file">The Register File</a></h3> <p>The Curta’s register file consists of three digital registers, each of which contains a decimal integer (i.e., each digit is from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">9</code>, rather than <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">1</code> like on a binary computer):</p> <ul> <li><code class="language-plaintext highlighter-rouge">sr</code>, the <em>setting register</em>, is located on the side of the device. The value in <code class="language-plaintext highlighter-rouge">sr</code> can be set manually by the operator using a set of knobs on the side of the device. The machine will never write to it, only read from it. It has 11 digits.</li> <li><code class="language-plaintext highlighter-rouge">rr</code>, the <em>results register</em>, is located at the top of the device along the black part of the dial. It is readable and writable by the machine, but not directly modifiable by the operator. It has 15 digits.</li> <li><code class="language-plaintext highlighter-rouge">cr</code>, the <em>counting register</em>, is located next to <code class="language-plaintext highlighter-rouge">rr</code> along the silver part of the dial. Like <code class="language-plaintext highlighter-rouge">rr</code>, it is only machine-modifiable. It has 8 digits.</li> </ul> <figure> <p><img src="https://mcyoung.xyz/public/curta/sr.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">sr</code>, set to <code class="language-plaintext highlighter-rouge">1997</code>.</p> </figcaption> </figure> <figure> <p><img src="https://mcyoung.xyz/public/curta/cr_rr.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">rr</code> is the black dial; <code class="language-plaintext highlighter-rouge">cr</code> is the silver one.</p> </figcaption> </figure> <p>There are also two settings on the device that aren’t really registers, but, since they are changed as part of operation, they are a lot like the control registers of a modern computer.</p> <p>The <em>carriage</em> (there isn’t an abbreviation for this one, so I’ll call it <code class="language-plaintext highlighter-rouge">ca</code>) is the upper knurled ring on the machine. It can be set to a value from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">7</code><sup id="fnref:one-index" role="doc-noteref"><a href="#fn:one-index" class="footnote" rel="footnote">2</a></sup>. To set it, the operator lifts the ring up (against spring tension), twists it, and lets it spring back into the detent for the chosen value. This is a one-hand motion.</p> <p>There is a small triangle in the middle of the top of the device that points at which of the digits in <code class="language-plaintext highlighter-rouge">cr</code> will get incremented.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/ca.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">ca</code> raised and in motion.</p> </figcaption> </figure> <p>Finally, <code class="language-plaintext highlighter-rouge">rl</code>, the <em>reversing lever</em>, is a small switch near the back of the device that can be in the up or down position. This is like a flag register: up is cleared, down is set.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/rl.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">rl</code> in the up position.</p> </figcaption> </figure> <h3 id="the-instruction-set"><a href="#the-instruction-set">The Instruction Set</a></h3> <p>We have all this memory, but the meat of a machine is what it can <em>do</em>. I will provide an <em>instruction set</em> for the Curta to aid in giving rigorous descriptions of operations you can perform with it.</p> <p>The core operation of the Curta is “add-with-shift-and-increment”. This is a mouthful. At the very top of the machine is the handle, which is analogous to a clock signal pin. Every clockwise turn of this handle executes one of these operations. Internally, this is implemented using a variation on the <a href="https://en.wikipedia.org/wiki/Leibniz_wheel">Leibniz gear</a>, a common feature of mechanical calculators.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/pturn.jpg" alt=""/></p> <figcaption>The handle in "addition" mode.</figcaption> </figure> <p>This operation is not that complicated, it just does a lot of stuff. It takes the value of <code class="language-plaintext highlighter-rouge">sr</code>, left-shifts it (in decimal) by the value in <code class="language-plaintext highlighter-rouge">ca</code>, and adds it to <code class="language-plaintext highlighter-rouge">rr</code>. Also, it increments <code class="language-plaintext highlighter-rouge">CR</code> by <code class="language-plaintext highlighter-rouge">1</code> shifted by <code class="language-plaintext highlighter-rouge">ca</code>. In other words:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">rr += sr &lt;&lt; ca
cr += 1 &lt;&lt; ca</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Recall that this is a decimal machine, so <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> is the same as multiplication by a power of 10, not a power of 2.</p> <p>Addition can overflow, and it wraps around as expected: adding one to <code class="language-plaintext highlighter-rouge">999_999_999_999_999_999</code> already in <code class="language-plaintext highlighter-rouge">rr</code> will fill it with zeroes.</p> <p>Pulling the handle up reveals a red ring, indicating the machine is in <em>subtraction mode</em>. This flips the signs of both the <code class="language-plaintext highlighter-rouge">rr</code> and <code class="language-plaintext highlighter-rouge">cr</code> modifications:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">rr -= sr &lt;&lt; ca
cr -= 1 &lt;&lt; ca</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <figure> <p><img src="https://mcyoung.xyz/public/curta/mturn.jpg" alt=""/></p> <figcaption>The handle in "subtraction" mode.</figcaption> </figure> <p>The Curta cannot handle negative numbers, so it will instead display the ten’s complement<sup id="fnref:10s-cmp" role="doc-noteref"><a href="#fn:10s-cmp" class="footnote" rel="footnote">3</a></sup> of a negative result. For example, subtracting <code class="language-plaintext highlighter-rouge">1</code> from <code class="language-plaintext highlighter-rouge">0</code> will produce all-nines.</p> <p>You can detect when underflow or overflow occurs when the resulting value is unexpectedly larger or smaller than the prior value in <code class="language-plaintext highlighter-rouge">rr</code>, respectively. (This trick is necessary on architectures that lack a carry flags register, like RISC-V.)</p> <p>Setting <code class="language-plaintext highlighter-rouge">rl</code> will reverse the sign of the operation done on <code class="language-plaintext highlighter-rouge">cr</code> during a turn of the handle. In addition mode, it will cause <code class="language-plaintext highlighter-rouge">cr</code> to be subtracted from, while in subtraction mode, it will cause it to be added to. Some complex algorithms make use of this.</p> <p>Finally, the <em>clearing lever</em> can be used to clear (to zero) <code class="language-plaintext highlighter-rouge">sr</code> or <code class="language-plaintext highlighter-rouge">rr</code>, independently. It is a small ring-shaped lever that, while the carriage is raised, can be wiped past digits to clear them. Registers cannot be partially cleared.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/pturn.jpg" alt=""/></p> <figcaption>The clearing lever.</figcaption> </figure> <h3 id="notation"><a href="#notation">Notation</a></h3> <p>Let’s give names to all the instructions the operator needs to follow, so we can write some assembly:</p> <ul> <li><code class="language-plaintext highlighter-rouge">mr</code>, or <em>Machine Ready!</em>, means to clear/zero every register. All Curta instructions use the term “Machine Ready” to indicate the beginning of a calculation session.</li> <li><code class="language-plaintext highlighter-rouge">pturn</code> is the core addition operation, a “plus turn”.</li> <li><code class="language-plaintext highlighter-rouge">mturn</code> is its subtraction twin, a “minus turn”.</li> <li><code class="language-plaintext highlighter-rouge">set &lt;flag&gt;</code> requests the operator set one of <code class="language-plaintext highlighter-rouge">rl</code> or <code class="language-plaintext highlighter-rouge">sm</code>.</li> <li><code class="language-plaintext highlighter-rouge">clr &lt;flag&gt;</code> is the opposite of <code class="language-plaintext highlighter-rouge">set</code>.</li> <li><code class="language-plaintext highlighter-rouge">zero &lt;reg&gt;</code> request a clear of one of <code class="language-plaintext highlighter-rouge">rr</code> or <code class="language-plaintext highlighter-rouge">cr</code> using the clearing lever.</li> <li><code class="language-plaintext highlighter-rouge">add &lt;reg&gt;, &lt;imm&gt;</code> requests manual addition of an immediate to <code class="language-plaintext highlighter-rouge">sr</code> or <code class="language-plaintext highlighter-rouge">ca</code>. This is limited by what mental math we can ask of the operator.</li> <li><code class="language-plaintext highlighter-rouge">copy &lt;reg&gt;, sr</code> requests a copy of the value in <code class="language-plaintext highlighter-rouge">rr</code> or <code class="language-plaintext highlighter-rouge">cr</code> to <code class="language-plaintext highlighter-rouge">sr</code>.</li> <li><code class="language-plaintext highlighter-rouge">wrnp &lt;reg&gt;, &lt;symbol&gt;</code> indicates we need to write down a value in any register to a handy notepad (hence <code class="language-plaintext highlighter-rouge">wr</code>ite <code class="language-plaintext highlighter-rouge">n</code>ote<code class="language-plaintext highlighter-rouge">p</code>ad), marked with <code class="language-plaintext highlighter-rouge">&lt;symbol&gt;</code>.</li> <li><code class="language-plaintext highlighter-rouge">rdnp &lt;reg&gt;, &lt;symbol&gt;</code> asks the operator to <code class="language-plaintext highlighter-rouge">re</code>ad a value recorded with <code class="language-plaintext highlighter-rouge">wrnp</code>.</li> <li><code class="language-plaintext highlighter-rouge">if &lt;cond&gt;, &lt;label&gt;</code> asks the operator to check a condition (in terms of <code class="language-plaintext highlighter-rouge">cr</code>, <code class="language-plaintext highlighter-rouge">rr</code>, and <code class="language-plaintext highlighter-rouge">sr</code>) and, if true, proceed to the instruction at the given <code class="language-plaintext highlighter-rouge">label:</code>. Here’s some examples of conditions we’ll use: <ul> <li><code class="language-plaintext highlighter-rouge">rr == 42</code>, i.e., <code class="language-plaintext highlighter-rouge">rr</code> equals some constant value.</li> <li><code class="language-plaintext highlighter-rouge">rr.ovflow</code>, i.e., <code class="language-plaintext highlighter-rouge">rr</code> overflowed/underflowed due to the most recent <code class="language-plaintext highlighter-rouge">pturn</code>/<code class="language-plaintext highlighter-rouge">mturn</code>.</li> <li><code class="language-plaintext highlighter-rouge">cr[1] == 9</code>, i.e. <code class="language-plaintext highlighter-rouge">cr</code>’s second digit (zero-indexed, not like the physical device!) equals <code class="language-plaintext highlighter-rouge">9</code>.</li> <li><code class="language-plaintext highlighter-rouge">cr[0..ca] &lt; sr[0..ca]</code>, i.e., <code class="language-plaintext highlighter-rouge">cr</code>, considering only the digits up to the setting of <code class="language-plaintext highlighter-rouge">ca</code>, is less than those same digits in <code class="language-plaintext highlighter-rouge">sr</code>.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">goto &lt;label&gt;</code> is like <code class="language-plaintext highlighter-rouge">if</code> without a condition.</li> <li><code class="language-plaintext highlighter-rouge">done</code> means we’re done and the result can be read off of <code class="language-plaintext highlighter-rouge">rr</code> (or <code class="language-plaintext highlighter-rouge">cr</code>).</li> </ul> <p>Note that there is a lot of mental math in some of the conditions. Algorithms on the Curta are aimed to minimize what work the operator needs to do to compute a result, but remember that it is only an ALU: all of the control flow logic needs to be provided by the human operator.</p> <p>None of this is real code, and it is specifically for the benefit of readers.</p> <h2 id="some-algorithms"><a href="#some-algorithms">Some Algorithms</a></h2> <p>So, addition and subtraction are easy, because there are hardware instructions for those. There is, however, no direct way to do multiplication or division. Let’s take a look at some of our options.</p> <p>Given that a Curta is kinda expensive, you can try out an online simulator if you want to follow along. <a href="https://www.cailliau.org/en/Alphabetical/C/Computing/Curta/Simulator/">This one</a> is pretty simple and runs in your browser.</p> <h3 id="multiplication"><a href="#multiplication">Multiplication</a></h3> <p>The easiest way to do multiplication is by repeated addition; <code class="language-plaintext highlighter-rouge">cr</code> helps us check our work.</p> <p>Given a value like <code class="language-plaintext highlighter-rouge">8364</code>, we can multiply it by <code class="language-plaintext highlighter-rouge">5</code> like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">mul_by_5:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">8364</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="mi">5</span><span class="p">,</span> <span class="n">end</span>
    <span class="n">pturn</span>
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Here, we input the larger factor into <code class="language-plaintext highlighter-rouge">sr</code>, and then keep turning until <code class="language-plaintext highlighter-rouge">cr</code> contains the other factor. The result is <code class="language-plaintext highlighter-rouge">41820</code>:</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/mul.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">8364 * 5 == 41820</code></p> </figcaption> </figure> <p>Of course, this does not work well for complex products, such as squaring <code class="language-plaintext highlighter-rouge">41820</code>. You could sit there and turn the handle forty thousand times if you wanted to, or you might decided that you should get a better hobby, since modern silicon can do this in nanoseconds.</p> <p>We can speed this up exponentially by making use of the distributive property and the fact that <code class="language-plaintext highlighter-rouge">turn</code> can incorporate multiplication by a power of <code class="language-plaintext highlighter-rouge">10</code>.</p> <p>Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">41820 * 41820
= 41820 * (40000 + 1000 + 800 + 20)
= 41820 * 40000 + 41820 * 1000 + 41820 * 800 + 41820 * 20</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Each nice round number here can be achieved in <code class="language-plaintext highlighter-rouge">cr</code> by use of <code class="language-plaintext highlighter-rouge">ca</code>. Our algorithm will look a bit like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="c1">// Check if we're done.</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="mi">41820</span><span class="p">,</span> <span class="n">end</span>
  <span class="n">inner</span><span class="o">:</span>
      <span class="c1">// Turn until the first `ca` digits of `cr` and the</span>
      <span class="c1">// other factor match.</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="mi">41802</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">ca</span><span class="p">],</span> <span class="n">inner_end</span>
      <span class="n">pturn</span>
      <span class="k">goto</span>  <span class="n">inner</span>
  <span class="n">inner_end</span><span class="o">:</span>
    <span class="c1">// Increment `ca` and repeat until done.</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span> 
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>There are two loops. The inner loop runs as many turns as is necessary to get the next prefix of the factor into <code class="language-plaintext highlighter-rouge">cr</code>, then incrementing <code class="language-plaintext highlighter-rouge">ca</code> to do the next digit, and on and on until <code class="language-plaintext highlighter-rouge">cr</code> contains the entire other factor, at which point we can read off the result.</p> <p>The actual trace of operations (omitting control flow), and the resulting contents of the registers <code class="language-plaintext highlighter-rouge">sr/rr/mr/ca</code> at each step, looks something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="c1">// 00000041820/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000000000/00000000/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000418200/00000010/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000083640/00000020/1</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000083640/00000020/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000005018400/00000120/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000009200400/00000220/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000013382400/00000320/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000017564400/00000420/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000021746400/00000520/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000025928400/00000620/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000030110400/00000720/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000034292400/00000820/2</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000034292400/00000820/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000076112400/00001820/3</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000494312400/00011820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000912512400/00021820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001330712400/00031820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001748912400/00041820/4</span>
<span class="n">pturn</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>The result can be read off from <code class="language-plaintext highlighter-rouge">rr</code>: <code class="language-plaintext highlighter-rouge">1748912400</code>. In the trace, you can see <code class="language-plaintext highlighter-rouge">cr</code> get built up digit by digit, making this operation rather efficient.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/square.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">41820 * 41820 == 1748912400</code></p> </figcaption> </figure> <p>We can do even better, if we use subtraction. For example, note that <code class="language-plaintext highlighter-rouge">18 = 20 - 2</code>; we can build up <code class="language-plaintext highlighter-rouge">18</code> in <code class="language-plaintext highlighter-rouge">cr</code> by doing only 4 turns rather than nine, according to this formula. Here’s the general algorithm for <code class="language-plaintext highlighter-rouge">n * m</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">mul:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="n">n</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="n">m</span><span class="p">,</span> <span class="n">end</span>
    <span class="c1">// Same as before, but if the next digit is large,</span>
    <span class="c1">// go into subtraction mode.</span>
    <span class="k">if</span>    <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_sub</span>
  <span class="n">inner</span><span class="o">:</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">ca</span><span class="p">],</span> <span class="n">inner_end</span>
      <span class="n">pturn</span>
      <span class="k">goto</span>  <span class="n">inner</span>
  <span class="n">by_sub</span><span class="o">:</span>
    <span class="c1">// Store the current `ca` position.</span>
    <span class="n">wrnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">sub_from</span>
    <span class="c1">// Find the next small digit (eg. imagine n * 199, we</span>
    <span class="c1">// want to find the 1).</span>
  <span class="n">find_small</span><span class="o">:</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span>
    <span class="k">if</span>    <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">find_small</span>
    <span class="c1">// Set the digit to one plus the desired value for that</span>
    <span class="c1">// digit.</span>
  <span class="n">outer_turns</span><span class="o">:</span>
    <span class="n">pturn</span>
    <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">outer_turns</span>
    <span class="c1">// Store how far we need to re-advance `ca`.</span>
    <span class="n">wrnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">continue_from</span>
    <span class="c1">// Go back to the original `ca` position and enter</span>
    <span class="c1">// subtraction mode.</span>
    <span class="n">rdnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">sub_from</span>
  <span class="n">subs</span><span class="o">:</span>
  <span class="n">subs_inner</span><span class="o">:</span>
      <span class="c1">// Perform subtractions until we get the value we want.</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">],</span>  <span class="n">subs_end</span>
      <span class="n">mturn</span>
      <span class="k">goto</span>  <span class="n">subs_inner</span>
  <span class="n">subs_end</span><span class="o">:</span>
    <span class="c1">// Advance `ca` and keep going until we're done.</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span>
    <span class="k">if</span>    <span class="n">ca</span> <span class="o">!=</span> <span class="n">continue_from</span><span class="p">,</span> <span class="n">subs</span>
    <span class="k">goto</span>  <span class="n">loop</span>
  <span class="n">inner_end</span><span class="o">:</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span> 
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Although more complicated, if we execute it step by step, we’ll see we get to our answer in fewer turns:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="c1">// 00000041820/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000000000/00000000/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000418200/00000010/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000835400/00000020/1</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">2</span>
<span class="c1">// 00000041820/000000000835400/00000020/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000042656400/00001020/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000084476400/00002020/3</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000041820/000000084476400/00002020/2</span>
<span class="n">mturn</span>
<span class="c1">// 00000041820/000000080294400/00001920/2</span>
<span class="n">mturn</span>
<span class="c1">// 00000041820/000000076112400/00001820/2</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">2</span>
<span class="c1">// 00000041820/000000494312400/00011820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000912512400/00021820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001330712400/00031820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001748912400/00041820/4</span>
<span class="n">pturn</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>In exchange for a little overhead, the number of turns drops from 15 to 10. This is the fastest <em>general</em> algorithm, but some techniques from <em>Hacker’s Delight</em> can likely be applied here to make it faster for some products.</p> <h4 id="cubes"><a href="#cubes">Cubes</a></h4> <p>As a quick note, computing the cube of a number without taking extra notes is easy, so long as the number is already written down somewhere you can already see it. After computing <code class="language-plaintext highlighter-rouge">n^2</code> by any of the methods above, we can do</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">cube:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span>
  <span class="c1">// Perform a multiplication by `n`, then copy the result</span>
  <span class="c1">// into `sr`.</span>
  <span class="n">copy</span>  <span class="n">sr</span><span class="p">,</span>   <span class="n">rr</span>
  <span class="n">zero</span>  <span class="n">rr</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="c1">// Perform another multiplication by `n`, but now with</span>
  <span class="c1">// its square in `sr`.</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>This sequence can be repeated over and over to produce higher powers, and is only limited by the size of <code class="language-plaintext highlighter-rouge">rr</code>.</p> <h3 id="division"><a href="#division">Division</a></h3> <p>Division is way more interesting, because it can be <em>inexact</em>, and thus produces a <em>remainder</em> in addition to the quotient. There are a few different algorithms, but the simplest one is division by repeated subtraction. Some literature calls this “division by breaking down”.</p> <p>For small numbers, this is quite simple, such as <code class="language-plaintext highlighter-rouge">21 / 4</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">div_by_4:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">21</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">4</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">oflow</span><span class="p">,</span> <span class="n">end</span>
    <span class="n">mturn</span>
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">pturn</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>This works by first getting the dividend into <code class="language-plaintext highlighter-rouge">rr</code> and resetting the rest of the machine. Then, with <code class="language-plaintext highlighter-rouge">rl</code> set, we subtract the divisor from <code class="language-plaintext highlighter-rouge">rr</code> until we get overflow, at which point we add to undo the overflow. The quotient will appear in <code class="language-plaintext highlighter-rouge">cr</code>: we set <code class="language-plaintext highlighter-rouge">rl</code>, so each subtraction <em>increments</em> <code class="language-plaintext highlighter-rouge">cr</code>, giving us a count of <code class="language-plaintext highlighter-rouge">mturn</code>s executed. The remainder appears in <code class="language-plaintext highlighter-rouge">rr</code>.</p> <p>In this case, we get down to <code class="language-plaintext highlighter-rouge">1</code> before the next <code class="language-plaintext highlighter-rouge">mturn</code> underflows; the result of that underflow is to <code class="language-plaintext highlighter-rouge">99...97</code>, the ten’s complement of -3. We then undo the last operation by <code class="language-plaintext highlighter-rouge">pturn</code>ing, getting <code class="language-plaintext highlighter-rouge">5</code> in <code class="language-plaintext highlighter-rouge">cr</code>: this is our quotient. <code class="language-plaintext highlighter-rouge">1</code> in <code class="language-plaintext highlighter-rouge">rr</code> is the remainder.</p> <p>The same tricks from earlier work here, using <code class="language-plaintext highlighter-rouge">ca</code> to make less work, effectively implementing decimal long division of <code class="language-plaintext highlighter-rouge">n/m</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">div:</span>
  <span class="c1">// Set up the registers.</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">m</span>
  <span class="n">set</span>   <span class="n">rl</span>
  <span class="c1">// Move `ca` to be such that the highest digit of</span>
  <span class="c1">// `sr` lines up with the highest digit of `rr`.</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="n">log</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="c1">// Make subtractive turns until we underflow.</span>
  <span class="n">inner</span><span class="o">:</span>
    <span class="n">mturn</span>
    <span class="k">if</span>    <span class="o">!</span><span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span> <span class="n">inner</span>
  <span class="c1">// Undo the turn that underflowed by doing an addition.</span>
  <span class="c1">// Because `rl` is set, this will also conveniently subtract</span>
  <span class="c1">// from `cr`, to remove the extra count from the</span>
  <span class="c1">// underflowing turn.</span>
  <span class="n">pturn</span>
  <span class="c1">// We're done if this is the last digit we can be subtracting.</span>
  <span class="c1">// Otherwise, decrement `ca` and start over.</span>
  <span class="k">if</span>    <span class="n">ca</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
  <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Let’s execute this on <code class="language-plaintext highlighter-rouge">3141592653 / 137</code>, with an instruction trace as before.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">3141592653</span>
<span class="c1">// 03141592653/000000000000000/00000000/0</span>
<span class="n">pturn</span>
<span class="c1">// 03141592653/000003141592653/00000001/0</span>
<span class="n">zero</span>  <span class="n">cr</span>
<span class="c1">// 03141592653/000003141592653/00000000/0</span>
<span class="n">zero</span>  <span class="n">sr</span>
<span class="c1">// 00000000000/000003141592653/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">137</span>
<span class="c1">// 00000000137/000003141592653/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">7</span>
<span class="c1">// 00000000137/000003141592653/00000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000001771592653/10000000/7</span>
<span class="n">turn</span>
<span class="c1">// 00000000137/000000401592653/20000000/7</span>
<span class="n">turn</span>
<span class="c1">// 00000000137/999990031592653/30000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00000000137/000000401592653/20000000/7</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000401592653/20000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000000264592653/21000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000000127592653/22000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/999999990592653/23000000/6</span>
<span class="n">pturn</span>
<span class="c1">// 00000000137/000000127592653/22000000/6</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000127592653/22000000/5</span>
<span class="c1">// More turns...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000004292653/22900000/4</span>
<span class="c1">// More turns...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000182653/22930000/3</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000045653/22931000/2</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000004553/22931300/1</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000000443/22931330/0</span>
<span class="c1">// ...</span>
<span class="n">done</span>
<span class="c1">// 00000000137/000000000000032/22931333/0</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>For a quotient this big, you’ll need to work through all eight <code class="language-plaintext highlighter-rouge">cr</code> digits, which is a ton of work. At the end, we get a quotient of <code class="language-plaintext highlighter-rouge">22931333</code> and reminder <code class="language-plaintext highlighter-rouge">32</code>.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/quot.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">3141592653 / 137 == 22931333, rem 32</code></p> </figcaption> </figure> <p>Unfortunately, we can’t as easily “cheat” with subtraction as we did with multiplication, because we don’t know the value that needs to appear in <code class="language-plaintext highlighter-rouge">cr</code>.</p> <h3 id="square-roots"><a href="#square-roots">Square Roots</a></h3> <p>Computing square roots by approximation is one of the premiere operations on the Curta. There’s a number of approaches. Newton’s method is the classic, but requires a prior approximation, access to lookup tables, or a lot of multiplication.</p> <p>A slower, but much more mechanical approach is to use <em>Töpler’s method</em>. This consists of observing that the sum of the first <code class="language-plaintext highlighter-rouge">n</code> odd numbers is the square of <code class="language-plaintext highlighter-rouge">n</code>. Thus, we can use an approach similar to that for division, only that we now subtract off consecutive odd numbers. Let’s take the square root of <code class="language-plaintext highlighter-rouge">92</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">sqrt_of_92:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">92</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="n">mturn</span>
  <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span> <span class="n">end</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>  
  <span class="k">goto</span>  <span class="n">loop</span> 
<span class="n">end</span><span class="o">:</span>
  <span class="n">pturn</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>We get <code class="language-plaintext highlighter-rouge">9</code> as our result, but that’s pretty awful precision. We can improve precision by multiplying <code class="language-plaintext highlighter-rouge">92</code> by a large, even power of ten, and then dividing the result by that power of ten’s square root (half the zeroes).</p> <p>Unfortunately, this runs into the same problem as naive multiplication: we have to turn the handle <em>a lot</em>. Turning this algorithm into something that can be done exponentially faster is a bit fussier.</p> <p>One approach (which I found on <curta.org>) allows us to compute the root by shifting. Several programmers appear to have independently discovered this in the 70s or 80s.</curta.org></p> <p>It is based on the so-called <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation">“digit-by-digit”</a> algorithm, dating back to at least the time of Napier. Wikipedia provides a good explanation of why this method works. However, I have not been able to write down a proof that this specific version works, since it incorporates borrowing to compute intermediate terms with successive odd numbers in a fairly subtle way. I would really appreciate a proof, if anyone knows of one!</p> <p>The algorithm is thus, for a radicand <code class="language-plaintext highlighter-rouge">n</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">sqrt:</span>
  <span class="n">mr</span>
  <span class="c1">// Put `ca` as far as it will go, and then enter</span>
  <span class="c1">// the radicand as far right as it will go, so you</span>
  <span class="c1">// get as many digits as possible to work with.</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">8</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="c1">// Put a 1 under the leftmost pair of digits. This</span>
  <span class="c1">// assumes a number with an even number of digits.</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="n">sqrt_loop</span><span class="o">:</span>
      <span class="c1">// Add an odd number (with a bunch of zeros</span>
      <span class="c1">// after it.)</span>
      <span class="n">mturn</span>
      <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span>  <span class="n">sqrt_end</span>
      <span class="c1">// Increment sr by 2 (again, with a bunch of</span>
      <span class="c1">// zeros after it). This gives us our next odd</span>
      <span class="c1">// number.</span>
      <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">goto</span>  <span class="n">sqrt_loop</span>
  <span class="n">sqrt_end</span><span class="o">:</span>
    <span class="c1">// Note that we do NOT undo the increment of `sr`</span>
    <span class="c1">// that caused overflow, but we do undo the last</span>
    <span class="c1">// mturn.</span>
    <span class="n">pturn</span>
    <span class="c1">// If `ca` is all the way to the right, we're out of</span>
    <span class="c1">// space, so these are all the digits we're getting.</span>
    <span class="c1">// Zeroing out `rr` also means we're done.</span>
    <span class="k">if</span>    <span class="n">ca</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">rr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span>
    <span class="c1">// Subtract ONE from the digit in `sr` we were</span>
    <span class="c1">// incrementing in the loop. This results in an even</span>
    <span class="c1">// number.</span>
    <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1">// Decrement `ca` and keep cranking. </span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
    <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Let’s compute some digits of <code class="language-plaintext highlighter-rouge">sqrt(2)</code>. Here’s the instruction trace.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">7</span>
<span class="c1">// 00000000000/000000000000000/00000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="c1">// 00020000000/000000000000000/00000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00020000000/200000000000000/10000000/7</span>
<span class="n">zero</span>  <span class="n">cr</span>
<span class="c1">// 00020000000/200000000000000/00000000/7</span>
<span class="n">zero</span>  <span class="n">sr</span>
<span class="c1">// 00000000000/200000000000000/00000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00010000000/200000000000000/00000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00010000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00030000000/100000000000000/10000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00030000000/800000000000000/10000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00030000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">// 00020000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00020000000/100000000000000/10000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00021000000/100000000000000/10000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00021000000/079000000000000/11000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00023000000/079000000000000/11000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00023000000/056000000000000/12000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00025000000/056000000000000/12000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00025000000/031000000000000/13000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00027000000/031000000000000/13000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00027000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00029000000/004000000000000/14000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00029000000/975000000000000/15000000/6</span>
<span class="n">pturn</span>
<span class="c1">// 00029000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">// 00028000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00028000000/004000000000000/14000000/5</span>
<span class="c1">// More of the same...</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Over time, the digits <code class="language-plaintext highlighter-rouge">14121356</code> will appear in <code class="language-plaintext highlighter-rouge">cr</code>. This is the square root (although we do need to place the decimal point; the number of digits before it will be half of what we started with, rounded up).</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/sqrt.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">sqrt(2) ~ 1.4121356</code></p> </figcaption> </figure> <h2 id="wrap-up"><a href="#wrap-up">Wrap-up</a></h2> <p>There’s a quite a few other algorithms out there, but most of them boil down to clever use of lookup tables and combinations of the above techniques. For example, the so-called “rule of 3” is simply performing a multiplication to get a product into <code class="language-plaintext highlighter-rouge">rr</code>, and then using it as the dividend to produce a quotient of the form <code class="language-plaintext highlighter-rouge">a * b / c</code> in <code class="language-plaintext highlighter-rouge">cr</code>.</p> <p>I hope that these simple numeric algorithms, presented in a style resembling assembly, helps illustrate that programming at such a low level is not <em>hard</em>, but merely requires learning a different bag of tricks.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:mech-digital" role="doc-endnote"> <p>Although this seems like an oxymoron, it is accurate! The Curta contains no electrical or electronic components, and its registers contain discrete symbols, not continuous values. It is <em>not</em> an analog computer! <a href="#fnref:mech-digital" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:one-index" role="doc-endnote"> <p>The Curta is a one-indexed machine, insofar as the values engraved on <code class="language-plaintext highlighter-rouge">ca</code> are not <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">7</code> but <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">8</code>. However, as we all know, zero-indexing is far more convenient. Any place where I say “set <code class="language-plaintext highlighter-rouge">ca</code> to <code class="language-plaintext highlighter-rouge">n</code>”, I mean the <code class="language-plaintext highlighter-rouge">n + 1</code>th detent.</p> <p>Doing this avoids a lot of otherwise unnecessary <code class="language-plaintext highlighter-rouge">-1</code>s in the prose. <a href="#fnref:one-index" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:10s-cmp" role="doc-endnote"> <p>The <em>ten’s complement</em> of a number <code class="language-plaintext highlighter-rouge">x</code> is analogous to the two’s complement (i.e., the value of <code class="language-plaintext highlighter-rouge">-x</code> when viewed as an unsigned integer on a binary machine). It is equal to <code class="language-plaintext highlighter-rouge">MAX_VALUE - x + 1</code>, where <code class="language-plaintext highlighter-rouge">MAX_VALUE</code> is the largest value that <code class="language-plaintext highlighter-rouge">x</code> could be. For example, this is <code class="language-plaintext highlighter-rouge">999_999_999_999_999_999</code> (fifteen nines) for <code class="language-plaintext highlighter-rouge">rr</code>. <a href="#fnref:10s-cmp" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post"> <span class="post-meta"> <span> <a href="https://mcyoung.xyz/tags.html#c++">#c++</a> <a href="https://mcyoung.xyz/tags.html#templates">#templates</a> <a href="https://mcyoung.xyz/tags.html#metaprogramming">#metaprogramming</a> </span> <span> 2022-07-13 </span> </span> <h1 class="post-title"><a href="/2022/07/13/tuples-the-hard-way/"> std::tuple the Hard Way </a></h1> <span class="post-meta", style="font-size: 80%;"> <span> <em> 2429 words • 13 minutes </em> </span> </span> <p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">tuple</span> <span class="p">{</span>
  <span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoidGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVzPlxuY2xhc3MgdHVwbGUg e1xuICBUeXBlcy4uLiB2YWx1ZXM7XG59OyIsImNvbXBpbGVycyI6W10sImV4 ZWN1dG9ycyI6W3siY29tcGlsZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJP dXRwdXRWaXNpYmxlIjp0cnVlLCJjb21waWxlciI6eyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6IiJ9fV19XX0=">godbolt</a><div class="codeblock-button">C++</div></div></div> <p>If you click through to Godbolt, you’ll see it doesn’t: this feature doesn’t exist in C++<sup id="fnref:circle-cxx" role="doc-noteref"><a href="#fn:circle-cxx" class="footnote" rel="footnote">2</a></sup> (normally, you’d do <code class="language-plaintext highlighter-rouge">std::tuple&lt;Types...&gt;</code>, but we need to write down <code class="language-plaintext highlighter-rouge">std::tuple</code> somehow). The usual approach is to use some kind of recursive template, which can tend to generate a lot of code.</p> <p>However, C++ does actually have tuples built into the language, as a C++11 feature… lambdas! As an extra challenge, we’re going to try to minimize the number of templates that the compiler needs to instantiate; <code class="language-plaintext highlighter-rouge">std::tuple</code> is famously bad about this and can lead to very poor build performance.</p> <p>For our tuple library type, we need to solve the following problems:</p> <ul> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple()</code> and <code class="language-plaintext highlighter-rouge">std::tuple(args...)</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::apply</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple_element</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::get</code>?</li> </ul> <h2 id="the-power-of-"><a href="#the-power-of-">The Power of [](){}</a></h2> <p>Alright, let’s back up. In C++11, we got <em>lambdas</em>, which are expressions that expand to anonymous functions. In C++, lambdas are <em>closures</em>, meaning that they capture (“close over”) their environment.</p> <p>This is a lambda in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">// 13</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">3</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <ol> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</p> </li> </ol> <p>We can use this type like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">4</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now, our constructor looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">5</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">6</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now we can see everything in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">7</a></sup>.</p> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:circle-cxx" role="doc-endnote"> <p>The Circle compiler totally laughs in our faces, though, because it <em>has this exact syntax</em>. <a href="https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple">https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple</a> <a href="#fnref:circle-cxx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoiXG4jaW5jbHVkZSA8bmV3PiBcbiNpbmNsdWRlIDx1dGlsaXR5PiBcblxu ICAgIHRlbXBsYXRlIDx0eXBlbmFtZSBUPlxuICAgIGNsYXNzIGFsaWduYXMo VCkgU3RvcmFnZUZvciB7XG4gICAgIHB1YmxpYzpcbiAgICAgIFN0b3JhZ2VG b3IoKSA9IGRlZmF1bHQ7XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4g QXJncz5cbiAgICAgIHZvaWQgSW5pdChBcmdzJiYuLi4gYXJncykge1xuICAg ICAgICBuZXcgKHJlaW50ZXJwcmV0X2Nhc3Q8VCo+KCZkYXRhXykpIFQoXG4g ICAgICAgICAgc3RkOjpmb3J3YXJkPEFyZ3M+KGFyZ3MpLi4uKTtcbiAgICAg IH1cblxuICAgICAgY29uc3QgVCogZ2V0KCkgY29uc3QgeyByZXR1cm4gcmVp bnRlcnByZXRfY2FzdDxjb25zdCBUKj4oJmRhdGFfKTsgfVxuICAgICAgVCog Z2V0KCkgeyByZXR1cm4gcmVpbnRlcnByZXRfY2FzdDxUKj4oJmRhdGFfKTsg fVxuICAgICAgY29uc3QgVCYgb3BlcmF0b3IqKCkgY29uc3QgeyByZXR1cm4g KmdldCgpOyB9XG4gICAgICBUJiBvcGVyYXRvciooKSB7IHJldHVybiAqZ2V0 KCk7IH1cbiAgICAgIGNvbnN0IFQqIG9wZXJhdG9yLT4oKSBjb25zdCB7IHJl dHVybiBnZXQoKTsgfVxuICAgICAgVCogb3BlcmF0b3ItPigpIHsgcmV0dXJu IGdldCgpOyB9XG4gICAgIHByaXZhdGU6XG4gICAgICBjaGFyIGRhdGFfW3Np emVvZihUKV07XG4gICAgfTtcblxuICAgIHRlbXBsYXRlIDx0eXBlbmFtZS4u LiBUeXBlcz5cbiAgICBjbGFzcyBUdXBsZSB7XG4gICAgIHB1YmxpYzpcbiAg ICAgIFR1cGxlKCkge1xuICAgICAgICBsYW1iZGFfKFtdIChTdG9yYWdlRm9y PFR5cGVzPiYuLi4gcGxhY2VzKSB7XG4gICAgICAgICAgKHBsYWNlcy5Jbml0 KCksIC4uLik7XG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgdGVt cGxhdGUgPHR5cGVuYW1lLi4uIEFyZ3MsXG4gICAgICAgICAgICAgICAgZGVj bHR5cGUoKG5ldyAobnVsbHB0cikgVHlwZXMoc3RkOjpkZWNsdmFsPEFyZ3M+ KCkpLCAuLi4pKVxuICAgICAgICAgICAgICAgICAgPSBudWxscHRyPlxuICAg ICAgVHVwbGUoQXJncyYmLi4uIGFyZ3MpIHtcbiAgICAgICAgbGFtYmRhXyhb Jl0gKFN0b3JhZ2VGb3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAg ICAocGxhY2VzLkluaXQoc3RkOjpmb3J3YXJkPGRlY2x0eXBlKGFyZ3MpPihh cmdzKSksIC4uLik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBU dXBsZShjb25zdCBUdXBsZSYgdGhhdCkge1xuICAgICAgICBsYW1iZGFfKFsm XSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRoZXNlKSB7XG4gICAgICAgICAg dGhhdC5sYW1iZGFfKFsmXSAoY29uc3QgU3RvcmFnZUZvcjxUeXBlcz4mLi4u IHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVzZS5nZXQoKSkgVHlw ZXMoKnRob3NlKSwgLi4uKTsgICBcbiAgICAgICAgICB9KTtcbiAgICAgICAg fSk7XG4gICAgICB9XG5cbiAgICAgIFR1cGxlKFR1cGxlJiYgdGhhdCkge1xu ICAgICAgICBsYW1iZGFfKFsmXSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRo ZXNlKSB7XG4gICAgICAgICAgdGhhdC5sYW1iZGFfKFsmXSAoU3RvcmFnZUZv cjxUeXBlcz4mLi4uIHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVz ZSkgVHlwZXMoc3RhdGljX2Nhc3Q8VHlwZXMmJj4oKnRob3NlKSksIC4uLik7 ICAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4g ICAgICB+VHVwbGUoKSB7XG4gICAgICAgIGxhbWJkYV8oW10gKFN0b3JhZ2VG b3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAgICAocGxhY2VzLT5+ VHlwZXMoKSwgLi4uKTtcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAg IHByaXZhdGU6XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4gQXJncz5c biAgICAgIHN0YXRpYyBhdXRvIFR1cGxlTGFtYmRhKEFyZ3MuLi4gYXJncykg e1xuICAgICAgICByZXR1cm4gWz1dIChhdXRvIGNhbGxiYWNrKSBtdXRhYmxl IC0+IGRlY2x0eXBlKGF1dG8pIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJh Y2soYXJncy4uLik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG11 dGFibGUgZGVjbHR5cGUoVHVwbGVMYW1iZGEoU3RvcmFnZUZvcjxUeXBlcz57 fS4uLikpIGxhbWJkYV8gPVxuICAgICAgICBUdXBsZUxhbWJkYShTdG9yYWdl Rm9yPFR5cGVzPnt9Li4uKTtcbiAgICB9O1xuXG4gICAgdGVtcGxhdGUgPHR5 cGVuYW1lLi4uIFR5cGVzPlxuICAgIFR1cGxlKFR5cGVzLi4uKSAtPiBUdXBs ZTxUeXBlcy4uLj47XG4gICAgdGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVz PlxuICAgIFR1cGxlKGNvbnN0IFR1cGxlPFR5cGVzLi4uPiYpIC0+IFR1cGxl PFR5cGVzLi4uPjtcblxuICAgIGludCBtYWluKCkge1xuICAgICAgVHVwbGUg dHVwezEsIDIsIFwiZm9vXCIsIFwiYmFyXCJ9O1xuICAgICAgVHVwbGUgdHVw MiA9IHR1cDtcbiAgICB9IiwiY29tcGlsZXJzIjpbeyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6Ii0tc3RkPWMrKzE3In1dfV19 ">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="cp">#endif
</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>
  
  <span class="cp">#else // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span>  <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cp">#endif // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tup</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="cp">#if USE_CLANG_INTRINSIC
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="cp">#else
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TupleType</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/z/eYeb9Y6cn">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div> <div class="pagination post-footer"> <a class="pagination-item newer" href="https://mcyoung.xyz/page2">&lt; Prev</a> • <a class="pagination-item older" href="https://mcyoung.xyz/page4">Next &gt;</a> </div></div> </body> <div class="sidebar show-if-mobile"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2023 Miguel Young de la Sota </div> </div> </html>