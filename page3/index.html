<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-12-10 • 2588 words • 21 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> • <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> </span> <h1><a href="/2024/12/10/json-sucks/"> Nobody Gets Fired for Picking JSON, but Maybe They Should? </a></h1> </div> <div class="post"> <p>JSON is extremely popular but deeply flawed. This article discusses the details of JSON’s design, how it’s used (and misused), and how seemingly helpful “human readability” features cause headaches instead. Crucially, you rarely find JSON-based tools (except dedicated tools like <code class="language-plaintext highlighter-rouge">jq</code>) that can safely handle arbitrary JSON documents without a schema—common corner cases can lead to data corruption!</p> <h2 id="what-is-json"><a href="#what-is-json">What is JSON?</a></h2> <p>JSON is famously simple. In fact, you can <a href="https://www.flickr.com/photos/equanimity/3763158824/in/photostream/">fit the entire grammar on the back of a business card</a>. It’s so omnipresent in REST APIs that you might assume you already know JSON quite well. It has decimal numbers, quoted strings, arrays with square brackets, and key-value maps (called “objects”) with curly braces. A JSON document consists of any of these constructs: <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">42</code>, and <code class="language-plaintext highlighter-rouge">{"foo":"bar"}</code> are all valid JSON documents.</p> <p>However, the formal definition of JSON is quite complicated. JSON is defined by the IETF document <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC8259</a> (if you don’t know what the IETF is, it’s the standards body for Internet protocols). However, it’s <em>also</em> normatively defined by <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a>, which is from ECMA, the standards body that defines JavaScript[^json.org].</p> <p>[^json.org]: Of course, some wise guy will probably want to cite <json.org>. I should underscore: <json.org> is __NOT__ a standard. It is __NOT__ normative. the documents produced by the IETF and by ECMA, which are international standards organizations that represent the industry __ARE__ normative. When a browser implementer wants to implement JSON to the letter, they go to ECMA, not to some dude's 90's ass website.</json.org></json.org></p> <p>JavaScript? Yes, JSON (JavaScript Object Notation) is closely linked with JavaScript and is, in fact, (almost) a subset of it. While JSON’s JavaScript ancestry is the main source of its quirks, several other poor design decisions add additional unforced errors.</p> <p>However, the biggest problem with JSON isn’t any specific design decision but rather the incredible diversity of parser behavior and non-conformance across and within language ecosystems. RFC8259 goes out of its way to call this out:</p> <blockquote> <p>Note, however, that ECMA-404 allows several practices that this specification recommends avoiding in the interests of maximal interoperability.</p> </blockquote> <p>The RFC makes many observations regarding interoperability elsewhere in the document. Probably the most glaring—and terrifying—is how numbers work.</p> <h2 id="everything-is-implementation-defined"><a href="#everything-is-implementation-defined">Everything is Implementation-Defined</a></h2> <p>JSON numbers are encoded in decimal, with an optional minus sign, a fractional part after a decimal point, and a scientific notation exponent. This is similar to how many programming languages define their own numeric literals.</p> <p>Presumably, JSON numbers are meant to be floats, right?</p> <p>Wrong.</p> <p>RFC8259 reveals that the answer is, unfortunately, “whatever you want.”</p> <blockquote> <p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">binary64</code> is the “standards-ese” name for the type usually known as <code class="language-plaintext highlighter-rouge">double</code> or <code class="language-plaintext highlighter-rouge">float64</code>. Floats have great dynamic range but often can’t represent exact values. For example, <code class="language-plaintext highlighter-rouge">1.1</code> isn’t representable as a float because all floats are fractions of the form <code class="language-plaintext highlighter-rouge">n / 2^m</code> for integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code>, but <code class="language-plaintext highlighter-rouge">1.1 = 11/10</code>, which has a factor of 5 in its denominator. The closest <code class="language-plaintext highlighter-rouge">float64</code> value is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">2476979795053773 / 2^51 = 1.100000000000000088817841970012523233890533447265625</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Of course, you might think to declare “all JSON values map to their closest <code class="language-plaintext highlighter-rouge">float64</code> value”. Unfortunately, this value might not be unique. For example, the value <code class="language-plaintext highlighter-rouge">900000000000.00006103515625</code> isn’t representable as a <code class="language-plaintext highlighter-rouge">float64</code>, and it’s precisely between two exact <code class="language-plaintext highlighter-rouge">float64</code> values. Depending on the rounding mode, this rounds to either or <code class="language-plaintext highlighter-rouge">900000000000</code> or <code class="language-plaintext highlighter-rouge">900000000000.0001220703125</code> .</p> <p>IEEE 754 recommends “round ties to even” as the default rounding mode, so for almost all software, the result is <code class="language-plaintext highlighter-rouge">900000000000</code>. But remember, floating-point state is a global variable implemented in hardware, and might just happen to be clobbered by some dependency that calls <code class="language-plaintext highlighter-rouge">fesetround()</code> or a similar system function.</p> <h2 id="data-loss-data-loss"><a href="#data-loss-data-loss">Data Loss! Data Loss!</a></h2> <p>You’re probably thinking, “I don’t care about such fussy precision stuff. None of my numbers have any fractional parts—and there is where you would be wrong. The <code class="language-plaintext highlighter-rouge">n</code> part of <code class="language-plaintext highlighter-rouge">n / 2^m</code> only has 53 bits available, but <code class="language-plaintext highlighter-rouge">int64</code> values fall outside of that range. This means that for very large 64-bit integers, such as randomly generated IDs, a JSON parser that converts integers into floats results in <em>data loss.</em> Go’s <code class="language-plaintext highlighter-rouge">encoding/json</code> package does this, for example.</p> <p>How often does this actually happen for randomly-generated numbers? We can do a little Monte Carlo simulation to find out.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
	<span class="s">"math/big"</span>
	<span class="s">"math/rand"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">trials</span> <span class="o">=</span> <span class="m">5</span><span class="n">_000_000</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">misses</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">err</span> <span class="n">big</span><span class="o">.</span><span class="n">Float</span>
	<span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
		<span class="n">y</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c">// Round-trip through binary64.</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
			<span class="n">misses</span><span class="o">++</span>
			<span class="n">err</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span><span class="o">.</span><span class="n">Quo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">trials</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"misses: %d/%d, avg: %f"</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">trials</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// misses: 4970572/5000000, avg: 170.638499</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>It turns out that almost all randomly distributed <code class="language-plaintext highlighter-rouge">int64</code> values are affected by round-trip data loss. Roughly, the only numbers that are safe are those with at most 16 digits (although not exactly: 9,999,999,999,999,999, for example, gets rounded up to a nice round 10 quadrillion).</p> <p>How does this affect you? Suppose you have a JSON document somewhere that includes a user ID and a transcript of their private messages with another user. Data loss due to rounding would result in the wrong user ID being associated with the private messages, which could result in leaking PII or incorrect management of privacy consent (such as GDPR requirements).</p> <p>This isn’t just about <em>your</em> user IDs, mind you. Plenty of other vendors’ IDs are nice big integers, which the JSON grammar can technically accommodate and which random tools will mangle. Some examples:</p> <ul> <li> <p>License keys: for example, Adobe uses 24 digits for <a href="https://helpx.adobe.com/x-productkb/global/invalid-revoked-serial-numbers.html">their serial numbers</a>, which may be tempting to store as an integer.</p> </li> <li> <p>Barcode IDs like the unique serial numbers of medical devices, <a href="https://www.fda.gov/medical-devices/unique-device-identification-system-udi-system/udi-basics">which are tightly regulated</a>.</p> </li> <li> <p>Visa and Mastercard credit card numbers <em>happen</em> to fit in the “safe” range for <code class="language-plaintext highlighter-rouge">binary64</code> , which may lull you into a false sense of security, since they’re so common. But not all credit cards have 16 digit numbers: <a href="https://en.wikipedia.org/wiki/Payment_card_number#Structure">some now support 19</a>.</p> </li> </ul> <p>These are pretty bad compliance consequences purely due to a data serialization format.</p> <p>This problem is avoidable with care. After all, Go can parse JSON into any arbitrary type using reflection. For example, if we replace the inner loop of the Monte Carlo simulation with something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
	<span class="k">var</span> <span class="n">v</span> <span class="k">struct</span><span class="p">{</span> <span class="n">N</span> <span class="kt">int64</span> <span class="p">}</span>
	<span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">`{"N":%d}`</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
	<span class="n">y</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">N</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
		<span class="c">// ...</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>We suddenly see that <code class="language-plaintext highlighter-rouge">x == y</code> in every trial. This is because with type information, Go’s JSON library knows exactly what the target precision is. If we were parsing to an <code class="language-plaintext highlighter-rouge">any</code> instead of to a <code class="language-plaintext highlighter-rouge">struct { N int64 }</code>, we’d be in deep trouble: the outer object would be parsed into a <code class="language-plaintext highlighter-rouge">map[string]any</code>, and the <code class="language-plaintext highlighter-rouge">N</code> field would become a <code class="language-plaintext highlighter-rouge">float64</code>.</p> <p>This means that your system probably can’t safely handle JSON documents with unknown fields. Tools like <code class="language-plaintext highlighter-rouge">jq</code> must be extremely careful about number handling to avoid data loss. This is an easy mistake for third-party tools to make.</p> <p>But again, <code class="language-plaintext highlighter-rouge">float64</code> isn’t the standard—there is no standard. Some implementations might only have 32-bit floats available, making the problem worse. Some implementations might try to be clever, using a <code class="language-plaintext highlighter-rouge">float64</code> for fractional values and an <code class="language-plaintext highlighter-rouge">int64</code> for integer values; however, this still imposes arbitrary limits on the parsed values, potentially resulting in data loss.</p> <p>Some implementations such as Python use bignums, so they appear not to have this problem. However, this can lead to a false sense of security where issues are not caught until it’s too late: some database now contains ostensibly valid but non-interoperable JSON.</p> <p>Protobuf is forced to deal with this in a pretty non-portable way. To avoid data loss, large 64-bit integers are serialized as quoted strings when serializing to JSON. So, instead of writing <code class="language-plaintext highlighter-rouge">{"foo":6574404881820635023}</code>, it emits <code class="language-plaintext highlighter-rouge">{"foo":"6574404881820635023"}</code>. This solves the data loss issue but does not work with other JSON libraries such as Go’s, producing errors like this one:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">json: cannot unmarshal string into Go struct field .N of type int64</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <h3 id="non-finite-values"><a href="#non-finite-values">Non-Finite Values</a></h3> <p>The special floating point values <code class="language-plaintext highlighter-rouge">Infinity</code>, <code class="language-plaintext highlighter-rouge">-Infinity</code>, and <code class="language-plaintext highlighter-rouge">NaN</code> are not representable: it’s the wild west as to what happens when you try to serialize the equivalent of <code class="language-plaintext highlighter-rouge">{x:1.0/0.0}</code>.</p> <ul> <li>Go refuses to serialize, citing <code class="language-plaintext highlighter-rouge">json: unsupported value: +Inf</code>.</li> <li>Protobuf serializes it as <code class="language-plaintext highlighter-rouge">{"x":"inf"}</code> (or should—it’s unclear which implementations get it right).</li> <li>JavaScript won’t even bother trying: <code class="language-plaintext highlighter-rouge">JSON.stringify({x:Infinity})</code> prints <code class="language-plaintext highlighter-rouge">{"x":null}.</code></li> <li>Python is arguably the worst offender: <code class="language-plaintext highlighter-rouge">json.dumps({"x":float("inf")})</code> prints <code class="language-plaintext highlighter-rouge">{"x":Infinity}</code>, which isn’t even valid JSON per RFC8259.</li> </ul> <p>NaN is arguably an even worse offender, because the NaN payload (yes, <a href="https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns">NaNs have a special payload</a>) is discarded when converting to <code class="language-plaintext highlighter-rouge">"nan"</code> or however your library represents it.</p> <p>Does this affect you? Well, if you’re doing anything with floats, you’re one division-by-zero or overflow away from triggering serialization errors. At best, it’s “benign” data corruption (JavaScript). At worst, when the data is partially user-controlled, it might result in crashes or unparseable output, which is the making of a DoS vector.</p> <p>In comparison, Protobuf serialization can’t fail except due to non-UTF-8 <code class="language-plaintext highlighter-rouge">string</code> fields or cyclic message references, both of which are comparatively unlikely to a NaN popping up in a calculation.</p> <p>The upshot is that all the parsers end up parsing a bunch of crazy things for the special floating-point values over time because of <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s law</a>. RFC8259 makes no effort to provide suggestions for dealing with such real-world situations beyond “tough luck, not interoperable.”</p> <h2 id="text-encodings-and-invalid-unicode"><a href="#text-encodings-and-invalid-unicode">Text Encodings and Invalid Unicode</a></h2> <p>JSON strings are relatively tame, with some marked (but good) divergence from JavaScript. Specifically, JavaScript, being a language of a certain age (along with Java), uses UTF-16 as its Unicode text encoding. Most of the world has realized this is a bad idea (it doubles the size of ASCII text, which makes up almost all of Internet traffic), so JSON uses UTF-8 instead. RFC8259 actually specifies that the whole document MUST be encoded in UTF-8.</p> <p>But when we go to read about Unicode characters in §8.2, we are disappointed: it merely says that it’s <em>really great</em> when all quoted strings consist entirely of Unicode characters, which means that unpaired surrogates are allowed. In effect, the spec merely requires that JSON strings be <a href="https://en.wikipedia.org/wiki/UTF-8#Surrogates">WTF-8</a>: UTF-8 that permits unpaired surrogates.</p> <p>What’s an unpaired surrogate? It’s any encoded Unicode 32-bit value in the range <code class="language-plaintext highlighter-rouge">U+D800</code> to <code class="language-plaintext highlighter-rouge">U+DFFF</code> , which form a gap in the Unicode codepoint range. UTF-8’s variable-length integer encoding can encode them, but their presence in a bytestream makes it invalid UTF-8. WTF-8 is UTF-8 but permitting the appearance of these values.</p> <p>So, who actually supports parsing (or serializing) these? Consider the document <code class="language-plaintext highlighter-rouge">{"x":"\udead"}</code>, which contains an unpaired surrogate, <code class="language-plaintext highlighter-rouge">U+DEAD</code>.</p> <ul> <li> <p>Go gladly deserializes AND serializes it (Go’s strings are arbitrary byte strings, not UTF-8). However, Go serializes a non-UTF-8 string such as <code class="language-plaintext highlighter-rouge">"\xff"</code> as <code class="language-plaintext highlighter-rouge">"\ufffd"</code>, having replaced the invalid byte with a <code class="language-plaintext highlighter-rouge">U+FFFD</code> replacement character (this thing: �).</p> </li> <li> <p>Most Java parsers seem to follow the same behavior as Go, but there are many different parsers available, and we’ve already learned that different JSON parsers may behave differently.</p> </li> <li> <p>JavaScript and Python similarly gladly parse unpaired surrogates, but they also serialize them back without converting them into <code class="language-plaintext highlighter-rouge">U+FFFD</code>.</p> </li> <li> <p>Different Protobuf runtimes may not handle this identically, but the reference C++ implementation (whose JSON codec I wrote!) refuses to parse unpaired surrogates.</p> </li> </ul> <p>There are other surprising pitfalls around strings: are <code class="language-plaintext highlighter-rouge">"x"</code> and <code class="language-plaintext highlighter-rouge">“\x78"</code> the same string? RFC8259 feels the need to call out that they are, for the purposes of checking that object keys are equal. The fact that they feel the need to call it out indicates that this is also a source of potential problems.</p> <h2 id="byte-strings"><a href="#byte-strings">Byte Strings</a></h2> <p>What if I don’t want to send text? A common type of byte blob to send is a cryptographic hash that identifies a document in a content-addressed blobstore, or perhaps a digital signature (an encrypted hash). JSON has no native way of representing byte strings.</p> <p>You could send a quoted string full of ASCII and <code class="language-plaintext highlighter-rouge">\xNN</code> escapes (for bytes which are not in the ASCII range), but this is wasteful in terms of bandwidth, and has serious interoperability problems (as noted above, Go actively destroys data in this case). You could also encode it as an array of JSON numbers, which is much worse for bandwidth and serialization speed.</p> <p>What everyone winds up doing, one way or another, is to rely on base64 encoding. Protobuf, for example, encodes <code class="language-plaintext highlighter-rouge">bytes</code> fields into base64 strings in JSON. This has the unfortunate side-effect of defeating JSON’s human-readable property: if the blob contains mostly ASCII, a human reader can’t tell.</p> <p>Because this isn’t part of JSON, virtually no JSON codec does this decoding for you, particularly because in a schema-less context, there’s nothing to distinguish a byte blob encoded with base64 from an actual textual string that <em>happens</em> to contain valid base64, such as an alphanumeric username.</p> <p>Compared to other problems, this is more like a paper cut, but it’s unnecessary and adds complexity and interop problems. <a href="https://en.wikipedia.org/wiki/Base64#Variants_summary_table">By the way, did you know there are multiple incompatible Base64 alphabets?</a></p> <h1 id="streaming-doesnt-work"><a href="#streaming-doesnt-work">Streaming Doesn’t Work</a></h1> <p>A less obvious problem with JSON is that it can’t be streamed. Almost all JSON documents are objects or arrays and are therefore <em>incomplete</em> until they reach the closing <code class="language-plaintext highlighter-rouge">}</code> or <code class="language-plaintext highlighter-rouge">]</code>, respectively. This means you can’t send a stream of JSON documents that form a part of a larger document without some additional protocol for combining them in post-processing.</p> <p><a href="https://jsonlines.org/">JSONL</a> is the world’s silliest spec that “solves” this problem in the simplest way possible: a JSONL document is a sequence of JSON documents separated by newlines. JSONL <em>is</em> streamable, but because it’s done in the simplest way possible, it only supports streaming a giant array. You can’t, for example, stream an object field-by-field or stream an array within that object.</p> <p>Protobuf doesn’t have this problem: in a nutshell, the Protobuf wire format is as if we removed the braces and brackets from the top-level array or object of a document, and made it so that values with the same key get merged. In the wire format, the equivalent of the JSONL document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>is automatically “merged” into the single document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w"> </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>This forms the basis of the “message merge” operation, which is intimately connected to how the wire format was designed. We’ll dive into this fundamental operation in a future article.</p> <h1 id="canonicalization-leads-to-data-loss"><a href="#canonicalization-leads-to-data-loss">Canonicalization Leads to Data Loss</a></h1> <p>Thanks to <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC7519</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC7515</a>, which define JSON Web Tokens (JWT) and JSON Web Signatures (JWS), digitally signing JSON documents is a very common operation. However, digital signatures can only sign specific byte blobs and are sensitive to things that JSON isn’t, such as whitespace and key ordering.</p> <p>This results in specifications like <a href="https://datatracker.ietf.org/doc/html/rfc8785">RFC8785</a> for <em>canonicalization</em> of JSON documents. This introduces a new avenue by which existing JSON documents, which accidentally happen to contain non-interoperable (or, thanks to non-conforming implementations such as Python’s) invalid JSON that must be manipulated and reformatted by third-party tools. RFC8785 itself references ECMA-262 (the JavaScript standard) for how to serialize numbers, meaning that it’s <em>required</em> to induce data loss for 64-bit numerical values!</p> <h1 id="is-json-fixable"><a href="#is-json-fixable">Is JSON Fixable?</a></h1> <p>Plainly? No. JSON can’t be fixed because of how extremely popular it is. Common mistakes are baked into the format. Are comments allowed? Trailing commas? Number formats? Nobody knows!</p> <p>What tools are touching your JSON? Are they aware of all of the rakes they can step on? Do they emit invalid JSON (like Python does)? How do you even begin to audit that?</p> <p>Thankfully, you don’t have to use JSON. There are alternatives—BSON, UBJSON, MessagePack, and CBOR are just a few binary formats that try to replicate JSON’s data model. Unfortunately, many of them have their own problems.</p> <p>Protobuf, however, has none of these problems, because it was <em>designed</em> to fulfill needs JSON couldn’t meet. Using a strongly-typed schema system, like Protobuf, makes all of these problems go away.</p> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2024-04-17 • 3689 words • 30 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2024/04/17/calling-convention/"> The Rust Calling Convention We Deserve </a></h1> </div> <div class="post"> <p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified0- calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>However, we are too conservative. We get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>Not only does clang produce patently <em>bad</em> code for passing things by value, but it also knows how to do it better, if you request a standard calling convention! We could be generating <em>way</em> better code than Clang, but we don’t!</p> <p>Hereforth, I will describe how to do it.</p> <h3 id="-zcallconv"><a href="#-zcallconv"><code class="language-plaintext highlighter-rouge">-Zcallconv</code></a></h3> <p>Let’s suppose that we keep the current calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code><sup id="fnref:just-use-extern-c" role="doc-noteref"><a href="#fn:just-use-extern-c" class="footnote" rel="footnote">1</a></sup>, but we add a flag <code class="language-plaintext highlighter-rouge">-Zcallconv</code> that sets the calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code> when compiling a crate. The supported values will be <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> for the current one, and <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for the one we’re going to design. We could even let <code class="language-plaintext highlighter-rouge">-O</code> set <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> automatically.</p> <p>Why keep the old calling convention? Although I did sweep debugability under the rug, one nice property <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> will not have is that it does not place arguments in the C ABI order, which means that a reader replying on the “Diana’s silk dress cost $89” mnemonic on x86 will get fairly confused.</p> <p>I am also assuming we may not even support <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for some targets, like WASM, where there is no concept of “registers” and “spilling”. It may not even make sense to enable it for for debug builds, because it will produce much worse code with optimizations turned off.</p> <p>There is also a mild wrinkle with function pointers, and <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code> blocks. Because this flag is per-crate, even though functions can advertise which version of <code class="language-plaintext highlighter-rouge">extern "Rust"</code> they use, function pointers have no such luxury. However, calling through a function pointer is slow and rare, so we can simply force them to use <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. We can generate a shim to translate calling conventions as needed.</p> <p>Similarly, we can, in principle, call any Rust function like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">secret_call</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">my_func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">my_func</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this mechanism can only be used to call unmangled symbols. Thus, we can simply force <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> symbols to use the legacy calling convention.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following procedure.</p> <ol> <li> <p>First, determine, for a given target triple, the maximum number of values that can be passed “by register”. I will explain how to do this below.</p> </li> <li> <p>Decide how to pass the return value. It will either fit in the output registers, or it will need to be returned “by reference”, in which case we pass an extra <code class="language-plaintext highlighter-rouge">ptr</code> argument to the function (tagged with the <code class="language-plaintext highlighter-rouge">sret</code> attribute) and the actual return value of the function is that pointer.</p> </li> <li> <p>Decide which arguments that have been passed by value need to be demoted to being passed by reference. This will be a heuristic, but generally will be approximately “arguments larger than the by-register space”. For example, on x86, this comes out to 176 bytes.</p> </li> <li> <p>Decide which arguments get passed by register, so as to maximize register space usage. This problem is NP-hard (it’s the knapsack problem) so it will require a heuristic. All other arguments are passed on the stack.</p> </li> <li> <p>Generate the function signature in LLVM IR. This will be all of the arguments that are passed by register encoded as various non-aggregates, such as <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">ptr</code>, <code class="language-plaintext highlighter-rouge">double</code>, and <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>. What valid choices are for said non-aggregates depends on the target, but the above are what you will generally get on a 64-bit architecture. Arguments passed on the stack will follow the “register inputs”.</p> </li> <li> <p>Generate a function prologue. This is code to decode each Rust-level argument from the register inputs, so that there are <code class="language-plaintext highlighter-rouge">%ssa</code> values corresponding to those that would be present when using <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This allows us to generate the same code for the body of the function regardless of calling convention. Redundant decoding code will be eliminated by DCE passes.</p> </li> <li> <p>Generate a function exit block. This is a block that contains a single <code class="language-plaintext highlighter-rouge">phi</code> instruction for the return type as it would be for <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This block will encode it into the requisite output format and then <code class="language-plaintext highlighter-rouge">ret</code> as appropriate. All exit paths through the function should <code class="language-plaintext highlighter-rouge">br</code> to this block instead of <code class="language-plaintext highlighter-rouge">ret</code>-ing.</p> </li> <li> <p>If a non-polymorphic, non-inline function may have its address taken (as a function pointer), either because it is exported out of the crate or the crate takes a function pointer to it, generate a shim that uses <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> and immediately tail-calls the real implementation. This is necessary to preserve function pointer equality.</p> </li> </ol> <p>The main upshot here is that we need to cook up heuristics for figuring out what goes in registers (since we allow reordering arguments to get better throughput). This is equivalent to the knapsack problem; knapsack heuristics are beyond the scope of this article. This should happen early enough that this information can be stuffed into <code class="language-plaintext highlighter-rouge">rmeta</code> to avoid needing to recompute it. We may want to use different, faster heuristics depending on <code class="language-plaintext highlighter-rouge">-Copt-level</code>. Note that correctness requires that we forbid linking code generated by multiple different Rust compilers, which is already the case, since Rust breaks ABI from release to release.</p> <h3 id="what-is-llvm-willing-to-do"><a href="#what-is-llvm-willing-to-do">What Is LLVM Willing to Do?</a></h3> <p>Assuming we do that, how do we actually get LLVM to pass things in the way we want it to? We need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of<sup id="fnref:doubles-and-vectors" role="doc-noteref"><a href="#fn:doubles-and-vectors" class="footnote" rel="footnote">2</a></sup>).</p> <p>The above values are for x86<sup id="fnref:official-support" role="doc-noteref"><a href="#fn:official-support" class="footnote" rel="footnote">3</a></sup>. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>I recommend that <em>every function</em> have the same number of by-register arguments. So on x86, EVERY <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> function’s signature should look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">declare</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span> <span class="vg">@my_func</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span><span class="p">,</span>
  <span class="c1">; other args...</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When passing pointers, the appropriate <code class="language-plaintext highlighter-rouge">i64</code>s should be replaced by <code class="language-plaintext highlighter-rouge">ptr</code>, and when passing <code class="language-plaintext highlighter-rouge">double</code>s, they replace <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>s.</p> <p>But you’re probably saying, “Miguel, that’s crazy! Most functions don’t pass 176 bytes!” And you’d be right, if not for the magic of LLVM’s very well-specified <code class="language-plaintext highlighter-rouge">poison</code> semantics.</p> <p>We can get away with not doing extra work if every argument we do not use is passed <code class="language-plaintext highlighter-rouge">poison</code>. Because <code class="language-plaintext highlighter-rouge">poison</code> is equal to “the most convenient possible value at the present moment”, when LLVM sees <code class="language-plaintext highlighter-rouge">poison</code> passed into a function via register, it decides that the most convenient value is “whatever happens to be in the register already”, and so it doesn’t have to touch that register!</p> <p>For example, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we would generate the following code.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; This is a -Zcallconv=fast-style function.</span>
<span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@load_rcx</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%load</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%load</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="nv">%1</span><span class="p">,</span>     <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span>  <span class="n">rax</span>
  <span class="n">mov</span>   <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span>  <span class="n">malloc</span>
  <span class="n">mov</span>   <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>  <span class="n">load_rcx</span>
  <span class="n">add</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">pop</span>   <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any proscribed way. And as we see, <code class="language-plaintext highlighter-rouge">load_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into the other thirteen registers compiles down to nothing<sup id="fnref:requires-opt" role="doc-noteref"><a href="#fn:requires-opt" class="footnote" rel="footnote">4</a></sup>, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, it is not total. In an ideal world, the same registers are used for input and output, to allow easier pipelining of calls without introducing extra register traffic. This is true on ARM and RISC-V, but not x86. However, because register ordering is merely a suggestion for us, we can choose to allocate the return registers in whatever order we want. For example, we can pretend the order registers should be allocated in is <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code> for inputs, and <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rax</code> for outputs.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%sq</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%sq</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">ARM Assembly</div></div></div> </div> <h3 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h3> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>First, return values. This is relatively straightforward, since there is only one value to pass. The amount of data we need to return is <em>not</em> the size of the struct. For example, <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code> measures 32 bytes wide. However, eight of those bytes are padding! We do not need to preserve padding when returning by value, so we can flatten the struct into <code class="language-plaintext highlighter-rouge">(u64, u32, u64, u32)</code> and sort by size into <code class="language-plaintext highlighter-rouge">(u64, u64, u32, u32)</code>. This has no padding and is 24 bytes wide, which fits into the three return registers LLVM gives us on x86. We define the <em>effective size</em> of a type to be the number of non-<code class="language-plaintext highlighter-rouge">undef</code> bits it occupies. For <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code>, this is 192 bits, since it excludes the padding. For <code class="language-plaintext highlighter-rouge">bool</code>, this is one. For <code class="language-plaintext highlighter-rouge">char</code> this is technically 21, but it’s simpler to treat <code class="language-plaintext highlighter-rouge">char</code> as an alias for <code class="language-plaintext highlighter-rouge">u32</code>.</p> <p>The reason for counting bits this way is that it permits significant compaction. For example, returning a struct full of bools can simply bit-pack the bools into a single register.</p> <p>So, a return value is converted to a by-ref return if its effective size is smaller than the output register space (on x86, this is three integer registers and four SSE registers, so we get 88 bytes total, or 704 bits).</p> <p>Argument registers are much harder, because we hit the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, which is NP-hard. The following relatively naive heuristic is where I would start, but it can be made infinitely smarter over time.</p> <p>First, demote to by-ref any argument whose effective size is larget than the total by-register input space (on x86, 176 bytes or 1408 bits). This means we get a pointer argument instead. This is beneficial to do first, since a single pointer might pack better than the huge struct.</p> <p>Enums should be replaced by the appropriate discriminant-union pair. For example, <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> is, internally, <code class="language-plaintext highlighter-rouge">(union { i32, () }, i1)</code>, while <code class="language-plaintext highlighter-rouge">Option&lt;Option&lt;i32&gt;&gt;</code> is <code class="language-plaintext highlighter-rouge">(union { i32, (), () }, i2)</code>. Using a small non-power-of-two integer improves our ability to pack things, since enum discriminants are often quite tiny.</p> <p>Next, we need to handle unions. Because mucking about with unions’ uninitialized bits behind our backs is allowed, we need to either pass it as an array of <code class="language-plaintext highlighter-rouge">u8</code>, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">5</a></sup>.</p> <p>Now, we can proceed to flatten everything. All of the converted arguments are flattened into their most primitive components: pointers, integers, floats, and bools. Every field should be no larger than the smallest argument register; this may require splitting large types such as <code class="language-plaintext highlighter-rouge">u128</code> or <code class="language-plaintext highlighter-rouge">f64</code>.</p> <p>This big list of primitives is next sorted by effective size, from smallest to largest. We take the largest prefix of this that will fit in the available register space; everything else goes on the stack.</p> <p>If part of a Rust-level input is sent to the stack in this way, and that part is larger than a small multiple of the pointer size (e.g., 2x), it is demoted to being passed by pointer-on-the-stack, to minimize memory traffic. Everything else is passed directly on the stack in the order those inputs were before the sort. This helps keep regions that need to be copied relatively contiguous, to minimize calls to <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>The things we choose to pass in registers are allocated to registers in reverse size order, so e.g. first 64-bit things, then 32-bit things, etc. This is the same layout algorithm that <code class="language-plaintext highlighter-rouge">repr(Rust)</code> structs use to move all the padding into the tail. Once we get to the <code class="language-plaintext highlighter-rouge">bool</code>s, those are bit-packed, 64 to a register.</p> <p>Here’s a relatively complicated example. My Rust function is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Context</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_thing</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">6</span><span class="p">],</span>
                <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">op_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">op_count</span> <span class="p">{</span>
    <span class="n">context</span><span class="nf">.check</span><span class="p">(</span><span class="n">op_count</span><span class="p">,</span> <span class="n">options</span><span class="py">.colorize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">code</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">suf</span><span class="p">))</span> <span class="o">=</span> <span class="n">name</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">suf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="s">"idk"</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The codegen for this function is quite complex, so I’ll only cover the prologue and epilogue. After sorting and flattening, our raw argument LLVM types are something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nl">gprs:</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm0:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm1:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Everything fits in registers! So, what does the LLVM function look like on x86?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@do_thing</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="c1">; Unused.</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">; First, unpack all the primitives.</span>
  <span class="nv">%r9.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%r9.1.i64</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span> <span class="m">32</span>
  <span class="nv">%r9.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9.1.i64</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%xmm0.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm0.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm0.2</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%xmm0.3</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span>
  <span class="nv">%xmm1.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm1.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.1.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.1.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.2.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%xmm1.1.2</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.2.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.3.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%xmm1.1.3</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.3.i32</span> <span class="k">to</span> <span class="kt">i1</span>

  <span class="c1">; Next, reassemble them into concrete values as needed.</span>
  <span class="nv">%op_count.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%op_count</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%op_count.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%context.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%context</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="nv">%context.0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%name.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%name</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="nv">%name.0</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%code.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.0</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.1</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.0</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%code.3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.2</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%code.4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.3</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.2</span><span class="p">,</span> <span class="m">4</span>
  <span class="nv">%code</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.4</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.3</span><span class="p">,</span> <span class="m">5</span>
  <span class="nv">%options.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm1.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%options.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%options.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.2</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%options</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.2</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.3</span><span class="p">,</span> <span class="m">3</span>

  <span class="c1">; Codegen as usual.</span>
  <span class="c1">; ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Above, <code class="language-plaintext highlighter-rouge">!dbg</code> metadata for the argument values should be attached to the instruction that actually materializes it. This ensures that gdb does something halfway intelligent when you ask it to print argument values.</p> <p>On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what returns <em>could</em> look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does)! When we’re generating the ABI that all callers will see (for <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code>), we can look at the function body. This means that a crate can advertise the <em>precise</em> ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABIs. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it.</p> <p>Another example: suppose that we know that an <code class="language-plaintext highlighter-rouge">&amp;T</code> argument is not retained (a question the borrow checker can answer at this point in the compiler) and is never converted to a raw pointer (or written to memory a raw pointer is taken of, etc). We also know that <code class="language-plaintext highlighter-rouge">T</code> is fairly small, and <code class="language-plaintext highlighter-rouge">T: Freeze</code>. Then, we can replace the reference with the pointee directly, passed by value.</p> <p>The most obvious candidates for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is a step further. We might know that some arguments are hotter than others, which might cause them to be prioritized in the register allocation order.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find really frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. But <code class="language-plaintext highlighter-rouge">-Zcallconv</code> is intended to only be used with optimizations turned on, so I don’t think this is a meaningful complaint. Nor do I think the project’s Goodhartization of compilation time as a metric is healthy… but I do not think this is ultimately a relevant drawback.</p> <p>I, unfortunately, do not have the spare time to dive into fixing rustc’s ABI code, but I do know LLVM really well, and I know that this is a place where Rust has a low bus factor. For that reason, I am happy to provide the Rust compiler team expert knowledge on getting LLVM to do the right thing in service of making optimized code faster.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:just-use-extern-c" role="doc-endnote"> <p>Or just switch it to the codepath for <code class="language-plaintext highlighter-rouge">extern "C"</code> or <code class="language-plaintext highlighter-rouge">extern "fastcall"</code> since those are clearly better. We will always need to know how to generate code for the non-<code class="language-plaintext highlighter-rouge">extern "Rust"</code> calling conventions. <a href="#fnref:just-use-extern-c" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:doubles-and-vectors" role="doc-endnote"> <p>It’s Complicated. Passing a <code class="language-plaintext highlighter-rouge">double</code> burns a whole <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code> slot. This seems bad, but it can be beneficial since keeping a <code class="language-plaintext highlighter-rouge">double</code> in vector registers reduces register traffic, since usually, fp instructions use the vector registers (or the fp registers shadow the vector registers, like on ARM). <a href="#fnref:doubles-and-vectors" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:official-support" role="doc-endnote"> <p>On the one hand, you might say this “extended calling convention” isn’t an explicitly supported part of LLVM’s <code class="language-plaintext highlighter-rouge">ccc</code> calling convention. On the other hand, <a href="hyrumslaw.com">Hyrum’s Law</a> cuts both ways: Rust is big enough of an LLVM user that LLVM cannot simply miscompile all Rust programs at this point, and the IR I propose Rust emits is extremely reasonable.</p> <p>If Rust causes LLVM to misbehave, that’s an LLVM bug, and we should fix LLVM bugs, not work around them. <a href="#fnref:official-support" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-opt" role="doc-endnote"> <p>Only on <code class="language-plaintext highlighter-rouge">-O1</code> or higher, bizarrely. At <code class="language-plaintext highlighter-rouge">-O0</code>, LLVM decides that all of the <code class="language-plaintext highlighter-rouge">poison</code>s must have the same value, so it copies a bunch of registers around needlessly. This seems like a bug? <a href="#fnref:requires-opt" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-11-27 • 6485 words • 54 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#optimization">#optimization</a> </span> <h1><a href="/2023/11/27/simd-base64/"> Designing a SIMD Algorithm from Scratch </a></h1> </div> <div class="post"> <p>Another explainer on a fun, esoteric topic: optimizing code with SIMD (single instruction multiple data, also sometimes called <em>vectorization</em>). Designing a good, fast, portable SIMD algorithm is not a simple matter and requires thinking a little bit like a circuit designer.</p> <p>Here’s the mandatory performance benchmark graph to catch your eye.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph.png" alt="perf perf perf"/></p> <p>“SIMD” often gets thrown around as a buzzword by performance and HPC (high performance computing) nerds, but I don’t think it’s a topic that has very friendly introductions out there, for a lot of reasons.</p> <ul> <li>It’s not something you will really want to care about unless you think performance is cool.</li> <li>APIs for programming with SIMD in most programming languages are <em>garbage</em> (I’ll get into why).</li> <li>SIMD algorithms are hard to think about if you’re very procedural-programming-brained. A functional programming mindset can help a lot.</li> </ul> <p>This post is mostly about <a href="https://docs.rs/vb64/latest/vb64/"><code class="language-plaintext highlighter-rouge">vb64</code></a> (which stands for <em>v</em>ector <em>b</em>ase<em>64</em>), a base64 codec I wrote to see for myself if Rust’s <code class="language-plaintext highlighter-rouge">std::simd</code> library is any good, but it’s also an excuse to talk about SIMD in general.</p> <p>What <em>is</em> SIMD, anyways? Let’s dive in.</p> <p>If you want to skip straight to the writeup on <code class="language-plaintext highlighter-rouge">vb64</code>, click <a href="#parsing-with-simd">here</a>.</p> <h2 id="problems-with-physics"><a href="#problems-with-physics">Problems with Physics</a></h2> <p>Unfortunately, computers exist in the real world<sup>[citation-needed]</sup>, and are bound by the laws of nature. SIMD has relatively little to do with theoretical CS considerations, and everything to do with <em>physics</em>.</p> <p>In the infancy of modern computing, you could simply improve performance of existing programs by buying new computers. This is often incorrectly attributed to Moore’s law (the number of transistors on IC designs doubles every two years). Moore’s law still appears to hold as of 2023, but some time in the last 15 years the <a href="https://en.wikipedia.org/wiki/Dennard_scaling">Dennard scaling</a> effect broke down. This means that denser transistors eventually means increased power dissipation density. In simpler terms, we don’t know how to continue to increase the clock frequency of computers without literally <em>liquefying</em> them.</p> <p>So, since the early aughts, the hot new thing has been bigger core counts. Make your program more multi-threaded and it will run faster on bigger CPUs. This comes with synchronization overhead, since now the cores need to cooperate. All control flow, be it jumps, virtual calls, or synchronization will result in “stall”.</p> <p>The main causes of stall are <em>branches</em>, instructions that indicate code can take one of two possible paths (like an <code class="language-plaintext highlighter-rouge">if</code> statement), and <em>memory operations</em>. Branches include all control flow: <code class="language-plaintext highlighter-rouge">if</code> statements, loops, function calls, function returns, even <code class="language-plaintext highlighter-rouge">switch</code> statements in C. Memory operations are loads and stores, especially ones that are cache-unfriendly.</p> <h3 id="procedural-code-is-slow"><a href="#procedural-code-is-slow">Procedural Code Is Slow</a></h3> <p>Modern compute cores do not execute code line-by-line, because that would be very inefficient. Suppose I have this program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{a}, {b}"</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There’s no reason for the CPU to wait to finish computing <code class="language-plaintext highlighter-rouge">a</code> before it begins computing <code class="language-plaintext highlighter-rouge">b</code>; it does not depend on <code class="language-plaintext highlighter-rouge">a</code>, and while the add is being executed, the xor circuits are idle. Computers say “program order be damned” and issue the add for <code class="language-plaintext highlighter-rouge">a</code> and the xor for <code class="language-plaintext highlighter-rouge">b</code> simultaneously. This is called <em>instruction-level parallelism</em>, and dependencies that get in the way of it are often called <em>data hazards</em>.</p> <p>Of course, the Zen 2 in the machine I’m writing this with does not have one measly adder per core. It has dozens and dozens! The opportunities for parallelism are massive, as long as the compiler in your CPU’s execution pipeline can clear any data hazards in the way.</p> <p>The better the core can do this, the more it can saturate all of the “functional units” for things like arithmetic, and the more numbers it can crunch per unit time, approaching maximum utilization of the hardware. Whenever the compiler can’t do this, the execution pipeline stalls and your code is slower.</p> <p>Branches stall because they need to wait for the branch condition to be computed before fetching the next instruction (speculative execution is a somewhat iffy workaround for this). Memory operations stall because the data needs to physically arrive at the CPU, and the speed of light is finite in this universe.</p> <p>Trying to reduce stall by improving opportunities for single-core parallelism is not a new idea. Consider the not-so-humble GPU, whose purpose in life is to render images. Images are vectors of pixels (i.e., color values), and rendering operations tend to be highly local. For example, a convolution kernel for a Gaussian blur will be two or even three orders of magnitude smaller than the final image, lending itself to locality.</p> <p>Thus, GPUs are built for divide-and-conquer: they provide primitives for doing batched operations, and extremely limited control flow.</p> <p>“SIMD” is synonymous with “batching”. It stands for “single instruction, multiple data”: a single instruction dispatches parallel operations on multiple <em>lanes</em> of data. GPUs are the original SIMD machines.</p> <h2 id="lane-wise"><a href="#lane-wise">Lane-Wise</a></h2> <p>“SIMD” and “vector” are often used interchangeably. The fundamental unit a SIMD instruction (or “vector instruction”) operates on is a vector: a fixed-size array of numbers that you primarily operate on component-wise These components are called <em>lanes</em>.</p> <p>SIMD vectors are usually quite small, since they need to fit into registers. For example, on my machine, the largest vectors are 256 bits wide. This is enough for 32 bytes (a <code class="language-plaintext highlighter-rouge">u8x32</code>), 4 double-precision floats (an <code class="language-plaintext highlighter-rouge">f64x8</code>), or all kinds of things in between.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/vectors.png" alt="some 256-bit vectors"/></p> <p>Although this doesn’t seem like much, remember that offloading the overhead of keeping the pipeline saturated by a factor of 4x can translate to that big of a speedup in latency.</p> <h3 id="one-bit-lanes"><a href="#one-bit-lanes">One-Bit Lanes</a></h3> <p>The simplest vector operations are bitwise: and, or, xor. Ordinary integers can be thought of as vectors themselves, with respect to the bitwise operations. That’s literally what “bitwise” means: lanes-wise with lanes that are one bit wide. An <code class="language-plaintext highlighter-rouge">i32</code> is, in this regard, an <code class="language-plaintext highlighter-rouge">i1x32</code>.</p> <p>In fact, as a warmup, let’s look at the problem of counting the number of 1 bits in an integer. This operation is called “population count”, or <code class="language-plaintext highlighter-rouge">popcnt</code>. If we view an <code class="language-plaintext highlighter-rouge">i32</code> as an <code class="language-plaintext highlighter-rouge">i1x32</code>, <code class="language-plaintext highlighter-rouge">popcnt</code> is just a fold or reduce operation:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">popcnt</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">32</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bit</span><span class="p">)</span> <span class="k">in</span> <span class="n">bits</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">total</span><span class="p">,</span> <span class="n">bit</span><span class="p">|</span> <span class="n">total</span> <span class="o">+</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBwb3BjbnQobXV0IHg6IHUzMikgLT4gdTMyIHtcbiAgbGV0 IG11dCBiaXRzID0gWzA7IDMyXTtcbiAgZm9yIChpLCBiaXQpIGluIGJpdHMu aXRlcl9tdXQoKS5lbnVtZXJhdGUoKSB7XG4gICAgKmJpdCA9ICh4ID4+IGkp ICYgMTtcbiAgfVxuICBiaXRzLmludG9faXRlcigpLmZvbGQoMCwgfHRvdGFs LCBiaXR8IHRvdGFsICsgYml0KVxufSIsImNvbXBpbGVycyI6W3siaWQiOiJi ZXRhIiwib3B0aW9ucyI6Ii1PIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>In other words, we interpret the integer as an array of bits and then add the bits together to a 32-bit accumulator. Note that the accumulator needs to be higher precision to avoid overflow: accumulating into an <code class="language-plaintext highlighter-rouge">i1</code> (as with the <code class="language-plaintext highlighter-rouge">Iterator::reduce()</code> method) will only tell us whether the number of 1 bits is even or odd.</p> <p>Of course, this produces… comically bad code, frankly. We can do much better if we notice that we can <em>vectorize</em> the addition: first we add all of the adjacent pairs of bits together, then the pairs of pairs, and so on. This means the number of adds is logarithmic in the number of bits in the integer.</p> <p>Visually, what we do is we “unzip” each vector, shift one to line up the lanes, add them, and then repeat with lanes twice as big.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/popcnt.png" alt="first two popcnt merge steps"/></p> <p>This is what that looks like in code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">popcnt</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="c1">// View x as a i1x32, and split it into two vectors</span>
  <span class="c1">// that contain the even and odd bits, respectively.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x55555555</span><span class="p">;</span> <span class="c1">// 0x5 == 0b0101.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xaaaaaaaa</span><span class="p">;</span> <span class="c1">// 0xa == 0b1010.</span>
  <span class="c1">// Shift odds down to align the bits, and then add them together.</span>
  <span class="c1">// We interpret x now as a i2x16. When adding, each two-bit</span>
  <span class="c1">// lane cannot overflow, because the value in each lane is</span>
  <span class="c1">// either 0b00 or 0b01.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Repeat again but now splitting even and odd bit-pairs.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x33333333</span><span class="p">;</span> <span class="c1">// 0x3 == 0b0011.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xcccccccc</span><span class="p">;</span> <span class="c1">// 0xc == 0b1100.</span>
  <span class="c1">// We need to shift by 2 to align, and now for this addition</span>
  <span class="c1">// we interpret x as a i4x8.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Again. The pattern should now be obvious.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x0f0f0f0f</span><span class="p">;</span> <span class="c1">// 0x0f == 0b00001111.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xf0f0f0f0</span><span class="p">;</span> <span class="c1">// 0xf0 == 0b11110000.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// i8x4</span>

  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x00ff00ff</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xff00ff00</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>  <span class="c1">// i16x2</span>

  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x0000ffff</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xffff0000</span><span class="p">;</span>
  <span class="c1">// Because the value of `x` is at most 32, although we interpret this as a</span>
  <span class="c1">// i32x1 add, we could get away with just one e.g. i16 add.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

  <span class="n">x</span> <span class="c1">// Done. All bits have been added.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBwb3BjbnQobXV0IHg6IHUzMikgLT4gdTMyIHtcbiAgLy8g VmlldyB4IGFzIGEgaTF4MzIsIGFuZCBzcGxpdCBpdCBpbnRvIHR3byB2ZWN0 b3JzXG4gIC8vIHRoYXQgY29udGFpbiB0aGUgZXZlbiBhbmQgb2RkIGJpdHMs IHJlc3BlY3RpdmVseS5cbiAgbGV0IGV2ZW4gPSB4ICYgMHg1NTU1NTU1NTsg Ly8gMHg1ID09IDBiMDEwMS5cbiAgbGV0IG9kZHMgPSB4ICYgMHhhYWFhYWFh YTsgLy8gMHhhID09IDBiMTAxMC5cbiAgLy8gU2hpZnQgb2RkcyBkb3duIHRv IGFsaWduIHRoZSBiaXRzLCBhbmQgdGhlbiBhZGQgdGhlbSB0b2dldGhlci5c biAgLy8gV2UgaW50ZXJwcmV0IHggbm93IGFzIGEgaTJ4MTYuIFdoZW4gYWRk aW5nLCBlYWNoIHR3by1iaXRcbiAgLy8gbGFuZSBjYW5ub3Qgb3ZlcmZsb3cs IGJlY2F1c2UgdGhlIHZhbHVlIGluIGVhY2ggbGFuZSBpc1xuICAvLyBlaXRo ZXIgMGIwMCBvciAwYjAxLlxuICB4ID0gZXZlbiArIChvZGRzID4+IDEpO1xu XG4gIC8vIFJlcGVhdCBhZ2FpbiBidXQgbm93IHNwbGl0dGluZyBldmVuIGFu ZCBvZGQgYml0LXBhaXJzLlxuICBsZXQgZXZlbiA9IHggJiAweDMzMzMzMzMz OyAvLyAweDMgPT0gMGIwMDExLlxuICBsZXQgb2RkcyA9IHggJiAweGNjY2Nj Y2NjOyAvLyAweGMgPT0gMGIxMTAwLlxuICAvLyBXZSBuZWVkIHRvIHNoaWZ0 IGJ5IDIgdG8gYWxpZ24sIGFuZCBub3cgZm9yIHRoaXMgYWRkaXRpb25cbiAg Ly8gd2UgaW50ZXJwcmV0IHggYXMgYSBpNHg4LlxuICB4ID0gZXZlbiArIChv ZGRzID4+IDIpO1xuXG4gIC8vIEFnYWluLiBUaGUgcGF0dGVybiBzaG91bGQg bm93IGJlIG9idmlvdXMuXG4gIGxldCBldmVuID0geCAmIDB4MGYwZjBmMGY7 IC8vIDB4MGYgPT0gMGIwMDAwMTExMS5cbiAgbGV0IG9kZHMgPSB4ICYgMHhm MGYwZjBmMDsgLy8gMHhmMCA9PSAwYjExMTEwMDAwLlxuICB4ID0gZXZlbiAr IChvZGRzID4+IDQpOyAvLyBpOHg0XG5cbiAgbGV0IGV2ZW4gPSB4ICYgMHgw MGZmMDBmZjtcbiAgbGV0IG9kZHMgPSB4ICYgMHhmZjAwZmYwMDtcbiAgeCA9 IGV2ZW4gKyAob2RkcyA+PiA4KTsgIC8vIGkxNngyXG5cbiAgbGV0IGV2ZW4g PSB4ICYgMHgwMDAwZmZmZjtcbiAgbGV0IG9kZHMgPSB4ICYgMHhmZmZmMDAw MDtcbiAgLy8gQmVjYXVzZSB0aGUgdmFsdWUgb2YgYHhgIGlzIGF0IG1vc3Qg MzIsIGFsdGhvdWdoIHdlIGludGVycHJldCB0aGlzIGFzIGFcbiAgLy8gaTMy eDEgYWRkLCB3ZSBjb3VsZCBnZXQgYXdheSB3aXRoIGp1c3Qgb25lIGUuZy4g aTE2IGFkZC5cbiAgeCA9IGV2ZW4gKyAob2RkcyA+PiAxNik7XG5cbiAgeCAv LyBEb25lLiBBbGwgYml0cyBoYXZlIGJlZW4gYWRkZWQuXG59IiwiY29tcGls ZXJzIjpbeyJpZCI6ImJldGEiLCJvcHRpb25zIjoiLU8ifV19XX0=">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This still won’t optimize down to a <code class="language-plaintext highlighter-rouge">popcnt</code> instruction, of course. The search scope for such a simplification is in the regime of superoptimizers. However, the generated code is small and fast, which is why this is the ideal implementation of <code class="language-plaintext highlighter-rouge">popcnt</code> for systems without such an instruction.</p> <p>It’s <em>especially</em> nice because it is implementable for e.g. <code class="language-plaintext highlighter-rouge">u64</code> with only one more reduction step (remember: it’s <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>!), and does not at any point require a full <code class="language-plaintext highlighter-rouge">u64</code> addition.</p> <p>Even though this is “just” using scalars, divide-and-conquer approaches like this are the bread and butter of the SIMD programmer.</p> <h3 id="scaling-up-operations-on-real-vectors"><a href="#scaling-up-operations-on-real-vectors">Scaling Up: Operations on Real Vectors</a></h3> <p>Proper SIMD vectors provide more sophisticated semantics than scalars do, particularly because there is more need to provide replacements for things like control flow. Remember, control flow is slow!</p> <p>What’s actually available is highly dependent on the architecture you’re compiling to (more on this later), but the way vector instruction sets are usually structured is something like this.</p> <p>We have <em>vector registers</em> that are kind of like really big general-purpose registers. For example, on x86, most “high performance” cores (like my Zen 2) implement AVX2, which provides 256 bit <code class="language-plaintext highlighter-rouge">ymm</code> vectors. The registers themselves do not have a “lane count”; that is specified by the instructions. For example, the “vector byte add instruction” interprets the register as being divided into eight-byte lanes and adds them. The corresponding x86 instruction is <code class="language-plaintext highlighter-rouge">vpaddb</code>, which interprets a <code class="language-plaintext highlighter-rouge">ymm</code> as an <code class="language-plaintext highlighter-rouge">i8x32</code>.</p> <p>The operations you usually get are:</p> <ol> <li> <p>Bitwise operations. These don’t need to specify a lane width because it’s always implicitly <code class="language-plaintext highlighter-rouge">1</code>: they’re <em>bit</em>wise.</p> </li> <li> <p>Lane-wise arithmetic. This is addition, subtraction, multiplication, division (both int and float), and shifts<sup id="fnref:shifts-are-arithmetic" role="doc-noteref"><a href="#fn:shifts-are-arithmetic" class="footnote" rel="footnote">1</a></sup> (int only). Lane-wise min and max are also common. These require specifying a lane width. Typically the smallest number of lanes is two or four.</p> </li> <li> <p>Lane-wise compare. Given <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, we can create a new <em>mask vector</em> <code class="language-plaintext highlighter-rouge">m</code> such that <code class="language-plaintext highlighter-rouge">m[i] = a[i] &lt; b[i]</code> (or any other comparison operation). A mask vector’s lanes contain boolean values with an unusual bit-pattern: all-zeros (for false) or all-ones (for true)<sup id="fnref:minus-true" role="doc-noteref"><a href="#fn:minus-true" class="footnote" rel="footnote">2</a></sup>.</p> <ul> <li>Masks can be used to select between two vectors: for example, given <code class="language-plaintext highlighter-rouge">m</code>, <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">y</code>, you can form a fourth vector <code class="language-plaintext highlighter-rouge">z</code> such that <code class="language-plaintext highlighter-rouge">z[i] = m[i] ? a[i] : b[i]</code>.</li> </ul> </li> <li> <p>Shuffles (sometimes called swizzles). Given <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">x</code>, create a third vector <code class="language-plaintext highlighter-rouge">s</code> such that <code class="language-plaintext highlighter-rouge">s[i] = a[x[i]]</code>. <code class="language-plaintext highlighter-rouge">a</code> is used as a lookup table, and <code class="language-plaintext highlighter-rouge">x</code> as a set of indices. Out of bounds produces a special value, usually zero. This emulates parallelized array access without needing to actually touch RAM (RAM is extremely slow).</p> <ul> <li>Often there is a “shuffle2” or “riffle” operation that allows taking elements from one of two vectors. Given <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">x</code>, we now define <code class="language-plaintext highlighter-rouge">s</code> as being <code class="language-plaintext highlighter-rouge">s[i] = (a ++ b)[x[i]]</code>, where <code class="language-plaintext highlighter-rouge">a ++ b</code> is a double-width concatenation. How this is actually implemented depends on architecture, and it’s easy to build out of single shuffles regardless.</li> </ul> </li> </ol> <p>(1) and (2) are ordinary number crunching. Nothing deeply special about them.</p> <p>The comparison and select operations in (3) are intended to help SIMD code stay “branchless”. Branchless code is written such that it performs the same operations regardless of its inputs, and relies on the properties of those operations to produce correct results. For example, this might mean taking advantage of identities like <code class="language-plaintext highlighter-rouge">x * 0 = 0</code> and <code class="language-plaintext highlighter-rouge">a ^ b ^ a = b</code> to discard “garbage” results.</p> <p>The shuffles described in (4) are much more powerful than meets the eye.</p> <p>For example, “broadcast” (sometimes called “splat”) makes a vector whose lanes are all the same scalar, like Rust’s <code class="language-plaintext highlighter-rouge">[42; N]</code> array literal. A broadcast can be expressed as a shuffle: create a vector with the desired value in the first lane, and then shuffle it with an index vector of <code class="language-plaintext highlighter-rouge">[0, 0, ...]</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/broadcast.png" alt="diagram of a broadcast"/></p> <p>“Interleave” (also called “zip” or “pack”) takes two vectors <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> and creates two new vectors <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> whose lanes are alternating lanes from <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. If the lane count is <code class="language-plaintext highlighter-rouge">n</code>, then <code class="language-plaintext highlighter-rouge">c = [a[0], b[0], a[1], b[1], ...]</code> and <code class="language-plaintext highlighter-rouge">d = [a[n/2], b[n/2], a[n/2 + 1], b[n/2 + 1], ...]</code>. This can also be implemented as a shuffle2, with shuffle indices of <code class="language-plaintext highlighter-rouge">[0, n, 1, n + 1, ...]</code>. “Deinterleave” (or “unzip”, or “unpack”) is the opposite operation: it interprets a pair of vectors as two halves of a larger vector of pairs, and produces two new vectors consisting of the halves of each pair.</p> <p>Interleave can also be interpreted as taking a <code class="language-plaintext highlighter-rouge">[T; N]</code>, transmuting it to a <code class="language-plaintext highlighter-rouge">[[T; N/2]; 2]</code>, performing a matrix transpose to turn it into a <code class="language-plaintext highlighter-rouge">[[T; 2]; N/2]</code>, and then transmuting that back to <code class="language-plaintext highlighter-rouge">[T; N]</code> again. Deinterleave is the same but it transmutes to <code class="language-plaintext highlighter-rouge">[[T; 2]; N/2]</code> first.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/interleave.png" alt="diagram of a interleave"/></p> <p>“Rotate” takes a vector <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">n</code> lanes and produces a new vector <code class="language-plaintext highlighter-rouge">b</code> such that <code class="language-plaintext highlighter-rouge">b[i] = a[(i + j) % n]</code>, for some chosen integer <code class="language-plaintext highlighter-rouge">j</code>. This is yet another shuffle, with indices <code class="language-plaintext highlighter-rouge">[j, j + 1, ..., n - 1, 0, 1, ... j - 1]</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/rotate.png" alt="diagram of a rotate"/></p> <p>Shuffles are worth trying to wrap your mind around. SIMD programming is all about reinterpreting larger-than-an-integer-sized blocks of data as smaller blocks of varying sizes, and shuffling is important for getting data into the right “place”.</p> <h3 id="intrinsics-and-instruction-selection"><a href="#intrinsics-and-instruction-selection">Intrinsics and Instruction Selection</a></h3> <p>Earlier, I mentioned that what you get varies by architecture. This section is basically a giant footnote.</p> <p>So, there’s two big factors that go into this.</p> <ol> <li>We’ve learned over time which operations tend to be most useful to programmers. x86 might have something that ARM doesn’t because it “seemed like a good idea at the time” but turned out to be kinda niche.</li> <li>Instruction set extensions are often market differentiators, even within the same vendor. Intel has AVX-512, which provides even more sophisticated instructions, but it’s only available on high-end server chips, because it makes manufacturing more expensive.</li> </ol> <p>Toolchains generalize different extensions as “target features”. Features can be detected at runtime through architecture-specific magic. On Linux, the <code class="language-plaintext highlighter-rouge">lscpu</code> command will list what features the CPU advertises that it recognizes, which correlate with the names of features that e.g. LLVM understands. What features are enabled for a particular function affects how LLVM compiles it. For example, LLVM will only emit <code class="language-plaintext highlighter-rouge">ymm</code>-using code when compiling with <code class="language-plaintext highlighter-rouge">+avx2</code>.</p> <p>So how do you write portable SIMD code? On the surface, the answer is mostly “you don’t”, but it’s more complicated than that, and for that we need to understand how the later parts of a compiler works.</p> <p>When a user requests an add by writing <code class="language-plaintext highlighter-rouge">a + b</code>, how should I decide which instruction to use for it? This seems like a trick question… <em>just</em> an <code class="language-plaintext highlighter-rouge">add</code> right? On x86, even this isn’t so easy, since you have a choice between the actual <code class="language-plaintext highlighter-rouge">add</code> instruction, or a <code class="language-plaintext highlighter-rouge">lea</code> instruction (which, among other things, preserves the <code class="language-plaintext highlighter-rouge">rflags</code> register). This question becomes more complicated for more sophisticated operations. This general problem is called <em>instruction selection</em>.</p> <p>Because which “target features” are enabled affects which instructions are available, they affect instruction selection. When I went over operations “typically available”, this means that compilers will usually be able to select good choices of instructions for them on most architectures.</p> <p>Compiling with something like <code class="language-plaintext highlighter-rouge">-march=native</code> or <code class="language-plaintext highlighter-rouge">-Ctarget-cpu=native</code> gets you “the best” code possible for the machine you’re building on, but it might not be portable<sup id="fnref:abi" role="doc-noteref"><a href="#fn:abi" class="footnote" rel="footnote">3</a></sup> to different processors. Gentoo was quite famous for building packages from source on user machines to take advantage of this (not to mention that they loved using <code class="language-plaintext highlighter-rouge">-O3</code>, which mostly exists to slow down build times with little benefit).</p> <p>There is also runtime feature detection, where a program decides which version of a function to call at runtime by asking the CPU what it supports. Code deployed on heterogenous devices (like cryptography libraries) often make use of this. Doing this correctly is very hard and something I don’t particularly want to dig deeply into here.</p> <p>The situation is made worse by the fact that in C++, you usually write SIMD code using “intrinsics”, which are special functions with inscrutable names like <code class="language-plaintext highlighter-rouge">_mm256_cvtps_epu32</code> that represent a low-level operation in a specific instruction set (this is a float to int cast from AVX2). Intrinsics are defined by hardware vendors, but don’t necessarily map down to single instructions; the compiler can still optimize these instructions by merging, deduplication, and through instruction selection.</p> <p>As a result you wind up writing the same code multiple times for different instruction sets, with only minor maintainability benefits over writing assembly.</p> <p>The alternative is a portable SIMD library, which does some instruction selection behind the scenes at the library level but tries to rely on the compiler for most of the heavy-duty work. For a long time I was skeptical that this approach would actually produce good, competitive code, which brings us to the actual point of this article: using Rust’s portable SIMD library to implement a somewhat fussy algorithm, and measuring performance.</p> <h2 id="parsing-with-simd"><a href="#parsing-with-simd">Parsing with SIMD</a></h2> <p>Let’s design a SIMD implementation for a well-known algorithm. Although it doesn’t look like it at first, the power of shuffles makes it possible to parse text with SIMD. And this parsing can be very, very fast.</p> <p>In this case, we’re going to implement base64 decoding. To review, base64 is an encoding scheme for arbitrary binary data into ASCII. We interpret a byte slice as a bit vector, and divide it into six-bit chunks called <em>sextets</em>. Then, each sextet from 0 to 63 is mapped to an ASCII character:</p> <ol> <li><code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">25</code> go to <code class="language-plaintext highlighter-rouge">'A'</code> to <code class="language-plaintext highlighter-rouge">'Z'</code>.</li> <li><code class="language-plaintext highlighter-rouge">26</code> to <code class="language-plaintext highlighter-rouge">51</code> go to <code class="language-plaintext highlighter-rouge">'a'</code> to <code class="language-plaintext highlighter-rouge">'z'</code>.</li> <li><code class="language-plaintext highlighter-rouge">52</code> to <code class="language-plaintext highlighter-rouge">61</code> go to <code class="language-plaintext highlighter-rouge">'0'</code> to <code class="language-plaintext highlighter-rouge">'9'</code>.</li> <li><code class="language-plaintext highlighter-rouge">62</code> goes to <code class="language-plaintext highlighter-rouge">+</code>.</li> <li><code class="language-plaintext highlighter-rouge">63</code> goes to <code class="language-plaintext highlighter-rouge">/</code>.</li> </ol> <p>There <em>are</em> other variants of base64, but the bulk of the complexity is the same for each variant.</p> <p>There are a few basic pitfalls to keep in mind.</p> <ol> <li> <p>Base64 is a “big endian” format: specifically, the bits in each byte are big endian. Because a sextet can span only parts of a byte, this distinction is important.</p> </li> <li> <p>We need to beware of cases where the input length is not divisible by 4; ostensibly messages should be padded with <code class="language-plaintext highlighter-rouge">=</code> to a multiple of 4, but it’s easy to just handle messages that aren’t padded correctly.</p> </li> </ol> <p>The length of a decoded message is given by this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">input</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="k">match</span> <span class="n">input</span> <span class="o">%</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="p">|</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="mi">3</span> <span class="k">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Given all this, the easiest way to implement base64 is something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Tear off at most two trailing =.</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// Split the input into chunks of at most 4 bytes.</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">byte</span> <span class="k">in</span> <span class="n">chunk</span> <span class="p">{</span>
      <span class="c1">// Translate each ASCII character into its corresponding</span>
      <span class="c1">// sextet, or return an error.</span>
      <span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
        <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
        <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
        <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
        <span class="sc">b'+'</span> <span class="k">=&gt;</span> <span class="mi">62</span><span class="p">,</span>
        <span class="sc">b'/'</span> <span class="k">=&gt;</span> <span class="mi">63</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nf">Error</span><span class="p">(</span><span class="o">...</span><span class="p">)),</span>
      <span class="p">};</span>

      <span class="c1">// Append the sextet to the temporary buffer.</span>
      <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
      <span class="n">bytes</span> <span class="p">|</span><span class="o">=</span> <span class="n">sextet</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Shift things so the actual data winds up at the</span>
    <span class="c1">// top of `bytes`.</span>
    <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">32</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">chunk</span><span class="nf">.len</span><span class="p">();</span>

    <span class="c1">// Append the decoded data to `out`, keeping in mind that</span>
    <span class="c1">// `bytes` is big-endian encoded.</span>
    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="nf">.to_be_bytes</span><span class="p">()[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So, what’s the process of turning this into a SIMD version? We want to follow one directive with inexorable, robotic dedication.</p> <p><strong>Eliminate all branches.</strong></p> <p>This is not completely feasible, since the input is of variable length. But we can try. There are several branches in this code:</p> <ol> <li>The <code class="language-plaintext highlighter-rouge">for chunk in</code> line. This one is is the length check: it checks if there is any data left to process.</li> <li>The <code class="language-plaintext highlighter-rouge">for &amp;byte in</code> line. This is the hottest loop: it branches once per input byte.</li> <li>The <code class="language-plaintext highlighter-rouge">match byte</code> line is several branches, to determine which of the five “valid” match arms we land in.</li> <li>The <code class="language-plaintext highlighter-rouge">return Err</code> line. Returning in a hot loop is extra control flow, which is not ideal.</li> <li>The call to <code class="language-plaintext highlighter-rouge">decoded_len</code> contains a <code class="language-plaintext highlighter-rouge">match</code>, which generates branches.</li> <li>The call to <code class="language-plaintext highlighter-rouge">Vec::extend_from_slice</code>. This contains not just branches, but potential calls into the allocator. Extremely slow.</li> </ol> <p>(5) is the easiest to deal with. The <code class="language-plaintext highlighter-rouge">match</code> is mapping the values <code class="language-plaintext highlighter-rouge">0, 1, 2, 3</code> to <code class="language-plaintext highlighter-rouge">0, 1, 1, 2</code>. Call this function <code class="language-plaintext highlighter-rouge">f</code>. Then, the sequence given by <code class="language-plaintext highlighter-rouge">x - f(x)</code> is <code class="language-plaintext highlighter-rouge">0, 0, 1, 1</code>. This just happens to equal <code class="language-plaintext highlighter-rouge">x / 2</code> (or <code class="language-plaintext highlighter-rouge">x &gt;&gt; 1</code>), so we can write a completely branchless version of <code class="language-plaintext highlighter-rouge">decoded_len</code> like so.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">mod4</span> <span class="o">=</span> <span class="n">input</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">input</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">mod4</span> <span class="o">-</span> <span class="n">mod4</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBkZWNvZGVkX2xlbihpbnB1dDogdXNpemUpIC0+IHVzaXpl IHtcbiAgbGV0IG1vZDQgPSBpbnB1dCAlIDQ7XG4gIGlucHV0IC8gNCAqIDMg KyAobW9kNCAtIG1vZDQgLyAyKVxufSIsImNvbXBpbGVycyI6W3siaWQiOiJi ZXRhIiwib3B0aW9ucyI6Ii1PIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>That’s one branch eliminated<sup id="fnref:why-cant-llvm-do-it" role="doc-noteref"><a href="#fn:why-cant-llvm-do-it" class="footnote" rel="footnote">4</a></sup>. ✅</p> <p>The others will not prove so easy. Let’s turn our attention to the innermost loop next, branches (2), (3), and (4).</p> <h3 id="the-hottest-loop"><a href="#the-hottest-loop">The Hottest Loop</a></h3> <p>The superpower of SIMD is that because you operate on so much data at a time, you can unroll the loop so hard it becomes branchless.</p> <p>The insight is this: we want to load at most four bytes, do something to them, and then spit out at most three decoded bytes. While doing this operation, we may encounter a syntax error so we need to report that somehow.</p> <p>Here’s some facts we can take advantage of.</p> <ol> <li>We don’t need to figure out how many bytes are in the “output” of the hot loop: our handy branchless <code class="language-plaintext highlighter-rouge">decoded_len()</code> does that for us.</li> <li>Invalid base64 is extremely rare. We want that syntax error to cost as little as possible. If the user still cares about which byte was the problem, they can scan the input for it after the fact.</li> <li><code class="language-plaintext highlighter-rouge">A</code> is zero in base64. If we’re parsing a truncated chunk, padding it with <code class="language-plaintext highlighter-rouge">A</code> won’t change the value<sup id="fnref:pad-with-A" role="doc-noteref"><a href="#fn:pad-with-A" class="footnote" rel="footnote">5</a></sup>.</li> </ol> <p>This suggests an interface for the body of the “hottest loop”. We can factor it out as a separate function, and simplify since we can assume our input is always four bytes now.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="p">([</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ok</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">byte</span> <span class="k">in</span> <span class="n">ascii</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
      <span class="sc">b'+'</span> <span class="k">=&gt;</span> <span class="mi">62</span><span class="p">,</span>
      <span class="sc">b'/'</span> <span class="k">=&gt;</span> <span class="mi">63</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">bytes</span> <span class="p">|</span><span class="o">=</span> <span class="n">sextet</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="n">ok</span> <span class="o">&amp;=</span> <span class="n">byte</span> <span class="o">==</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This is the `to_be_bytes()` call.</span>
  <span class="k">let</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">bytes</span><span class="nf">.to_le_bytes</span><span class="p">();</span>
  <span class="p">([</span><span class="n">b3</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">],</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// In decode()...</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
  <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

  <span class="k">let</span> <span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">);</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
  <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>You’re probably thinking: why not return <code class="language-plaintext highlighter-rouge">Option&lt;[u8; 3]&gt;</code>? Returning an enum will make it messier to eliminate the <code class="language-plaintext highlighter-rouge">if !ok</code> branch later on (which we will!). We want to write branchless code, so let’s focus on finding a way of producing that three-byte output without needing to do early returns.</p> <p>Now’s when we want to start talking about vectors rather than arrays, so let’s try to rewrite our function as such.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="nd">unimplemented!</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that the output is now four bytes, not three. SIMD lane counts need to be powers of two, and that last element will never get looked at, so we don’t need to worry about what winds up there.</p> <p>The callsite also needs to be tweaked, but only slightly, because <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> is <code class="language-plaintext highlighter-rouge">From&lt;[u8; 4]&gt;</code>.</p> <h3 id="ascii-to-sextet"><a href="#ascii-to-sextet">ASCII to Sextet</a></h3> <p>Let’s look at the first part of the <code class="language-plaintext highlighter-rouge">for byte in ascii</code> loop. We need to map each lane of the <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> to the corresponding sextet, and somehow signal which ones are invalid. First, notice something special about the <code class="language-plaintext highlighter-rouge">match</code>: almost every arm can be written as <code class="language-plaintext highlighter-rouge">byte - C</code> for some constant <code class="language-plaintext highlighter-rouge">C</code>. The non-range case looks a little silly, but humor me:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
  <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
  <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
  <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
  <span class="sc">b'+'</span>        <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'+'</span> <span class="o">+</span> <span class="mi">62</span><span class="p">,</span>
  <span class="sc">b'/'</span>        <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'/'</span> <span class="o">+</span> <span class="mi">63</span><span class="p">,</span>
  <span class="n">_</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So, it should be sufficient to build a vector <code class="language-plaintext highlighter-rouge">offsets</code> that contains the appropriate constant <code class="language-plaintext highlighter-rouge">C</code> for each lane, and then <code class="language-plaintext highlighter-rouge">let sextets = ascii - offsets;</code></p> <p>How can we build <code class="language-plaintext highlighter-rouge">offsets</code>? Using compare-and-select.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// A lane-wise version of `x &gt;= start &amp;&amp; x &lt;= end`.</span>
<span class="k">fn</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">bytes</span><span class="nf">.simd_ge</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">bytes</span><span class="nf">.simd_le</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Create masks for each of the five ranges.</span>
<span class="c1">// Note that these are disjoint: for any two masks, m1 &amp; m2 == 0.</span>
<span class="k">let</span> <span class="n">uppers</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'A'</span><span class="p">,</span> <span class="sc">b'Z'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">lowers</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'a'</span><span class="p">,</span> <span class="sc">b'z'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">digits</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'0'</span><span class="p">,</span> <span class="sc">b'9'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">pluses</span> <span class="o">=</span> <span class="n">ascii</span><span class="nf">.simd_eq</span><span class="p">([</span><span class="sc">b'+'</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span><span class="nf">.into</span><span class="p">());</span>
<span class="k">let</span> <span class="n">solidi</span> <span class="o">=</span> <span class="n">ascii</span><span class="nf">.simd_eq</span><span class="p">([</span><span class="sc">b'/'</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span><span class="nf">.into</span><span class="p">());</span>

<span class="c1">// If any byte was invalid, none of the masks will select for it,</span>
<span class="c1">// so that lane will be 0 in the or of all the masks. This is our</span>
<span class="c1">// validation check.</span>
<span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">uppers</span> <span class="p">|</span> <span class="n">lowers</span> <span class="p">|</span> <span class="n">digits</span> <span class="p">|</span> <span class="n">pluses</span> <span class="p">|</span> <span class="n">solidi</span><span class="p">)</span><span class="nf">.all</span><span class="p">();</span>

<span class="c1">// Given a mask, create a new vector by splatting `value`</span>
<span class="c1">// over the set lanes.</span>
<span class="k">fn</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">mask</span><span class="nf">.select</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Fill the the lanes of the offset vector by filling the</span>
<span class="c1">// set lanes with the corresponding offset. This is like</span>
<span class="c1">// a "vectorized" version of the `match`.</span>
<span class="k">let</span> <span class="n">offsets</span> <span class="o">=</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">uppers</span><span class="p">,</span>  <span class="mi">65</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span>  <span class="mi">71</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">pluses</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">solidi</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">);</span>

<span class="c1">// Finally, Build the sextets vector.</span>
<span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-</span> <span class="n">offsets</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This solution is quite elegant, and will produce very competitive code, but it’s not actually ideal. We need to do a lot of comparisons here: eight in total. We also keep lots of values alive at the same time, which might lead to unwanted register pressure.</p> <h3 id="simd-hash-table"><a href="#simd-hash-table">SIMD Hash Table</a></h3> <p>Let’s look at the byte representations of the ranges. <code class="language-plaintext highlighter-rouge">A-Z</code>, <code class="language-plaintext highlighter-rouge">a-z</code>, and <code class="language-plaintext highlighter-rouge">0-9</code> are, as byte ranges, <code class="language-plaintext highlighter-rouge">0x41..0x5b</code>, <code class="language-plaintext highlighter-rouge">0x61..0x7b</code>, and <code class="language-plaintext highlighter-rouge">0x30..0x3a</code>. Notice they all have different high nybbles! What’s more, <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">/</code> are <code class="language-plaintext highlighter-rouge">0x2b</code> and <code class="language-plaintext highlighter-rouge">0x2f</code>, so the function <code class="language-plaintext highlighter-rouge">byte &gt;&gt; 4</code> is <em>almost</em> enough to distinguish all the ranges. If we subtract one if <code class="language-plaintext highlighter-rouge">byte == b'/'</code>, we have a <em>perfect hash</em> for the ranges.</p> <p>In other words, the value <code class="language-plaintext highlighter-rouge">(byte &gt;&gt; 4) - (byte == '/')</code> maps the ranges as follows:</p> <ul> <li><code class="language-plaintext highlighter-rouge">A-Z</code> goes to 4 or 5.</li> <li><code class="language-plaintext highlighter-rouge">a-z</code> goes to 6 or 7.</li> <li><code class="language-plaintext highlighter-rouge">0-9</code> goes to 3.</li> <li><code class="language-plaintext highlighter-rouge">+</code> goes to 2.</li> <li><code class="language-plaintext highlighter-rouge">/</code> goes to 1.</li> </ul> <p>This is small enough that we could cram a lookup table of values for building the <code class="language-plaintext highlighter-rouge">offsets</code> vector into another SIMD vector, and use a shuffle operation to do the lookup.</p> <p>This is not my original idea; I came across a <a href="https://github.com/WojciechMula/base64simd/issues/3">GitHub issue</a> where an anonymous user points out this perfect hash.</p> <p>Our new ascii-to-sextet code looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Compute the perfect hash for each lane.</span>
<span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
  <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
    <span class="nf">.to_int</span><span class="p">()</span>  <span class="c1">// to_int() is equivalent to masked_splat(-1, 0).</span>
    <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Look up offsets based on each hash and subtract them from `ascii`.</span>
<span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="c1">// This lookup table corresponds to the offsets we used to build the</span>
    <span class="c1">// `offsets` vector in the previous implementation, placed in the</span>
    <span class="c1">// indices that the perfect hash produces.</span>
  <span class="o">-</span> <span class="nn">Simd</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
    <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There is a small wrinkle here: <a href="https://doc.rust-lang.org/std/simd/struct.Simd.html#method.swizzle_dyn"><code class="language-plaintext highlighter-rouge">Simd::swizzle_dyn()</code></a> requires that the index array be the same length as the lookup table. This is annoying because right now <code class="language-plaintext highlighter-rouge">ascii</code> is a <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code>, but that will not be the case later on, so I will simply sweep this under the rug.</p> <p>Note that we no longer get validation as a side-effect of computing the sextets vector. The same GitHub issue also provides an exact bloom-filter for checking that a particular byte is valid; you can see my implementation <a href="https://github.com/mcy/vb64/blob/894f833e933860e070dabcfcc189430c45fecbd7/src/simd.rs#L93">here</a>. I’m not sure how the OP constructed the bloom filter, but the search space is small enough that you could have written a little script to brute force it.</p> <h3 id="riffling-the-sextets"><a href="#riffling-the-sextets">Riffling the Sextets</a></h3> <p>Now comes a much tricker operation: we need to somehow pack all four sextets into three bytes. One way to try to wrap our head around what the packing code in <code class="language-plaintext highlighter-rouge">decode_hot()</code> is doing is to pass in the all-ones sextet in one of the four bytes, and see where those ones end up in the return value.</p> <p>This is not unlike how they use radioactive dyes in biology to track the moment of molecules or cells through an organism.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">bits</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">b4</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="nf">.reverse_bits</span><span class="p">()</span><span class="nf">.to_le_bytes</span><span class="p">();</span>
  <span class="nd">format!</span><span class="p">(</span><span class="s">"{b1:08b} {b2:08b} {b3:08b} {b4:08b}"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">decode_pack</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">byte</span> <span class="k">in</span> <span class="n">input</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">output</span> <span class="p">|</span><span class="o">=</span> <span class="n">byte</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">output</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="nf">bits</span><span class="p">(</span><span class="nn">u32</span><span class="p">::</span><span class="nf">from_be_bytes</span><span class="p">(</span><span class="n">input</span><span class="p">)),</span> <span class="nf">bits</span><span class="p">(</span><span class="n">output</span><span class="p">));</span>
<span class="p">}</span>

<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">]);</span>

<span class="c1">// Output:</span>
<span class="c1">// 11111100 00000000 00000000 00000000</span>
<span class="c1">// 00111111 00000000 00000000 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 11111100 00000000 00000000</span>
<span class="c1">// 11000000 00001111 00000000 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 00000000 11111100 00000000</span>
<span class="c1">// 00000000 11110000 00000011 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 00000000 00000000 11111100</span>
<span class="c1">// 00000000 00000000 11111100 00000000</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xuZm4gYml0cyh2YWx1ZTogdTMyKSAtPiBT dHJpbmcge1xuICBsZXQgW2IxLCBiMiwgYjMsIGI0XSA9IHZhbHVlLnJldmVy c2VfYml0cygpLnRvX2xlX2J5dGVzKCk7XG4gIGZvcm1hdCEoXCJ7YjE6MDhi fSB7YjI6MDhifSB7YjM6MDhifSB7YjQ6MDhifVwiKVxufVxuXG5mbiBkZWNv ZGVfcGFjayhpbnB1dDogW3U4OyA0XSkge1xuICBsZXQgbXV0IG91dHB1dCA9 IDB1MzI7XG4gIGZvciBieXRlIGluIGlucHV0IHtcbiAgICBvdXRwdXQgPDw9 IDY7XG4gICAgb3V0cHV0IHw9IGJ5dGUgYXMgdTMyO1xuICB9XG4gIG91dHB1 dCA8PD0gODtcblxuICBwcmludGxuIShcInt9XFxue31cXG5cIiwgYml0cyh1 MzI6OmZyb21fYmVfYnl0ZXMoaW5wdXQpKSwgYml0cyhvdXRwdXQpKTtcbn1c blxuZGVjb2RlX3BhY2soWzBiMTExMTExLCAwLCAwLCAwXSk7XG5kZWNvZGVf cGFjayhbMCwgMGIxMTExMTEsIDAsIDBdKTtcbmRlY29kZV9wYWNrKFswLCAw LCAwYjExMTExMSwgMF0pO1xuZGVjb2RlX3BhY2soWzAsIDAsIDAsIDBiMTEx MTExXSk7XG5cbi8vIE91dHB1dDpcbi8vIDExMTExMTAwIDAwMDAwMDAwIDAw MDAwMDAwIDAwMDAwMDAwXG4vLyAwMDExMTExMSAwMDAwMDAwMCAwMDAwMDAw MCAwMDAwMDAwMFxuLy9cbi8vIDAwMDAwMDAwIDExMTExMTAwIDAwMDAwMDAw IDAwMDAwMDAwXG4vLyAxMTAwMDAwMCAwMDAwMTExMSAwMDAwMDAwMCAwMDAw MDAwMFxuLy9cbi8vIDAwMDAwMDAwIDAwMDAwMDAwIDExMTExMTAwIDAwMDAw MDAwXG4vLyAwMDAwMDAwMCAxMTExMDAwMCAwMDAwMDAxMSAwMDAwMDAwMFxu Ly9cbi8vIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDExMTExMTAwXG4v LyAwMDAwMDAwMCAwMDAwMDAwMCAxMTExMTEwMCAwMDAwMDAwMFxufVxuIiwi Y29tcGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlclZpc2libGUi OmZhbHNlLCJjb21waWxlck91dHB1dFZpc2libGUiOnRydWUsImNvbXBpbGVy Ijp7ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiIifX1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>Bingo. Playing around with the inputs lets us verify which pieces of the bytes wind up where. For example, by passing <code class="language-plaintext highlighter-rouge">0b110000</code> as <code class="language-plaintext highlighter-rouge">input[1]</code>, we see that the two high bits of <code class="language-plaintext highlighter-rouge">input[1]</code> correspond to the low bits of <code class="language-plaintext highlighter-rouge">output[0]</code>. I’ve written the code so that the bits in each byte are printed in little-endian order, so bits on the left are the low bits.</p> <p>Putting this all together, we can draw a schematic of what this operation does to a general <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/riffle.png" alt="the riffling operation"/></p> <p>Now, there’s no single instruction that will do this for us. Shuffles can be used to move bytes around, but we’re dealing with <em>pieces</em> of bytes here. We also can’t really do a shift, since we need bits that are overshifted to move into adjacent lanes.</p> <p>The trick is to just make the lanes bigger.</p> <p>Among the operations available for SIMD vectors are lane-wise casts, which allow us to zero-extend, sign-extend, or truncate each lane. So what we can do is cast <code class="language-plaintext highlighter-rouge">sextets</code> to a vector of <code class="language-plaintext highlighter-rouge">u16</code>, do the shift there and then… somehow put the parts back together?</p> <p>Let’s see how far shifting gets us. How much do we need to shift things by? First, notice that the order of the bits within each chunk that doesn’t cross a byte boundary doesn’t change. For example, the four low bits of <code class="language-plaintext highlighter-rouge">input[1]</code> are in the same order when they become the high bits of <code class="language-plaintext highlighter-rouge">output[1]</code>, and the two high bits of <code class="language-plaintext highlighter-rouge">input[1]</code> are also in the same order when they become the low bits of <code class="language-plaintext highlighter-rouge">output[0]</code>.</p> <p>This means we can determine how far to shift by comparing the bit position of the lowest bit of a byte of <code class="language-plaintext highlighter-rouge">input</code> with the bit position of the corresponding bit in <code class="language-plaintext highlighter-rouge">output</code>.</p> <p><code class="language-plaintext highlighter-rouge">input[0]</code>’s low bit is the third bit of <code class="language-plaintext highlighter-rouge">output[0]</code>, so we need to shift <code class="language-plaintext highlighter-rouge">input[0]</code> by 2. <code class="language-plaintext highlighter-rouge">input[1]</code>’s lowest bit is the fifth bit of <code class="language-plaintext highlighter-rouge">output[1]</code>, so we need to shift by 4. Analogously, the shifts for <code class="language-plaintext highlighter-rouge">input[2]</code> and <code class="language-plaintext highlighter-rouge">input[3]</code> turn out to be 6 and 0. In code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So now we have a <code class="language-plaintext highlighter-rouge">Simd&lt;u16, 4&gt;</code> that contains the individual chunks that we need to move around, in the high and low bytes of each <code class="language-plaintext highlighter-rouge">u16</code>, which we can think of as being analogous to a <code class="language-plaintext highlighter-rouge">[[u8; 2]; 4]</code>. For example, <code class="language-plaintext highlighter-rouge">shifted[0][0]</code> contains <code class="language-plaintext highlighter-rouge">sextet[0]</code>, but shifted. This corresponds to the red segment in the first schematic. The smaller blue segment is given by <code class="language-plaintext highlighter-rouge">shifted[1][1]</code>, i.e., the high byte of the second <code class="language-plaintext highlighter-rouge">u16</code>. It’s already in the right place within that byte, so we want <code class="language-plaintext highlighter-rouge">output[0] = shifted[0][0] | shifted[1][1]</code>.</p> <p>This suggests a more general strategy: we want to take two vectors, the low bytes and the high bytes of each <code class="language-plaintext highlighter-rouge">u16</code> in <code class="language-plaintext highlighter-rouge">shifted</code>, respectively, and somehow shuffle them so that when or’ed together, they give the desired output.</p> <p>Look at the schematic again: if we had a vector consisting of <code class="language-plaintext highlighter-rouge">[..aaaaaa, ....bbbb, ......cc]</code>, we could or it with a vector like <code class="language-plaintext highlighter-rouge">[bb......, cccc...., dddddd..]</code> to get the desired result.</p> <p>One problem: <code class="language-plaintext highlighter-rouge">dddddd..</code> is <code class="language-plaintext highlighter-rouge">shifted[3][0]</code>, i.e., it’s a low byte. If we change the vector we shift by to <code class="language-plaintext highlighter-rouge">[2, 4, 6, 8]</code>, though, it winds up in <code class="language-plaintext highlighter-rouge">shifted[3][1]</code>, since it’s been shifted up by <code class="language-plaintext highlighter-rouge">8</code> bits: a full byte.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Split shifted into low byte and high byte vectors.</span>
<span class="c1">// Same way you'd split a single u16 into bytes, but lane-wise.</span>
<span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">8</span><span class="p">;</span> <span class="mi">4</span><span class="p">]))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Align the lanes: we want to get shifted[0][0] | shifted[1][1],</span>
<span class="c1">// shifted[1][0] | shifted[2][1], etc.</span>
<span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Et voila, here is our new, totally branchless implementation of <code class="language-plaintext highlighter-rouge">decode_hot()</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
      <span class="nf">.to_int</span><span class="p">()</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="o">-</span> <span class="nn">Simd</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
      <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span>  <span class="c1">// Note quite right yet, see next section.</span>

  <span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="cm">/* bloom filter shenanigans */</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
  <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compactness of this solution should not be understated. The simplicity of this solution is a large part of what makes it so efficient, because it aggressively leverages the primitives the hardware offers us.</p> <h3 id="scaling-up"><a href="#scaling-up">Scaling Up</a></h3> <p>Ok, so now we have to contend with a new aspect of our implementation that’s crap: a <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> is tiny. That’s not even 128 bits, which are the smallest vector registers on x86. What we need to do is make <code class="language-plaintext highlighter-rouge">decode_hot()</code> generic on the lane count. This will allow us to tune the number of lanes to batch together depending on benchmarks later on.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode_hot</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="k">where</span>
  <span class="c1">// This makes sure N is a small power of 2.</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
      <span class="nf">.to_int</span><span class="p">()</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="o">-</span> <span class="nf">tiled</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
      <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span>  <span class="c1">// Works fine now, as long as N &gt;= 8.</span>

  <span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="cm">/* bloom filter shenanigans */</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nf">tiled</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
  <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Generates a new vector made up of repeated "tiles" of identical</span>
<span class="cd">/// data.</span>
<span class="k">const</span> <span class="k">fn</span> <span class="n">tiled</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">tile</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">N</span><span class="p">];</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="p">{</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">tile</span><span class="nf">.len</span><span class="p">()];</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nn">Simd</span><span class="p">::</span><span class="nf">from_array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We have to change virtually nothing, which is pretty awesome! But unfortunately, this code is subtly incorrect. Remember how in the <code class="language-plaintext highlighter-rouge">N = 4</code> case, the result of <code class="language-plaintext highlighter-rouge">output</code> had a garbage value that we ignore in its highest lane? Well, now that garbage data is interleaved into output: every fourth lane contains garbage.</p> <p>We can use a shuffle to delete these lanes, thankfully. Specifically, we want <code class="language-plaintext highlighter-rouge">shuffled[i] = output[i + i / 3]</code>, which skips every forth index. So, <code class="language-plaintext highlighter-rouge">shuffled[3] = output[4]</code>, skipping over the garbage value in <code class="language-plaintext highlighter-rouge">output[3]</code>. If <code class="language-plaintext highlighter-rouge">i + i / 3</code> overflows <code class="language-plaintext highlighter-rouge">N</code>, that’s ok, because that’s the high quarter of the final output vector, which is ignored anyways. In code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode_hot</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="k">where</span>
  <span class="c1">// This makes sure N is a small power of 2.</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>

  <span class="k">let</span> <span class="n">decoded_chunks</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="nd">swizzle!</span><span class="p">(</span><span class="n">N</span><span class="p">;</span> <span class="n">decoded_chunks</span><span class="p">,</span> <span class="nd">array!</span><span class="p">(</span><span class="n">N</span><span class="p">;</span> <span class="p">|</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <blockquote> <p><code class="language-plaintext highlighter-rouge">swizzle!()</code> is a helper macro<sup id="fnref:macros" role="doc-noteref"><a href="#fn:macros" class="footnote" rel="footnote">6</a></sup> for generating generic implementations of <code class="language-plaintext highlighter-rouge">std::simd::Swizzle</code>, and <code class="language-plaintext highlighter-rouge">array!()</code> is something I wrote for generating generic-length array constants; the closure is called once for each <code class="language-plaintext highlighter-rouge">i in 0..N</code>.</p> </blockquote> <p>So now we can decode 32 base64 bytes in parallel by calling <code class="language-plaintext highlighter-rouge">decode_hot::&lt;32&gt;()</code>. We’ll try to keep things generic from here, so we can tune the lane parameter based on benchmarks.</p> <h3 id="the-outer-loop"><a href="#the-outer-loop">The Outer Loop</a></h3> <p>Let’s look at <code class="language-plaintext highlighter-rouge">decode()</code> again. Let’s start by making it generic on the internal lane count, too.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// N-sized chunks now.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dec</span><span class="p">[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What branches are left? There’s still the branch from <code class="language-plaintext highlighter-rouge">for chunks in ...</code>. It’s not ideal because it can’t do an exact pointer comparison, and needs to do a <code class="language-plaintext highlighter-rouge">&gt;=</code> comparison on a length instead.</p> <p>We call <code class="language-plaintext highlighter-rouge">[T]::copy_from_slice</code>, which is super slow because it needs to make a variable-length <code class="language-plaintext highlighter-rouge">memcpy</code> call, which can’t be inlined. Function calls are branches! The bounds checks are also a problem.</p> <p>We branch on <code class="language-plaintext highlighter-rouge">ok</code> every loop iteration, still. Not returning early in <code class="language-plaintext highlighter-rouge">decode_hot</code> doesn’t win us anything (yet).</p> <p>We potentially call the allocator in <code class="language-plaintext highlighter-rouge">extend_from_slice</code>, and perform another non-inline-able <code class="language-plaintext highlighter-rouge">memcpy</code> call.</p> <h3 id="preallocating-with-slop"><a href="#preallocating-with-slop">Preallocating with Slop</a></h3> <p>The last of these is the easiest to address: we can reserve space in <code class="language-plaintext highlighter-rouge">out</code>, since we know exactly how much data we need to write thanks to <code class="language-plaintext highlighter-rouge">decoded_len</code>. Better yet, we can reserve some “slop”: i.e., scratch space past where the end of the message would be, so we can perform full SIMD stores, instead of the variable-length memcpy.</p> <p>This way, in each iteration, we write the full SIMD vector, including any garbage bytes in the upper quarter. Then, the next write is offset <code class="language-plaintext highlighter-rouge">3/4 * N</code> bytes over, so it overwrites the garbage bytes with decoded message bytes. The garbage bytes from the final right get “deleted” by not being included in the final <code class="language-plaintext highlighter-rouge">Vec::set_len()</code> that “commits” the memory we wrote to.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">let</span> <span class="n">final_len</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="n">out</span><span class="nf">.reserve</span><span class="p">(</span><span class="n">final_len</span> <span class="o">+</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// Reserve with slop.</span>

  <span class="c1">// Get a raw pointer to where we should start writing.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">out</span><span class="nf">.as_mut_ptr_range</span><span class="p">()</span><span class="nf">.end</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// N-sized chunks now.</span>
    <span class="cm">/* snip */</span>

    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// Do a raw write and advance the pointer.</span>
      <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">dec</span><span class="p">);</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">decoded</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="c1">// Update the vector's final length.</span>
    <span class="c1">// This is the final "commit".</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">out</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is safe, because we’ve pre-allocated exactly the amount of memory we need, and where <code class="language-plaintext highlighter-rouge">ptr</code> lands is equal to the amount of memory actually decoded. We could also compute the final length of <code class="language-plaintext highlighter-rouge">out</code> ahead of time.</p> <p>Note that if we early return due to <code class="language-plaintext highlighter-rouge">if !ok</code>, <code class="language-plaintext highlighter-rouge">out</code> remains unmodified, because even though we did write to its buffer, we never execute the “commit” part, so the code remains correct.</p> <h3 id="delaying-failure"><a href="#delaying-failure">Delaying Failure</a></h3> <p>Next up, we can eliminate the <code class="language-plaintext highlighter-rouge">if !ok</code> branches by waiting to return an error until as late as possible: just before the <code class="language-plaintext highlighter-rouge">set_len</code> call.</p> <p>Remember our observation from before: most base64 encoded blobs are valid, so this unhappy path should be very rare. Also, syntax errors cannot cause code that follows to misbehave arbitrarily, so letting it go wild doesn’t hurt anything.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">error</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="n">error</span> <span class="p">|</span><span class="o">=</span> <span class="o">!</span><span class="n">ok</span><span class="p">;</span>

    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">out</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The branch is still “there”, sure, but it’s out of the hot loop.</p> <p>Because we never hit the <code class="language-plaintext highlighter-rouge">set_len</code> call and commit whatever garbage we wrote, said garbage essentially disappears when we return early, to be overwritten by future calls to <code class="language-plaintext highlighter-rouge">Vec::push()</code>.</p> <h3 id="unroll-it-harder"><a href="#unroll-it-harder">Unroll It Harder</a></h3> <p>Ok, let’s look at the memcpy from <code class="language-plaintext highlighter-rouge">copy_from_slice</code> at the start of the hot loop. The loop has already been partly unrolled: it does <code class="language-plaintext highlighter-rouge">N</code> iterations with SIMD each step, doing something funny on the last step to make up for the missing data (padding with <code class="language-plaintext highlighter-rouge">A</code>).</p> <p>We can take this a step further by doing an “unroll and jam” optimization. This type of unrolling splits the loop into two parts: a hot vectorized loop and a cold remainder part. The hot loop <em>always</em> handles length <code class="language-plaintext highlighter-rouge">N</code> input, and the remainder runs at most once and handles <code class="language-plaintext highlighter-rouge">i &lt; N</code> input.</p> <p>Rust provides an iterator adapter for hand-rolled (lol) unroll-and-jam: <code class="language-plaintext highlighter-rouge">Iterator::chunks_exact()</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">error</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">chunks</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.chunks_exact</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">chunks</span> <span class="p">{</span>
    <span class="c1">// Simd::from_slice() can do a load in one instruction.</span>
    <span class="c1">// The bounds check is easy for the compiler to elide.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>
    <span class="n">error</span> <span class="p">|</span><span class="o">=</span> <span class="o">!</span><span class="n">ok</span><span class="p">;</span>
    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">chunks</span><span class="nf">.remainder</span><span class="p">();</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="cm">/* snip */</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Splitting into two parts lets us call <code class="language-plaintext highlighter-rouge">Simd::from_slice()</code>, which performs a single, vector-sized load.</p> <h2 id="so-how-fast-is-it"><a href="#so-how-fast-is-it">So, How Fast Is It?</a></h2> <p>At this point, it looks like we’ve addressed every branch that we can, so some benchmarks are in order. I wrote a benchmark that decodes messages of every length from 0 to something like 200 or 500 bytes, and compared it against the baseline base64 implementation on crates.io.</p> <p>I compiled with <code class="language-plaintext highlighter-rouge">-Zbuild-std</code> and <code class="language-plaintext highlighter-rouge">-Ctarget-cpu=native</code> to try to get the best results. Based on some tuning, <code class="language-plaintext highlighter-rouge">N = 32</code> was the best length, since it used one YMM register for each iteration of the hot loop.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph-old.png" alt="a performance graph; our code is really good compared to the baseline, but variance is high"/></p> <p>So, we have the baseline beat. But what’s up with that crazy heartbeat waveform? You can tell it has something to do with the “remainder” part of the loop, since it correlates strongly with <code class="language-plaintext highlighter-rouge">data.len() % 32</code>.</p> <p>I stared at the assembly for a while. I don’t remember what was there, but I think that <code class="language-plaintext highlighter-rouge">copy_from_slice</code> had been inlined and unrolled into a loop that loaded each byte at a time. The moral equivalent of this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="nn">Iterator</span><span class="p">::</span><span class="nf">zip</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">ascii</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I decided to try <code class="language-plaintext highlighter-rouge">Simd::gather_or()</code>, which is kind of like a “vectorized load”. It wound up producing worse assembly, so I gave up on using a gather and instead wrote a carefully optimized loading function by hand.</p> <h3 id="unroll-and-jam-revisited"><a href="#unroll-and-jam-revisited">Unroll and Jam, Revisited</a></h3> <p>The idea here is to perform the largest scalar loads Rust offers where possible. The strategy is again unroll and jam: perform <code class="language-plaintext highlighter-rouge">u128</code> loads in a loop and deal with the remainder separately.</p> <p>The hot part looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>

<span class="c1">// Load a bunch of big 16-byte chunks. LLVM will lower these to XMM loads.</span>
<span class="k">let</span> <span class="n">ascii_ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">write_at</span> <span class="o">=</span> <span class="n">ascii_ptr</span><span class="p">;</span>
<span class="k">if</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">16</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">/</span> <span class="mi">16</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">write_at</span> <span class="o">=</span> <span class="n">write_at</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">word</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="nf">.read_unaligned</span><span class="p">();</span>
      <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The cold part seems hard to optimize at first. What’s the least number of unaligned loads you need to do to load 15 bytes from memory? It’s two! You can load a <code class="language-plaintext highlighter-rouge">u64</code> from <code class="language-plaintext highlighter-rouge">p</code>, and then another one from <code class="language-plaintext highlighter-rouge">p + 7</code>; these loads (call them <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>) overlap by one byte, but we can or them together to merge that byte, so our loaded value is <code class="language-plaintext highlighter-rouge">a as u128 | (b as u128 &lt;&lt; 56)</code>.</p> <p>A similar trick works if the data to load is between a <code class="language-plaintext highlighter-rouge">u32</code> and a <code class="language-plaintext highlighter-rouge">u64</code>. Finally, to load 1, 2, or 3 bytes, we can load <code class="language-plaintext highlighter-rouge">p</code>, <code class="language-plaintext highlighter-rouge">p + len/2</code> and <code class="language-plaintext highlighter-rouge">p + len-1</code>; depending on whether <code class="language-plaintext highlighter-rouge">len</code> is 1, 2, or 3, this will potentially load the same byte multiple times; however, this reduces the number of branches necessary, since we don’t need to distinguish the 1, 2, or 3 lines.</p> <p>This is the kind of code that’s probably easier to read than to explain.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.offset</span><span class="p">(</span><span class="n">write_at</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">ascii_ptr</span><span class="p">));</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>

  <span class="k">if</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">8</span> <span class="p">{</span>
    <span class="c1">// Load two overlapping u64s.</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u128</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">16</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="c1">// Load two overlapping u32s.</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u64</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">8</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Load 3 overlapping u8s.</span>

    <span class="c1">// For len       1       2       3     ...</span>
    <span class="c1">// ... this is  ptr[0]  ptr[0]  ptr[0]</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="c1">// ... this is  ptr[0]  ptr[1]  ptr[1]</span>
    <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="c1">// ... this is  ptr[0]  ptr[1]  ptr[2]</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="p">|</span> <span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u32</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I learned this type of loading code while contributing to Abseil: it’s very useful for loading variable-length data for data-hungry algorithms, like a codec or a hash function.</p> <p>Here’s the same benchmark again, but with our new loading code.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph.png" alt="a performance graph; our code is even better and the variance is very tight"/></p> <p>The results are really, really good. The variance is super tight, and our performance is 2x that of the baseline pretty much everywhere. <em>Success.</em></p> <h3 id="encoding-web-safe"><a href="#encoding-web-safe">Encoding? Web-Safe?</a></h3> <p>Writing an encoding function is simple enough: first, implement an <code class="language-plaintext highlighter-rouge">encode_hot()</code> function that reverses the operations from <code class="language-plaintext highlighter-rouge">decode_hot()</code>. The perfect hash from before won’t work, so you’ll need to <a href="https://github.com/mcy/vb64/blob/main/src/simd.rs#L170">invent a new one</a>.</p> <p>Also, the loading/storing code around the encoder is slightly different, too. <code class="language-plaintext highlighter-rouge">vb64</code> implements a very efficient encoding routine too, so I suggest taking a look at the source code if you’re interested.</p> <p>There is a base64 variant called web-safe base64, that replaces the <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">/</code> characters with <code class="language-plaintext highlighter-rouge">-</code> and <code class="language-plaintext highlighter-rouge">_</code>. Building a perfect hash for these is trickier: you would probably have to do something like <code class="language-plaintext highlighter-rouge">(byte &gt;&gt; 4) - (byte == '_' ? '_' : 0)</code>. I don’t support web-safe base64 yet, but only because I haven’t gotten around to it.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>My library doesn’t really solve an important problem; base64 decoding isn’t a bottleneck… anywhere that I know of, really. But writing SIMD code is really fun! Writing branchless code is often overkill but can give you a good appreciation for what your compilers can and <em>can’t</em> do for you.</p> <p>This project was also an excuse to try <code class="language-plaintext highlighter-rouge">std::simd</code>. I think it’s great overall, and generates excellent code. There’s some rough edges I’d like to see fixed to make SIMD code even simpler, but overall I’m very happy with the work that’s been done there.</p> <p>This is probably one of the most complicated posts I’ve written in a long time. SIMD (and performance in general) is a complex topic that requires a breadth of knowledge of tricks and hardware, a lot of which isn’t written down. More of it is written down now, though.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:shifts-are-arithmetic" role="doc-endnote"> <p>Shifts are better understood as arithmetic. They have a lane width, and closely approximate multiplication and division. AVX2 doesn’t even have vector shift <em>or</em> vector division: you emulate it with multiplication. <a href="#fnref:shifts-are-arithmetic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:minus-true" role="doc-endnote"> <p>The two common representations of <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code>, i.e. <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">0xff...</code> and <code class="language-plaintext highlighter-rouge">0</code>, are related by the two’s complement operation.</p> <p>For example, if I write <code class="language-plaintext highlighter-rouge">uint32_t m = -(a == b);</code>, <code class="language-plaintext highlighter-rouge">m</code> will be zero if <code class="language-plaintext highlighter-rouge">a == b</code> is false, and all-ones otherwise. This because applying any arithmetic operation to a <code class="language-plaintext highlighter-rouge">bool</code> promotes it to <code class="language-plaintext highlighter-rouge">int</code>, so <code class="language-plaintext highlighter-rouge">false</code> maps to <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">true</code> maps to <code class="language-plaintext highlighter-rouge">1</code>. Applying the <code class="language-plaintext highlighter-rouge">-</code> sends <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">-1</code>, and it’s useful to know that in two’s complement, <code class="language-plaintext highlighter-rouge">-1</code> is represented as all-ones.</p> <p>The all-ones representation for <code class="language-plaintext highlighter-rouge">true</code> is useful, because it can be used to implement branchless select very easily. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">select_if_eq</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This function returns <code class="language-plaintext highlighter-rouge">x</code> if <code class="language-plaintext highlighter-rouge">a == b</code>, and <code class="language-plaintext highlighter-rouge">y</code> otherwise. Can you tell why? <a href="#fnref:minus-true" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:abi" role="doc-endnote"> <p>Target features also affect ABI in subtle ways that I could write many, many more words on. Compiling libraries you plan to distribute with weird target feature flags is a recipe for disaster. <a href="#fnref:abi" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:why-cant-llvm-do-it" role="doc-endnote"> <p>Why can’t we leave this kind of thing to LLVM? Finding this particular branchless implementation is tricky. LLVM is smart enough to fold the match into a switch table, but that’s unnecessary memory traffic to look at the table. (In this domain, unnecessary memory traffic makes our code slower.)</p> <p>Incidentally, with the code I wrote for the original <code class="language-plaintext highlighter-rouge">decoded_len()</code>, LLVM produces a jump <em>and</em> a lookup table, which is definitely an odd choice? I went down something of a rabbit-hole. https://github.com/rust-lang/rust/issues/118306</p> <p>As for getting LLVM to find the “branchless” version of the lookup table? The search space is quite large, and this kind of “general strength reduction” problem is fairly open (keywords: “superoptimizers”). <a href="#fnref:why-cant-llvm-do-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:pad-with-A" role="doc-endnote"> <p>To be clear on why this works: suppose that in our reference implementation, we only handle inputs that are a multiple-of-4 length, and are padded with <code class="language-plaintext highlighter-rouge">=</code> as necessary, and we treat <code class="language-plaintext highlighter-rouge">=</code> as zero in the <code class="language-plaintext highlighter-rouge">match</code>. Then, for the purposes of computing the <code class="language-plaintext highlighter-rouge">bytes</code> value (before appending it to <code class="language-plaintext highlighter-rouge">out</code>), we can assume the chunk length is always 4. <a href="#fnref:pad-with-A" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:macros" role="doc-endnote"> <p>See <a href="https://github.com/mcy/vb64/blob/ed75566393a25d174a2766c3f8947d9c6a506315/src/util.rs"><code class="language-plaintext highlighter-rouge">vb64/src/util.rs</code></a>. <a href="#fnref:macros" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div> <div class="pagination post-footer"> <a class="pagination-item newer" href="https://mcyoung.xyz/page2">&lt; Prev</a> • <a class="pagination-item older" href="https://mcyoung.xyz/page4">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>