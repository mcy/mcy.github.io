<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item active" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> • <a class="sidebar-nav-item" href="https://github.com/mcy"> <img src="https://mcyoung.xyz/public/images/github.svg"></a> • <a class="sidebar-nav-item" href="https://bsky.app/profile/mcy.gay"> <img style="height: 0.75em;" src="https://mcyoung.xyz/public/images/bsky.svg"></a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/feed"> <img style="height: 0.8em; transform: translate(0.07em, 0.15em);" src="https://mcyoung.xyz/public/images/rss.svg"></a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="posts"> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-05-11 • 2075 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/2023/05/11/sam-closures/"> Single Abstract Method Traits </a></h1> </div> <div class="post"> <p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Java gets a bad rap but the core language does have some interesting features in it. A very handy one is an <em>anonymous class</em>.</p> <p>Let’s suppose I want to pass a callback into something. In Java 6, which I grew up on, you did it like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Interface() {...}</code> syntax mints a new class on the spot that implements <code class="language-plaintext highlighter-rouge">Interface</code>. You provide a standard class body between the braces, after the name of the type. You can also do this with a class type too.</p> <p>Now, this is a bit tedious: I need to re-type the signature of the one method. This is fine if I need to implement a bunch of methods, but it’s a little annoying in the one-method case.</p> <p>In Java 8 we got lambdas (syntax: <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>). Java made the interesting choice of not adding a <code class="language-plaintext highlighter-rouge">Function</code> type to be “the type of lambdas”. For a long time I thought this was a weird cop-out but I have since come to regard it as a masterclass in language design.</p> <p>Instead, Java’s lambdas are a sort of syntax sugar over this anonymous class syntax.<sup id="fnref:invokedynamic" role="doc-noteref"><a href="#fn:invokedynamic" class="footnote" rel="footnote">1</a></sup> Instead, you need to assign a lambda to an interface type with a single abstract method, and it will use the body of the lambda to implement that one method.</p> <p>Interfaces compatible with lambdas are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation, which must satisfy the following constraints:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the aforementioned <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts and no GATs.</li> <li>All of its supertraits are <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, or <code class="language-plaintext highlighter-rouge">Sync</code>.</li> </ol> <p>These restrictions are chosen so that we have a shot at actually implementing the entire trait.</p> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, ordinary closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate.</p> <p>None of these traits are SAM, so we can safely allow them to be automatically derived for SAM closures to, under the same rules as for ordinary closures.</p> </blockquote> <p>To request a SAM closure, I will use the tentative syntax of <code class="language-plaintext highlighter-rouge">impl Trait |args| expr</code>. This syntax is unambiguously an expression rather than an <code class="language-plaintext highlighter-rouge">impl</code> item, because a <code class="language-plaintext highlighter-rouge">|</code> cannot appear in a path-in-type, and <code class="language-plaintext highlighter-rouge">impl $path</code> must be followed by <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">where</code>. The precise syntax is unimportant.</p> <p>Applied to the <code class="language-plaintext highlighter-rouge">call_many</code> example above, we get this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="n">Callback</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compiler rewrites this into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">CallbackImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CallbackImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CallbackImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This rewrite can happen relatively early, before we need to infer a type for <code class="language-plaintext highlighter-rouge">x</code>. We also need to verify that this trait’s captures are compatible with an <code class="language-plaintext highlighter-rouge">&amp;self</code> receiver The same rules for when a trait implements <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code> would decide which of the three receiver types the closure is compatible with.</p> <p>Note that SAM closures WOULD NOT implement any <code class="language-plaintext highlighter-rouge">Fn</code> traits.</p> <h3 id="more-complicated-examples"><a href="#more-complicated-examples">More Complicated Examples</a></h3> <p>We are required to name the trait we want but its type parameters can be left up in the air. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Out</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Display</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Out</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// We can infer `T = i32` and `Tr::Out = String`.</span>
<span class="k">let</span> <span class="n">tr</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In general, unspecified parameters and associated types result in inference variables, which are resolved in the same way as the parameters of the <code class="language-plaintext highlighter-rouge">Fn</code> closures are.</p> <p>In fact, we can emulate ordinary closures using SAM closures.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.map</span><span class="p">(</span><span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">_</span> <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that because <code class="language-plaintext highlighter-rouge">Fn</code> and <code class="language-plaintext highlighter-rouge">FnMut</code> have non-trival supertraits we can’t make them out of SAM closures.</p> <p>One application is to completely obsolete <code class="language-plaintext highlighter-rouge">std::iter::from_fn</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">u64</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Copy</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Or, if you need a quick helper implementation of <code class="language-plaintext highlighter-rouge">Debug</code>…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="n">f</span><span class="nf">.debug_list</span><span class="p">()</span>
    <span class="nf">.entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">impl</span> <span class="n">Debug</span> <span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"something something {}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.next_thingy</span><span class="p">())</span>
    <span class="p">})</span>
    <span class="nf">.finish</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are probably additional restrictions we will want to place on the SAM trait, but it’s not immediately clear what the breadth of those are. For example, we probably shouldn’t try to make this work:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">UniversalFactory</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">make</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">UniversalFactory</span> <span class="p">||</span> <span class="p">{</span>
  <span class="c1">// How do I name T so that I can pass it to size_of?</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are definitely clever tricks you <em>can</em> play to make this work, but the benefit seems slim.</p> <h2 id="future-work"><a href="#future-work">Future Work</a></h2> <p>There’s two avenues for how we could extend this concept. The first is straightforward and desireable; the second is probably unimplementable.</p> <h3 id="anonymous-trait-impls"><a href="#anonymous-trait-impls">Anonymous Trait Impls</a></h3> <p>Backing up from the Java equivalent of lambdas, it seems not unreasonable to have a full-fledged expression version of <code class="language-plaintext highlighter-rouge">impl</code> that can make captures.</p> <p>Syntactically, I will use <code class="language-plaintext highlighter-rouge">impl Trait for { ... }</code>. This is currently unambiguous, although I think that making it so that <code class="language-plaintext highlighter-rouge">{</code> cannot start a type is probably a non-starter.</p> <p>Let’s pick something mildly complicated… like <code class="language-plaintext highlighter-rouge">Iterator</code> with an overriden method. Then we might write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">[</span><span class="o">...</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iterator</span> <span class="o">=</span> <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="o">*</span><span class="n">my_list</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">my_list</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The contents of the braces after <code class="language-plaintext highlighter-rouge">for</code> is an item list, except that variables from the outside are available, having the semantics of captures; they are, in effect, accesses of <code class="language-plaintext highlighter-rouge">self</code> without the <code class="language-plaintext highlighter-rouge">self.</code> prefix.</p> <p>Hammering out precisely how this would interact with the self types of the functions in the body seems… complicated. Pretty doable, just fussy. There are also awkward questions about what <code class="language-plaintext highlighter-rouge">Self</code> is here and to what degree you’re allowed to interact with it.</p> <h3 id="trait-inference"><a href="#trait-inference">Trait Inference</a></h3> <p>Suppose that we could instead “just” write <code class="language-plaintext highlighter-rouge">impl |x| x * x</code> and have the compiler figure out what trait we want (to say nothing of making this the default behavior and dropping the leading <code class="language-plaintext highlighter-rouge">impl</code> keyword).</p> <p>This means that I could just write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We get into trouble fast.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <p>Currently, rustc does not have to produce impls “on demand”; the trait solver has a finite set of impls to look at. What we are asking the trait solver to do is to, for certain types, attempt to reify impls based on <em>usage</em>. I.e., I have my opaque closure type <code class="language-plaintext highlighter-rouge">T</code> and I the compiler decided it needed to prove a <code class="language-plaintext highlighter-rouge">T: Foo</code> bound so now it gets to perform type checking to validate whether it has an <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>This seems unimplementable with how the solver currently works. It is not insurmountable! But it would be very hard.</p> <p>It is possible that there are relaxations of this that are not insane to implement, e.g. the <code class="language-plaintext highlighter-rouge">impl ||</code> expression is used to initialize an argument to a function that happens to be generic, so we can steal the bounds off of that type variable and hope it’s SAM. But realistically, this direction is more trouble than its worth.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:invokedynamic" role="doc-endnote"> <p>Except for the part where they are extremely not. Where <code class="language-plaintext highlighter-rouge">new T() {}</code> mints a brand new class and accompanying <code class="language-plaintext highlighter-rouge">.class</code> file, Java lambdas use this complicated machinery from Java 7 to generate method handles on the fly, via the <code class="language-plaintext highlighter-rouge">invokedynamic</code> JVM instruction. This, I’m told, makes them much easier to optimize. <a href="#fnref:invokedynamic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-04-04 • 1311 words • 14 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> • <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <h1><a href="/2023/04/04/trait-rez-wishlist/"> Better Trait Resolution in Rust </a></h1> </div> <div class="post"> <p>Traits are the core of polymorphism in Rust. Let’s review:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{self}"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Prints `42`.</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="mi">42</span><span class="nf">.string</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xudHJhaXQgU3RyaW5nZXIge1xuICBmbiBz dHJpbmcoJnNlbGYpIC0+IFN0cmluZztcbn1cblxuaW1wbCBTdHJpbmdlciBm b3IgaTMyIHtcbiAgZm4gc3RyaW5nKCZzZWxmKSAtPiBTdHJpbmcge1xuICAg IGZvcm1hdCEoXCJ7c2VsZn1cIilcbiAgfVxufVxuXG4vLyBQcmludHMgYDQy YC5cbnByaW50bG4hKFwie31cIiwgNDIuc3RyaW5nKCkpO1xufVxuIiwiY29t cGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlclZpc2libGUiOmZh bHNlLCJjb21waWxlck91dHB1dFZpc2libGUiOnRydWUsImNvbXBpbGVyIjp7 ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiIifX1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>Notice that we call the trait method <code class="language-plaintext highlighter-rouge">Stringer::string</code> directly on the value in question. This means that traits (at least, those currently in scope) inject their methods into the namespace of anything that implements them.</p> <p>Now, this isn’t immediately a problem, because Rust’s namespace lookup rules are such that methods <em>inherent</em> to a type are searched for first:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Woofer</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"woof"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"bark"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Prints `bark`.</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">Woofer</span><span class="nf">.string</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xudHJhaXQgU3RyaW5nZXIge1xuICBmbiBz dHJpbmcoJnNlbGYpIC0+IFN0cmluZztcbn1cblxuc3RydWN0IFdvb2Zlcjtc bmltcGwgU3RyaW5nZXIgZm9yIFdvb2ZlciB7XG4gIGZuIHN0cmluZygmc2Vs ZikgLT4gU3RyaW5nIHtcbiAgICBmb3JtYXQhKFwid29vZlwiKVxuICB9XG59 XG5cbmltcGwgV29vZmVyIHtcbiAgZm4gc3RyaW5nKCZzZWxmKSAtPiBTdHJp bmcge1xuICAgIGZvcm1hdCEoXCJiYXJrXCIpXG4gIH1cbn1cblxuLy8gUHJp bnRzIGBiYXJrYC5cbnByaW50bG4hKFwie31cIiwgV29vZmVyLnN0cmluZygp KTtcbn1cbiIsImNvbXBpbGVycyI6W10sImV4ZWN1dG9ycyI6W3siY29tcGls ZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJPdXRwdXRWaXNpYmxlIjp0cnVl LCJjb21waWxlciI6eyJpZCI6ImJldGEiLCJvcHRpb25zIjoiIn19XX1dfQ== ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This means that traits cannot <em>easily</em> break downstream code by adding new methods, but there are a few possible hazards:</p> <ul> <li> <p>If the owner of a type adds a method with the same name as a trait method, it will override direct (i.e., <code class="language-plaintext highlighter-rouge">foo.string()</code>) calls to that trait method, even if the type owner is unaware of the trait method.</p> </li> <li> <p>If traits <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are in scope, and <code class="language-plaintext highlighter-rouge">String</code> implements both, and we call <code class="language-plaintext highlighter-rouge">str.foo()</code> (which resolves to <code class="language-plaintext highlighter-rouge">A::foo()</code>), and later <code class="language-plaintext highlighter-rouge">B</code> adds a new method <code class="language-plaintext highlighter-rouge">B::foo()</code>, the callsite for <code class="language-plaintext highlighter-rouge">String</code> will break. <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>’s owners do not need to be aware of each other for this to happen.</p> </li> </ul> <p>Of course, Rust has a disambiguation mechanism. Given any trait implementation <code class="language-plaintext highlighter-rouge">Foo: Bar</code>, we can reference its items by writing <code class="language-plaintext highlighter-rouge">&lt;Foo as Bar&gt;::baz</code>. However, this syntax is <em>very</em> unweildy (it doesn’t work with method chaining), so it doesn’t get used. As a result, small evolution hazards can build up in a large codebase.</p> <p>Those who know me know that I often talk about a syntax that I call <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>, or “qualified method call syntax”. In this post, I want to discuss this syntax in more detail, and some related ideas, and how they factor into type and trait design.</p> <h2 id="paths-as-methods"><a href="#paths-as-methods">Paths-as-Methods</a></h2> <p>This idea isn’t new; others have proposed it, and it forms the core of Carbon’s version of trait method calls (you can read more about Carbon’s name lookup story <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/member_access.md">here</a>).</p> <p>Let’s recreate the original example in Carbon (bear in mind that I am not an expert on this language, and the semantics are still up in the air).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">interface</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">external</span> <span class="k">impl</span> <span class="nb">i32</span> <span class="k">as</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Carbon</span><span class="nf">.Print</span><span class="p">(</span><span class="mf">42.</span><span class="p">(</span><span class="n">Stringer</span><span class="py">.String</span><span class="p">)())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Carbon</div></div></div> <p>Notice <code class="language-plaintext highlighter-rouge">42.(Stringer.String)()</code>: Carbon <em>requires</em> that we qualify the method call, because <code class="language-plaintext highlighter-rouge">42</code> has the concrete type <code class="language-plaintext highlighter-rouge">i32</code>. If this were in a generic context and we had a type variable bounded by <code class="language-plaintext highlighter-rouge">Stringer</code>, we could just write <code class="language-plaintext highlighter-rouge">x.String()</code>; no ambiguity.</p> <p>In Carbon, all qualification uses <code class="language-plaintext highlighter-rouge">.</code>, so they have to add parens. Because Rust uses <code class="language-plaintext highlighter-rouge">::</code> for qualifying paths, we don’t have this syntactic abiguity, so we can augment the syntax to allow more path expressions after the <code class="language-plaintext highlighter-rouge">.</code>.</p> <p>The current grammar is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">MethodCallExpression :
   Expression . PathExprSegment (CallParams?)

PathExprSegment :
   PathIdentSegment (:: GenericArgs)?</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>That is, exactly one identifier and an optional turbofish. I would like to see this extended to allow any <code class="language-plaintext highlighter-rouge">QualifiedPathInExpression</code> after the <code class="language-plaintext highlighter-rouge">.</code> and before the parens. This would allow, for example:</p> <ul> <li><code class="language-plaintext highlighter-rouge">expr.Trait::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.Self::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.&lt;Foo as Trait&gt;::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.::path::to::Trait::&lt;Args&gt;::method::&lt;MoreArgs&gt;()</code></li> </ul> <p>These would all be desugared as the equivalent UFCS, taking into account that method call syntax can trigger autoref.</p> <ul> <li><code class="language-plaintext highlighter-rouge">Trait::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">Self::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">&lt;Foo as Trait&gt;::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">::path::to::Trait::&lt;Args&gt;::method::&lt;MoreArgs&gt;(expr)</code></li> </ul> <p>The method would still need to be valid to have been called via <code class="language-plaintext highlighter-rouge">.</code> syntax; I’m not proposing we add the following, even though it is unambiguous.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span>

<span class="c1">// Would be equivalent to `square(42)`.</span>
<span class="mi">42</span><span class="py">.self</span><span class="p">::</span><span class="nf">square</span><span class="p">()</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Trait method callers can now use qualified method call syntax where they might want to use UFCS without issues around wordiness.</p> <h2 id="impl-modality"><a href="#impl-modality">Impl Modality</a></h2> <p>Of course, this isn’t the only idea from Carbon’s interfaces worth stealing; Carbon also has a notion of “external” and “internal” <code class="language-plaintext highlighter-rouge">impl</code>s; I will call these “<code class="language-plaintext highlighter-rouge">impl</code> modes”.</p> <p>An external <code class="language-plaintext highlighter-rouge">impl</code> is like the one we showed above, whose methods can only be found by qualified lookup: <code class="language-plaintext highlighter-rouge">foo.(Bar.Baz)()</code>. An internal <code class="language-plaintext highlighter-rouge">impl</code> is one which is “part” of a type.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">interface</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">class</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">impl</span> <span class="k">as</span> <span class="n">Stringer</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">w</span><span class="p">:</span> <span class="n">Woofer</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
  <span class="n">w</span><span class="nf">.String</span><span class="p">()</span>  <span class="c1">// Unqualified!</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Carbon</div></div></div> <p>This also implies that we don’t need to import <code class="language-plaintext highlighter-rouge">Stringer</code> to call <code class="language-plaintext highlighter-rouge">w.String()</code>.</p> <p>There are definitely traits in Rust which fit into these modes.</p> <p><code class="language-plaintext highlighter-rouge">Clone</code> and <code class="language-plaintext highlighter-rouge">Iterator</code> almost always want to be internal. An iterator exists to implement <code class="language-plaintext highlighter-rouge">Iterator</code>, and cloning is a fundamental operation. Because both of these traits are in the prelude, it’s not a problem, but it is a problem for traits provided by a non-<code class="language-plaintext highlighter-rouge">std</code> crate, like <a href="https://docs.rs/rand/latest/rand/trait.Rng.html"><code class="language-plaintext highlighter-rouge">rand::Rng</code></a>. The lack of a way to do this leads to the proliferation of <code class="language-plaintext highlighter-rouge">prelude</code> modules and namespace pollution. (I think that <code class="language-plaintext highlighter-rouge">prelude</code>s are bad library design.)</p> <p>On the other hand, something like <code class="language-plaintext highlighter-rouge">Debug</code> wants to be external very badly. It almost never makes sense to call <code class="language-plaintext highlighter-rouge">foo.fmt()</code>, since that gets called for you by <code class="language-plaintext highlighter-rouge">println!</code> and friends; not to mention that all of the <code class="language-plaintext highlighter-rouge">std::fmt</code> traits have a method <code class="language-plaintext highlighter-rouge">fmt()</code>, making such a call likely to need disambiguation with UFCS. <code class="language-plaintext highlighter-rouge">Borrow</code> is similar; it exists to be a bound for things like <code class="language-plaintext highlighter-rouge">Cow</code> more than to provide the <code class="language-plaintext highlighter-rouge">.borrow()</code> method.</p> <p>There’s also a third mode, which I will call “extension impls”. These want to inject methods into a type, either to extend it, like <a href="https://docs.rs/itertools/latest/itertools/"><code class="language-plaintext highlighter-rouge">itertools</code></a>, or as part of some framework, like <a href="https://docs.rs/tap/latest/tap/"><code class="language-plaintext highlighter-rouge">tap</code></a>. This use of traits is somewhat controversial, but I can sympathize with wanting to have this.</p> <p>If we have paths-as-methods, we can use this classification to move towards something more like the Carbon model of method lookup, without impacting existing uses.</p> <p>My strawman is to add a <code class="language-plaintext highlighter-rouge">#[mode]</code> attribute to place on trait <code class="language-plaintext highlighter-rouge">impls</code>, which allows a caller to select the behavior:</p> <ul> <li><code class="language-plaintext highlighter-rouge">#[mode(extension)]</code> is today’s behavior. The <code class="language-plaintext highlighter-rouge">impl</code>’s trait must be in scope so that unqualified calls like <code class="language-plaintext highlighter-rouge">foo.method()</code> resolve to it.</li> <li><code class="language-plaintext highlighter-rouge">#[mode(internal)]</code> makes it so that <code class="language-plaintext highlighter-rouge">foo.method()</code> can resolve to a method from this <code class="language-plaintext highlighter-rouge">impl</code> without its trait being in scope<sup id="fnref:internal-restrictions" role="doc-noteref"><a href="#fn:internal-restrictions" class="footnote" rel="footnote">1</a></sup>. It can only be applied to <code class="language-plaintext highlighter-rouge">impl</code>s that are such that you could write a corresponding inherent impl, so things like <code class="language-plaintext highlighter-rouge">#[mode(internal)] impl&lt;T&gt; Trait for T { .. }</code> are forbidden.</li> <li><code class="language-plaintext highlighter-rouge">#[mode(external)]</code> makes it so that <code class="language-plaintext highlighter-rouge">foo.method()</code> never resolves to a method from this <code class="language-plaintext highlighter-rouge">impl</code>. It must be called as <code class="language-plaintext highlighter-rouge">Trait::method(foo)</code> or <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>.</li> </ul> <p>Every trait would be <code class="language-plaintext highlighter-rouge">#[mode(extension)]</code> if not annotated, and it would be easy to migrate to external-by-default across an edition. Similarly, we could change whether a <code class="language-plaintext highlighter-rouge">std</code> impl is external vs extension based on the edition of the caller, and provide a <code class="language-plaintext highlighter-rouge">cargo fix</code> rewrite to convert from <code class="language-plaintext highlighter-rouge">foo.method()</code> to <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>.</p> <p>It may also make sense for traits to be able to specify the default modality of their <code class="language-plaintext highlighter-rouge">impl</code>s, but I haven’t thought very carefully about this.</p> <p>Note that moving in the external -&gt; extension -&gt; internal direction is not a breaking change, but moving the other way is.</p> <h2 id="what-about-delegation"><a href="#what-about-delegation">What about Delegation?</a></h2> <p>A related feature that I will touch on lightly is delegation; that is, being able to write something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// crate a</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">boing</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// crate b</span>
<span class="k">trait</span> <span class="n">Bar</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">boing</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Bar</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nn">Foo</span><span class="p">::</span><span class="n">boing</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">use</code> in the <code class="language-plaintext highlighter-rouge">impl</code> indicates that we want to re-use <code class="language-plaintext highlighter-rouge">Foo::boing</code> to implement <code class="language-plaintext highlighter-rouge">&lt;Foo as Bar&gt;::boing</code>. This saves us having to write out a function signature, and results in less work for the compiler because that’s one less function we risk asking LLVM to codegen for us (at scale, this is a Big Deal).</p> <p>You could imagine using delegation instead of <code class="language-plaintext highlighter-rouge">#[mode]</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Woofer</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"woof"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nn">Stringer</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The reason I haven’t gone down this road is because delegation is a very large feature, and doesn’t give us a clean way to express <code class="language-plaintext highlighter-rouge">#[mode(external)]</code>, which is a big part of what I want. A delegation-compatible way to express this proposal is to not add <code class="language-plaintext highlighter-rouge">#[mode(internal)]</code>, and add <code class="language-plaintext highlighter-rouge">use Trait::method;</code> and <code class="language-plaintext highlighter-rouge">use Trait::*;</code> (and no other variations) inside of inherent <code class="language-plaintext highlighter-rouge">impl</code> blocks.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>I don’t have the personal bandwidth to write RFCs for any of this stuff, but it’s something I talk about a lot as a potential evolution hazard for Rust. I hope that putting these ideas to paper can help make name resolution in Rust more robust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:internal-restrictions" role="doc-endnote"> <p>This needs to carry a bunch of other restrictions, because it’s equivalent to adding inherent methods to the implee. For example, none of the methods can have the same name as a method in any other inherent or internal impl block, and internal impl methods should take lookup priority over extension impl methods during name lookup. <a href="#fnref:internal-restrictions" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="post-preview"> <div class="post-title"> <span class="post-meta"> 2023-03-29 • 2768 words • 30 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#concurrency">#concurrency</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2023/03/29/rseq-checkout/"> Atomicless Concurrency </a></h1> </div> <div class="post"> <p>Let’s say we’re building an allocator. Good allocators need to serve many threads simultaneously, and as such any lock they take is going to be highly contended. One way to work around this, pioneered by TCMalloc, is to have thread-local caches of blocks (hence, the “TC” - thread cached).</p> <p>Unfortunately threads can be ephemeral, so book-keeping needs to grow dynamically, and large, complex programs (like the Google Search ranking server) can have tens of thousands of threads, so per-thread cost can add up. Also, any time a thread context-switches and resumes, its CPU cache will contain different cache lines – likely the wrong ones. This is because either another thread doing something compeltely different executed on that CPU, or the switched thread <em>migrated</em> to execute on a different core.</p> <p>These days, instead of caching per-thread, TCMalloc uses <em>per-CPU</em> data. This means that book-keeping is fixed, and this is incredibly friendly to the CPU’s cache: in the steady-state, each piece of the data will only ever be read or written to by a single CPU. It also has the amazing property that <em>there are no atomic operations involved</em> in the fast path, because operations on per-CPU data, by definition, do not need to be synchronized with other cores.</p> <p>This post gives an overview of how to build a CPU-local data structure on modern Linux. The exposition will be for x86, but other than the small bits of assembly you need to write, the technique is architecture-independent.</p> <h2 id="the-kernel-primitive"><a href="#the-kernel-primitive">The Kernel Primitive</a></h2> <p>Concurrency primitives require cooperating with the kernel, which is responsible for global scheduling decisions on the system. However, making syscalls is quite expensive; to alieviate this, there has been a trend in Linux to use shared memory as a kernelspace/userspace communication channel.</p> <p><a href="https://en.wikipedia.org/wiki/Futex">Futexes</a> are the classic “cas-with-the-kernel” syscall (I’m assuming basic knowledge of atomic operations like cas in this article). In the happy path, we just need to cas on some memory to lock a futex, and only make a syscall if we need to go to sleep because of contention. The kernel will perform its own cas on this variable if necessary.</p> <p><em>Restartable sequences</em> are another such proto-primitive, which are used for per-CPUuprogramming. The relevant syscall for us, <code class="language-plaintext highlighter-rouge">rseq(2)</code>, was added in Linux 4.18. Its manpage reads</p> <blockquote> <p>A restartable sequence is a sequence of instructions guaranteed to be executed atomically with respect to other threads and signal handlers on the current CPU. If its execution does not complete atomically, the kernel changes the execution flow by jumping to an abort handler defined by userspace for that restartable sequence.</p> </blockquote> <p>A restartable sequence, or “rseq” is a special kind of critical section that the kernel guarantees executes from start to finish without any kind of preemption. If preemption <em>does</em> happen (because of a signal or whatever), userspace observes this as a jump to a special handler for that critical section. Conceptually it’s like handling an exception:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">try</span> <span class="p">{</span>
  <span class="c1">// Per-CPU code here.</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">PremptionException</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Handle having been preempted, which usally just means</span>
  <span class="c1">// "try again".</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>These critical sections are usually of the following form:</p> <ol> <li>Read the current CPU index (the rseq mechanism provides a way to do this).</li> <li>Index into some data structure and do something to it.</li> <li>Complete the operation with a single memory write. This is the “commit”.</li> </ol> <p>All the kernel tells us is that we couldn’t finish successfully. We can always try again, but the critical section needs to be such that executing any prefix of it, up to the commit, has no effect on the data structure. We get no opportunity to perform “partial rollbacks”.</p> <p>In other words, the critical section must be a <em>transaction</em>.</p> <h3 id="enabling-rseq"><a href="#enabling-rseq">Enabling <code class="language-plaintext highlighter-rouge">rseq</code></a></h3> <p>Using rseqs requires turning on support for it for a particular thread; this is what calling <code class="language-plaintext highlighter-rouge">rseq(2)</code> (the syscall) accomplishes.</p> <p>The signature for this syscall looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// This type is part of Linux's ABI.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="n">cpu_id_start</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">cpu_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">crit_sec</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Note: this is a syscall, not an actual Rust function.</span>
<span class="k">fn</span> <span class="nf">rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The syscall registers “the” <code class="language-plaintext highlighter-rouge">Rseq</code> struct for the current thread; there can be at most one, per thread.</p> <p><code class="language-plaintext highlighter-rouge">rseq</code> is a pointer to this struct. <code class="language-plaintext highlighter-rouge">len</code> should be <code class="language-plaintext highlighter-rouge">size_of::&lt;Rseq&gt;()</code>, and <code class="language-plaintext highlighter-rouge">signature</code> can be any 32-bit integer (more on this later). For our purposes, we can ignore <code class="language-plaintext highlighter-rouge">flags</code> on the struct.</p> <p><code class="language-plaintext highlighter-rouge">flags</code> on the syscall, on the other hand, is used to indicate whether we’re unregistering the struct; this is explained below.</p> <p>In the interest of exposition, we’ll call the syscall directly. If you’ve never seen how a Linux syscall is done (on x86), you load the syscall number into <code class="language-plaintext highlighter-rouge">rax</code>, then up to six arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">r10</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code><sup id="fnref:mnemonic" role="doc-noteref"><a href="#fn:mnemonic" class="footnote" rel="footnote">1</a></sup>. We only need the first four.</p> <p>The return value comes out in <code class="language-plaintext highlighter-rouge">rax</code>, which is 0 on success, and a negative of an <code class="language-plaintext highlighter-rouge">errno</code> code otherwise. In particular, we need to check for <code class="language-plaintext highlighter-rouge">EINTR</code> to deal with syscall interruption. (every Linux syscall can be interrupted).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">unregister</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Perform an open-coded Linux syscall.</span>
  <span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rax</span> <span class="o">=</span> <span class="mi">334</span><span class="p">;</span>  <span class="c1">// rseq(2) syscall number; x86-specific.</span>
    <span class="nd">asm!</span> <span class="p">{</span>
      <span class="s">"syscall"</span><span class="p">,</span>
      <span class="nf">inout</span><span class="p">(</span><span class="s">"rax"</span><span class="p">)</span> <span class="n">rax</span><span class="p">,</span>
      <span class="cm">/* rseq:      */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdi"</span><span class="p">)</span> <span class="n">rseq</span><span class="p">,</span>
      <span class="cm">/* len:       */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rsi"</span><span class="p">)</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;</span><span class="p">(),</span>
      <span class="cm">/* flags:     */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdx"</span><span class="p">)</span> <span class="n">unregister</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">,</span>
      <span class="cm">/* signature: */</span> <span class="k">in</span><span class="p">(</span><span class="s">"r10"</span><span class="p">)</span> <span class="n">signature</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">match</span> <span class="n">rax</span> <span class="p">{</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>      <span class="c1">// Success, we're done.</span>
      <span class="o">-</span><span class="mi">4</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>  <span class="c1">// EINTR, try again.</span>
      <span class="n">errno</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"error calling rseq(2): {}"</span><span class="p">,</span> <span class="o">-</span><span class="n">errno</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note the <code class="language-plaintext highlighter-rouge">unregister</code> parameter: this is used to tear down <code class="language-plaintext highlighter-rouge">rseq</code> support on the way out of a thread. Generally, <code class="language-plaintext highlighter-rouge">rseq</code> will be a thread-local, and registration happens at thread startup. Glibc will do this and has a mechanism for acquiring the <code class="language-plaintext highlighter-rouge">rseq</code> pointer. Unfortunately, the glibc I have isn’t new enough to know to do this, so I hacked up something to register my own thread local.</p> <p>I had the bright idea of putting my <code class="language-plaintext highlighter-rouge">Rseq</code> struct in a box, which triggered an interesting bug: when a thread exits, it destroys all of the thread local variables, including the box to hold our <code class="language-plaintext highlighter-rouge">Rseq</code>. But if the thread then syscalls to deallocate its stack, when the kernel goes to resume, it will attempt to write the current CPU index to the <code class="language-plaintext highlighter-rouge">rseq.cpu_id</code> field.</p> <p>This presents a problem, because the kernel is probably going to write to a garbage location. This is all but guaranteed to result in a segfault. Debuggers observe this as a segfault on the instruction right after the <code class="language-plaintext highlighter-rouge">syscall</code> instruction; I spent half an hour trying to figure out what was causing a call to <code class="language-plaintext highlighter-rouge">madvise(2)</code> to segfault.</p> <p>Hence, we need to wrap our thread local in something that will call <code class="language-plaintext highlighter-rouge">rseq(2)</code> to unregister the struct. Putting everything together we get something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">current_thread_rseq</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="c1">// This has to be its own struct so we can run a thread-exit destructor.</span>
  <span class="k">pub</span> <span class="k">struct</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;&gt;</span><span class="p">);</span>
  <span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">RseqBox</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="k">true</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nd">thread_local!</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">RSEQ</span><span class="p">:</span> <span class="n">RseqBox</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// Has to be in a box, since we need pointer stability.</span>
      <span class="k">let</span> <span class="n">rseq</span> <span class="o">=</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Rseq</span> <span class="p">{</span>
        <span class="n">cpu_id_start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">cpu_id</span><span class="p">:</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">crit_sec</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="p">})));</span>

      <span class="c1">// Register it!!!</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
      <span class="n">rseq</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="n">RSEQ</span><span class="nf">.with</span><span class="p">(|</span><span class="n">ra</span><span class="p">|</span> <span class="n">ra</span><span class="na">.0</span><span class="nf">.get</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Per Rust’s semantics, this will execute the first time we access this thread local, instead of at thread startup. Not <em>ideal</em>, since now we pay for an (uncontended) atomic read every time we touch RSEQ, but it will do.</p> <h3 id="creating-a-critical-section"><a href="#creating-a-critical-section">Creating a Critical Section</a></h3> <p>To set up and execute a restartable sequence, we need to assemble a struct that describes it. The following struct is also defined by Linux’s syscall ABI:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CritSec</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">abort_handler</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">start</code> is the address of the first instruction in the sequence, and <code class="language-plaintext highlighter-rouge">len</code> is the length of the sequence in bytes. <code class="language-plaintext highlighter-rouge">abort_handler</code> is the address of the abort handler. <code class="language-plaintext highlighter-rouge">version</code> must be 0 and we can ignore <code class="language-plaintext highlighter-rouge">flags</code>.</p> <p>Once we have a value of this struct (on the stack or as a constant), we grab <code class="language-plaintext highlighter-rouge">RSEQ</code> and atomically store the address of our <code class="language-plaintext highlighter-rouge">CritSec</code> to <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code>. This needs to be atomic because the kernel may decide to look at this pointer from a different CPU core, but it likely will not be contended.</p> <p>Note that <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> should be null before we do this; restartable sequences can’t nest.</p> <p>Next time the kernel preempts our thread (and later gets ready to resume it), it will look at <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to decide if it preempted a restartable sequence and, if so, jump to the abort handler.</p> <p>Once we finish our critical section, we must reset <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to 0.</p> <blockquote> <h4 id="labels-and-constants-oh-my"><a href="#labels-and-constants-oh-my">Labels and Constants, Oh My</a></h4> <p>There is a wrinkle: we would like for our <code class="language-plaintext highlighter-rouge">CritSec</code> value to be a constant, but Rust doesn’t provide us with a way to initialize the <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">abort_handler</code> fields directly, since it doesn’t have a way to refer<sup id="fnref:relocations" role="doc-noteref"><a href="#fn:relocations" class="footnote" rel="footnote">2</a></sup> to the labels (jump targets) inside the inline assembly. The simplest way to get around this is to assemble (lol) the <code class="language-plaintext highlighter-rouge">CritSec</code> on the stack, with inline assembly. The overhead is quite minimal.</p> </blockquote> <p>On x86, this is what our boilerplate will look like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">cs</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">CritSec</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nd">asm!</span> <span class="p">{</span><span class="s">r"
  // We meed to do `rip`-relative loads so that this code is PIC;
  // otherwise we'll get linker errors. Thus, we can't `mov`
  // directly; we need to compute the address with a `lea`
  // first.

  // Initialize the first two fields to zero.
  mov qword ptr [{_cs}], 0

  // Load `90f` into `cs.start`. Note that this is 'forward
  // reference' to the jump target `90:` below.
  lea {_pc}, [90f + rip]
  mov qword ptr [{_cs} + 8], {_pc}

  // We need to get the difference `91f - 90f` into `cs.len`.
  // To do that, we write `-90f` to it, and then add `91f`.
  neg {_pc}
  mov qword ptr [{_cs} + 16], {_pc}
  lea {_pc}, [91f + rip]
  add qword ptr [{_cs} + 16], {_pc}

  // Same as the first line, but loading `cs.abort_handler`.
  lea {_pc}, [92f + rip]
  mov qword ptr [{_cs} + 24], {_pc}

  // Write `&amp;cs` to `RSEQ.crit_sec`. This turns on
  // restartable sequence handling.
  mov qword ptr [{rseq} + 8], {_cs}

90:
  // Do something cool here (coming soon).

91:
  // Jump over the abort handler.
  jmp 93f

  .int 0x53053053  // The signature!
92:
  // Nothing special, just zero `ok` to indicate this was a failure.
  // This is written this way simply because we can't early-return
  // out of inline assembly.
  xor {_ok:e}, {_ok:e}

93:
  // Clear `RSEQ.crit_sec`, regardless of which exit path
  // we took.
  mov qword ptr [{rseq} + 8], 0
  "</span><span class="p">,</span>
  <span class="n">_pc</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
  <span class="n">_ok</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ok</span><span class="p">,</span>
  <span class="n">_cs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cs</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CritSec</span><span class="p">,</span>
  <span class="n">rseq</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="nf">current_thread_rseq</span><span class="p">(),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>A few things to note:</p> <ol> <li>Because this is inline assembly, we need to use numeric labels. I’ve chosen labels in the 90s for no particular reason. <code class="language-plaintext highlighter-rouge">90:</code> declares a jump target, and <code class="language-plaintext highlighter-rouge">90f</code> is a forward reference to that instruction address.</li> <li>Most of this assembly is just initalizing a struct<sup id="fnref:cs-init" role="doc-noteref"><a href="#fn:cs-init" class="footnote" rel="footnote">3</a></sup>. It’s not until the <code class="language-plaintext highlighter-rouge">mov</code> right before <code class="language-plaintext highlighter-rouge">90:</code> (the critical section start) that anything interesting happens.</li> <li>Immediately before <code class="language-plaintext highlighter-rouge">92:</code> (the abort handler) is an <code class="language-plaintext highlighter-rouge">.int</code> directive that emits the same four-byte signature we passed to <code class="language-plaintext highlighter-rouge">rseq(2)</code> into the instruction stream. This <em>must</em> be here, otherwise the kernel will issue a segfault to the thread. This is a very basic control-flow integrity feature.</li> <li>We clear <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> at the very end.</li> </ol> <p>This is a lot of boilerplate. In an ideal world, we could have something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">run_rseq</span><span class="p">(</span><span class="n">cs</span><span class="p">:</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">unsafe</span> <span class="k">fn</span><span class="p">(</span><span class="nb">u32</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this is very hard to do, because the constraints on restartable sequences are draconian:</p> <ul> <li>Can’t jump out of the critical section until it completes or aborts. This means you can’t call functions or make syscalls!</li> <li>Last instruction must be the commit, which is a memory store operation, <em>not</em> a return.</li> </ul> <p>This means that you can’t have the compiler generating code for you; it might outline things or move things around in ways you don’t want. In something like ASAN mode, it might inject function calls that will completely break the primitive.</p> <p>This means we muyst write our critical section in assembly. That assembly also almost unavoidably needs to be part of the boilerplate given above, and it means it can’t participate in ASAN or TSAN instrumentation.</p> <p>In the interest of exposition, we can build a wrapper over this inline assembly boilerplate that looks something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
    // Assembly for our critical section...
  "</span><span class="p">,</span>
  <span class="c1">// Inline asm constraints.</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>When I wrote the snippet above, I chose numeric labels in the 90s to avoid potential conflicts with whatever assembly gets pasted here. This is also why I used a leading <code class="language-plaintext highlighter-rouge">_</code> on the names of some of the assembly constraints; thise are private to the macro. <code class="language-plaintext highlighter-rouge">rseq</code> isn’t, though, since callers will want to access the CPU id in it.</p> <p>The intent is for the assembly string to be pasted over the <code class="language-plaintext highlighter-rouge">// Do something cool here</code> comment, and for the constraints to be tacked on after the boilerplate’s constraints.</p> <p>But with that we now have access to the full rseq primitive, in slightly sketchy macro form. Let’s use it to build a CPU-local data structure.</p> <h2 id="a-checkout-desk"><a href="#a-checkout-desk">A Checkout Desk</a></h2> <p>Let’s say we have a pool of objects that are needed to perform an allocation, our putative page caches. Let’s say we have the following interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">FreeList</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">get_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">return_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">get_cache()</code> grabs a cache of pages off the global free list. This requires taking a lock or traversing a lockless linked list, so it’s pretty expensive. <code class="language-plaintext highlighter-rouge">return_cache()</code> returns a cache back to the global free list for re-use; it is a similarly expensive operation. Both of these operations are going to be contended like crazy, so we want to memoize them.</p> <p>To achieve this, we want one slot for every CPU to hold the cache it (or rather, a thread running on it) most recently acquired, so that it can be reused. These slots will have “checkout desk” semantics: if you take a thing, you must put something in its place, even if it’s just a sign that says you took the thing.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/golden-idol.gif" alt=""/></p> </figure> <p><a href="https://fowles.github.io/">Matthew Kulukundis</a> came up with this idea, and he’d totally put this gif in a slide deck about this data structure.</p> <p>As a function signature, this is what it looks like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We can then use it like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">free_list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FreeList</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">per_cpu</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">PageCache</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">iou</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>

<span class="c1">// Check out this CPU's cache pointer, and replace it with</span>
<span class="c1">// an IOU note (a null pointer).</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">iou</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">==</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// If we got an IOU ourselves, this means another thread that</span>
  <span class="c1">// was executing on this CPU took the cache and left *us* with</span>
  <span class="c1">// a null, so we need to perform the super-expensive operation</span>
  <span class="c1">// to acquire a new one.</span>
  <span class="n">cache</span> <span class="o">=</span> <span class="n">free_list</span><span class="nf">.get_cache</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Do stuff with `cache` here. We have unique access to it.</span>
<span class="n">cache</span><span class="nf">.alloc_page</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

<span class="c1">// Return the pointer to the checkout desk.</span>
<span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">!=</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// Usually, we expect to get back the IOU we put into the cache.</span>
  <span class="c1">// If we don't, that probably means another thread (or</span>
  <span class="c1">// hundreds) are hammering this slot and fighting for page caches.</span>
  <span class="c1">// If this happens, we need to throw away the cache.</span>
  <span class="n">free_list</span><span class="nf">.return_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The semantics of <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> is that it is an array of <code class="language-plaintext highlighter-rouge">nprocs</code> (the number of logical cores on the system) pointers, all initialized to null. <code class="language-plaintext highlighter-rouge">checkout()</code> swaps the pointer stored in the current CPU’s slot in the <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> with the replacement argument.</p> <h3 id="building-the-checkout-desk"><a href="#building-the-checkout-desk">Building the Checkout Desk</a></h3> <p>The implementation of this type is relatively simple, but the devil is in the details. Naively, you’d think you literally want an array of pointers:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this is cache-hostile. We expect that (depending on how <code class="language-plaintext highlighter-rouge">ptrs</code> is aligned in memory) for eight CPUs’ checkout pointers to be on the same cache line. This means eight separate cores are going to be writing to the same cache line, which is going to result in a lot of cache thrash. This memory wants to be in L1 cache, but will probably wind up mostly in shared L3 cache.</p> <p>This effect is called “false sharing”, and is a fundamental part of the design of modern processors. We have to adjust for this.</p> <p>Instead, we want to give each core a full cache line (64 bytes aligned to a 64-byte boundary) for it to store its pointer in. This sounds super wasteful (56 of those bytes will go unused), but this is the right call for a perf-sensitive primitive.</p> <p>This amount of memory can add up pretty fast (two whole pages of memory for a 128-core server!), so we’ll want to lazilly initialize them. Our cache-friendly struct will look more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">AtomicPtr</span><span class="o">&lt;</span><span class="n">CacheLine</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// This struct wraps a T and forces it to take up an entire cache line.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">64</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CacheLine</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Initializing it requires finding out how many cores there are on the machine. This is a… fairly platform-specific affair. Rust <em>does</em> offer a “maximum paralellism” query in its standard library, but it is intended as a hint for how many worker threads to spawn, as opposed to a hard upper bound on the number of CPU indices.</p> <p>Instead, we call <code class="language-plaintext highlighter-rouge">get_nprocs_conf()</code>, which is fine since we’re already extremely non-portable already. This is a GNU libc extension.</p> <p>In code…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
      <span class="c1">// #include &lt;sys/sysinfo.h&gt;</span>
      <span class="c1">//</span>
      <span class="c1">// This function returns the maximum number of cores the</span>
      <span class="c1">// kernel knows of for the current machine. This function</span>
      <span class="c1">// is very expensive to call, so we need to cache it.</span>
      <span class="k">fn</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">mut</span> <span class="n">NPROCS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">INIT</span><span class="p">:</span> <span class="n">Once</span> <span class="o">=</span> <span class="nn">Once</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">INIT</span><span class="nf">.call_once</span><span class="p">(||</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">NPROCS</span> <span class="o">=</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">NPROCS</span> <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="p">{</span>
      <span class="n">ptrs</span><span class="nf">.push</span><span class="p">(</span><span class="nn">AtomicPtr</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span> <span class="n">ptrs</span><span class="p">:</span> <span class="n">ptrs</span><span class="nf">.into_boxed_slice</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(I’m not going to implement <code class="language-plaintext highlighter-rouge">Drop</code> for this type. That’s an exercise for the reader.)</p> <h3 id="implementing-checkout"><a href="#implementing-checkout">Implementing <code class="language-plaintext highlighter-rouge">checkout()</code></a></h3> <p>Now’s the moment we’ve all be waiting for: writing our restartable sequence. As critical sections go, this one’s pretty simple:</p> <ol> <li>Index into the <code class="language-plaintext highlighter-rouge">ptrs</code> array to get this CPU’s pointer-to-cache-line.</li> <li>If that pointer is null, bail out of the rseq and initialize a fresh cache line (and then try again).</li> <li>If it’s not null, swap <code class="language-plaintext highlighter-rouge">replacement</code> with the value in the cache line.</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
    <span class="c1">// We need to try this operation in a loop, to deal with</span>
    <span class="c1">// rseq aborts.</span>
    <span class="k">loop</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="nf">.as_ptr</span><span class="p">();</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">vcpu</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">need_alloc</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
        // Load the current CPU number.
        mov {vcpu:e}, dword ptr [{rseq} + 4]

        // Load the `vcpu`th pointer from `ptrs`.
        // On x86, `mov` is atomic. The only threads we might
        // be condending with are those that are trying to
        // initialize this pointer if it's null.
        mov {scratch}, qword ptr [{ptrs} + 8 * {vcpu:r}]

        // If null, exit early and trigger an allocation
        // for this vcpu.
        test {scratch}, {scratch}
        jz 1f

        // Make sure the outer code knows not to allocate
        // a new cache line.
        xor {need_alloc:e}, {need_alloc:e}

        // Commit the checkout by exchanging `replacement`.
        xchg {ptr}, qword ptr [{scratch}]
      1:
        "</span><span class="p">,</span>
        <span class="n">ptrs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ptrs</span><span class="p">,</span>
        <span class="n">scratch</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">replacement</span><span class="p">,</span>
        <span class="n">vcpu</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">vcpu</span><span class="p">,</span>
        <span class="n">need_alloc</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">need_alloc</span><span class="p">,</span>
      <span class="p">};</span>

      <span class="c1">// We got preempted, so it's time to try again.</span>
      <span class="k">if</span> <span class="n">result</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>

      <span class="c1">// If we don't need to allocate, we're done.</span>
      <span class="k">if</span> <span class="n">need_alloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="n">replacement</span> <span class="p">}</span>

      <span class="c1">// Otherwise, allocate a new cache line and cas it into</span>
      <span class="c1">// place. This is Atomics 101, nothing fancy.</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache_line</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">CacheLine</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
      <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cas</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="p">[</span><span class="n">vcpu</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span><span class="nf">.compare_exchange_weak</span><span class="p">(</span>
          <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span> <span class="n">cache_line</span><span class="nf">.as_mut</span><span class="p">(),</span>
          <span class="nn">Ordering</span><span class="p">::</span><span class="n">AcqRel</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="k">match</span> <span class="n">cas</span> <span class="p">{</span>
          <span class="nf">Ok</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Successful allocation.</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_null</span><span class="p">());</span>
            <span class="c1">// Make sure to stop `cache_line`'s memory</span>
            <span class="c1">// from being freed by `Box`'s dtor.</span>
            <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">cache_line</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Try again: this is a spurious failure.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="nf">.is_null</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
          <span class="c1">// Someone got here first; we can just discard</span>
          <span class="c1">// `Box`.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This code listing is a lot to take in. It can be broken into two parts: the restartable sequence itself, and the allocation fallback if the pointer-to-cache-line happens to be null.</p> <p>The restartable sequence is super short. It looks at the pointer-to-cache-line, bails if its null (this triggers the later part of the function) and then does an <code class="language-plaintext highlighter-rouge">xchg</code> between the actual <code class="language-plaintext highlighter-rouge">*mut T</code> in the per-CPU cache line, and the replacement.</p> <p>If the rseq aborts, we just try again. This is short enough that preemption in the middle of the rseq is quite rare. Then, if <code class="language-plaintext highlighter-rouge">need_alloc</code> was zeroed, that means we successfully committed, so we’re done.</p> <p>Otherwise we need to allocate a cache line for this CPU. We’re now outside of the rseq, so we’re back to needing atomics. Many threads might be racing to be the thread that initializes the pointer-to-cache-line; we use a basic cas loop to make sure that we only initialize from null, and if someone beats us to it, we don’t leak the memory we had just allocated. This is an RMW operation, so we want both acquire and release ordering. Atomics 101!</p> <p>Then, we try again. Odds are good we won’t have migrated CPUs when we execute again, so we won’t need to allocate again. Eventually all of the pointers in the <code class="language-plaintext highlighter-rouge">ptrs</code> array will be non-null, so in the steady state this <code class="language-plaintext highlighter-rouge">needs_alloc</code> case doesn’t need to happen.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is just a glimpse of what per-CPU concurrent programming looks like. I’m pretty new to it myself, and this post was motivated by building an end-to-end example in Rust. You can read more about how TCMalloc makes use of restartable sequences <a href="https://google.github.io/tcmalloc/rseq.html">here</a>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:mnemonic" role="doc-endnote"> <p>This is annoyingly <em>different</em> from the function calling convention, which passes arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, with the mnemonic “Diana’s silk dress cost $89.” I don’t know a cute mnemonic for the syscall registers. <a href="#fnref:mnemonic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:relocations" role="doc-endnote"> <p>It’s actually worse than that. You’d think you could do</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">jmp</span> <span class="n">foo</span>
<span class="n">pointers</span><span class="o">:</span>
  <span class="p">.</span><span class="kt">int</span> <span class="n">foo</span>

<span class="n">foo</span><span class="o">:</span>
  <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">pointers</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>but this makes the resulting code non-position-independent on x86. What this means is that the code must know at link time what address it will be loaded at, which breaks the position-independent requirement of many modern platforms.</p> <p>Indeed, this code will produce a linker error like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">= note: /usr/bin/ld: /home/mcyoung/projects/cpulocal/target/debug/deps/cpulocal-a7eeabaf0b1f2c43.2l48u2rfiak1q1ik.rcgu.o:
      relocation R_X86_64_32 against `.text._ZN8cpulocal15PerCpu$LT$T$GT$8checkout17h42fde3ce3bd0180aE'
      can not be used when making a PIE object; recompile with -fPIE
      collect2: error: ld returned 1 exit status</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Not only is <code class="language-plaintext highlighter-rouge">.int foo</code> a problem, but so is referring to <code class="language-plaintext highlighter-rouge">pointers</code>. Instead we must write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">lea</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">pointers</span> <span class="o">+</span> <span class="n">rip</span><span class="p">]</span>
<span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>to be able to load the address of <code class="language-plaintext highlighter-rouge">pointers</code> at all. This <em>can</em> be worked around if you’re smart; after all, it is possible to put the addresses of functions into static variables and not have the linker freak out. It’s too hard to do in inline assembly tho. <a href="#fnref:relocations" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:cs-init" role="doc-endnote"> <p>Basically this code, which can’t be properly-expressed in Rust.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">CrtiticalSection</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="cm">/* &amp;90f */</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="cm">/* &amp;91f - &amp;90f */</span><span class="p">,</span>
  <span class="n">abort</span><span class="p">:</span> <span class="cm">/* &amp;92f */</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><a href="#fnref:cs-init" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> </div> <div class="pagination post-footer"> <a class="pagination-item newer" href="https://mcyoung.xyz/page7">&lt; Prev</a> • <a class="pagination-item older" href="https://mcyoung.xyz/page9">Next &gt;</a> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>