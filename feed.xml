<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://mcyoung.xyz/https://mcyoung.xyz/feed.xml" rel="self" type="application/atom+xml"/><link href="https://mcyoung.xyz/https://mcyoung.xyz/" rel="alternate" type="text/html"/><updated>2024-05-22T13:59:14-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/feed.xml</id><title type="html">mcyoung</title><subtitle>I&apos;m Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </subtitle><author><name>Miguel Young de la Sota</name></author><entry><title type="html">The Rust Calling Convention We Deserve</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2024/04/17/calling-convention/" rel="alternate" type="text/html" title="The Rust Calling Convention We Deserve"/><published>2024-04-17T00:00:00-04:00</published><updated>2024-04-17T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2024/04/17/calling-convention</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2024/04/17/calling-convention/"><![CDATA[<p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified0- calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>However, we are too conservative. We get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>Not only does clang produce patently <em>bad</em> code for passing things by value, but it also knows how to do it better, if you request a standard calling convention! We could be generating <em>way</em> better code than Clang, but we don’t!</p> <p>Hereforth, I will describe how to do it.</p> <h3 id="-zcallconv"><a href="#-zcallconv"><code class="language-plaintext highlighter-rouge">-Zcallconv</code></a></h3> <p>Let’s suppose that we keep the current calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code><sup id="fnref:just-use-extern-c" role="doc-noteref"><a href="#fn:just-use-extern-c" class="footnote" rel="footnote">1</a></sup>, but we add a flag <code class="language-plaintext highlighter-rouge">-Zcallconv</code> that sets the calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code> when compiling a crate. The supported values will be <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> for the current one, and <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for the one we’re going to design. We could even let <code class="language-plaintext highlighter-rouge">-O</code> set <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> automatically.</p> <p>Why keep the old calling convention? Although I did sweep debugability under the rug, one nice property <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> will not have is that it does not place arguments in the C ABI order, which means that a reader replying on the “Diana’s silk dress cost $89” mnemonic on x86 will get fairly confused.</p> <p>I am also assuming we may not even support <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for some targets, like WASM, where there is no concept of “registers” and “spilling”. It may not even make sense to enable it for for debug builds, because it will produce much worse code with optimizations turned off.</p> <p>There is also a mild wrinkle with function pointers, and <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code> blocks. Because this flag is per-crate, even though functions can advertise which version of <code class="language-plaintext highlighter-rouge">extern "Rust"</code> they use, function pointers have no such luxury. However, calling through a function pointer is slow and rare, so we can simply force them to use <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. We can generate a shim to translate calling conventions as needed.</p> <p>Similarly, we can, in principle, call any Rust function like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">secret_call</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">my_func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">my_func</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this mechanism can only be used to call unmangled symbols. Thus, we can simply force <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> symbols to use the legacy calling convention.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following procedure.</p> <ol> <li> <p>First, determine, for a given target triple, the maximum number of values that can be passed “by register”. I will explain how to do this below.</p> </li> <li> <p>Decide how to pass the return value. It will either fit in the output registers, or it will need to be returned “by reference”, in which case we pass an extra <code class="language-plaintext highlighter-rouge">ptr</code> argument to the function (tagged with the <code class="language-plaintext highlighter-rouge">sret</code> attribute) and the actual return value of the function is that pointer.</p> </li> <li> <p>Decide which arguments that have been passed by value need to be demoted to being passed by reference. This will be a heuristic, but generally will be approximately “arguments larger than the by-register space”. For example, on x86, this comes out to 176 bytes.</p> </li> <li> <p>Decide which arguments get passed by register, so as to maximize register space usage. This problem is NP-hard (it’s the knapsack problem) so it will require a heuristic. All other arguments are passed on the stack.</p> </li> <li> <p>Generate the function signature in LLVM IR. This will be all of the arguments that are passed by register encoded as various non-aggregates, such as <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">ptr</code>, <code class="language-plaintext highlighter-rouge">double</code>, and <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>. What valid choices are for said non-aggregates depends on the target, but the above are what you will generally get on a 64-bit architecture. Arguments passed on the stack will follow the “register inputs”.</p> </li> <li> <p>Generate a function prologue. This is code to decode each Rust-level argument from the register inputs, so that there are <code class="language-plaintext highlighter-rouge">%ssa</code> values corresponding to those that would be present when using <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This allows us to generate the same code for the body of the function regardless of calling convention. Redundant decoding code will be eliminated by DCE passes.</p> </li> <li> <p>Generate a function exit block. This is a block that contains a single <code class="language-plaintext highlighter-rouge">phi</code> instruction for the return type as it would be for <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This block will encode it into the requisite output format and then <code class="language-plaintext highlighter-rouge">ret</code> as appropriate. All exit paths through the function should <code class="language-plaintext highlighter-rouge">br</code> to this block instead of <code class="language-plaintext highlighter-rouge">ret</code>-ing.</p> </li> <li> <p>If a non-polymorphic, non-inline function may have its address taken (as a function pointer), either because it is exported out of the crate or the crate takes a function pointer to it, generate a shim that uses <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> and immediately tail-calls the real implementation. This is necessary to preserve function pointer equality.</p> </li> </ol> <p>The main upshot here is that we need to cook up heuristics for figuring out what goes in registers (since we allow reordering arguments to get better throughput). This is equivalent to the knapsack problem; knapsack heuristics are beyond the scope of this article. This should happen early enough that this information can be stuffed into <code class="language-plaintext highlighter-rouge">rmeta</code> to avoid needing to recompute it. We may want to use different, faster heuristics depending on <code class="language-plaintext highlighter-rouge">-Copt-level</code>. Note that correctness requires that we forbid linking code generated by multiple different Rust compilers, which is already the case, since Rust breaks ABI from release to release.</p> <h3 id="what-is-llvm-willing-to-do"><a href="#what-is-llvm-willing-to-do">What Is LLVM Willing to Do?</a></h3> <p>Assuming we do that, how do we actually get LLVM to pass things in the way we want it to? We need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of<sup id="fnref:doubles-and-vectors" role="doc-noteref"><a href="#fn:doubles-and-vectors" class="footnote" rel="footnote">2</a></sup>).</p> <p>The above values are for x86<sup id="fnref:official-support" role="doc-noteref"><a href="#fn:official-support" class="footnote" rel="footnote">3</a></sup>. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>I recommend that <em>every function</em> have the same number of by-register arguments. So on x86, EVERY <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> function’s signature should look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">declare</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span> <span class="vg">@my_func</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span><span class="p">,</span>
  <span class="c1">; other args...</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When passing pointers, the appropriate <code class="language-plaintext highlighter-rouge">i64</code>s should be replaced by <code class="language-plaintext highlighter-rouge">ptr</code>, and when passing <code class="language-plaintext highlighter-rouge">double</code>s, they replace <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>s.</p> <p>But you’re probably saying, “Miguel, that’s crazy! Most functions don’t pass 176 bytes!” And you’d be right, if not for the magic of LLVM’s very well-specified <code class="language-plaintext highlighter-rouge">poison</code> semantics.</p> <p>We can get away with not doing extra work if every argument we do not use is passed <code class="language-plaintext highlighter-rouge">poison</code>. Because <code class="language-plaintext highlighter-rouge">poison</code> is equal to “the most convenient possible value at the present moment”, when LLVM sees <code class="language-plaintext highlighter-rouge">poison</code> passed into a function via register, it decides that the most convenient value is “whatever happens to be in the register already”, and so it doesn’t have to touch that register!</p> <p>For example, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we would generate the following code.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; This is a -Zcallconv=fast-style function.</span>
<span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@load_rcx</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%load</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%load</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="nv">%1</span><span class="p">,</span>     <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span>  <span class="n">rax</span>
  <span class="n">mov</span>   <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span>  <span class="n">malloc</span>
  <span class="n">mov</span>   <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>  <span class="n">load_rcx</span>
  <span class="n">add</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">pop</span>   <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any proscribed way. And as we see, <code class="language-plaintext highlighter-rouge">load_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into the other thirteen registers compiles down to nothing<sup id="fnref:requires-opt" role="doc-noteref"><a href="#fn:requires-opt" class="footnote" rel="footnote">4</a></sup>, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, it is not total. In an ideal world, the same registers are used for input and output, to allow easier pipelining of calls without introducing extra register traffic. This is true on ARM and RISC-V, but not x86. However, because register ordering is merely a suggestion for us, we can choose to allocate the return registers in whatever order we want. For example, we can pretend the order registers should be allocated in is <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code> for inputs, and <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rax</code> for outputs.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%sq</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%sq</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">ARM Assembly</div></div></div> </div> <h3 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h3> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>First, return values. This is relatively straightforward, since there is only one value to pass. The amount of data we need to return is <em>not</em> the size of the struct. For example, <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code> measures 32 bytes wide. However, eight of those bytes are padding! We do not need to preserve padding when returning by value, so we can flatten the struct into <code class="language-plaintext highlighter-rouge">(u64, u32, u64, u32)</code> and sort by size into <code class="language-plaintext highlighter-rouge">(u64, u64, u32, u32)</code>. This has no padding and is 24 bytes wide, which fits into the three return registers LLVM gives us on x86. We define the <em>effective size</em> of a type to be the number of non-<code class="language-plaintext highlighter-rouge">undef</code> bits it occupies. For <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code>, this is 192 bits, since it excludes the padding. For <code class="language-plaintext highlighter-rouge">bool</code>, this is one. For <code class="language-plaintext highlighter-rouge">char</code> this is technically 21, but it’s simpler to treat <code class="language-plaintext highlighter-rouge">char</code> as an alias for <code class="language-plaintext highlighter-rouge">u32</code>.</p> <p>The reason for counting bits this way is that it permits significant compaction. For example, returning a struct full of bools can simply bit-pack the bools into a single register.</p> <p>So, a return value is converted to a by-ref return if its effective size is smaller than the output register space (on x86, this is three integer registers and four SSE registers, so we get 88 bytes total, or 704 bits).</p> <p>Argument registers are much harder, because we hit the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, which is NP-hard. The following relatively naive heuristic is where I would start, but it can be made infinitely smarter over time.</p> <p>First, demote to by-ref any argument whose effective size is larget than the total by-register input space (on x86, 176 bytes or 1408 bits). This means we get a pointer argument instead. This is beneficial to do first, since a single pointer might pack better than the huge struct.</p> <p>Enums should be replaced by the appropriate discriminant-union pair. For example, <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> is, internally, <code class="language-plaintext highlighter-rouge">(union { i32, () }, i1)</code>, while <code class="language-plaintext highlighter-rouge">Option&lt;Option&lt;i32&gt;&gt;</code> is <code class="language-plaintext highlighter-rouge">(union { i32, (), () }, i2)</code>. Using a small non-power-of-two integer improves our ability to pack things, since enum discriminants are often quite tiny.</p> <p>Next, we need to handle unions. Because mucking about with unions’ uninitialized bits behind our backs is allowed, we need to either pass it as an array of <code class="language-plaintext highlighter-rouge">u8</code>, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">5</a></sup>.</p> <p>Now, we can proceed to flatten everything. All of the converted arguments are flattened into their most primitive components: pointers, integers, floats, and bools. Every field should be no larger than the smallest argument register; this may require splitting large types such as <code class="language-plaintext highlighter-rouge">u128</code> or <code class="language-plaintext highlighter-rouge">f64</code>.</p> <p>This big list of primitives is next sorted by effective size, from smallest to largest. We take the largest prefix of this that will fit in the available register space; everything else goes on the stack.</p> <p>If part of a Rust-level input is sent to the stack in this way, and that part is larger than a small multiple of the pointer size (e.g., 2x), it is demoted to being passed by pointer-on-the-stack, to minimize memory traffic. Everything else is passed directly on the stack in the order those inputs were before the sort. This helps keep regions that need to be copied relatively contiguous, to minimize calls to <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>The things we choose to pass in registers are allocated to registers in reverse size order, so e.g. first 64-bit things, then 32-bit things, etc. This is the same layout algorithm that <code class="language-plaintext highlighter-rouge">repr(Rust)</code> structs use to move all the padding into the tail. Once we get to the <code class="language-plaintext highlighter-rouge">bool</code>s, those are bit-packed, 64 to a register.</p> <p>Here’s a relatively complicated example. My Rust function is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Context</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_thing</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">6</span><span class="p">],</span>
                <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">op_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">op_count</span> <span class="p">{</span>
    <span class="n">context</span><span class="nf">.check</span><span class="p">(</span><span class="n">op_count</span><span class="p">,</span> <span class="n">options</span><span class="py">.colorize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">code</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">suf</span><span class="p">))</span> <span class="o">=</span> <span class="n">name</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">suf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="s">"idk"</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The codegen for this function is quite complex, so I’ll only cover the prologue and epilogue. After sorting and flattening, our raw argument LLVM types are something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nl">gprs:</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm0:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm1:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Everything fits in registers! So, what does the LLVM function look like on x86?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@do_thing</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="c1">; Unused.</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">; First, unpack all the primitives.</span>
  <span class="nv">%r9.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%r9.1.i64</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span> <span class="m">32</span>
  <span class="nv">%r9.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9.1.i64</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%xmm0.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm0.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm0.2</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%xmm0.3</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span>
  <span class="nv">%xmm1.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm1.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.1.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.1.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.2.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%xmm1.1.2</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.2.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.3.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%xmm1.1.3</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.3.i32</span> <span class="k">to</span> <span class="kt">i1</span>

  <span class="c1">; Next, reassemble them into concrete values as needed.</span>
  <span class="nv">%op_count.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%op_count</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%op_count.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%context.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%context</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="nv">%context.0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%name.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%name</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="nv">%name.0</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%code.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.0</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.1</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.0</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%code.3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.2</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%code.4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.3</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.2</span><span class="p">,</span> <span class="m">4</span>
  <span class="nv">%code</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.4</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.3</span><span class="p">,</span> <span class="m">5</span>
  <span class="nv">%options.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm1.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%options.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%options.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.2</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%options</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.2</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.3</span><span class="p">,</span> <span class="m">3</span>

  <span class="c1">; Codegen as usual.</span>
  <span class="c1">; ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Above, <code class="language-plaintext highlighter-rouge">!dbg</code> metadata for the argument values should be attached to the instruction that actually materializes it. This ensures that gdb does something halfway intelligent when you ask it to print argument values.</p> <p>On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what returns <em>could</em> look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does)! When we’re generating the ABI that all callers will see (for <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code>), we can look at the function body. This means that a crate can advertise the <em>precise</em> ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABIs. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it.</p> <p>Another example: suppose that we know that an <code class="language-plaintext highlighter-rouge">&amp;T</code> argument is not retained (a question the borrow checker can answer at this point in the compiler) and is never converted to a raw pointer (or written to memory a raw pointer is taken of, etc). We also know that <code class="language-plaintext highlighter-rouge">T</code> is fairly small, and <code class="language-plaintext highlighter-rouge">T: Freeze</code>. Then, we can replace the reference with the pointee directly, passed by value.</p> <p>The most obvious candidates for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is a step further. We might know that some arguments are hotter than others, which might cause them to be prioritized in the register allocation order.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find really frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. But <code class="language-plaintext highlighter-rouge">-Zcallconv</code> is intended to only be used with optimizations turned on, so I don’t think this is a meaningful complaint. Nor do I think the project’s Goodhartization of compilation time as a metric is healthy… but I do not think this is ultimately a relevant drawback.</p> <p>I, unfortunately, do not have the spare time to dive into fixing rustc’s ABI code, but I do know LLVM really well, and I know that this is a place where Rust has a low bus factor. For that reason, I am happy to provide the Rust compiler team expert knowledge on getting LLVM to do the right thing in service of making optimized code faster.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:just-use-extern-c" role="doc-endnote"> <p>Or just switch it to the codepath for <code class="language-plaintext highlighter-rouge">extern "C"</code> or <code class="language-plaintext highlighter-rouge">extern "fastcall"</code> since those are clearly better. We will always need to know how to generate code for the non-<code class="language-plaintext highlighter-rouge">extern "Rust"</code> calling conventions. <a href="#fnref:just-use-extern-c" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:doubles-and-vectors" role="doc-endnote"> <p>It’s Complicated. Passing a <code class="language-plaintext highlighter-rouge">double</code> burns a whole <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code> slot. This seems bad, but it can be beneficial since keeping a <code class="language-plaintext highlighter-rouge">double</code> in vector registers reduces register traffic, since usually, fp instructions use the vector registers (or the fp registers shadow the vector registers, like on ARM). <a href="#fnref:doubles-and-vectors" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:official-support" role="doc-endnote"> <p>On the one hand, you might say this “extended calling convention” isn’t an explicitly supported part of LLVM’s <code class="language-plaintext highlighter-rouge">ccc</code> calling convention. On the other hand, <a href="hyrumslaw.com">Hyrum’s Law</a> cuts both ways: Rust is big enough of an LLVM user that LLVM cannot simply miscompile all Rust programs at this point, and the IR I propose Rust emits is extremely reasonable.</p> <p>If Rust causes LLVM to misbehave, that’s an LLVM bug, and we should fix LLVM bugs, not work around them. <a href="#fnref:official-support" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-opt" role="doc-endnote"> <p>Only on <code class="language-plaintext highlighter-rouge">-O1</code> or higher, bizarrely. At <code class="language-plaintext highlighter-rouge">-O0</code>, LLVM decides that all of the <code class="language-plaintext highlighter-rouge">poison</code>s must have the same value, so it copies a bunch of registers around needlessly. This seems like a bug? <a href="#fnref:requires-opt" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="dark-arts"/><category term="assembly"/><category term="rust"/><summary type="html"><![CDATA[I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the Go register ABI, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.]]></summary></entry><entry><title type="html">Designing a SIMD Algorithm from Scratch</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2023/11/27/simd-base64/" rel="alternate" type="text/html" title="Designing a SIMD Algorithm from Scratch"/><published>2023-11-27T00:00:00-05:00</published><updated>2023-11-27T00:00:00-05:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2023/11/27/simd-base64</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2023/11/27/simd-base64/"><![CDATA[<p>Another explainer on a fun, esoteric topic: optimizing code with SIMD (single instruction multiple data, also sometimes called <em>vectorization</em>). Designing a good, fast, portable SIMD algorithm is not a simple matter and requires thinking a little bit like a circuit designer.</p> <p>Here’s the mandatory performance benchmark graph to catch your eye.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph.png" alt="perf perf perf"/></p> <p>“SIMD” often gets thrown around as a buzzword by performance and HPC (high performance computing) nerds, but I don’t think it’s a topic that has very friendly introductions out there, for a lot of reasons.</p> <ul> <li>It’s not something you will really want to care about unless you think performance is cool.</li> <li>APIs for programming with SIMD in most programming languages are <em>garbage</em> (I’ll get into why).</li> <li>SIMD algorithms are hard to think about if you’re very procedural-programming-brained. A functional programming mindset can help a lot.</li> </ul> <p>This post is mostly about <a href="https://docs.rs/vb64/latest/vb64/"><code class="language-plaintext highlighter-rouge">vb64</code></a> (which stands for <em>v</em>ector <em>b</em>ase<em>64</em>), a base64 codec I wrote to see for myself if Rust’s <code class="language-plaintext highlighter-rouge">std::simd</code> library is any good, but it’s also an excuse to talk about SIMD in general.</p> <p>What <em>is</em> SIMD, anyways? Let’s dive in.</p> <p>If you want to skip straight to the writeup on <code class="language-plaintext highlighter-rouge">vb64</code>, click <a href="#parsing-with-simd">here</a>.</p> <h2 id="problems-with-physics"><a href="#problems-with-physics">Problems with Physics</a></h2> <p>Unfortunately, computers exist in the real world<sup>[citation-needed]</sup>, and are bound by the laws of nature. SIMD has relatively little to do with theoretical CS considerations, and everything to do with <em>physics</em>.</p> <p>In the infancy of modern computing, you could simply improve performance of existing programs by buying new computers. This is often incorrectly attributed to Moore’s law (the number of transistors on IC designs doubles every two years). Moore’s law still appears to hold as of 2023, but some time in the last 15 years the <a href="https://en.wikipedia.org/wiki/Dennard_scaling">Dennard scaling</a> effect broke down. This means that denser transistors eventually means increased power dissipation density. In simpler terms, we don’t know how to continue to increase the clock frequency of computers without literally <em>liquefying</em> them.</p> <p>So, since the early aughts, the hot new thing has been bigger core counts. Make your program more multi-threaded and it will run faster on bigger CPUs. This comes with synchronization overhead, since now the cores need to cooperate. All control flow, be it jumps, virtual calls, or synchronization will result in “stall”.</p> <p>The main causes of stall are <em>branches</em>, instructions that indicate code can take one of two possible paths (like an <code class="language-plaintext highlighter-rouge">if</code> statement), and <em>memory operations</em>. Branches include all control flow: <code class="language-plaintext highlighter-rouge">if</code> statements, loops, function calls, function returns, even <code class="language-plaintext highlighter-rouge">switch</code> statements in C. Memory operations are loads and stores, especially ones that are cache-unfriendly.</p> <h3 id="procedural-code-is-slow"><a href="#procedural-code-is-slow">Procedural Code Is Slow</a></h3> <p>Modern compute cores do not execute code line-by-line, because that would be very inefficient. Suppose I have this program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{a}, {b}"</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There’s no reason for the CPU to wait to finish computing <code class="language-plaintext highlighter-rouge">a</code> before it begins computing <code class="language-plaintext highlighter-rouge">b</code>; it does not depend on <code class="language-plaintext highlighter-rouge">a</code>, and while the add is being executed, the xor circuits are idle. Computers say “program order be damned” and issue the add for <code class="language-plaintext highlighter-rouge">a</code> and the xor for <code class="language-plaintext highlighter-rouge">b</code> simultaneously. This is called <em>instruction-level parallelism</em>, and dependencies that get in the way of it are often called <em>data hazards</em>.</p> <p>Of course, the Zen 2 in the machine I’m writing this with does not have one measly adder per core. It has dozens and dozens! The opportunities for parallelism are massive, as long as the compiler in your CPU’s execution pipeline can clear any data hazards in the way.</p> <p>The better the core can do this, the more it can saturate all of the “functional units” for things like arithmetic, and the more numbers it can crunch per unit time, approaching maximum utilization of the hardware. Whenever the compiler can’t do this, the execution pipeline stalls and your code is slower.</p> <p>Branches stall because they need to wait for the branch condition to be computed before fetching the next instruction (speculative execution is a somewhat iffy workaround for this). Memory operations stall because the data needs to physically arrive at the CPU, and the speed of light is finite in this universe.</p> <p>Trying to reduce stall by improving opportunities for single-core parallelism is not a new idea. Consider the not-so-humble GPU, whose purpose in life is to render images. Images are vectors of pixels (i.e., color values), and rendering operations tend to be highly local. For example, a convolution kernel for a Gaussian blur will be two or even three orders of magnitude smaller than the final image, lending itself to locality.</p> <p>Thus, GPUs are built for divide-and-conquer: they provide primitives for doing batched operations, and extremely limited control flow.</p> <p>“SIMD” is synonymous with “batching”. It stands for “single instruction, multiple data”: a single instruction dispatches parallel operations on multiple <em>lanes</em> of data. GPUs are the original SIMD machines.</p> <h2 id="lane-wise"><a href="#lane-wise">Lane-Wise</a></h2> <p>“SIMD” and “vector” are often used interchangeably. The fundamental unit a SIMD instruction (or “vector instruction”) operates on is a vector: a fixed-size array of numbers that you primarily operate on component-wise These components are called <em>lanes</em>.</p> <p>SIMD vectors are usually quite small, since they need to fit into registers. For example, on my machine, the largest vectors are 256 bits wide. This is enough for 32 bytes (a <code class="language-plaintext highlighter-rouge">u8x32</code>), 4 double-precision floats (an <code class="language-plaintext highlighter-rouge">f64x8</code>), or all kinds of things in between.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/vectors.png" alt="some 256-bit vectors"/></p> <p>Although this doesn’t seem like much, remember that offloading the overhead of keeping the pipeline saturated by a factor of 4x can translate to that big of a speedup in latency.</p> <h3 id="one-bit-lanes"><a href="#one-bit-lanes">One-Bit Lanes</a></h3> <p>The simplest vector operations are bitwise: and, or, xor. Ordinary integers can be thought of as vectors themselves, with respect to the bitwise operations. That’s literally what “bitwise” means: lanes-wise with lanes that are one bit wide. An <code class="language-plaintext highlighter-rouge">i32</code> is, in this regard, an <code class="language-plaintext highlighter-rouge">i1x32</code>.</p> <p>In fact, as a warmup, let’s look at the problem of counting the number of 1 bits in an integer. This operation is called “population count”, or <code class="language-plaintext highlighter-rouge">popcnt</code>. If we view an <code class="language-plaintext highlighter-rouge">i32</code> as an <code class="language-plaintext highlighter-rouge">i1x32</code>, <code class="language-plaintext highlighter-rouge">popcnt</code> is just a fold or reduce operation:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">popcnt</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">32</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bit</span><span class="p">)</span> <span class="k">in</span> <span class="n">bits</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">total</span><span class="p">,</span> <span class="n">bit</span><span class="p">|</span> <span class="n">total</span> <span class="o">+</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBwb3BjbnQobXV0IHg6IHUzMikgLT4gdTMyIHtcbiAgbGV0 IG11dCBiaXRzID0gWzA7IDMyXTtcbiAgZm9yIChpLCBiaXQpIGluIGJpdHMu aXRlcl9tdXQoKS5lbnVtZXJhdGUoKSB7XG4gICAgKmJpdCA9ICh4ID4+IGkp ICYgMTtcbiAgfVxuICBiaXRzLmludG9faXRlcigpLmZvbGQoMCwgfHRvdGFs LCBiaXR8IHRvdGFsICsgYml0KVxufSIsImNvbXBpbGVycyI6W3siaWQiOiJi ZXRhIiwib3B0aW9ucyI6Ii1PIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>In other words, we interpret the integer as an array of bits and then add the bits together to a 32-bit accumulator. Note that the accumulator needs to be higher precision to avoid overflow: accumulating into an <code class="language-plaintext highlighter-rouge">i1</code> (as with the <code class="language-plaintext highlighter-rouge">Iterator::reduce()</code> method) will only tell us whether the number of 1 bits is even or odd.</p> <p>Of course, this produces… comically bad code, frankly. We can do much better if we notice that we can <em>vectorize</em> the addition: first we add all of the adjacent pairs of bits together, then the pairs of pairs, and so on. This means the number of adds is logarithmic in the number of bits in the integer.</p> <p>Visually, what we do is we “unzip” each vector, shift one to line up the lanes, add them, and then repeat with lanes twice as big.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/popcnt.png" alt="first two popcnt merge steps"/></p> <p>This is what that looks like in code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">popcnt</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="c1">// View x as a i1x32, and split it into two vectors</span>
  <span class="c1">// that contain the even and odd bits, respectively.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x55555555</span><span class="p">;</span> <span class="c1">// 0x5 == 0b0101.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xaaaaaaaa</span><span class="p">;</span> <span class="c1">// 0xa == 0b1010.</span>
  <span class="c1">// Shift odds down to align the bits, and then add them together.</span>
  <span class="c1">// We interpret x now as a i2x16. When adding, each two-bit</span>
  <span class="c1">// lane cannot overflow, because the value in each lane is</span>
  <span class="c1">// either 0b00 or 0b01.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Repeat again but now splitting even and odd bit-pairs.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x33333333</span><span class="p">;</span> <span class="c1">// 0x3 == 0b0011.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xcccccccc</span><span class="p">;</span> <span class="c1">// 0xc == 0b1100.</span>
  <span class="c1">// We need to shift by 2 to align, and now for this addition</span>
  <span class="c1">// we interpret x as a i4x8.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Again. The pattern should now be obvious.</span>
  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x0f0f0f0f</span><span class="p">;</span> <span class="c1">// 0x0f == 0b00001111.</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xf0f0f0f0</span><span class="p">;</span> <span class="c1">// 0xf0 == 0b11110000.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// i8x4</span>

  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x00ff00ff</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xff00ff00</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>  <span class="c1">// i16x2</span>

  <span class="k">let</span> <span class="n">even</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0x0000ffff</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">0xffff0000</span><span class="p">;</span>
  <span class="c1">// Because the value of `x` is at most 32, although we interpret this as a</span>
  <span class="c1">// i32x1 add, we could get away with just one e.g. i16 add.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">even</span> <span class="o">+</span> <span class="p">(</span><span class="n">odds</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

  <span class="n">x</span> <span class="c1">// Done. All bits have been added.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBwb3BjbnQobXV0IHg6IHUzMikgLT4gdTMyIHtcbiAgLy8g VmlldyB4IGFzIGEgaTF4MzIsIGFuZCBzcGxpdCBpdCBpbnRvIHR3byB2ZWN0 b3JzXG4gIC8vIHRoYXQgY29udGFpbiB0aGUgZXZlbiBhbmQgb2RkIGJpdHMs IHJlc3BlY3RpdmVseS5cbiAgbGV0IGV2ZW4gPSB4ICYgMHg1NTU1NTU1NTsg Ly8gMHg1ID09IDBiMDEwMS5cbiAgbGV0IG9kZHMgPSB4ICYgMHhhYWFhYWFh YTsgLy8gMHhhID09IDBiMTAxMC5cbiAgLy8gU2hpZnQgb2RkcyBkb3duIHRv IGFsaWduIHRoZSBiaXRzLCBhbmQgdGhlbiBhZGQgdGhlbSB0b2dldGhlci5c biAgLy8gV2UgaW50ZXJwcmV0IHggbm93IGFzIGEgaTJ4MTYuIFdoZW4gYWRk aW5nLCBlYWNoIHR3by1iaXRcbiAgLy8gbGFuZSBjYW5ub3Qgb3ZlcmZsb3cs IGJlY2F1c2UgdGhlIHZhbHVlIGluIGVhY2ggbGFuZSBpc1xuICAvLyBlaXRo ZXIgMGIwMCBvciAwYjAxLlxuICB4ID0gZXZlbiArIChvZGRzID4+IDEpO1xu XG4gIC8vIFJlcGVhdCBhZ2FpbiBidXQgbm93IHNwbGl0dGluZyBldmVuIGFu ZCBvZGQgYml0LXBhaXJzLlxuICBsZXQgZXZlbiA9IHggJiAweDMzMzMzMzMz OyAvLyAweDMgPT0gMGIwMDExLlxuICBsZXQgb2RkcyA9IHggJiAweGNjY2Nj Y2NjOyAvLyAweGMgPT0gMGIxMTAwLlxuICAvLyBXZSBuZWVkIHRvIHNoaWZ0 IGJ5IDIgdG8gYWxpZ24sIGFuZCBub3cgZm9yIHRoaXMgYWRkaXRpb25cbiAg Ly8gd2UgaW50ZXJwcmV0IHggYXMgYSBpNHg4LlxuICB4ID0gZXZlbiArIChv ZGRzID4+IDIpO1xuXG4gIC8vIEFnYWluLiBUaGUgcGF0dGVybiBzaG91bGQg bm93IGJlIG9idmlvdXMuXG4gIGxldCBldmVuID0geCAmIDB4MGYwZjBmMGY7 IC8vIDB4MGYgPT0gMGIwMDAwMTExMS5cbiAgbGV0IG9kZHMgPSB4ICYgMHhm MGYwZjBmMDsgLy8gMHhmMCA9PSAwYjExMTEwMDAwLlxuICB4ID0gZXZlbiAr IChvZGRzID4+IDQpOyAvLyBpOHg0XG5cbiAgbGV0IGV2ZW4gPSB4ICYgMHgw MGZmMDBmZjtcbiAgbGV0IG9kZHMgPSB4ICYgMHhmZjAwZmYwMDtcbiAgeCA9 IGV2ZW4gKyAob2RkcyA+PiA4KTsgIC8vIGkxNngyXG5cbiAgbGV0IGV2ZW4g PSB4ICYgMHgwMDAwZmZmZjtcbiAgbGV0IG9kZHMgPSB4ICYgMHhmZmZmMDAw MDtcbiAgLy8gQmVjYXVzZSB0aGUgdmFsdWUgb2YgYHhgIGlzIGF0IG1vc3Qg MzIsIGFsdGhvdWdoIHdlIGludGVycHJldCB0aGlzIGFzIGFcbiAgLy8gaTMy eDEgYWRkLCB3ZSBjb3VsZCBnZXQgYXdheSB3aXRoIGp1c3Qgb25lIGUuZy4g aTE2IGFkZC5cbiAgeCA9IGV2ZW4gKyAob2RkcyA+PiAxNik7XG5cbiAgeCAv LyBEb25lLiBBbGwgYml0cyBoYXZlIGJlZW4gYWRkZWQuXG59IiwiY29tcGls ZXJzIjpbeyJpZCI6ImJldGEiLCJvcHRpb25zIjoiLU8ifV19XX0=">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This still won’t optimize down to a <code class="language-plaintext highlighter-rouge">popcnt</code> instruction, of course. The search scope for such a simplification is in the regime of superoptimizers. However, the generated code is small and fast, which is why this is the ideal implementation of <code class="language-plaintext highlighter-rouge">popcnt</code> for systems without such an instruction.</p> <p>It’s <em>especially</em> nice because it is implementable for e.g. <code class="language-plaintext highlighter-rouge">u64</code> with only one more reduction step (remember: it’s <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>!), and does not at any point require a full <code class="language-plaintext highlighter-rouge">u64</code> addition.</p> <p>Even though this is “just” using scalars, divide-and-conquer approaches like this are the bread and butter of the SIMD programmer.</p> <h3 id="scaling-up-operations-on-real-vectors"><a href="#scaling-up-operations-on-real-vectors">Scaling Up: Operations on Real Vectors</a></h3> <p>Proper SIMD vectors provide more sophisticated semantics than scalars do, particularly because there is more need to provide replacements for things like control flow. Remember, control flow is slow!</p> <p>What’s actually available is highly dependent on the architecture you’re compiling to (more on this later), but the way vector instruction sets are usually structured is something like this.</p> <p>We have <em>vector registers</em> that are kind of like really big general-purpose registers. For example, on x86, most “high performance” cores (like my Zen 2) implement AVX2, which provides 256 bit <code class="language-plaintext highlighter-rouge">ymm</code> vectors. The registers themselves do not have a “lane count”; that is specified by the instructions. For example, the “vector byte add instruction” interprets the register as being divided into eight-byte lanes and adds them. The corresponding x86 instruction is <code class="language-plaintext highlighter-rouge">vpaddb</code>, which interprets a <code class="language-plaintext highlighter-rouge">ymm</code> as an <code class="language-plaintext highlighter-rouge">i8x32</code>.</p> <p>The operations you usually get are:</p> <ol> <li> <p>Bitwise operations. These don’t need to specify a lane width because it’s always implicitly <code class="language-plaintext highlighter-rouge">1</code>: they’re <em>bit</em>wise.</p> </li> <li> <p>Lane-wise arithmetic. This is addition, subtraction, multiplication, division (both int and float), and shifts<sup id="fnref:shifts-are-arithmetic" role="doc-noteref"><a href="#fn:shifts-are-arithmetic" class="footnote" rel="footnote">1</a></sup> (int only). Lane-wise min and max are also common. These require specifying a lane width. Typically the smallest number of lanes is two or four.</p> </li> <li> <p>Lane-wise compare. Given <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, we can create a new <em>mask vector</em> <code class="language-plaintext highlighter-rouge">m</code> such that <code class="language-plaintext highlighter-rouge">m[i] = a[i] &lt; b[i]</code> (or any other comparison operation). A mask vector’s lanes contain boolean values with an unusual bit-pattern: all-zeros (for false) or all-ones (for true)<sup id="fnref:minus-true" role="doc-noteref"><a href="#fn:minus-true" class="footnote" rel="footnote">2</a></sup>.</p> <ul> <li>Masks can be used to select between two vectors: for example, given <code class="language-plaintext highlighter-rouge">m</code>, <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">y</code>, you can form a fourth vector <code class="language-plaintext highlighter-rouge">z</code> such that <code class="language-plaintext highlighter-rouge">z[i] = m[i] ? a[i] : b[i]</code>.</li> </ul> </li> <li> <p>Shuffles (sometimes called swizzles). Given <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">x</code>, create a third vector <code class="language-plaintext highlighter-rouge">s</code> such that <code class="language-plaintext highlighter-rouge">s[i] = a[x[i]]</code>. <code class="language-plaintext highlighter-rouge">a</code> is used as a lookup table, and <code class="language-plaintext highlighter-rouge">x</code> as a set of indices. Out of bounds produces a special value, usually zero. This emulates parallelized array access without needing to actually touch RAM (RAM is extremely slow).</p> <ul> <li>Often there is a “shuffle2” or “riffle” operation that allows taking elements from one of two vectors. Given <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">x</code>, we now define <code class="language-plaintext highlighter-rouge">s</code> as being <code class="language-plaintext highlighter-rouge">s[i] = (a ++ b)[x[i]]</code>, where <code class="language-plaintext highlighter-rouge">a ++ b</code> is a double-width concatenation. How this is actually implemented depends on architecture, and it’s easy to build out of single shuffles regardless.</li> </ul> </li> </ol> <p>(1) and (2) are ordinary number crunching. Nothing deeply special about them.</p> <p>The comparison and select operations in (3) are intended to help SIMD code stay “branchless”. Branchless code is written such that it performs the same operations regardless of its inputs, and relies on the properties of those operations to produce correct results. For example, this might mean taking advantage of identities like <code class="language-plaintext highlighter-rouge">x * 0 = 0</code> and <code class="language-plaintext highlighter-rouge">a ^ b ^ a = b</code> to discard “garbage” results.</p> <p>The shuffles described in (4) are much more powerful than meets the eye.</p> <p>For example, “broadcast” (sometimes called “splat”) makes a vector whose lanes are all the same scalar, like Rust’s <code class="language-plaintext highlighter-rouge">[42; N]</code> array literal. A broadcast can be expressed as a shuffle: create a vector with the desired value in the first lane, and then shuffle it with an index vector of <code class="language-plaintext highlighter-rouge">[0, 0, ...]</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/broadcast.png" alt="diagram of a broadcast"/></p> <p>“Interleave” (also called “zip” or “pack”) takes two vectors <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> and creates two new vectors <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> whose lanes are alternating lanes from <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. If the lane count is <code class="language-plaintext highlighter-rouge">n</code>, then <code class="language-plaintext highlighter-rouge">c = [a[0], b[0], a[1], b[1], ...]</code> and <code class="language-plaintext highlighter-rouge">d = [a[n/2], b[n/2], a[n/2 + 1], b[n/2 + 1], ...]</code>. This can also be implemented as a shuffle2, with shuffle indices of <code class="language-plaintext highlighter-rouge">[0, n, 1, n + 1, ...]</code>. “Deinterleave” (or “unzip”, or “unpack”) is the opposite operation: it interprets a pair of vectors as two halves of a larger vector of pairs, and produces two new vectors consisting of the halves of each pair.</p> <p>Interleave can also be interpreted as taking a <code class="language-plaintext highlighter-rouge">[T; N]</code>, transmuting it to a <code class="language-plaintext highlighter-rouge">[[T; N/2]; 2]</code>, performing a matrix transpose to turn it into a <code class="language-plaintext highlighter-rouge">[[T; 2]; N/2]</code>, and then transmuting that back to <code class="language-plaintext highlighter-rouge">[T; N]</code> again. Deinterleave is the same but it transmutes to <code class="language-plaintext highlighter-rouge">[[T; 2]; N/2]</code> first.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/interleave.png" alt="diagram of a interleave"/></p> <p>“Rotate” takes a vector <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">n</code> lanes and produces a new vector <code class="language-plaintext highlighter-rouge">b</code> such that <code class="language-plaintext highlighter-rouge">b[i] = a[(i + j) % n]</code>, for some chosen integer <code class="language-plaintext highlighter-rouge">j</code>. This is yet another shuffle, with indices <code class="language-plaintext highlighter-rouge">[j, j + 1, ..., n - 1, 0, 1, ... j - 1]</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/rotate.png" alt="diagram of a rotate"/></p> <p>Shuffles are worth trying to wrap your mind around. SIMD programming is all about reinterpreting larger-than-an-integer-sized blocks of data as smaller blocks of varying sizes, and shuffling is important for getting data into the right “place”.</p> <h3 id="intrinsics-and-instruction-selection"><a href="#intrinsics-and-instruction-selection">Intrinsics and Instruction Selection</a></h3> <p>Earlier, I mentioned that what you get varies by architecture. This section is basically a giant footnote.</p> <p>So, there’s two big factors that go into this.</p> <ol> <li>We’ve learned over time which operations tend to be most useful to programmers. x86 might have something that ARM doesn’t because it “seemed like a good idea at the time” but turned out to be kinda niche.</li> <li>Instruction set extensions are often market differentiators, even within the same vendor. Intel has AVX-512, which provides even more sophisticated instructions, but it’s only available on high-end server chips, because it makes manufacturing more expensive.</li> </ol> <p>Toolchains generalize different extensions as “target features”. Features can be detected at runtime through architecture-specific magic. On Linux, the <code class="language-plaintext highlighter-rouge">lscpu</code> command will list what features the CPU advertises that it recognizes, which correlate with the names of features that e.g. LLVM understands. What features are enabled for a particular function affects how LLVM compiles it. For example, LLVM will only emit <code class="language-plaintext highlighter-rouge">ymm</code>-using code when compiling with <code class="language-plaintext highlighter-rouge">+avx2</code>.</p> <p>So how do you write portable SIMD code? On the surface, the answer is mostly “you don’t”, but it’s more complicated than that, and for that we need to understand how the later parts of a compiler works.</p> <p>When a user requests an add by writing <code class="language-plaintext highlighter-rouge">a + b</code>, how should I decide which instruction to use for it? This seems like a trick question… <em>just</em> an <code class="language-plaintext highlighter-rouge">add</code> right? On x86, even this isn’t so easy, since you have a choice between the actual <code class="language-plaintext highlighter-rouge">add</code> instruction, or a <code class="language-plaintext highlighter-rouge">lea</code> instruction (which, among other things, preserves the <code class="language-plaintext highlighter-rouge">rflags</code> register). This question becomes more complicated for more sophisticated operations. This general problem is called <em>instruction selection</em>.</p> <p>Because which “target features” are enabled affects which instructions are available, they affect instruction selection. When I went over operations “typically available”, this means that compilers will usually be able to select good choices of instructions for them on most architectures.</p> <p>Compiling with something like <code class="language-plaintext highlighter-rouge">-march=native</code> or <code class="language-plaintext highlighter-rouge">-Ctarget-cpu=native</code> gets you “the best” code possible for the machine you’re building on, but it might not be portable<sup id="fnref:abi" role="doc-noteref"><a href="#fn:abi" class="footnote" rel="footnote">3</a></sup> to different processors. Gentoo was quite famous for building packages from source on user machines to take advantage of this (not to mention that they loved using <code class="language-plaintext highlighter-rouge">-O3</code>, which mostly exists to slow down build times with little benefit).</p> <p>There is also runtime feature detection, where a program decides which version of a function to call at runtime by asking the CPU what it supports. Code deployed on heterogenous devices (like cryptography libraries) often make use of this. Doing this correctly is very hard and something I don’t particularly want to dig deeply into here.</p> <p>The situation is made worse by the fact that in C++, you usually write SIMD code using “intrinsics”, which are special functions with inscrutable names like <code class="language-plaintext highlighter-rouge">_mm256_cvtps_epu32</code> that represent a low-level operation in a specific instruction set (this is a float to int cast from AVX2). Intrinsics are defined by hardware vendors, but don’t necessarily map down to single instructions; the compiler can still optimize these instructions by merging, deduplication, and through instruction selection.</p> <p>As a result you wind up writing the same code multiple times for different instruction sets, with only minor maintainability benefits over writing assembly.</p> <p>The alternative is a portable SIMD library, which does some instruction selection behind the scenes at the library level but tries to rely on the compiler for most of the heavy-duty work. For a long time I was skeptical that this approach would actually produce good, competitive code, which brings us to the actual point of this article: using Rust’s portable SIMD library to implement a somewhat fussy algorithm, and measuring performance.</p> <h2 id="parsing-with-simd"><a href="#parsing-with-simd">Parsing with SIMD</a></h2> <p>Let’s design a SIMD implementation for a well-known algorithm. Although it doesn’t look like it at first, the power of shuffles makes it possible to parse text with SIMD. And this parsing can be very, very fast.</p> <p>In this case, we’re going to implement base64 decoding. To review, base64 is an encoding scheme for arbitrary binary data into ASCII. We interpret a byte slice as a bit vector, and divide it into six-bit chunks called <em>sextets</em>. Then, each sextet from 0 to 63 is mapped to an ASCII character:</p> <ol> <li><code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">25</code> go to <code class="language-plaintext highlighter-rouge">'A'</code> to <code class="language-plaintext highlighter-rouge">'Z'</code>.</li> <li><code class="language-plaintext highlighter-rouge">26</code> to <code class="language-plaintext highlighter-rouge">51</code> go to <code class="language-plaintext highlighter-rouge">'a'</code> to <code class="language-plaintext highlighter-rouge">'z'</code>.</li> <li><code class="language-plaintext highlighter-rouge">52</code> to <code class="language-plaintext highlighter-rouge">61</code> go to <code class="language-plaintext highlighter-rouge">'0'</code> to <code class="language-plaintext highlighter-rouge">'9'</code>.</li> <li><code class="language-plaintext highlighter-rouge">62</code> goes to <code class="language-plaintext highlighter-rouge">+</code>.</li> <li><code class="language-plaintext highlighter-rouge">63</code> goes to <code class="language-plaintext highlighter-rouge">/</code>.</li> </ol> <p>There <em>are</em> other variants of base64, but the bulk of the complexity is the same for each variant.</p> <p>There are a few basic pitfalls to keep in mind.</p> <ol> <li> <p>Base64 is a “big endian” format: specifically, the bits in each byte are big endian. Because a sextet can span only parts of a byte, this distinction is important.</p> </li> <li> <p>We need to beware of cases where the input length is not divisible by 4; ostensibly messages should be padded with <code class="language-plaintext highlighter-rouge">=</code> to a multiple of 4, but it’s easy to just handle messages that aren’t padded correctly.</p> </li> </ol> <p>The length of a decoded message is given by this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">input</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="k">match</span> <span class="n">input</span> <span class="o">%</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="p">|</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="mi">3</span> <span class="k">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Given all this, the easiest way to implement base64 is something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Tear off at most two trailing =.</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// Split the input into chunks of at most 4 bytes.</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">byte</span> <span class="k">in</span> <span class="n">chunk</span> <span class="p">{</span>
      <span class="c1">// Translate each ASCII character into its corresponding</span>
      <span class="c1">// sextet, or return an error.</span>
      <span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
        <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
        <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
        <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
        <span class="sc">b'+'</span> <span class="k">=&gt;</span> <span class="mi">62</span><span class="p">,</span>
        <span class="sc">b'/'</span> <span class="k">=&gt;</span> <span class="mi">63</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nf">Error</span><span class="p">(</span><span class="o">...</span><span class="p">)),</span>
      <span class="p">};</span>

      <span class="c1">// Append the sextet to the temporary buffer.</span>
      <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
      <span class="n">bytes</span> <span class="p">|</span><span class="o">=</span> <span class="n">sextet</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Shift things so the actual data winds up at the</span>
    <span class="c1">// top of `bytes`.</span>
    <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">32</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">chunk</span><span class="nf">.len</span><span class="p">();</span>

    <span class="c1">// Append the decoded data to `out`, keeping in mind that</span>
    <span class="c1">// `bytes` is big-endian encoded.</span>
    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="nf">.to_be_bytes</span><span class="p">()[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So, what’s the process of turning this into a SIMD version? We want to follow one directive with inexorable, robotic dedication.</p> <p><strong>Eliminate all branches.</strong></p> <p>This is not completely feasible, since the input is of variable length. But we can try. There are several branches in this code:</p> <ol> <li>The <code class="language-plaintext highlighter-rouge">for chunk in</code> line. This one is is the length check: it checks if there is any data left to process.</li> <li>The <code class="language-plaintext highlighter-rouge">for &amp;byte in</code> line. This is the hottest loop: it branches once per input byte.</li> <li>The <code class="language-plaintext highlighter-rouge">match byte</code> line is several branches, to determine which of the five “valid” match arms we land in.</li> <li>The <code class="language-plaintext highlighter-rouge">return Err</code> line. Returning in a hot loop is extra control flow, which is not ideal.</li> <li>The call to <code class="language-plaintext highlighter-rouge">decoded_len</code> contains a <code class="language-plaintext highlighter-rouge">match</code>, which generates branches.</li> <li>The call to <code class="language-plaintext highlighter-rouge">Vec::extend_from_slice</code>. This contains not just branches, but potential calls into the allocator. Extremely slow.</li> </ol> <p>(5) is the easiest to deal with. The <code class="language-plaintext highlighter-rouge">match</code> is mapping the values <code class="language-plaintext highlighter-rouge">0, 1, 2, 3</code> to <code class="language-plaintext highlighter-rouge">0, 1, 1, 2</code>. Call this function <code class="language-plaintext highlighter-rouge">f</code>. Then, the sequence given by <code class="language-plaintext highlighter-rouge">x - f(x)</code> is <code class="language-plaintext highlighter-rouge">0, 0, 1, 1</code>. This just happens to equal <code class="language-plaintext highlighter-rouge">x / 2</code> (or <code class="language-plaintext highlighter-rouge">x &gt;&gt; 1</code>), so we can write a completely branchless version of <code class="language-plaintext highlighter-rouge">decoded_len</code> like so.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">mod4</span> <span class="o">=</span> <span class="n">input</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">input</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">mod4</span> <span class="o">-</span> <span class="n">mod4</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBkZWNvZGVkX2xlbihpbnB1dDogdXNpemUpIC0+IHVzaXpl IHtcbiAgbGV0IG1vZDQgPSBpbnB1dCAlIDQ7XG4gIGlucHV0IC8gNCAqIDMg KyAobW9kNCAtIG1vZDQgLyAyKVxufSIsImNvbXBpbGVycyI6W3siaWQiOiJi ZXRhIiwib3B0aW9ucyI6Ii1PIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>That’s one branch eliminated<sup id="fnref:why-cant-llvm-do-it" role="doc-noteref"><a href="#fn:why-cant-llvm-do-it" class="footnote" rel="footnote">4</a></sup>. ✅</p> <p>The others will not prove so easy. Let’s turn our attention to the innermost loop next, branches (2), (3), and (4).</p> <h3 id="the-hottest-loop"><a href="#the-hottest-loop">The Hottest Loop</a></h3> <p>The superpower of SIMD is that because you operate on so much data at a time, you can unroll the loop so hard it becomes branchless.</p> <p>The insight is this: we want to load at most four bytes, do something to them, and then spit out at most three decoded bytes. While doing this operation, we may encounter a syntax error so we need to report that somehow.</p> <p>Here’s some facts we can take advantage of.</p> <ol> <li>We don’t need to figure out how many bytes are in the “output” of the hot loop: our handy branchless <code class="language-plaintext highlighter-rouge">decoded_len()</code> does that for us.</li> <li>Invalid base64 is extremely rare. We want that syntax error to cost as little as possible. If the user still cares about which byte was the problem, they can scan the input for it after the fact.</li> <li><code class="language-plaintext highlighter-rouge">A</code> is zero in base64. If we’re parsing a truncated chunk, padding it with <code class="language-plaintext highlighter-rouge">A</code> won’t change the value<sup id="fnref:pad-with-A" role="doc-noteref"><a href="#fn:pad-with-A" class="footnote" rel="footnote">5</a></sup>.</li> </ol> <p>This suggests an interface for the body of the “hottest loop”. We can factor it out as a separate function, and simplify since we can assume our input is always four bytes now.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="p">([</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ok</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">byte</span> <span class="k">in</span> <span class="n">ascii</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
      <span class="sc">b'+'</span> <span class="k">=&gt;</span> <span class="mi">62</span><span class="p">,</span>
      <span class="sc">b'/'</span> <span class="k">=&gt;</span> <span class="mi">63</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">bytes</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">bytes</span> <span class="p">|</span><span class="o">=</span> <span class="n">sextet</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="n">ok</span> <span class="o">&amp;=</span> <span class="n">byte</span> <span class="o">==</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This is the `to_be_bytes()` call.</span>
  <span class="k">let</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">bytes</span><span class="nf">.to_le_bytes</span><span class="p">();</span>
  <span class="p">([</span><span class="n">b3</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">],</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// In decode()...</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
  <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

  <span class="k">let</span> <span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">);</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
  <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>You’re probably thinking: why not return <code class="language-plaintext highlighter-rouge">Option&lt;[u8; 3]&gt;</code>? Returning an enum will make it messier to eliminate the <code class="language-plaintext highlighter-rouge">if !ok</code> branch later on (which we will!). We want to write branchless code, so let’s focus on finding a way of producing that three-byte output without needing to do early returns.</p> <p>Now’s when we want to start talking about vectors rather than arrays, so let’s try to rewrite our function as such.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="nd">unimplemented!</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that the output is now four bytes, not three. SIMD lane counts need to be powers of two, and that last element will never get looked at, so we don’t need to worry about what winds up there.</p> <p>The callsite also needs to be tweaked, but only slightly, because <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> is <code class="language-plaintext highlighter-rouge">From&lt;[u8; 4]&gt;</code>.</p> <h3 id="ascii-to-sextet"><a href="#ascii-to-sextet">ASCII to Sextet</a></h3> <p>Let’s look at the first part of the <code class="language-plaintext highlighter-rouge">for byte in ascii</code> loop. We need to map each lane of the <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> to the corresponding sextet, and somehow signal which ones are invalid. First, notice something special about the <code class="language-plaintext highlighter-rouge">match</code>: almost every arm can be written as <code class="language-plaintext highlighter-rouge">byte - C</code> for some constant <code class="language-plaintext highlighter-rouge">C</code>. The non-range case looks a little silly, but humor me:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">sextet</span> <span class="o">=</span> <span class="k">match</span> <span class="n">byte</span> <span class="p">{</span>
  <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'Z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'A'</span><span class="p">,</span>
  <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'z'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">26</span><span class="p">,</span>
  <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'0'</span> <span class="o">+</span> <span class="mi">52</span><span class="p">,</span>
  <span class="sc">b'+'</span>        <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'+'</span> <span class="o">+</span> <span class="mi">62</span><span class="p">,</span>
  <span class="sc">b'/'</span>        <span class="k">=&gt;</span> <span class="n">byte</span> <span class="o">-</span> <span class="sc">b'/'</span> <span class="o">+</span> <span class="mi">63</span><span class="p">,</span>
  <span class="n">_</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So, it should be sufficient to build a vector <code class="language-plaintext highlighter-rouge">offsets</code> that contains the appropriate constant <code class="language-plaintext highlighter-rouge">C</code> for each lane, and then <code class="language-plaintext highlighter-rouge">let sextets = ascii - offsets;</code></p> <p>How can we build <code class="language-plaintext highlighter-rouge">offsets</code>? Using compare-and-select.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// A lane-wise version of `x &gt;= start &amp;&amp; x &lt;= end`.</span>
<span class="k">fn</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">bytes</span><span class="nf">.simd_ge</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">bytes</span><span class="nf">.simd_le</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Create masks for each of the five ranges.</span>
<span class="c1">// Note that these are disjoint: for any two masks, m1 &amp; m2 == 0.</span>
<span class="k">let</span> <span class="n">uppers</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'A'</span><span class="p">,</span> <span class="sc">b'Z'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">lowers</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'a'</span><span class="p">,</span> <span class="sc">b'z'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">digits</span> <span class="o">=</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="sc">b'0'</span><span class="p">,</span> <span class="sc">b'9'</span><span class="p">);</span>
<span class="k">let</span> <span class="n">pluses</span> <span class="o">=</span> <span class="n">ascii</span><span class="nf">.simd_eq</span><span class="p">([</span><span class="sc">b'+'</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span><span class="nf">.into</span><span class="p">());</span>
<span class="k">let</span> <span class="n">solidi</span> <span class="o">=</span> <span class="n">ascii</span><span class="nf">.simd_eq</span><span class="p">([</span><span class="sc">b'/'</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span><span class="nf">.into</span><span class="p">());</span>

<span class="c1">// If any byte was invalid, none of the masks will select for it,</span>
<span class="c1">// so that lane will be 0 in the or of all the masks. This is our</span>
<span class="c1">// validation check.</span>
<span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">uppers</span> <span class="p">|</span> <span class="n">lowers</span> <span class="p">|</span> <span class="n">digits</span> <span class="p">|</span> <span class="n">pluses</span> <span class="p">|</span> <span class="n">solidi</span><span class="p">)</span><span class="nf">.all</span><span class="p">();</span>

<span class="c1">// Given a mask, create a new vector by splatting `value`</span>
<span class="c1">// over the set lanes.</span>
<span class="k">fn</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">Mask</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">mask</span><span class="nf">.select</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Fill the the lanes of the offset vector by filling the</span>
<span class="c1">// set lanes with the corresponding offset. This is like</span>
<span class="c1">// a "vectorized" version of the `match`.</span>
<span class="k">let</span> <span class="n">offsets</span> <span class="o">=</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">uppers</span><span class="p">,</span>  <span class="mi">65</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span>  <span class="mi">71</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">pluses</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">)</span>
            <span class="p">|</span> <span class="nf">masked_splat</span><span class="p">(</span><span class="n">solidi</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">);</span>

<span class="c1">// Finally, Build the sextets vector.</span>
<span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-</span> <span class="n">offsets</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This solution is quite elegant, and will produce very competitive code, but it’s not actually ideal. We need to do a lot of comparisons here: eight in total. We also keep lots of values alive at the same time, which might lead to unwanted register pressure.</p> <h3 id="simd-hash-table"><a href="#simd-hash-table">SIMD Hash Table</a></h3> <p>Let’s look at the byte representations of the ranges. <code class="language-plaintext highlighter-rouge">A-Z</code>, <code class="language-plaintext highlighter-rouge">a-z</code>, and <code class="language-plaintext highlighter-rouge">0-9</code> are, as byte ranges, <code class="language-plaintext highlighter-rouge">0x41..0x5b</code>, <code class="language-plaintext highlighter-rouge">0x61..0x7b</code>, and <code class="language-plaintext highlighter-rouge">0x30..0x3a</code>. Notice they all have different high nybbles! What’s more, <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">/</code> are <code class="language-plaintext highlighter-rouge">0x2b</code> and <code class="language-plaintext highlighter-rouge">0x2f</code>, so the function <code class="language-plaintext highlighter-rouge">byte &gt;&gt; 4</code> is <em>almost</em> enough to distinguish all the ranges. If we subtract one if <code class="language-plaintext highlighter-rouge">byte == b'/'</code>, we have a <em>perfect hash</em> for the ranges.</p> <p>In other words, the value <code class="language-plaintext highlighter-rouge">(byte &gt;&gt; 4) - (byte == '/')</code> maps the ranges as follows:</p> <ul> <li><code class="language-plaintext highlighter-rouge">A-Z</code> goes to 4 or 5.</li> <li><code class="language-plaintext highlighter-rouge">a-z</code> goes to 6 or 7.</li> <li><code class="language-plaintext highlighter-rouge">0-9</code> goes to 3.</li> <li><code class="language-plaintext highlighter-rouge">+</code> goes to 2.</li> <li><code class="language-plaintext highlighter-rouge">/</code> goes to 1.</li> </ul> <p>This is small enough that we could cram a lookup table of values for building the <code class="language-plaintext highlighter-rouge">offsets</code> vector into another SIMD vector, and use a shuffle operation to do the lookup.</p> <p>This is not my original idea; I came across a <a href="https://github.com/WojciechMula/base64simd/issues/3">GitHub issue</a> where an anonymous user points out this perfect hash.</p> <p>Our new ascii-to-sextet code looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Compute the perfect hash for each lane.</span>
<span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
  <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
    <span class="nf">.to_int</span><span class="p">()</span>  <span class="c1">// to_int() is equivalent to masked_splat(-1, 0).</span>
    <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Look up offsets based on each hash and subtract them from `ascii`.</span>
<span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="c1">// This lookup table corresponds to the offsets we used to build the</span>
    <span class="c1">// `offsets` vector in the previous implementation, placed in the</span>
    <span class="c1">// indices that the perfect hash produces.</span>
  <span class="o">-</span> <span class="nn">Simd</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
    <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There is a small wrinkle here: <a href="https://doc.rust-lang.org/std/simd/struct.Simd.html#method.swizzle_dyn"><code class="language-plaintext highlighter-rouge">Simd::swizzle_dyn()</code></a> requires that the index array be the same length as the lookup table. This is annoying because right now <code class="language-plaintext highlighter-rouge">ascii</code> is a <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code>, but that will not be the case later on, so I will simply sweep this under the rug.</p> <p>Note that we no longer get validation as a side-effect of computing the sextets vector. The same GitHub issue also provides an exact bloom-filter for checking that a particular byte is valid; you can see my implementation <a href="https://github.com/mcy/vb64/blob/894f833e933860e070dabcfcc189430c45fecbd7/src/simd.rs#L93">here</a>. I’m not sure how the OP constructed the bloom filter, but the search space is small enough that you could have written a little script to brute force it.</p> <h3 id="riffling-the-sextets"><a href="#riffling-the-sextets">Riffling the Sextets</a></h3> <p>Now comes a much tricker operation: we need to somehow pack all four sextets into three bytes. One way to try to wrap our head around what the packing code in <code class="language-plaintext highlighter-rouge">decode_hot()</code> is doing is to pass in the all-ones sextet in one of the four bytes, and see where those ones end up in the return value.</p> <p>This is not unlike how they use radioactive dyes in biology to track the moment of molecules or cells through an organism.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">bits</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">b4</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="nf">.reverse_bits</span><span class="p">()</span><span class="nf">.to_le_bytes</span><span class="p">();</span>
  <span class="nd">format!</span><span class="p">(</span><span class="s">"{b1:08b} {b2:08b} {b3:08b} {b4:08b}"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">decode_pack</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">byte</span> <span class="k">in</span> <span class="n">input</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">output</span> <span class="p">|</span><span class="o">=</span> <span class="n">byte</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">output</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>

  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="nf">bits</span><span class="p">(</span><span class="nn">u32</span><span class="p">::</span><span class="nf">from_be_bytes</span><span class="p">(</span><span class="n">input</span><span class="p">)),</span> <span class="nf">bits</span><span class="p">(</span><span class="n">output</span><span class="p">));</span>
<span class="p">}</span>

<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="nf">decode_pack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0b111111</span><span class="p">]);</span>

<span class="c1">// Output:</span>
<span class="c1">// 11111100 00000000 00000000 00000000</span>
<span class="c1">// 00111111 00000000 00000000 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 11111100 00000000 00000000</span>
<span class="c1">// 11000000 00001111 00000000 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 00000000 11111100 00000000</span>
<span class="c1">// 00000000 11110000 00000011 00000000</span>
<span class="c1">//</span>
<span class="c1">// 00000000 00000000 00000000 11111100</span>
<span class="c1">// 00000000 00000000 11111100 00000000</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xuZm4gYml0cyh2YWx1ZTogdTMyKSAtPiBT dHJpbmcge1xuICBsZXQgW2IxLCBiMiwgYjMsIGI0XSA9IHZhbHVlLnJldmVy c2VfYml0cygpLnRvX2xlX2J5dGVzKCk7XG4gIGZvcm1hdCEoXCJ7YjE6MDhi fSB7YjI6MDhifSB7YjM6MDhifSB7YjQ6MDhifVwiKVxufVxuXG5mbiBkZWNv ZGVfcGFjayhpbnB1dDogW3U4OyA0XSkge1xuICBsZXQgbXV0IG91dHB1dCA9 IDB1MzI7XG4gIGZvciBieXRlIGluIGlucHV0IHtcbiAgICBvdXRwdXQgPDw9 IDY7XG4gICAgb3V0cHV0IHw9IGJ5dGUgYXMgdTMyO1xuICB9XG4gIG91dHB1 dCA8PD0gODtcblxuICBwcmludGxuIShcInt9XFxue31cXG5cIiwgYml0cyh1 MzI6OmZyb21fYmVfYnl0ZXMoaW5wdXQpKSwgYml0cyhvdXRwdXQpKTtcbn1c blxuZGVjb2RlX3BhY2soWzBiMTExMTExLCAwLCAwLCAwXSk7XG5kZWNvZGVf cGFjayhbMCwgMGIxMTExMTEsIDAsIDBdKTtcbmRlY29kZV9wYWNrKFswLCAw LCAwYjExMTExMSwgMF0pO1xuZGVjb2RlX3BhY2soWzAsIDAsIDAsIDBiMTEx MTExXSk7XG5cbi8vIE91dHB1dDpcbi8vIDExMTExMTAwIDAwMDAwMDAwIDAw MDAwMDAwIDAwMDAwMDAwXG4vLyAwMDExMTExMSAwMDAwMDAwMCAwMDAwMDAw MCAwMDAwMDAwMFxuLy9cbi8vIDAwMDAwMDAwIDExMTExMTAwIDAwMDAwMDAw IDAwMDAwMDAwXG4vLyAxMTAwMDAwMCAwMDAwMTExMSAwMDAwMDAwMCAwMDAw MDAwMFxuLy9cbi8vIDAwMDAwMDAwIDAwMDAwMDAwIDExMTExMTAwIDAwMDAw MDAwXG4vLyAwMDAwMDAwMCAxMTExMDAwMCAwMDAwMDAxMSAwMDAwMDAwMFxu Ly9cbi8vIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDExMTExMTAwXG4v LyAwMDAwMDAwMCAwMDAwMDAwMCAxMTExMTEwMCAwMDAwMDAwMFxufVxuIiwi Y29tcGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlclZpc2libGUi OmZhbHNlLCJjb21waWxlck91dHB1dFZpc2libGUiOnRydWUsImNvbXBpbGVy Ijp7ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiIifX1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>Bingo. Playing around with the inputs lets us verify which pieces of the bytes wind up where. For example, by passing <code class="language-plaintext highlighter-rouge">0b110000</code> as <code class="language-plaintext highlighter-rouge">input[1]</code>, we see that the two high bits of <code class="language-plaintext highlighter-rouge">input[1]</code> correspond to the low bits of <code class="language-plaintext highlighter-rouge">output[0]</code>. I’ve written the code so that the bits in each byte are printed in little-endian order, so bits on the left are the low bits.</p> <p>Putting this all together, we can draw a schematic of what this operation does to a general <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code>.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/riffle.png" alt="the riffling operation"/></p> <p>Now, there’s no single instruction that will do this for us. Shuffles can be used to move bytes around, but we’re dealing with <em>pieces</em> of bytes here. We also can’t really do a shift, since we need bits that are overshifted to move into adjacent lanes.</p> <p>The trick is to just make the lanes bigger.</p> <p>Among the operations available for SIMD vectors are lane-wise casts, which allow us to zero-extend, sign-extend, or truncate each lane. So what we can do is cast <code class="language-plaintext highlighter-rouge">sextets</code> to a vector of <code class="language-plaintext highlighter-rouge">u16</code>, do the shift there and then… somehow put the parts back together?</p> <p>Let’s see how far shifting gets us. How much do we need to shift things by? First, notice that the order of the bits within each chunk that doesn’t cross a byte boundary doesn’t change. For example, the four low bits of <code class="language-plaintext highlighter-rouge">input[1]</code> are in the same order when they become the high bits of <code class="language-plaintext highlighter-rouge">output[1]</code>, and the two high bits of <code class="language-plaintext highlighter-rouge">input[1]</code> are also in the same order when they become the low bits of <code class="language-plaintext highlighter-rouge">output[0]</code>.</p> <p>This means we can determine how far to shift by comparing the bit position of the lowest bit of a byte of <code class="language-plaintext highlighter-rouge">input</code> with the bit position of the corresponding bit in <code class="language-plaintext highlighter-rouge">output</code>.</p> <p><code class="language-plaintext highlighter-rouge">input[0]</code>’s low bit is the third bit of <code class="language-plaintext highlighter-rouge">output[0]</code>, so we need to shift <code class="language-plaintext highlighter-rouge">input[0]</code> by 2. <code class="language-plaintext highlighter-rouge">input[1]</code>’s lowest bit is the fifth bit of <code class="language-plaintext highlighter-rouge">output[1]</code>, so we need to shift by 4. Analogously, the shifts for <code class="language-plaintext highlighter-rouge">input[2]</code> and <code class="language-plaintext highlighter-rouge">input[3]</code> turn out to be 6 and 0. In code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>So now we have a <code class="language-plaintext highlighter-rouge">Simd&lt;u16, 4&gt;</code> that contains the individual chunks that we need to move around, in the high and low bytes of each <code class="language-plaintext highlighter-rouge">u16</code>, which we can think of as being analogous to a <code class="language-plaintext highlighter-rouge">[[u8; 2]; 4]</code>. For example, <code class="language-plaintext highlighter-rouge">shifted[0][0]</code> contains <code class="language-plaintext highlighter-rouge">sextet[0]</code>, but shifted. This corresponds to the red segment in the first schematic. The smaller blue segment is given by <code class="language-plaintext highlighter-rouge">shifted[1][1]</code>, i.e., the high byte of the second <code class="language-plaintext highlighter-rouge">u16</code>. It’s already in the right place within that byte, so we want <code class="language-plaintext highlighter-rouge">output[0] = shifted[0][0] | shifted[1][1]</code>.</p> <p>This suggests a more general strategy: we want to take two vectors, the low bytes and the high bytes of each <code class="language-plaintext highlighter-rouge">u16</code> in <code class="language-plaintext highlighter-rouge">shifted</code>, respectively, and somehow shuffle them so that when or’ed together, they give the desired output.</p> <p>Look at the schematic again: if we had a vector consisting of <code class="language-plaintext highlighter-rouge">[..aaaaaa, ....bbbb, ......cc]</code>, we could or it with a vector like <code class="language-plaintext highlighter-rouge">[bb......, cccc...., dddddd..]</code> to get the desired result.</p> <p>One problem: <code class="language-plaintext highlighter-rouge">dddddd..</code> is <code class="language-plaintext highlighter-rouge">shifted[3][0]</code>, i.e., it’s a low byte. If we change the vector we shift by to <code class="language-plaintext highlighter-rouge">[2, 4, 6, 8]</code>, though, it winds up in <code class="language-plaintext highlighter-rouge">shifted[3][1]</code>, since it’s been shifted up by <code class="language-plaintext highlighter-rouge">8</code> bits: a full byte.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Split shifted into low byte and high byte vectors.</span>
<span class="c1">// Same way you'd split a single u16 into bytes, but lane-wise.</span>
<span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">8</span><span class="p">;</span> <span class="mi">4</span><span class="p">]))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Align the lanes: we want to get shifted[0][0] | shifted[1][1],</span>
<span class="c1">// shifted[1][0] | shifted[2][1], etc.</span>
<span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Et voila, here is our new, totally branchless implementation of <code class="language-plaintext highlighter-rouge">decode_hot()</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">decode_hot</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
      <span class="nf">.to_int</span><span class="p">()</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="o">-</span> <span class="nn">Simd</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
      <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span>  <span class="c1">// Note quite right yet, see next section.</span>

  <span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="cm">/* bloom filter shenanigans */</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
  <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compactness of this solution should not be understated. The simplicity of this solution is a large part of what makes it so efficient, because it aggressively leverages the primitives the hardware offers us.</p> <h3 id="scaling-up"><a href="#scaling-up">Scaling Up</a></h3> <p>Ok, so now we have to contend with a new aspect of our implementation that’s crap: a <code class="language-plaintext highlighter-rouge">Simd&lt;u8, 4&gt;</code> is tiny. That’s not even 128 bits, which are the smallest vector registers on x86. What we need to do is make <code class="language-plaintext highlighter-rouge">decode_hot()</code> generic on the lane count. This will allow us to tune the number of lanes to batch together depending on benchmarks later on.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode_hot</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="k">where</span>
  <span class="c1">// This makes sure N is a small power of 2.</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ascii</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="o">+</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">simd_eq</span><span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="sc">b'/'</span><span class="p">))</span>
      <span class="nf">.to_int</span><span class="p">()</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">sextets</span> <span class="o">=</span> <span class="n">ascii</span>
    <span class="o">-</span> <span class="nf">tiled</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">71</span><span class="p">])</span>
      <span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span>
      <span class="nf">.swizzle_dyn</span><span class="p">(</span><span class="n">hashes</span><span class="p">);</span>  <span class="c1">// Works fine now, as long as N &gt;= 8.</span>

  <span class="k">let</span> <span class="n">ok</span> <span class="o">=</span> <span class="cm">/* bloom filter shenanigans */</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">shifted</span> <span class="o">=</span> <span class="n">sextets</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nf">tiled</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
  <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">shifted</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifted</span> <span class="o">&gt;&gt;</span> <span class="nn">Simd</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Generates a new vector made up of repeated "tiles" of identical</span>
<span class="cd">/// data.</span>
<span class="k">const</span> <span class="k">fn</span> <span class="n">tiled</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">T</span><span class="p">:</span> <span class="n">SimdElement</span><span class="p">,</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">tile</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">N</span><span class="p">];</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="p">{</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">tile</span><span class="nf">.len</span><span class="p">()];</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nn">Simd</span><span class="p">::</span><span class="nf">from_array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We have to change virtually nothing, which is pretty awesome! But unfortunately, this code is subtly incorrect. Remember how in the <code class="language-plaintext highlighter-rouge">N = 4</code> case, the result of <code class="language-plaintext highlighter-rouge">output</code> had a garbage value that we ignore in its highest lane? Well, now that garbage data is interleaved into output: every fourth lane contains garbage.</p> <p>We can use a shuffle to delete these lanes, thankfully. Specifically, we want <code class="language-plaintext highlighter-rouge">shuffled[i] = output[i + i / 3]</code>, which skips every forth index. So, <code class="language-plaintext highlighter-rouge">shuffled[3] = output[4]</code>, skipping over the garbage value in <code class="language-plaintext highlighter-rouge">output[3]</code>. If <code class="language-plaintext highlighter-rouge">i + i / 3</code> overflows <code class="language-plaintext highlighter-rouge">N</code>, that’s ok, because that’s the high quarter of the final output vector, which is ignored anyways. In code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode_hot</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="k">where</span>
  <span class="c1">// This makes sure N is a small power of 2.</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>

  <span class="k">let</span> <span class="n">decoded_chunks</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="n">hi</span><span class="py">.rotate_lanes_left</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="nd">swizzle!</span><span class="p">(</span><span class="n">N</span><span class="p">;</span> <span class="n">decoded_chunks</span><span class="p">,</span> <span class="nd">array!</span><span class="p">(</span><span class="n">N</span><span class="p">;</span> <span class="p">|</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>

  <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <blockquote> <p><code class="language-plaintext highlighter-rouge">swizzle!()</code> is a helper macro<sup id="fnref:macros" role="doc-noteref"><a href="#fn:macros" class="footnote" rel="footnote">6</a></sup> for generating generic implementations of <code class="language-plaintext highlighter-rouge">std::simd::Swizzle</code>, and <code class="language-plaintext highlighter-rouge">array!()</code> is something I wrote for generating generic-length array constants; the closure is called once for each <code class="language-plaintext highlighter-rouge">i in 0..N</code>.</p> </blockquote> <p>So now we can decode 32 base64 bytes in parallel by calling <code class="language-plaintext highlighter-rouge">decode_hot::&lt;32&gt;()</code>. We’ll try to keep things generic from here, so we can tune the lane parameter based on benchmarks.</p> <h3 id="the-outer-loop"><a href="#the-outer-loop">The Outer Loop</a></h3> <p>Let’s look at <code class="language-plaintext highlighter-rouge">decode()</code> again. Let’s start by making it generic on the internal lane count, too.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span>
  <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// N-sized chunks now.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="n">out</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dec</span><span class="p">[</span><span class="o">..</span><span class="n">decoded</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What branches are left? There’s still the branch from <code class="language-plaintext highlighter-rouge">for chunks in ...</code>. It’s not ideal because it can’t do an exact pointer comparison, and needs to do a <code class="language-plaintext highlighter-rouge">&gt;=</code> comparison on a length instead.</p> <p>We call <code class="language-plaintext highlighter-rouge">[T]::copy_from_slice</code>, which is super slow because it needs to make a variable-length <code class="language-plaintext highlighter-rouge">memcpy</code> call, which can’t be inlined. Function calls are branches! The bounds checks are also a problem.</p> <p>We branch on <code class="language-plaintext highlighter-rouge">ok</code> every loop iteration, still. Not returning early in <code class="language-plaintext highlighter-rouge">decode_hot</code> doesn’t win us anything (yet).</p> <p>We potentially call the allocator in <code class="language-plaintext highlighter-rouge">extend_from_slice</code>, and perform another non-inline-able <code class="language-plaintext highlighter-rouge">memcpy</code> call.</p> <h3 id="preallocating-with-slop"><a href="#preallocating-with-slop">Preallocating with Slop</a></h3> <p>The last of these is the easiest to address: we can reserve space in <code class="language-plaintext highlighter-rouge">out</code>, since we know exactly how much data we need to write thanks to <code class="language-plaintext highlighter-rouge">decoded_len</code>. Better yet, we can reserve some “slop”: i.e., scratch space past where the end of the message would be, so we can perform full SIMD stores, instead of the variable-length memcpy.</p> <p>This way, in each iteration, we write the full SIMD vector, including any garbage bytes in the upper quarter. Then, the next write is offset <code class="language-plaintext highlighter-rouge">3/4 * N</code> bytes over, so it overwrites the garbage bytes with decoded message bytes. The garbage bytes from the final right get “deleted” by not being included in the final <code class="language-plaintext highlighter-rouge">Vec::set_len()</code> that “commits” the memory we wrote to.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="n">p</span> <span class="o">@</span> <span class="o">..</span><span class="p">,</span> <span class="sc">b'='</span><span class="p">]</span> <span class="p">|</span> <span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">let</span> <span class="n">final_len</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="n">out</span><span class="nf">.reserve</span><span class="p">(</span><span class="n">final_len</span> <span class="o">+</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// Reserve with slop.</span>

  <span class="c1">// Get a raw pointer to where we should start writing.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">out</span><span class="nf">.as_mut_ptr_range</span><span class="p">()</span><span class="nf">.end</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// N-sized chunks now.</span>
    <span class="cm">/* snip */</span>

    <span class="k">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nf">decoded_len</span><span class="p">(</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// Do a raw write and advance the pointer.</span>
      <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Simd</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">dec</span><span class="p">);</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">decoded</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="c1">// Update the vector's final length.</span>
    <span class="c1">// This is the final "commit".</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">out</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is safe, because we’ve pre-allocated exactly the amount of memory we need, and where <code class="language-plaintext highlighter-rouge">ptr</code> lands is equal to the amount of memory actually decoded. We could also compute the final length of <code class="language-plaintext highlighter-rouge">out</code> ahead of time.</p> <p>Note that if we early return due to <code class="language-plaintext highlighter-rouge">if !ok</code>, <code class="language-plaintext highlighter-rouge">out</code> remains unmodified, because even though we did write to its buffer, we never execute the “commit” part, so the code remains correct.</p> <h3 id="delaying-failure"><a href="#delaying-failure">Delaying Failure</a></h3> <p>Next up, we can eliminate the <code class="language-plaintext highlighter-rouge">if !ok</code> branches by waiting to return an error until as late as possible: just before the <code class="language-plaintext highlighter-rouge">set_len</code> call.</p> <p>Remember our observation from before: most base64 encoded blobs are valid, so this unhappy path should be very rare. Also, syntax errors cannot cause code that follows to misbehave arbitrarily, so letting it go wild doesn’t hurt anything.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">error</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="n">error</span> <span class="p">|</span><span class="o">=</span> <span class="o">!</span><span class="n">ok</span><span class="p">;</span>

    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">out</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The branch is still “there”, sure, but it’s out of the hot loop.</p> <p>Because we never hit the <code class="language-plaintext highlighter-rouge">set_len</code> call and commit whatever garbage we wrote, said garbage essentially disappears when we return early, to be overwritten by future calls to <code class="language-plaintext highlighter-rouge">Vec::push()</code>.</p> <h3 id="unroll-it-harder"><a href="#unroll-it-harder">Unroll It Harder</a></h3> <p>Ok, let’s look at the memcpy from <code class="language-plaintext highlighter-rouge">copy_from_slice</code> at the start of the hot loop. The loop has already been partly unrolled: it does <code class="language-plaintext highlighter-rouge">N</code> iterations with SIMD each step, doing something funny on the last step to make up for the missing data (padding with <code class="language-plaintext highlighter-rouge">A</code>).</p> <p>We can take this a step further by doing an “unroll and jam” optimization. This type of unrolling splits the loop into two parts: a hot vectorized loop and a cold remainder part. The hot loop <em>always</em> handles length <code class="language-plaintext highlighter-rouge">N</code> input, and the remainder runs at most once and handles <code class="language-plaintext highlighter-rouge">i &lt; N</code> input.</p> <p>Rust provides an iterator adapter for hand-rolled (lol) unroll-and-jam: <code class="language-plaintext highlighter-rouge">Iterator::chunks_exact()</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">out</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">LaneCount</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">SupportedLaneCount</span><span class="p">,</span>
<span class="p">{</span>
  <span class="cm">/* snip */</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">error</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">chunks</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.chunks_exact</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
  <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">chunks</span> <span class="p">{</span>
    <span class="c1">// Simd::from_slice() can do a load in one instruction.</span>
    <span class="c1">// The bounds check is easy for the compiler to elide.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">Simd</span><span class="p">::</span><span class="nf">from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>
    <span class="n">error</span> <span class="p">|</span><span class="o">=</span> <span class="o">!</span><span class="n">ok</span><span class="p">;</span>
    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">chunks</span><span class="nf">.remainder</span><span class="p">();</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="n">ascii</span><span class="p">[</span><span class="o">..</span><span class="n">chunk</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span> <span class="o">=</span> <span class="nn">decode_hot</span><span class="p">::</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ascii</span><span class="nf">.into</span><span class="p">());</span>
    <span class="cm">/* snip */</span>
  <span class="p">}</span>

  <span class="cm">/* snip */</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Splitting into two parts lets us call <code class="language-plaintext highlighter-rouge">Simd::from_slice()</code>, which performs a single, vector-sized load.</p> <h2 id="so-how-fast-is-it"><a href="#so-how-fast-is-it">So, How Fast Is It?</a></h2> <p>At this point, it looks like we’ve addressed every branch that we can, so some benchmarks are in order. I wrote a benchmark that decodes messages of every length from 0 to something like 200 or 500 bytes, and compared it against the baseline base64 implementation on crates.io.</p> <p>I compiled with <code class="language-plaintext highlighter-rouge">-Zbuild-std</code> and <code class="language-plaintext highlighter-rouge">-Ctarget-cpu=native</code> to try to get the best results. Based on some tuning, <code class="language-plaintext highlighter-rouge">N = 32</code> was the best length, since it used one YMM register for each iteration of the hot loop.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph-old.png" alt="a performance graph; our code is really good compared to the baseline, but variance is high"/></p> <p>So, we have the baseline beat. But what’s up with that crazy heartbeat waveform? You can tell it has something to do with the “remainder” part of the loop, since it correlates strongly with <code class="language-plaintext highlighter-rouge">data.len() % 32</code>.</p> <p>I stared at the assembly for a while. I don’t remember what was there, but I think that <code class="language-plaintext highlighter-rouge">copy_from_slice</code> had been inlined and unrolled into a loop that loaded each byte at a time. The moral equivalent of this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">ascii</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="nn">Iterator</span><span class="p">::</span><span class="nf">zip</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">ascii</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I decided to try <code class="language-plaintext highlighter-rouge">Simd::gather_or()</code>, which is kind of like a “vectorized load”. It wound up producing worse assembly, so I gave up on using a gather and instead wrote a carefully optimized loading function by hand.</p> <h3 id="unroll-and-jam-revisited"><a href="#unroll-and-jam-revisited">Unroll and Jam, Revisited</a></h3> <p>The idea here is to perform the largest scalar loads Rust offers where possible. The strategy is again unroll and jam: perform <code class="language-plaintext highlighter-rouge">u128</code> loads in a loop and deal with the remainder separately.</p> <p>The hot part looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'A'</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>

<span class="c1">// Load a bunch of big 16-byte chunks. LLVM will lower these to XMM loads.</span>
<span class="k">let</span> <span class="n">ascii_ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">write_at</span> <span class="o">=</span> <span class="n">ascii_ptr</span><span class="p">;</span>
<span class="k">if</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">16</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">/</span> <span class="mi">16</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">write_at</span> <span class="o">=</span> <span class="n">write_at</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">word</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="nf">.read_unaligned</span><span class="p">();</span>
      <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The cold part seems hard to optimize at first. What’s the least number of unaligned loads you need to do to load 15 bytes from memory? It’s two! You can load a <code class="language-plaintext highlighter-rouge">u64</code> from <code class="language-plaintext highlighter-rouge">p</code>, and then another one from <code class="language-plaintext highlighter-rouge">p + 7</code>; these loads (call them <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>) overlap by one byte, but we can or them together to merge that byte, so our loaded value is <code class="language-plaintext highlighter-rouge">a as u128 | (b as u128 &lt;&lt; 56)</code>.</p> <p>A similar trick works if the data to load is between a <code class="language-plaintext highlighter-rouge">u32</code> and a <code class="language-plaintext highlighter-rouge">u64</code>. Finally, to load 1, 2, or 3 bytes, we can load <code class="language-plaintext highlighter-rouge">p</code>, <code class="language-plaintext highlighter-rouge">p + len/2</code> and <code class="language-plaintext highlighter-rouge">p + len-1</code>; depending on whether <code class="language-plaintext highlighter-rouge">len</code> is 1, 2, or 3, this will potentially load the same byte multiple times; however, this reduces the number of branches necessary, since we don’t need to distinguish the 1, 2, or 3 lines.</p> <p>This is the kind of code that’s probably easier to read than to explain.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.offset</span><span class="p">(</span><span class="n">write_at</span><span class="nf">.offset_from</span><span class="p">(</span><span class="n">ascii_ptr</span><span class="p">));</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>

  <span class="k">if</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">8</span> <span class="p">{</span>
    <span class="c1">// Load two overlapping u64s.</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u128</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">16</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u128</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="c1">// Load two overlapping u32s.</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.read_unaligned</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u64</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">8</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Load 3 overlapping u8s.</span>

    <span class="c1">// For len       1       2       3     ...</span>
    <span class="c1">// ... this is  ptr[0]  ptr[0]  ptr[0]</span>
    <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="c1">// ... this is  ptr[0]  ptr[1]  ptr[1]</span>
    <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="c1">// ... this is  ptr[0]  ptr[1]  ptr[2]</span>
    <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">lo</span> <span class="p">|</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="p">|</span> <span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">u32</span><span class="p">::</span><span class="nf">from_ne_bytes</span><span class="p">([</span><span class="sc">b'A'</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">write_at</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.write_unaligned</span><span class="p">(</span><span class="n">data</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I learned this type of loading code while contributing to Abseil: it’s very useful for loading variable-length data for data-hungry algorithms, like a codec or a hash function.</p> <p>Here’s the same benchmark again, but with our new loading code.</p> <p><img src="https://mcyoung.xyz/public/images/simd-b64/graph.png" alt="a performance graph; our code is even better and the variance is very tight"/></p> <p>The results are really, really good. The variance is super tight, and our performance is 2x that of the baseline pretty much everywhere. <em>Success.</em></p> <h3 id="encoding-web-safe"><a href="#encoding-web-safe">Encoding? Web-Safe?</a></h3> <p>Writing an encoding function is simple enough: first, implement an <code class="language-plaintext highlighter-rouge">encode_hot()</code> function that reverses the operations from <code class="language-plaintext highlighter-rouge">decode_hot()</code>. The perfect hash from before won’t work, so you’ll need to <a href="https://github.com/mcy/vb64/blob/main/src/simd.rs#L170">invent a new one</a>.</p> <p>Also, the loading/storing code around the encoder is slightly different, too. <code class="language-plaintext highlighter-rouge">vb64</code> implements a very efficient encoding routine too, so I suggest taking a look at the source code if you’re interested.</p> <p>There is a base64 variant called web-safe base64, that replaces the <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">/</code> characters with <code class="language-plaintext highlighter-rouge">-</code> and <code class="language-plaintext highlighter-rouge">_</code>. Building a perfect hash for these is trickier: you would probably have to do something like <code class="language-plaintext highlighter-rouge">(byte &gt;&gt; 4) - (byte == '_' ? '_' : 0)</code>. I don’t support web-safe base64 yet, but only because I haven’t gotten around to it.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>My library doesn’t really solve an important problem; base64 decoding isn’t a bottleneck… anywhere that I know of, really. But writing SIMD code is really fun! Writing branchless code is often overkill but can give you a good appreciation for what your compilers can and <em>can’t</em> do for you.</p> <p>This project was also an excuse to try <code class="language-plaintext highlighter-rouge">std::simd</code>. I think it’s great overall, and generates excellent code. There’s some rough edges I’d like to see fixed to make SIMD code even simpler, but overall I’m very happy with the work that’s been done there.</p> <p>This is probably one of the most complicated posts I’ve written in a long time. SIMD (and performance in general) is a complex topic that requires a breadth of knowledge of tricks and hardware, a lot of which isn’t written down. More of it is written down now, though.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:shifts-are-arithmetic" role="doc-endnote"> <p>Shifts are better understood as arithmetic. They have a lane width, and closely approximate multiplication and division. AVX2 doesn’t even have vector shift <em>or</em> vector division: you emulate it with multiplication. <a href="#fnref:shifts-are-arithmetic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:minus-true" role="doc-endnote"> <p>The two common representations of <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code>, i.e. <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">0xff...</code> and <code class="language-plaintext highlighter-rouge">0</code>, are related by the two’s complement operation.</p> <p>For example, if I write <code class="language-plaintext highlighter-rouge">uint32_t m = -(a == b);</code>, <code class="language-plaintext highlighter-rouge">m</code> will be zero if <code class="language-plaintext highlighter-rouge">a == b</code> is false, and all-ones otherwise. This because applying any arithmetic operation to a <code class="language-plaintext highlighter-rouge">bool</code> promotes it to <code class="language-plaintext highlighter-rouge">int</code>, so <code class="language-plaintext highlighter-rouge">false</code> maps to <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">true</code> maps to <code class="language-plaintext highlighter-rouge">1</code>. Applying the <code class="language-plaintext highlighter-rouge">-</code> sends <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">-1</code>, and it’s useful to know that in two’s complement, <code class="language-plaintext highlighter-rouge">-1</code> is represented as all-ones.</p> <p>The all-ones representation for <code class="language-plaintext highlighter-rouge">true</code> is useful, because it can be used to implement branchless select very easily. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">select_if_eq</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This function returns <code class="language-plaintext highlighter-rouge">x</code> if <code class="language-plaintext highlighter-rouge">a == b</code>, and <code class="language-plaintext highlighter-rouge">y</code> otherwise. Can you tell why? <a href="#fnref:minus-true" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:abi" role="doc-endnote"> <p>Target features also affect ABI in subtle ways that I could write many, many more words on. Compiling libraries you plan to distribute with weird target feature flags is a recipe for disaster. <a href="#fnref:abi" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:why-cant-llvm-do-it" role="doc-endnote"> <p>Why can’t we leave this kind of thing to LLVM? Finding this particular branchless implementation is tricky. LLVM is smart enough to fold the match into a switch table, but that’s unnecessary memory traffic to look at the table. (In this domain, unnecessary memory traffic makes our code slower.)</p> <p>Incidentally, with the code I wrote for the original <code class="language-plaintext highlighter-rouge">decoded_len()</code>, LLVM produces a jump <em>and</em> a lookup table, which is definitely an odd choice? I went down something of a rabbit-hole. https://github.com/rust-lang/rust/issues/118306</p> <p>As for getting LLVM to find the “branchless” version of the lookup table? The search space is quite large, and this kind of “general strength reduction” problem is fairly open (keywords: “superoptimizers”). <a href="#fnref:why-cant-llvm-do-it" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:pad-with-A" role="doc-endnote"> <p>To be clear on why this works: suppose that in our reference implementation, we only handle inputs that are a multiple-of-4 length, and are padded with <code class="language-plaintext highlighter-rouge">=</code> as necessary, and we treat <code class="language-plaintext highlighter-rouge">=</code> as zero in the <code class="language-plaintext highlighter-rouge">match</code>. Then, for the purposes of computing the <code class="language-plaintext highlighter-rouge">bytes</code> value (before appending it to <code class="language-plaintext highlighter-rouge">out</code>), we can assume the chunk length is always 4. <a href="#fnref:pad-with-A" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:macros" role="doc-endnote"> <p>See <a href="https://github.com/mcy/vb64/blob/ed75566393a25d174a2766c3f8947d9c6a506315/src/util.rs"><code class="language-plaintext highlighter-rouge">vb64/src/util.rs</code></a>. <a href="#fnref:macros" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="rust"/><category term="optimization"/><summary type="html"><![CDATA[Another explainer on a fun, esoteric topic: optimizing code with SIMD (single instruction multiple data, also sometimes called vectorization). Designing a good, fast, portable SIMD algorithm is not a simple matter and requires thinking a little bit like a circuit designer.]]></summary></entry><entry><title type="html">What is a Matrix? A Miserable Pile of Coefficients!</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2023/09/29/what-is-a-matrix/" rel="alternate" type="text/html" title="What is a Matrix? A Miserable Pile of Coefficients!"/><published>2023-09-29T00:00:00-04:00</published><updated>2023-09-29T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2023/09/29/what-is-a-matrix</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2023/09/29/what-is-a-matrix/"><![CDATA[<p>Linear algebra is undoubtedly the most useful field in all of algebra. It finds applications in all kinds of science and engineering, like quantum mechanics, graphics programming, and machine learning. It is the “most well-behaved” algebraic theory, in that other abstract algebra topics often try to approximate linear algebra, when possible.</p> <p>For many students, linear algebra means vectors and matrices and determinants, and complex formulas for computing them. Matrices, in particular, come equipped with a fairly complicated, and <em>a fortiori</em> convoluted, multiplication operation.</p> <p>This is not the only way to teach linear algebra, of course. Matrices and their multiplication appear complicated, but actually are a natural and compact way to represent a particular type of <em>function</em>, i.e., a linear map (or linear transformation).</p> <p>This article is a short introduction to viewing linear algebra from the perspective of abstract algebra, from which matrices arise as a computational tool, rather than an object of study in and of themselves. I do assume some degree of familiarity with the idea of a matrix.</p> <h2 id="linear-spaces"><a href="#linear-spaces">Linear Spaces</a></h2> <p>Most linear algebra courses open with a description of vectors in Euclidean space: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>. Vectors there are defined as tuples of real numbers that can be added, multiplied, and scaled. Two vectors can be combined into a number through the dot product. Vectors come equipped with a notion of magnitude and direction.</p> <p>However, this highly geometric picture can be counterproductive, since it is hard to apply geometric intuition directly to higher dimensions. It also obscures how this connects to working over a different number system, like the complex numbers.</p> <p>Instead, I’d like to open with the concept of a <em>linear space</em>, which is somewhat more abstract than a vector space<sup id="fnref:vs-in-generality" role="doc-noteref"><a href="#fn:vs-in-generality" class="footnote" rel="footnote">1</a></sup>.</p> <p>First, we will need a notion of a “coefficient”, which is essentially something that you can do arithmetic with. We will draw coefficients from a designated <em>ground field</em> <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>. A field is a setting for doing arithmetic: a set of objects that can be added, subtracted, and multiplied, and divided in the “usual fashion” along with special <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span> values. E.g. <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + 0 = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>a</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">1a = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>b</mi><mo>+</mo><mi>a</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">a(b + c) = ab + ac</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span></span></span></span></span>, and so on.</p> <p>Not only are the real numbers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> a field, but so are the complex numbers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span></span>, and the rational numbers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">Q</span></span></span></span></span>. If we drop the “division” requirement, we can also include the integers <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span></span>, or polynomials with rational coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Q[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span>, for example.</p> <p>Having chosen our coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>, a linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> <em>over</em> <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> is another set of objects that can be added and subtracted (and including a special value <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span>)<sup id="fnref:ab-group" role="doc-noteref"><a href="#fn:ab-group" class="footnote" rel="footnote">2</a></sup>, along with a <em>scaling operation</em>, which takes a coefficient <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> and one of our objects <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> and produces a new <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">cv \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <p>The important part of the scaling operation is that it’s compatible with addition: if we have <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">a, b \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v, w \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we require that</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>v</mi><mo>+</mo><mi>a</mi><mi>w</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mi>v</mi><mo>=</mo><mi>a</mi><mi>v</mi><mo>+</mo><mi>b</mi><mi>v</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}a (v + w) = av + aw \\ (a + b) v = av + bv\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>This is what makes a linear space “linear”: you can write equations that look like first-degree polynomials (e.g. <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">ax + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span>), and which can be <em>manipulated like first-degree polynomials</em>.</p> <p>These polynomials are called linear because their graph looks like a line. There’s no multiplication, so we can’t have <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>, but we do have multiplication by a coefficient. This is what makes linear algebra is “linear”.</p> <p>Some examples: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>-tuples of elements drawn from any field are a linear space over that field, by componentwise addition and scalar multiplication; e.g., <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">R^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>. Setting <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span> shows that every field is a linear space over itself.</p> <p>Polynomials in one variable over some field, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span>, are also a linear space, since polynomials can be added together and scaled by a any value in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> (since lone coefficients are degree zero polynomials). Real-valued functions also form a linear space over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> in a similar way.</p> <h3 id="linear-transformations"><a href="#linear-transformations">Linear Transformations</a></h3> <p>A linear map is a function <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> between two linear spaces <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> which “respects” the linear structure in a particular way. That is, for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c\in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v, w \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>,</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>⋅</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}f(v + w) = f(v) + f(w) \\ f(cv) = c \cdot f(v)\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>We call this type of relationship (respecting addition and scaling) “linearity”. One way to think of this relationship is that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> is kind of like a different kind of coefficient, in that it distributes over addition, which commutes with the “ordinary” coefficients from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>. However, applying <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> produces a value from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> rather than <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <p>Another way to think of it is that if we have a linear polynomial like <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">p(x) = ax + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span> in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, then <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(p(x)) = p(f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></span>. We say that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> <em>commutes</em> with all linear polynomials.</p> <p>The most obvious sort of linear map is scaling. Given any coefficient <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>, it defines a “scaling map”:</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>μ</mi><mi>c</mi></msub><mo>:</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>v</mi><mo>↦</mo><mi>c</mi><mi>v</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}\mu_c: V \to V \\ v \mapsto cv\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>It’s trivial to check this is a linear map, by plugging it into the above equations: it’s linear because scaling is distributive and commutative.</p> <p>Linear maps are the essential thing we study in linear algebra, since they describe all the different kinds of relationships between linear spaces.</p> <p>Some linear maps are complicated. For example, a function from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup><mo>→</mo><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\R^2 \to \R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> that rotates the plane by some angle <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span> is linear, as are operations that stretch or shear the plane. However, they can’t “bend” or “fold” the plane: they are all fairly rigid motions. In the linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Q[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span> of rational polynomials, multiplication by <em>any</em> polynomial, such as <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> or <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^2 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>, is a linear map. The notion of “linear map” depends heavily on the space we’re in.</p> <p>Unfortunately, linear maps as they are quite opaque, and do not lend themselves well to calculation. However, we can build an explicit representation using a <em>linear basis</em>.</p> <h2 id="linear-basis"><a href="#linear-basis">Linear Basis</a></h2> <p>For any linear space, we can construct a relatively small of elements such that any element of the space can be expressed as some linear function of these elements.</p> <p>Explicitly, for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we can construct a sequence<sup id="fnref:indices" role="doc-noteref"><a href="#fn:indices" class="footnote" rel="footnote">3</a></sup> <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> such that for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we can find <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">c_i \in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> such that</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">v = \sum_i c_i e_i.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>Such a set <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is called a <em>basis</em> if it is linearly independent: no one <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> can be expressed as a linear function of the rest. The <em>dimension</em> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, denoted <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\dim V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, is the number of elements in any choice of basis. This value does not depend on the choice of basis<sup id="fnref:invariant-dim" role="doc-noteref"><a href="#fn:invariant-dim" class="footnote" rel="footnote">4</a></sup>.</p> <p>Constructing a basis for any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> is easy: we can do this recursively. First, pick a random element <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, and define a new linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> where we have identified all elements that differ by a factor of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> as equal (i.e., if <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>−</mo><mi>w</mi><mo>=</mo><mi>c</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v - w = ce_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, we treat <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></span> as equal in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>).</p> <p>Then, a basis for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> is a basis of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> with <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> added. The construction of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V/e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is essentially “collapsing” the dimension <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> “points” in, giving us a new space where we’ve “deleted” all of the elements that have a nonzero <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> component.</p> <p>However, this only works when the dimension is finite; more complex methods must be used for infinite-dimensional spaces. For example, the polynomials <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Q[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></span> are an infinite-dimensional space, with basis elements <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace linebreak="newline"></mspace><mrow><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mn>2</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>3</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\\{1, x, x^2, x^3, ...\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">…</span><span class="mspace newline"></span></span></span></span></span></span>. In general, for any linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, it <em>is</em> always possible to arbitrarily choose a basis, although it may be infinite<sup id="fnref:rq" role="doc-noteref"><a href="#fn:rq" class="footnote" rel="footnote">5</a></sup>.</p> <p>Bases are useful because they give us a concrete representation of any element of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>. Given a fixed basis <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, we can represent any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w = \sum_i c_i e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> by the coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> themselves. For a finite-dimensional <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, this brings us back <em>column vectors</em>: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>dim</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\dim V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></span>-tuples of coefficients from <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> that are added and scaled componentwise.</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>0</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mtext> </mtext><mo><munder><mo><mo>:</mo><mo>=</mo></mo><mrow><mtext>given </mtext><msub><mi>e</mi><mi>i</mi></msub></mrow></munder></mo><mtext> </mtext><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Mat{c_0 \\ c_1 \\ \vdots \\ c_n} \,\underset{\text{given } e_i}{:=}\, \sum_i c_i e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3665em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">given </span></span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">:=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8696em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>The <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>th basis element is represented as the vector whose entries are all <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> except for the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>th one, which is <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>. E.g.,</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mtext> </mtext><mo><munder><mo><mo>=</mo></mo><mrow><mtext>given </mtext><msub><mi>e</mi><mi>i</mi></msub></mrow></munder></mo><mtext> </mtext><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mtext> </mtext><mo><munder><mo><mo>=</mo></mo><mrow><mtext>given </mtext><msub><mi>e</mi><mi>i</mi></msub></mrow></munder></mo><mtext> </mtext><msub><mi>e</mi><mn>2</mn></msub><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Mat{1 \\ 0 \\ \vdots \\ 0} \,\underset{\text{given } e_i}{=}\, e_1, \,\,\, \Mat{0 \\ 1 \\ \vdots \\ 0} \,\underset{\text{given } e_i}{=}\, e_2, \,\,\, ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3665em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">given </span></span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8696em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3665em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">given </span></span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8696em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>It is important to recall that the choice of basis is <em>arbitrary</em>. From the mathematical perspective, any basis is just as good as any other, although some may be more computationally convenient.</p> <p>Over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> are sometimes called the “standard basis”, but <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mo>−</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3, -4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> are also a basis for this space. One easy mistake to make, particularly when working over the tuple space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">K^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>, is to confuse the actual elements of the linear space with the coefficient vectors that represent them. Working with abstract linear spaces eliminates this source of confusion.</p> <h3 id="representing-linear-transformations"><a href="#representing-linear-transformations">Representing Linear Transformations</a></h3> <p>Working with finite-dimensional linear spaces <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span>, let’s choose bases <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> for them, and let’s consider a linear map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span>.</p> <p>The powerful thing about bases is that we can more compactly express the information content of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>. Given any <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, we can decompose it into a linear function of the basis (for some coefficients), so we can write</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mi>f</mi><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>c</mi><mi>i</mi></msub><mo>⋅</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v) = f\left(\sum_i c_i e_i\right) = \sum_i f(c_i e_i) = \sum_i c_i \cdot f(e_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0277em;vertical-align:-1.2777em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>In other words, to specify <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>, we <em>only</em> need to specify what it does to each of the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\dim V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> basis elements. But what’s more, because <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> also has a basis, we can write</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">f(e_i) = \sum_j A_{ij} d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4638em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>Putting these two formulas together, we have an explicit closed form for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>, given the coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>, and the coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>:</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">f(v) = \sum_{i,j} c_i A_{ij} d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4638em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>Alternatively, we can express <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> as column vectors, and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> as the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> matrix with entires <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>. The entries of the resulting column vector are given by the above explicit formula for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>, fixing the value of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span> in each entry.</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><munder><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mi>n</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mi>n</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>0</mn><mo separator="true">,</mo><mi>m</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>m</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>A</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo stretchy="true">⏟</mo></munder><mi>A</mi></munder><mtext> </mtext><munder><munder><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>0</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>c</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo stretchy="true">⏟</mo></munder><mi>v</mi></munder><mo>=</mo><munder><munder><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo stretchy="true">⏟</mo></munder><mrow><mi>A</mi><mi>v</mi></mrow></munder></mrow><annotation encoding="application/x-tex">\underbrace{\Mat{ A_{0,0} &amp; A_{1,0} &amp; \cdots &amp; A_{n,0} \\ A_{1,0} &amp; A_{1,1} &amp; \cdots &amp; A_{n,1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ A_{0,m} &amp; A_{1,m} &amp; \cdots &amp; A_{n,m} }}_A \, \underbrace{\Mat{c_0 \\ c_1 \\ \vdots \\ c_n}}_v = \underbrace{\Mat{ \sum_i c_i A_{i,0} \\ \sum_i c_i A_{i,1} \\ \vdots \\ \sum_i c_i A_{i,m} }}_{Av}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.7863em;vertical-align:-3.8063em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-1.1737em;"><span class="pstrut" style="height:4.98em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span class="svg-align" style="top:-1.852em;"><span class="pstrut" style="height:4.98em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7 -331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214 c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0 -5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237 -174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.38em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.128em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.8063em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-1.3506em;"><span class="pstrut" style="height:4.98em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span class="svg-align" style="top:-1.852em;"><span class="pstrut" style="height:4.98em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7 -331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214 c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0 -5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237 -174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.128em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.6294em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:6.7863em;vertical-align:-3.8063em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-1.1737em;"><span class="pstrut" style="height:4.98em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span class="svg-align" style="top:-1.852em;"><span class="pstrut" style="height:4.98em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7 -331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214 c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0 -5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237 -174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.128em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.8063em;"><span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>(Remember, this is all dependent on the choices of bases <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>!)</p> <p>Behold, we have derived the matrix-vector multiplication formula: the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>th entry of the result is the dot product of the vector and the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>th row of the matrix.</p> <p>But it is crucial to keep in mind that we had to choose bases <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> to be entitled to write down a matrix for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span>. The values of the coefficients depend on the choice of basis.</p> <p>If your linear space happens to be <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>, there is an “obvious” choice of basis, but not every linear space over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> is <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>! Importantly, the actual linear algebra <em>does not</em> change depending on the basis<sup id="fnref:similar" role="doc-noteref"><a href="#fn:similar" class="footnote" rel="footnote">6</a></sup>.</p> <h2 id="matrix-multiplication"><a href="#matrix-multiplication">Matrix Multiplication</a></h2> <p>So, where does matrix multiplication come from? An <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span><sup id="fnref:rc" role="doc-noteref"><a href="#fn:rc" class="footnote" rel="footnote">7</a></sup> matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> <em>represents</em> some linear map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span>, where <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\dim V = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>W</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\dim W = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>, and appropriate choices of basis (<span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>) have been made.</p> <p>Keeping in mind that linear maps are supreme over matrices, suppose we have a third linear space <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span>, and a map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">g: U \to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, and let <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>=</mo><mi>dim</mi><mo>⁡</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\ell = \dim U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span>. Choosing a basis <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">h_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span>, we can represent <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span> as a matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> of dimension <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\ell \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>.</p> <p>Then, we’d like for the matrix product <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> to be the same matrix we’d get from representing the composite map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">fg: U \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> as a matrix, using the aforementioned choices of bases for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> (the basis choice for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> should “cancel out”).</p> <p>Recall our formula for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> in terms of its matrix coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> and the coefficients of the input <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>, which we call <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>. We can produce a similar formula for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span></span>, giving it matrix coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, and coefficients <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> for <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span>. (I appologize for the number of indices and coefficients here.)</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><msub><mi>c</mi><mi>i</mi></msub><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></munder><msub><mi>b</mi><mi>k</mi></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub><msub><mi>e</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}f(v) &amp;= \sum_{i,j} c_i A_{ij} d_j \\ g(u) &amp;= \sum_{k,i} b_k B_{ki} e_i\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.552em;vertical-align:-2.526em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.026em;"><span style="top:-5.026em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span><span style="top:-2.2622em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.526em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.026em;"><span style="top:-5.026em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.2622em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.526em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>If we write <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(u))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">))</span></span></span></span></span>, then <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is the coefficient <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is multiplied by; i.e., we fix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>, and drop it from the summation: <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mi>k</mi></msub><msub><mi>b</mi><mi>k</mi></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_i = \sum_k b_k B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>.</p> <p>Substituting that into the above formula, we now have something like the following.</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><munder><mo>∑</mo><mi>k</mi></munder><msub><mi>b</mi><mi>k</mi></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><msub><mi>b</mi><mi>k</mi></msub><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub><mo fence="true">)</mo></mrow><msub><mi>d</mi><mi>j</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}f(g(u)) &amp;= \sum_{i,j} \sum_{k} b_k B_{ki} A_{ij} d_j \\ f(g(u)) &amp;= \sum_{k,j} b_k \left(\sum_{i} A_{ij} B_{ki} \right) d_j &amp;(\star)\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.252em;vertical-align:-2.876em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.376em;"><span style="top:-6.076em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">))</span></span></span><span style="top:-2.6122em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">))</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.876em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.376em;"><span style="top:-6.076em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.6122em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.876em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6122em;"><span style="top:-2.6122em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">⋆</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.876em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>In <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\star)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">⋆</span><span class="mclose">)</span></span></span></span></span>, we’ve rearranged things so that the sum in parenthesis is the <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span>th matrix coefficient of the composite <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">fg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span>. Because we wanted <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> to represent <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">fg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span>, it must be an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\ell \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> matrix whose entries are</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>B</mi><msub><mo stretchy="false">)</mo><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(AB)_{kj} = \sum_{i} A_{ij} B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p><em>This</em> is matrix multiplication. It arises naturally out of composition of linear maps. In this way, the matrix multiplication formula is not a definition, but a <em>theorem</em> of linear algebra!</p> <blockquote> <h4 id="theorem-matrix-multiplication"><a href="#theorem-matrix-multiplication">Theorem (Matrix Multiplication)</a></h4> <p>Given an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\ell \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>, both with coefficients in <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span>, then <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> is an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\ell \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">ℓ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> matrix with entires</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>B</mi><msub><mo stretchy="false">)</mo><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>B</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex"> (AB)_{kj} = \sum_{i} A_{ij} B_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> </blockquote> <p>If the matrix dimension is read as <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \to m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> instead of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>, the shape requirements are more obvious: two matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> can be multiplied together only when they represent a pair of maps <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U \to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <h3 id="other-consequences-and-conclusion"><a href="#other-consequences-and-conclusion">Other Consequences, and Conclusion</a></h3> <p>The identity matrix is an <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> matrix:</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">I_n = \Mat{ 1 \\ &amp; 1 \\ &amp;&amp; \ddots \\ &amp;&amp;&amp; 1 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.95em;"><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>We want it to be such that for any appropriately-sized matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>, it has <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mi>I</mi><mi>n</mi></msub><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">AI_n = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub><mi>B</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">I_n B = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>. Lifted up to linear maps, this means that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> should represent the identity map <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">V \to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>, when <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mi>V</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\dim V = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">dim</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>. This map sends each basis element <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> to itself, so the columns of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> should be the basis vectors, in order:</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>⋯</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\Mat{1 \\ 0 \\ \vdots \\ 0} \Mat{0 \\ 1 \\ \vdots \\ 0} \cdots \Mat{0 \\ 0 \\ \vdots \\ 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>If we shuffle the columns, we’ll get a <em>permutation matrix</em>, which shuffles the coefficients of a column vector. For example, consider this matrix.</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\Mat{ 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84 H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z M347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <p>This is similar to the identity, but we’ve swapped the first two columns. Thus, it will swap the first two coefficients of any column vector.</p> <p>Matrices may seem unintuitive when they’re introduced as a subject of study. Every student encountering matrices for the same time may ask “If they add componentwise, why don’t they multiply componentwise too?”</p> <p>However, approaching matrices as a computational and representational tool shows that the convoluted-looking matrix multiplication formula is a direct consequence of linearity.</p> <div class="codeblock"><div class="katex-dpy"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>⋅</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}f(v + w) = f(v) + f(w) \\ f(cv) = c \cdot f(v)\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></div><div class="codeblock-buttons"><div class="codeblock-button">Math</div></div></div> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:vs-in-generality" role="doc-endnote"> <p>In actual modern mathematics, the objects I describe are still called vector spaces, which I think generates unnecessary confusion in this case. “Linear space” is a bit more on the nose for what I’m going for. <a href="#fnref:vs-in-generality" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ab-group" role="doc-endnote"> <p>This type of structure (just the addition part) is also called an “abelian group”. <a href="#fnref:ab-group" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:indices" role="doc-endnote"> <p>Throughout <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></span>, and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> are indices in some unspecified but ordered indexing set, usually <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, ..., n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">…</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span></span>. I will not bother giving this index set a name. <a href="#fnref:indices" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:invariant-dim" role="doc-endnote"> <p>This is sometimes called the <a href="https://en.wikipedia.org/wiki/Dimension_theorem_for_vector_spaces"><em>dimension theorem</em></a>, which is somewhat tedious to prove. <a href="#fnref:invariant-dim" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rq" role="doc-endnote"> <p>An example of a messy infinite-dimensional basis is <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span> considered as linear space over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">Q</span></span></span></span></span> (in general, every field is a linear space over its subfields). The basis for this space essentially has to be “<span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>, and all irrational numbers” except if we include e.g. <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span> we can’t include <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>π</mi></mrow><annotation encoding="application/x-tex">e + \frac{1}{2}\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span>, which is a <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">Q</span></span></span></span></span>-linear combination of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span>.</p> <p>On the other hand, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span></span> is two-dimensional over <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></span>, with basis <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace linebreak="newline"></mspace><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\\{1, i\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace newline"></span></span></span></span></span></span>.</p> <p>Incidentally, this idea of “view a field <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> as a linear space over its subfield <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span>” is such a useful concept that it is called the “degree of the field extension <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">/</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">K/F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span>”, and given the symbol <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>K</mi><mo>:</mo><mi>F</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[K : F]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">]</span></span></span></span></span>.</p> <p>This, <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="double-struck">R</mi><mo>:</mo><mi mathvariant="double-struck">Q</mi><mo stretchy="false">]</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">[\R : \Q] = \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathbb">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="double-struck">C</mi><mo>:</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">[\C : \R] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathbb">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">R</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span>. <a href="#fnref:rq" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:similar" role="doc-endnote"> <p>You may recall from linear algebra class that two matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span> of the same shape are <em>similar</em> if there are two appropriately-sized square matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span> such that <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>A</mi><mi>R</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">SAR = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span>. These matrices <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span> and <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span> represent a <em>change of basis</em>, and indicate that the linear maps <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">A, B: V \to W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span> these matrices come from do “the same thing” to elements of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>.</p> <p>Over an algebraically closed field like <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span></span> (i.e. all polynomials have solutions), there is an even stronger way to capture the information content of a linear map via <a href="https://en.wikipedia.org/wiki/Jordan_normal_form"><em>Jordan canonicalization</em></a>, which takes any square matrix <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and produces an almost-diagonal square matrix that only depends on the eigenvalues of <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>, which is the same for similar matrices, and thus basis-independent. <a href="#fnref:similar" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rc" role="doc-endnote"> <p>Here, as always, matrix dimensions are given in RC (row-column) order. You can think of this as being “input dimension” to “output dimension”. <a href="#fnref:rc" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="math"/><summary type="html"><![CDATA[Linear algebra is undoubtedly the most useful field in all of algebra. It finds applications in all kinds of science and engineering, like quantum mechanics, graphics programming, and machine learning. It is the “most well-behaved” algebraic theory, in that other abstract algebra topics often try to approximate linear algebra, when possible.]]></summary></entry><entry><title type="html">I Wrote A String Type</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2023/08/09/yarns/" rel="alternate" type="text/html" title="I Wrote A String Type"/><published>2023-08-09T00:00:00-04:00</published><updated>2023-08-09T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2023/08/09/yarns</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2023/08/09/yarns/"><![CDATA[<p>I write compilers for fun. I can’t help it. Consequently, I also write a lot of parsers. In systems programming, it’s usually a good idea to try to share memory rather than reuse it, so as such my AST types tend to look like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">enum</span> <span class="n">Expr</span><span class="o">&lt;</span><span class="nv">'src</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">Int</span><span class="p">(</span><span class="nb">u32</span><span class="p">)</span>
  <span class="nf">Ident</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'src</span> <span class="nb">str</span><span class="p">),</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Whenever we parse an identifier, rather than copy its name into a fresh <code class="language-plaintext highlighter-rouge">String</code>, we borrow from the input source string. This avoids an extra allocation, an extra copy, and saves a word in the representation. Compilers can be memory-hungry, so it helps to pick a lean representation.</p> <p>Unfortunately, it’s not so easy for quoted strings. Most strings, like <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code>, are “literally” in the original source, like an identifier. But strings with escapes aren’t: <code class="language-plaintext highlighter-rouge">\n</code> is encoded in the source code with the bytes <code class="language-plaintext highlighter-rouge">[0x5c, 0x6e]</code>, but the actual “decoded” value of a string literal replaces each escape with a single <code class="language-plaintext highlighter-rouge">0x0a</code>.</p> <p>The usual solution is a <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code></a>. In the more common, escape-less verison, we can use <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code>, which avoids the extra allocation and copy, and in the escaped version, we decode the escapes into a <code class="language-plaintext highlighter-rouge">String</code> and wrap it in a <code class="language-plaintext highlighter-rouge">Cow::Owned</code>.</p> <p>For example, suppose that we’re writing a parser for a language that has quoted strings with escapes. The string <code class="language-plaintext highlighter-rouge">"all my jelly babies"</code> can be represented as a byte string that borrows the input source code, so we’d use the <code class="language-plaintext highlighter-rouge">Cow::Borrowed</code> variant. This is most strings in any language: escapes tend to be rare.</p> <p>For example, if we have the string <code class="language-plaintext highlighter-rouge">"not UTF-8 \xff"</code>, the actual byte string value is different from that in the source code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">// Bytes in the source.
hex:   6e 6f 74 20 55 54 46 2d 38 20 5c 78 66 66
ascii: n  o  t     U  T  F  -  8     \  x  f  f

// Bytes represented by the string.
hex:   6e 6f 74 20 55 54 46 2d 38 20 ff
ascii: n  o  t     U  T  F  -  8</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Escapes are relatively rare, so most strings processed by the parser do not need to pay for an allocation.</p> <p>However, we still pay for that extra word, since <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> is 24 bytes (unless otherwise specified, all byte counts assume a 64-bit system), which is eight more than our <code class="language-plaintext highlighter-rouge">&amp;str</code>. Even worse, this is bigger than the string data itself, which is 11 bytes.</p> <p>If most of your strings are small (which is not uncommon in an AST parser), you will wind up paying for significant overhead.</p> <p>Over the years I’ve implemented various optimized string types to deal with this use-case, in various contexts. I finally got around to putting all of the tricks I know into a library, which I call <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a>. It advertises the following nice properties.</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>I’d like to share how these properties are achieved through careful layout optimization.</p> <h2 id="assumptions"><a href="#assumptions">Assumptions</a></h2> <p>We’re going to start by stating assumptions about how our strings will be used:</p> <ol> <li>Most strings are not mutated most of the time.</li> <li>Most strings are small.</li> <li>Most strings are substrings.</li> </ol> <h3 id="most-strings-are-immutable"><a href="#most-strings-are-immutable">Most Strings are Immutable</a></h3> <p><code class="language-plaintext highlighter-rouge">String</code> is modeled after C++’s <code class="language-plaintext highlighter-rouge">std::string</code>, which is a growable buffer that implements amortized linear-time append. This means that if we are appending <code class="language-plaintext highlighter-rouge">n</code> bytes to the buffer, we only pay for <code class="language-plaintext highlighter-rouge">n</code> bytes of <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>This is a useful but often unnecessary property. For example, Go strings are immutable, and when building up a large string, you are expected to use <code class="language-plaintext highlighter-rouge">strings.Builder</code>, which is implemented as essentially a Rust <code class="language-plaintext highlighter-rouge">String</code>. Java also as a similar story for strings, which allows for highly compact representations of <code class="language-plaintext highlighter-rouge">java.lang.String</code>s.</p> <p>In Rust, this kind of immutable string is represented by a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>, which is eight bytes smaller than <code class="language-plaintext highlighter-rouge">String</code>. Converting from <code class="language-plaintext highlighter-rouge">String</code> to <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is just a call to <code class="language-plaintext highlighter-rouge">realloc()</code> to resize the underlying allocation (which is often cheap<sup id="fnref:size-classes" role="doc-noteref"><a href="#fn:size-classes" class="footnote" rel="footnote">1</a></sup>) from being <code class="language-plaintext highlighter-rouge">capacity</code> bytes long to <code class="language-plaintext highlighter-rouge">len</code> bytes long.</p> <p>Thus, this assumption means we only need to store a pointer and a length, which puts our memory footprint floor at 16 bytes.</p> <h3 id="most-strings-are-substrings"><a href="#most-strings-are-substrings">Most Strings are Substrings</a></h3> <p>Suppose again that we’re parsing some textual format. Many structural elements will be verbatim references into the textual input. Not only string literals without escapes, but also identifiers.</p> <p><code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> cannot hold borrowed data, because it will always instruct the allocator to free its pointer when it goes out of scope. <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>, as we saw above, allows us to handle maybe-owned data uniformly, but has a minimum 24 byte overhead. This can’t be made any smaller, because a <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> can contain a 24-byte <code class="language-plaintext highlighter-rouge">String</code> value.</p> <p>But, we don’t want to store a capacity. Can we avoid the extra word of overhead in <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>?</p> <h3 id="most-strings-are-small"><a href="#most-strings-are-small">Most Strings are Small</a></h3> <p>Consider a string that is not a substring but which is small. For example, when parsing a string literal like <code class="language-plaintext highlighter-rouge">"Hello, world!\n"</code>, the trailing <code class="language-plaintext highlighter-rouge">\n</code> (bytes <code class="language-plaintext highlighter-rouge">0x5c 0x6e</code>) must be replaced with a newline byte (<code class="language-plaintext highlighter-rouge">0x0a</code>). This means we must handle a tiny heap allocation, 14 bytes long, that is smaller than a <code class="language-plaintext highlighter-rouge">&amp;str</code> referring to it.</p> <p>This is worse for single character<sup id="fnref:character" role="doc-noteref"><a href="#fn:character" class="footnote" rel="footnote">2</a></sup> strings. The overhead for a <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> is large.</p> <ul> <li>The <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> struct itself has a pointer field (eight bytes), and a length field (also eight bytes). Spelled out to show all the stored bits, the length is <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0001</code>. That’s a lot of zeroes!</li> <li>The pointer itself points to a heap allocation, which will not be a single byte! Allocators are not in the business of handing out such small pieces of memory. Instead, the allocation is likely costing us another eight bytes!</li> </ul> <p>So, the string <code class="language-plaintext highlighter-rouge">"a"</code>, whose data is just a <em>single byte</em>, instead takes up 24 bytes of memory.</p> <p>It turns out that for really small strings we can avoid the allocation altogether, <em>and</em> make effective use of all those zeroes in the <code class="language-plaintext highlighter-rouge">len</code> field.</p> <h2 id="stealing-bits"><a href="#stealing-bits">Stealing Bits</a></h2> <p>Let’s say we want to stick to a budget of 16 bytes for our <code class="language-plaintext highlighter-rouge">Yarn</code> type. Is there any extra space left for data in a <code class="language-plaintext highlighter-rouge">(*mut u8, usize)</code> pair?</p> <p><em>*cracks Fermi estimation knuckles*</em></p> <p>A <code class="language-plaintext highlighter-rouge">usize</code> is 64 bits, which means that the length of an <code class="language-plaintext highlighter-rouge">&amp;str</code> can be anywhere from zero to 18446744073709551615, or around 18 exabytes. For reference, “hundreds of exabytes” is a reasonable ballpark guess for how much RAM exists in 2023 (consider: 4 billion smartphones with 4GB each). More practically, the largest quantity of RAM you can fit in a server blade is measured in terabytes (much more than your measly eight DIMs on your gaming rig).</p> <p>If we instead use one less bit, 63 bits, this halves the maximum representable memory to nine exabytes. If we take another, it’s now four exabytes. Much more memory than you will ever <em>ever</em> want to stick in a string. <a href="https://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia#Size_of_the_English_Wikipedia_database">Wikpedia asserts</a> that Wikimedia Commons contains around 428 terabytes of media (the articles’ text with history is a measly 10 TB).</p> <p>Ah, but you say you’re programming for a 32-bit machine (today, this likely means either a low-end mobile phone, an embedded micro controller, or WASM).</p> <p>On a 32-bit machine it’s a little bit harrier: Now <code class="language-plaintext highlighter-rouge">usize</code> is 32 bits, for a maximum string size of 4 gigabytes (if you remember the 32-bit era, this limit may sound familiar). “Gigabytes” is an amount of memory that you can actually imagine having in a string.</p> <p>Even then, 1 GB of memory (if we steal two bits) on a 32-bit machine is a lot of data. You can only have four strings that big in a single address space, and every 32-bit allocator in the universe will refuse to serve an allocation of that size. If your strings are comparable in size to the whole address space, you should build your own string type.</p> <p>The upshot is that every <code class="language-plaintext highlighter-rouge">&amp;str</code> contains two bits we can reasonably assume are not used. <em>Free real-estate.</em><sup id="fnref:isize" role="doc-noteref"><a href="#fn:isize" class="footnote" rel="footnote">3</a></sup></p> <h3 id="a-hand-written-niche-optimization"><a href="#a-hand-written-niche-optimization">A Hand-Written Niche Optimization</a></h3> <p>Rust has the concept of <em>niches</em>, or invalid bit-patterns of a particular type, which it uses for automatic layout optimization of <code class="language-plaintext highlighter-rouge">enum</code>s. For example, references cannot be null, so the pointer bit-pattern of <code class="language-plaintext highlighter-rouge">0x0000_0000_0000_0000</code> is never used; this bit-pattern is called a “niche”. Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">),</span>
  <span class="n">Second</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>An <code class="language-plaintext highlighter-rouge">enum</code> of this form will not need any “extra” space to store the value that discriminates between the two variants: if a <code class="language-plaintext highlighter-rouge">Foo</code>’s bits are all zero, it’s <code class="language-plaintext highlighter-rouge">Foo::Second</code>; otherwise it’s a <code class="language-plaintext highlighter-rouge">Foo::First</code> and the payload is formed from <code class="language-plaintext highlighter-rouge">Foo</code>’s bit-pattern. This, incidentally, is what makes <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code> a valid representation for a “nullable pinter”.</p> <p>There are more general forms of this: <code class="language-plaintext highlighter-rouge">bool</code> is represented as a single byte, of which two bit are valid; the other 254 potential bit-patterns are niches. In Recent versions of Rust, <code class="language-plaintext highlighter-rouge">RawFd</code> has a niche for the all-ones bit-pattern, since POSIX file descriptors are always non-negative <code class="language-plaintext highlighter-rouge">int</code>s.</p> <p>By stealing two bits off of the length, we have given ourselves four niches, which essentially means we’ll have a hand-written version of something like this <code class="language-plaintext highlighter-rouge">enum</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="n">Yarn</span> <span class="p">{</span>
  <span class="nf">First</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Second</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Third</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
  <span class="nf">Fourth</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">u62</span><span class="p">),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>For reasons that will become clear later, we will specifically steal the <em>high</em> bits of the length, so that to recover the length, we do two shifts<sup id="fnref:two-shifts" role="doc-noteref"><a href="#fn:two-shifts" class="footnote" rel="footnote">4</a></sup> to shift in two high zero bits. Here’s some code that actually implements this for the low level type our string type will be built on.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">,</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the kind back out.</span>
  <span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="k">as</span> <span class="nb">u8</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that I’ve made this type <code class="language-plaintext highlighter-rouge">Copy</code>, and some functions take it by value. This is for two reasons.</p> <ol> <li> <p>There is a type of <code class="language-plaintext highlighter-rouge">Yarn</code> that is itself <code class="language-plaintext highlighter-rouge">Copy</code>, although I’m not covering it in this article.</p> </li> <li> <p>It is a two-word struct, which means that on most architectures it is eligible to be passed in a pair of registers. Passing it by value in the low-level code helps promote keeping it in registers. This isn’t always possible, as we will see when we discuss “SSO”.</p> </li> </ol> <p>Let’s chose kind <code class="language-plaintext highlighter-rouge">0</code> to mean “this is borrowed data”, and kind <code class="language-plaintext highlighter-rouge">1</code> to be “this is heap-allocated data”. We can use this to remember whether we need to call a destructor.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">raw</span><span class="p">:</span> <span class="n">RawYarn</span><span class="p">,</span>
  <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">BORROWED</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">HEAP</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="c1">// SAFETY: initialized either from uniquely-owned data,</span>
      <span class="c1">// or borrowed data of lifetime 'a that outlives self.</span>
      <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_slice</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">HEAP</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">dropped</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
        <span class="c1">// SAFETY: This is just reconstituting the box we dismantled</span>
        <span class="c1">// in Yarn::owned().</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.as_mut_slice</span><span class="p">())</span>
      <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// Same thing as as_slice, basically. This is just to make</span>
    <span class="c1">// Box::from_raw() above typecheck.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This gives us a type that strongly resembles <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code> with only half of the bytes. We can even write code to extend the lifetime of a <code class="language-plaintext highlighter-rouge">Yarn</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Removes the bound lifetime from the yarn, allocating if</span>
  <span class="cd">/// necessary.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">immortalize</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">BORROWED</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.as_slice</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
      <span class="k">self</span> <span class="o">=</span> <span class="nn">Yarn</span><span class="p">::</span><span class="nf">owned</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// We need to be careful that we discard the old yarn, since its</span>
    <span class="c1">// destructor may run and delete the heap allocation we created</span>
    <span class="c1">// above.</span>
    <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">;</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
    <span class="nn">Yarn</span><span class="p">::</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">,</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The remaining two niches can be put to use for optimizing small strings.</p> <h2 id="small-string-optimization"><a href="#small-string-optimization">Small String Optimization</a></h2> <p>C++’s <code class="language-plaintext highlighter-rouge">std::string</code> also makes the “most strings are small” assumption. In the <code class="language-plaintext highlighter-rouge">libc++</code> implementation of the standard library, <code class="language-plaintext highlighter-rouge">std::string</code>s of up to 23 bytes never hit the heap!</p> <p>C++ implementations do this by using most of the pointer, length, and capacity fields as a storage buffer for small strings, the so-called “small string optimization” (SSO). In <code class="language-plaintext highlighter-rouge">libc++</code>, in SSO mode, a <code class="language-plaintext highlighter-rouge">std::string</code>’s length fits in one byte, so the other 23 bytes can be used as storage. The capacity isn’t stored at all: an SSO string always has a capacity of 23.</p> <p><code class="language-plaintext highlighter-rouge">RawYarn</code> still has another two niches, so let’s dedicate one to a “small” representation. In small mode, the kind will be 2, and only the 16th byte will be the length.</p> <p>This is why we used the two <em>high</em> bits of <code class="language-plaintext highlighter-rouge">len</code> for our scratch space: no matter what mode it’s in, we can easily extract these bits<sup id="fnref:big-endian" role="doc-noteref"><a href="#fn:big-endian" class="footnote" rel="footnote">5</a></sup>. Some of the existing <code class="language-plaintext highlighter-rouge">RawYarn</code> methods need to be updated, though.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">SMALL</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a length, and a pointer.</span>
  <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Extracts the slice out (regardless of kind).</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">adjust</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">SMALL</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.assume_init</span><span class="p">(),</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">adjust</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In the non-<code class="language-plaintext highlighter-rouge">SMALL</code> case, we shift twice as before, but in the <code class="language-plaintext highlighter-rouge">SMALL</code> case, we need to get the high byte of the <code class="language-plaintext highlighter-rouge">len</code> field, so we need to shift down by an additional <code class="language-plaintext highlighter-rouge">usize::BITS - 8</code>. No matter what we’ve scribbled on the low bytes of <code class="language-plaintext highlighter-rouge">len</code>, we will always get just the length this way.</p> <p>We also need to use a different pointer value depending on whether we’re in <code class="language-plaintext highlighter-rouge">SMALL</code> mode. This is why <code class="language-plaintext highlighter-rouge">as_slice</code> needs to take a reference argument, since the slice data may be <em>directly</em> in <code class="language-plaintext highlighter-rouge">self</code>!</p> <p>Also, <code class="language-plaintext highlighter-rouge">ptr</code> is a <code class="language-plaintext highlighter-rouge">MaybeUninit</code> now, which will become clear in the next code listing.</p> <p>We should also provide a way to construct small strings.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">SSO_LEN</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Create a new small yarn. `data` must be valid for `len` bytes</span>
  <span class="cd">/// and `len` must be smaller than `SSO_LEN`.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RawYarn</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span><span class="p">);</span>

    <span class="c1">// Create a yarn with an uninitialized pointer value (!!)</span>
    <span class="c1">// and a length whose high byte is packed with `small` and</span>
    <span class="c1">// `len`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">yarn</span> <span class="o">=</span> <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">uninit</span><span class="p">(),</span>
      <span class="n">len</span><span class="p">:</span> <span class="p">(</span><span class="n">SMALL</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span> <span class="p">|</span> <span class="n">len</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// Memcpy the data to the new yarn.</span>
    <span class="c1">// We write directly onto the `yarn` variable. We won't</span>
    <span class="c1">// overwrite the high-byte length because `len` will</span>
    <span class="c1">// never be &gt;= 16.</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">copy_nonoverlapping</span><span class="p">(</span>
      <span class="n">data</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="k">mut</span> <span class="n">yarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">RawYarn</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
      <span class="n">data</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="n">yarn</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The precise maximum size of an SSO string is a bit more subtle than what’s given above, but it captures the spirit. The <code class="language-plaintext highlighter-rouge">RawYarn::from_small</code> illustrates why the pointer value is hidden in a <code class="language-plaintext highlighter-rouge">MaybeUninit</code>: we’re above to overwrite it with garbage, and in that case it won’t be a pointer at all.</p> <p>We can update our public <code class="language-plaintext highlighter-rouge">Yarn</code> type to use the new small representation whenever possible.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">borrowed</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">BORROWED</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cd">/// Create a new yarn from owned data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">owned</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">())</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">HEAP</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>It’s also possible to construct a <code class="language-plaintext highlighter-rouge">Yarn</code> directly from a character now, too!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_char</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.encode_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>
    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(Note that we do not need to update <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code>; why?)</p> <p>What we have now is a maybe-owned string that does not require an allocation for small strings. However, we still have an extra niche…</p> <h2 id="string-constants"><a href="#string-constants">String Constants</a></h2> <p>String constants in Rust are interesting, because we can actually detect them at compile-time<sup id="fnref:leaks" role="doc-noteref"><a href="#fn:leaks" class="footnote" rel="footnote">6</a></sup>.</p> <p>We can use the last remaining niche, 3, to represent data that came from a string constant, which means that it does not need to be boxed to be immortalized.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">const</span> <span class="n">STATIC</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Yarn</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="cd">/// Create a new yarn from borrowed data.</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_static</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.as_ptr</span><span class="p">()</span><span class="nf">.cast_mut</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SSO_LEN</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_small</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="nn">RawYarn</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">STATIC</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span>
      <span class="n">_ph</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This function is identical to <code class="language-plaintext highlighter-rouge">Yarn::borrowed</code>, except that <code class="language-plaintext highlighter-rouge">data</code> most now have a static lifetime, and we pass <code class="language-plaintext highlighter-rouge">STATIC</code> to <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code>.</p> <p>Because of how we’ve written all of the prior code, this does not require any special support in <code class="language-plaintext highlighter-rouge">Yarn::immortalize()</code> or in the low-level <code class="language-plaintext highlighter-rouge">RawYarn</code> code.</p> <p>The actual <code class="language-plaintext highlighter-rouge">byteyarn</code> library provides a <code class="language-plaintext highlighter-rouge">yarn!()</code> macro that has the same syntax as <code class="language-plaintext highlighter-rouge">format!()</code>. This is the primary way in which yarns are created. It is has been carefully written so that <code class="language-plaintext highlighter-rouge">yarn!("this is a literal")</code> always produces a <code class="language-plaintext highlighter-rouge">STATIC</code> string, rather than a heap-allocated string.</p> <h2 id="an-extra-niche-as-a-treat"><a href="#an-extra-niche-as-a-treat">An extra niche, as a treat?</a></h2> <p>Unfortunately, because of how we’ve written it, <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is 24 bytes, a whole word larger than a <code class="language-plaintext highlighter-rouge">Yarn</code>. However, there’s still a little gap where we can fit the <code class="language-plaintext highlighter-rouge">None</code> variant. It turns out that because of how we’ve chosen the discriminants, <code class="language-plaintext highlighter-rouge">len</code> is zero if and only if it is an empty <code class="language-plaintext highlighter-rouge">BORROWED</code> string. But this is not the only zero: if the high byte is <code class="language-plaintext highlighter-rouge">0x80</code>, this is an empty <code class="language-plaintext highlighter-rouge">SMALL</code> string. If we simply require that no other empty string is ever constructed (by marking <code class="language-plaintext highlighter-rouge">RawYarn::from_raw_parts()</code> as unsafe and specifying it should not be passed a length of zero), we can guarantee that <code class="language-plaintext highlighter-rouge">len</code> is <em>never</em> zero.</p> <p>Thus, we can update <code class="language-plaintext highlighter-rouge">len</code> to be a <code class="language-plaintext highlighter-rouge">NonZeroUsize</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="n">ptr</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="n">NonZeroUsize</span><span class="p">,</span>  <span class="c1">// (!!)</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RawYarn</span> <span class="p">{</span>
  <span class="cd">/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span class="cd">/// a *nonzero* length, and a pointer.</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_raw_parts</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">SMALL</span><span class="p">);</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"no way you have a string that big"</span><span class="p">);</span>

    <span class="n">RawYarn</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">:</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
      <span class="n">len</span><span class="p">:</span> <span class="nn">NonZeroUsize</span><span class="p">::</span><span class="nf">new_unchecked</span><span class="p">(</span>
        <span class="p">(</span><span class="n">kind</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;</span> <span class="mi">0b11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nn">usize</span><span class="p">::</span><span class="n">BITS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="n">len</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is a type especially known to the Rust compiler to have a niche bit-pattern of all zeros, which allows <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> to be 16 bytes too. This also has the convenient property that the all zeros bit-pattern for <code class="language-plaintext highlighter-rouge">Option&lt;Yarn&gt;</code> is <code class="language-plaintext highlighter-rouge">None</code>.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>The <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code class="language-plaintext highlighter-rouge">byteyarn</code></a> blurb describes what we’ve built:</p> <blockquote> <p>A <code class="language-plaintext highlighter-rouge">Yarn</code> is a highly optimized string type that provides a number of useful properties over <code class="language-plaintext highlighter-rouge">String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code class="language-plaintext highlighter-rouge">Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code class="language-plaintext highlighter-rouge">'static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>There are, of course, some trade-offs. Not only do we need the assumptions we made originally to hold, but we also need to relatively care more about memory than cycle-count performance, since basic operations like reading the length of the string require more math (but no extra branching).</p> <p>The actual implementation of <code class="language-plaintext highlighter-rouge">Yarn</code> is a bit more complicated, partly to keep all of the low-level book-keeping in one place, and partly to offer an ergonomic API that makes <code class="language-plaintext highlighter-rouge">Yarn</code> into a mostly-drop-in replacement for <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code>.</p> <p>I hope this peek under the hood has given you a new appreciation for what can be achieved by clever layout-hacking.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:size-classes" role="doc-endnote"> <p>Allocators rarely serve you memory with precisely the size you asked for. Instead, they will have some notion of a “size class” that allows them to use more efficient allocation techniques, <a href="https://mcyoung.xyz//2022/06/07/alkyne-gc">which I have written about</a>.</p> <p>As a result, if the size change in a <code class="language-plaintext highlighter-rouge">realloc()</code> would not change the size class, it becomes a no-op, especially if the allocator can take advantage of the current-size information Rust provides it. <a href="#fnref:size-classes" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:character" role="doc-endnote"> <p>Here and henceforth “character” means “32-bit Unicode scalar”. <a href="#fnref:character" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:isize" role="doc-endnote"> <p>Now, you might also point out that Rust and C do not allow an allocation whose size is larger than the pointer offset type (<code class="language-plaintext highlighter-rouge">isize</code> and <code class="language-plaintext highlighter-rouge">ptrdiff_t</code>, respectively). In practice this means that the high bit is <em>always</em> zero according to the language’s own rules.</p> <p>This is true, but we need to steal two bits, and I wanted to demonstrate that this is an extremely reasonable desire. 64-bit integers are so comically large. <a href="#fnref:isize" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:two-shifts" role="doc-endnote"> <p>Interestingly, LLVM will compile <code class="language-plaintext highlighter-rouge">(x &lt;&lt; 2) &gt;&gt; 2</code> to</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">movabs</span> <span class="n">rax</span><span class="p">,</span><span class="mh">0x3fffffffffffffff</span>
<span class="n">and</span>    <span class="n">rax</span><span class="p">,</span><span class="n">rdi</span>
<span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>If we want to play the byte-for-byte game, this costs 14 bytes when encoded in the Intel variable-length encoding. You would think that two shifts would result in marginally smaller code, but no, since the input comes in in <code class="language-plaintext highlighter-rouge">rdi</code> and needs to wind up in <code class="language-plaintext highlighter-rouge">rax</code>.</p> <p>On RISC-V, though, it seems to decide that two shifts is in fact cheaper, and will even optimize <code class="language-plaintext highlighter-rouge">x &amp; 0x3fff_ffff_ffff_ffff</code> back into two shifts. <a href="#fnref:two-shifts" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:big-endian" role="doc-endnote"> <p>This only works on little endian. Thankfully all computers are little endian. <a href="#fnref:big-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:leaks" role="doc-endnote"> <p>Technically, a <code class="language-plaintext highlighter-rouge">&amp;'static str</code> may also point to leaked memory. For our purposes, there is no essential difference. <a href="#fnref:leaks" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="dark-arts"/><category term="pointers"/><category term="rust"/><summary type="html"><![CDATA[I write compilers for fun. I can’t help it. Consequently, I also write a lot of parsers. In systems programming, it’s usually a good idea to try to share memory rather than reuse it, so as such my AST types tend to look like this.]]></summary></entry><entry><title type="html">A Gentle Introduction to LLVM IR</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2023/08/01/llvm-ir/" rel="alternate" type="text/html" title="A Gentle Introduction to LLVM IR"/><published>2023-08-01T00:00:00-04:00</published><updated>2023-08-01T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2023/08/01/llvm-ir</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2023/08/01/llvm-ir/"><![CDATA[<p>The other day, I saw <a href="https://twitter.com/burntsushi5/status/1684204136571478021?s=20">this tweet</a>. In it, Andrew Gallant argues that reaching for LLVM IR, instead of assembly, is a useful tool for someone working on performance. Unfortunately, learning material on LLVM is usually aimed at compiler engineers, not generalist working programmers.</p> <p>Now, <em>I’m</em> a compiler engineer, so my answer is <em>of course</em> you should know your optimizer’s IR. But I do think there’s a legitimate reason to be able to read it, in the same way that being able to read assembly to understand what your processor is doing is a powerful tool. I wrote an <a href="https://mcyoung.xyz//2021/11/29/assembly-1">introduction to assembly</a> over a year ago (still have to finish the followups… 💀), which I recommend reading first.</p> <p>Learning LLVM IR is similar, but it helps you understand what your <em>compiler</em> is doing to create highly optimized code. LLVM IR is very popular, and as such well-documented and reasonably well-specified, to the point that we can just treat it as a slightly weird programming language.</p> <p>In this article, I want to dig into what LLVM IR <em>is</em> and how to read it.</p> <h2 id="whats-llvm-ir"><a href="#whats-llvm-ir">What’s LLVM IR?</a></h2> <p>“LLVM” is an umbrella name for a number of software components that can be used to build compilers. If you write performance-critical code, you’ve probably heard of it.</p> <p>Its flagship product is Clang, a high-end C/C++/Objective-C compiler. Clang follows the orthodox compiler architecture: a frontend that parses source code into an AST and lowers it into an <em>intermediate representation</em>, an “IR”; an optimizer (or “middle-end”) that transforms IR into better IR, and a backend that converts IR into machine code for a particular platform.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">                               optimizer (opt)
                                    ___
                                   |   v
          .c file  --&gt;  AST  --&gt;  LLVM IR  --&gt;  assembly
                    ^         ^             ^
                 parser    lowering    backend (llc)

         \____________________/  \_____________________/
             Clang Frontend                LLVM</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button"></div></div></div> <p>LLVM often also refers to just the optimizer and backend parts of Clang; this is can be thought of as a compiler for the “LLVM language” or “LLVM assembly”. Clang, and other language frontends like Rust, essentially compile to LLVM IR, which LLVM then compiles to machine code.</p> <p>LLVM IR is well documented and… <em>somewhat</em> stable, which makes it a very good compilation target, since language implementers can re-use the thousands of engineer hours poured into LLVM already. The source of truth for “what is LLVM IR?” is the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>.</p> <p>LLVM IR is also binary format (sometimes called “bitcode”), although we will be working exclusively with its text format (which uses the <code class="language-plaintext highlighter-rouge">.ll</code> extension).</p> <p>LLVM-targeting compilers will have debugging flags to make them emit IR instead of their final output. For Clang, this is e.g. <code class="language-plaintext highlighter-rouge">clang++ -S -emit-llvm foo.cc</code>, while for Rust this is <code class="language-plaintext highlighter-rouge">rustc --emit=llvm-ir foo.rs</code>. Godbolt will also respect these options and correctly display LLVM IR output.</p> <h2 id="back-to-basic-blocks"><a href="#back-to-basic-blocks">Back to Basic Blocks</a></h2> <p>LLVM IR can be quite intimidating to read, since it contains much more ancillary information than an assembly dump. Consider this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>If you click on the “Godbolt” widget, it will take you to a Godbolt that lowers it to LLVM IR. Most of that code is just metadata, but it’s really intimidating!</p> <p>Starting from compiler output will have a steep difficulty curve, because we have to face the full complexity of LLVM IR. For Rust, this will likely mean encountering exception-handling, which is how panics are implemented, and function attributes that forward Rust’s guarantees (e.g. non-null pointers) to LLVM.</p> <p>Instead, we’ll start by introducing the basic syntax of LLVM IR, and <em>then</em> we’ll tackle reading compiler output.</p> <h3 id="a-trivial-function"><a href="#a-trivial-function">A Trivial Function</a></h3> <p>The meat of LLVM IR is function definitions, introduced with a <code class="language-plaintext highlighter-rouge">define</code>. There is also <code class="language-plaintext highlighter-rouge">declare</code>, which has exactly the same purpose as a function without a body in C: it brings an external symbol into scope.</p> <p>For example, the following function takes no arguments and returns immediately:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_nothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The return type of the function (<code class="language-plaintext highlighter-rouge">void</code>) immediately follows the <code class="language-plaintext highlighter-rouge">define</code> keyword; the name of the function starts with an <code class="language-plaintext highlighter-rouge">@</code>, which introduces us to the concept of <em>sigils</em>: every user-defined symbol starts with a sigil, indicating what kind of symbol it is. <code class="language-plaintext highlighter-rouge">@</code> is used for global and functions: things you can take the address of (when used as a value, they are always <code class="language-plaintext highlighter-rouge">ptr</code>-typed).</p> <p>The body of a function resembles assembly: a list of labels and instructions. Unlike ordinary assembly, however, there are significant restrictions on the structure of these instructions.</p> <p>In this case, there is only one instruction: a <code class="language-plaintext highlighter-rouge">void</code>-typed return. Unlike most assembly languages, LLVM IR is strongly typed, and requires explicit type annotations almost everywhere.</p> <p>Here is another trivial function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@do_not_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">unreachable</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function will trigger undefined behavior upon being called: the <code class="language-plaintext highlighter-rouge">unreachable</code> instruction represents a codepath that the compiler can assume is never executed; this is unlike e.g. the unimplemented <code class="language-plaintext highlighter-rouge">ud2</code> instruction in x86, which is guaranteed to issue a fault.</p> <p>This is an important distinction between LLVM IR and an assembly language: some operations are explicitly left undefined to leave room for potential optimizations. For example, LLVM can reason that, because <code class="language-plaintext highlighter-rouge">@do_not_call</code> immediately triggers undefined behavior, all calls to <code class="language-plaintext highlighter-rouge">@do_not_call</code> are also unreachable (and propagate unreachability from there).</p> <h3 id="purely-scalar-code"><a href="#purely-scalar-code">Purely Scalar Code</a></h3> <p>Let’s start with basic functions that only operate on integers. Consider the following function, that squares a 32-bit integer:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function takes arguments and has multiple instructions.</p> <p>The argument is specified as <code class="language-plaintext highlighter-rouge">i32 %x</code>. Names a <code class="language-plaintext highlighter-rouge">%</code> sigil are sort of like local variables, but with some restrictions that make them more optimization-friendly; as we’ll see later, they’re not really “variable” at all. LLVM sometimes calls them <em>registers</em>; in a sense, LLVM IR is assembly for an abstract machine with an infinite number of registers. I’ll be calling <code class="language-plaintext highlighter-rouge">%</code>-prefixed names “registers” throughout this article.</p> <p><code class="language-plaintext highlighter-rouge">i32</code> is a primitive integer types. All integer types in LLVM are of the form <code class="language-plaintext highlighter-rouge">iN</code>, for any <code class="language-plaintext highlighter-rouge">N</code> (even non-multiples of eight). There are no signed or unsigned types; instead, instructions that care about signedness will specify which semantic they use.</p> <p>The first instruction is a <code class="language-plaintext highlighter-rouge">mul i32</code>, which multiples the two <code class="language-plaintext highlighter-rouge">i32</code> operands together, and returns a value; we assign this to the new register <code class="language-plaintext highlighter-rouge">%1</code><sup id="fnref:numeric-names" role="doc-noteref"><a href="#fn:numeric-names" class="footnote" rel="footnote">1</a></sup>. The next instruction returns this value.</p> <p>The other arithmetic operations have the names you expect: <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">shl</code> (shift left). There are two division and remainder instructions, signed (<code class="language-plaintext highlighter-rouge">sdiv</code>, <code class="language-plaintext highlighter-rouge">srem</code>) and unsigned (<code class="language-plaintext highlighter-rouge">udiv</code>, <code class="language-plaintext highlighter-rouge">urem</code>). There two shift right instructions, again signed (<code class="language-plaintext highlighter-rouge">ashr</code>) and unsigned (<code class="language-plaintext highlighter-rouge">lshr</code>).</p> <blockquote> <p>Exercise for the reader: why are <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">%</code>, and <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> the only operations with signed and unsigned versions?</p> </blockquote> <p>We can also convert from one integer type to another using <code class="language-plaintext highlighter-rouge">trunc</code>, <code class="language-plaintext highlighter-rouge">zext</code>, and <code class="language-plaintext highlighter-rouge">sext</code>, which truncate, zero-extend, and sign-extend, respectively (<code class="language-plaintext highlighter-rouge">sext</code> and <code class="language-plaintext highlighter-rouge">zext</code> are another signed/unsigned pair). For example, if we wanted the <code class="language-plaintext highlighter-rouge">square</code> function to never overflow, we could write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">sext</span> <span class="kt">i32</span> <span class="nv">%x</span> <span class="k">to</span> <span class="kt">i64</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%1</span><span class="p">,</span> <span class="nv">%1</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we cast <code class="language-plaintext highlighter-rouge">%x</code> to <code class="language-plaintext highlighter-rouge">i64</code> by sign-extension (since we’ve decided we’re squaring signed integers) and then square the result. <code class="language-plaintext highlighter-rouge">trunc</code> and <code class="language-plaintext highlighter-rouge">zext</code> both have the same syntax as <code class="language-plaintext highlighter-rouge">sext</code>.</p> <h3 id="ill-be-back"><a href="#ill-be-back">“I’ll Be Back”</a></h3> <p>Of course, interesting functions have <em>control flow</em>. Suppose we want a safe division function: division by zero is UB, so we need to handle it explicitly. Perhaps something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try doing this using <code class="language-plaintext highlighter-rouge">select</code>, LLVM’s “ternary” operation.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">select</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">-1</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%2</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>However, this has a problem: division by zero is UB<sup id="fnref:divz" role="doc-noteref"><a href="#fn:divz" class="footnote" rel="footnote">2</a></sup>, and <code class="language-plaintext highlighter-rouge">select</code> is not short-circuiting: its semantics are closer to that of <code class="language-plaintext highlighter-rouge">cmov</code> in x86.</p> <p>To compile this correctly, need to use the <code class="language-plaintext highlighter-rouge">br</code> instruction, which represents a general branch operation<sup id="fnref:br-on-real-machines" role="doc-noteref"><a href="#fn:br-on-real-machines" class="footnote" rel="footnote">3</a></sup>. In C terms, a <code class="language-plaintext highlighter-rouge">br i1 %cond, label %a, label %b</code> is equivalent to <code class="language-plaintext highlighter-rouge">if (cond) goto a; else goto b;</code>.</p> <p>This is how we might write that:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@safe_div</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%d</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%iszero</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%nonzero</span>

<span class="nl">iszero:</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="m">-1</span>

<span class="nl">nonzero:</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">udiv</span> <span class="kt">i64</span> <span class="nv">%n</span><span class="p">,</span> <span class="nv">%d</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Now our function has labels, which are used by the <code class="language-plaintext highlighter-rouge">br</code> instruction as jump targets.</p> <p>In the first block, we do the <code class="language-plaintext highlighter-rouge">d == 0</code> check, implemented by an <code class="language-plaintext highlighter-rouge">icmp eq</code> instruction. This returns an <code class="language-plaintext highlighter-rouge">i1</code> (the type LLVM uses for booleans). We then pass the result into a <code class="language-plaintext highlighter-rouge">br</code> instruction, which jumps to the first label if it’s zero, otherwise to the second if it isn’t.</p> <p>The second block is the early-return; it returns the “sentinel” value; the third block is self-explanatory.</p> <p>Each of these blocks is a “basic block”: a sequence of non-control flow operations, plus an instruction that moves control flow away from the block. These blocks form the control flow graph (CFG) of the function.</p> <p>There are a few other “block terminator” instructions. The one-argument form of <code class="language-plaintext highlighter-rouge">br</code> takes a single label, and is a simple unconditional <code class="language-plaintext highlighter-rouge">goto</code>. There’s also <code class="language-plaintext highlighter-rouge">switch</code>, which is similar to a C <code class="language-plaintext highlighter-rouge">switch</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">switch</span> <span class="kt">i32</span> <span class="nv">%value</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%default</span> <span class="p">[</span>
  <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_zero</span>
  <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if_one</span><span class="p">,</span>
  <span class="c1">; etc</span>
<span class="p">]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The type of the <code class="language-plaintext highlighter-rouge">switch</code> must be an integer type. Although you could represent this operation with a chain of <code class="language-plaintext highlighter-rouge">br</code>s, a separate <code class="language-plaintext highlighter-rouge">switch</code> instruction makes it easier for LLVM to generate jump tables.</p> <p><code class="language-plaintext highlighter-rouge">unreachable</code>, which we saw before, is a special terminator that does not trigger control flow per se, but which can terminate a block because reaching it is undefined behavior; it is equivalent to e.g. <code class="language-plaintext highlighter-rouge">std::unreachable()</code> in C++.</p> <blockquote> <h4 id="llvm-deleted-my-code"><a href="#llvm-deleted-my-code">LLVM Deleted My Code!</a></h4> <p>The <code class="language-plaintext highlighter-rouge">unreachable</code> instruction provides a good example of why LLVM uses a basic block CFG: a naive dead code elimination (DCE) optimization pass can be implemented as follows:</p> <ol> <li>Fill a set with every block that ends in <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>For every block, if its terminator references a block in the unreachable set, delete that label from the terminator. For example, if we have <code class="language-plaintext highlighter-rouge">br i1 %c, label %a, label %b</code>, and the unreachable set contains <code class="language-plaintext highlighter-rouge">%a</code>, we can replace this with a <code class="language-plaintext highlighter-rouge">br label %b</code>.</li> <li>If every outgoing edge from a block is deleted in (2), replace the terminator with <code class="language-plaintext highlighter-rouge">unreachable</code>.</li> <li>Delete all blocks in the unreachable set.</li> <li>Repeat from (1) as many times as desired.</li> </ol> <p>Intuitively, <code class="language-plaintext highlighter-rouge">unreachable</code>s bubble <em>upwards</em> in the CFG, dissolving parts of the CFG among them. Other passes can generate <code class="language-plaintext highlighter-rouge">unreachable</code>s to represent UB: interplay between this and DCE results in the “the compiler <em>will</em> delete your code” outcome from UB.</p> <p>The actual DCE pass is much more complicated, since function calls make it harder to decide if a block is “pure” and thus transparently deletable.</p> </blockquote> <p>But, what if we want to implement something more complicated, like <code class="language-plaintext highlighter-rouge">a / b + 1</code>? This expression needs the intermediate result, so we can’t use two return statements as before.</p> <p>Working around this is not so straightforward: if we try to assign the same register in different blocks, the IR verifier will complain. This brings us to the concept of static single assignment.</p> <h3 id="phony-phony"><a href="#phony-phony">Phony! Phony!</a></h3> <p>LLVM IR is a <em>static single assignment form</em> (SSA) IR. LLVM was actually started at the turn of the century to create a modern SSA optimizer as an academic project. These days, SSA is extremely fashionable for optimizing imperative code.</p> <p>SSA form means that every register is assigned by at most one instruction per function. Different executions of the same block in the same function may produce different values for particular registers, but we cannot <em>mutate</em> already-assigned registers.</p> <p>In other words:</p> <ol> <li>Every register is guaranteed to be initialized by a single expression.</li> <li>Every register depends only on the values of registers assigned before its definition.</li> </ol> <p>This has many useful properties for writing optimizations: for example, within a basic block, every use of a particular register <code class="language-plaintext highlighter-rouge">%x</code> always refers to the same value, which makes optimizations like <a href="https://en.wikipedia.org/wiki/Value_numbering">global value numbering</a> and constant-folding much simpler to write, since the state of a register throughout a block doesn’t need to be tracked separately.</p> <p>In SSA, we reinterpret mutation as many <em>versions</em> of a single variable. Thus, we might lower <code class="language-plaintext highlighter-rouge">x += y</code> as</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%x.1</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%x.0</span><span class="p">,</span> <span class="nv">%y.0</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Here, we’ve used a <code class="language-plaintext highlighter-rouge">var.n</code> convention to indicate which version of a variable a specific register represents (LLVM does not enforce any naming conventions).</p> <p>However, when loops enter the mix, it’s not clear how to manage versions. The number of registers in a function is static, but the number of loop iterations is dynamic.</p> <p>Concretely, how do we implement this function?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">y</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We could try something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>  <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>   <span class="c1">; ERROR: Recursive definition.</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>But there’s a problem! What are the original definitions of <code class="language-plaintext highlighter-rouge">%r</code> and <code class="language-plaintext highlighter-rouge">%i</code>? The IR verifier will complain that these registers depend directly on themselves, which violates SSA form. What’s the “right” way to implement this function?</p> <p>One option is to ask LLVM! We’ll implement the function poorly, and let the optimizer clean it up for us.</p> <p>First, let’s write the function using memory operations, like <code class="language-plaintext highlighter-rouge">load</code>s and <code class="language-plaintext highlighter-rouge">store</code>s, to implement mutation. We can use the <code class="language-plaintext highlighter-rouge">alloca</code> instruction to create statically-sized stack slots; these instructions return a <code class="language-plaintext highlighter-rouge">ptr</code>[^clang-codegen].</p> <blockquote> <h4 id="clang-makes-a-mess-llvm-cleans-it-up"><a href="#clang-makes-a-mess-llvm-cleans-it-up">Clang Makes a Mess, LLVM Cleans It Up</a></h4> <p>Incidentally, this is how Clang and Rust both generate LLVM IR: stack variables are turned into <code class="language-plaintext highlighter-rouge">alloca</code>s and manipulated through loads and stores; temporaries are mostly turned into <code class="language-plaintext highlighter-rouge">%regs</code>s, but the compiler will sometimes emit extra allocas to avoid thinking too hard about needing to create <code class="language-plaintext highlighter-rouge">phi</code> instructions.</p> <p>This is pretty convenient, because it avoids needing to think very hard about SSA form outside of LLVM, and LLVM can trivially eliminate unnecessary allocas. The code I wrote for the codegen of <code class="language-plaintext highlighter-rouge">@pow</code> is very similar to what Rust would send to LLVM (although because we used an iterator, there’s a lot of extra junk Rust emits that LLVM has to work to eliminate).</p> </blockquote> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">; Create slots for r and the index, and initialize them.</span>
  <span class="c1">; This is equivalent to something like</span>
  <span class="c1">;   int i = 0, r = 1;</span>
  <span class="c1">; in C.</span>
  <span class="nv">%r</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="nv">%i</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">i32</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="c1">; Load the index and check if it equals y.</span>
  <span class="nv">%i.check</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.check</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="c1">; r *= x</span>
  <span class="nv">%r.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.old</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%r.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>

  <span class="c1">; i += 1</span>
  <span class="nv">%i.old</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.old</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">store</span> <span class="kt">i32</span> <span class="nv">%i.new</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%i</span>

  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="nv">%r.ret</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%r</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.ret</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Next, we can pass this into the LLVM optimizer. The command <code class="language-plaintext highlighter-rouge">opt</code>, which is part of the LLVM distribution, runs specific optimizer passes on the IR. In our case, we want <code class="language-plaintext highlighter-rouge">opt -p mem2reg</code>, which runs a single “memory to register” pass. We can also just run <code class="language-plaintext highlighter-rouge">opt --O2</code> or similar to get similar<sup id="fnref:frontend-optimization" role="doc-noteref"><a href="#fn:frontend-optimization" class="footnote" rel="footnote">4</a></sup> optimizations to the ones <code class="language-plaintext highlighter-rouge">clang -O2</code> runs.</p> <p>This is the result.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; After running through `opt -p mem2reg`</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">loop_start:</span>
  <span class="nv">%i.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%i.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%r.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i32</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="nv">%start</span><span class="p">],</span> <span class="p">[</span><span class="nv">%r.new</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r.0</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop_start</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r.0</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">alloca</code>s are gone, but now we’re faced with a new instruction: <code class="language-plaintext highlighter-rouge">phi</code>. “φ node” is jargon from the original SSA paper; the greek letter φ means “phoney”. These instructions select a value from a list based on which basic block we jumped to the block from.</p> <p>For example, <code class="language-plaintext highlighter-rouge">phi i32 [0, %start], [%i.new, %loop]</code> says “this value should be 0 if we came from the <code class="language-plaintext highlighter-rouge">start</code> block; otherwise <code class="language-plaintext highlighter-rouge">%i.new</code> if it came from <code class="language-plaintext highlighter-rouge">%loop</code>”.</p> <p>Unlike all other instructions, <code class="language-plaintext highlighter-rouge">phi</code> can refer to values that are not defined in all blocks that dominate the current block. This lets us have a dynamic number of versions of a variable! Here’s what that looks like in a dynamic execution context.</p> <blockquote> <p>A block <code class="language-plaintext highlighter-rouge">%a</code> is said to dominate a block <code class="language-plaintext highlighter-rouge">%b</code> if each of its predecessors is either <code class="language-plaintext highlighter-rouge">%a</code> or a block dominated by <code class="language-plaintext highlighter-rouge">%a</code>. In other words, every path from the first block to <code class="language-plaintext highlighter-rouge">%b</code> passes through <code class="language-plaintext highlighter-rouge">%a</code>. In general instructions can only refer to values defined in previous instructions in the current block or values from blocks that dominate it.</p> </blockquote> <ol> <li> <p><code class="language-plaintext highlighter-rouge">%start</code> directly jumps into <code class="language-plaintext highlighter-rouge">%loop_start</code>. The first block cannot be a jump target, since it cannot have <code class="language-plaintext highlighter-rouge">phi</code> nodes because its predecessors include function’s callsite.</p> </li> <li> <p>In <code class="language-plaintext highlighter-rouge">%loop_start</code>, since we’ve entered from <code class="language-plaintext highlighter-rouge">%start</code>, <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are selected to be the first versions of the (platonic) <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code> variables, i.e., their initial values; we jump to <code class="language-plaintext highlighter-rouge">%loop</code>.</p> </li> <li> <p>Then, <code class="language-plaintext highlighter-rouge">%loop</code> is dominated by <code class="language-plaintext highlighter-rouge">%loop_start</code> so we can use <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> there directly; these are the <code class="language-plaintext highlighter-rouge">*=</code> and <code class="language-plaintext highlighter-rouge">+=</code> operations. Then we jump back to <code class="language-plaintext highlighter-rouge">%loop_start</code>.</p> </li> <li> <p>Back in <code class="language-plaintext highlighter-rouge">%loop_start</code>, the <code class="language-plaintext highlighter-rouge">phi</code>s now select <code class="language-plaintext highlighter-rouge">%i.new</code> and <code class="language-plaintext highlighter-rouge">%r.new</code>, so now <code class="language-plaintext highlighter-rouge">%i.0</code> and <code class="language-plaintext highlighter-rouge">%r.0</code> are the <em>second</em> versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>. By induction, the nth execution of <code class="language-plaintext highlighter-rouge">%loop_start</code> has the nth versions of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">r</code>.</p> </li> <li> <p>When we finally get sent to <code class="language-plaintext highlighter-rouge">%exit</code>, we can use <code class="language-plaintext highlighter-rouge">%r.0</code> (since <code class="language-plaintext highlighter-rouge">%loop_start</code> dominates <code class="language-plaintext highlighter-rouge">%r.0</code>), which will be the <code class="language-plaintext highlighter-rouge">%y</code>th version of <code class="language-plaintext highlighter-rouge">r</code>; this is our return value.</p> </li> </ol> <p>This is a good place to stop and think about what we’ve done so far. SSA, domination, and <code class="language-plaintext highlighter-rouge">phi</code>s can be hard to wrap your head around, and are not absolutely necessary for reading most IR. However, it is absolutely worth trying to understand, because it captures essential facts about how compilers like to reason about code<sup id="fnref:block-args" role="doc-noteref"><a href="#fn:block-args" class="footnote" rel="footnote">5</a></sup>.</p> <p>With <code class="language-plaintext highlighter-rouge">phi</code> and <code class="language-plaintext highlighter-rouge">br</code>, we can build arbitrarily complicated control flow within a function<sup id="fnref:viz" role="doc-noteref"><a href="#fn:viz" class="footnote" rel="footnote">6</a></sup>.</p> <h2 id="types-and-aggregates"><a href="#types-and-aggregates">Types and Aggregates</a></h2> <p>Now that we have basic scalar functions, let’s review LLVM’s type system.</p> <p>We’ve seen <code class="language-plaintext highlighter-rouge">i32</code> and its friends; these are arbitrary-bit-with integers. <code class="language-plaintext highlighter-rouge">i1</code> is special because it is used as the boolean type. LLVM optimizations have been known to generate integer types with non-power-of-two sizes.</p> <p>LLVM also has <code class="language-plaintext highlighter-rouge">float</code> and <code class="language-plaintext highlighter-rouge">double</code>, and some exotic float types like <code class="language-plaintext highlighter-rouge">bfloat</code>; these use their own arithmetic instructions with different options. I’ll pass on them in this explainer; see <code class="language-plaintext highlighter-rouge">fadd</code> and friends in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> for more.</p> <p>We’ve also seen <code class="language-plaintext highlighter-rouge">void</code>, which is only used as a return value, and <code class="language-plaintext highlighter-rouge">ptr</code>, which is an untyped<sup id="fnref:typed-pointers" role="doc-noteref"><a href="#fn:typed-pointers" class="footnote" rel="footnote">7</a></sup> pointer.</p> <p>We’ve also seen the <code class="language-plaintext highlighter-rouge">label</code> pseudo-type, which represents a block label. It does not appear directly at runtime and has limited uses; the <code class="language-plaintext highlighter-rouge">token</code> and <code class="language-plaintext highlighter-rouge">metadata</code> types are similar.</p> <p>Arrays are spelled <code class="language-plaintext highlighter-rouge">[n x T]</code>; the number must be an integer and the type must have a definite size. E.g., <code class="language-plaintext highlighter-rouge">[1024 x i8]</code>. Zero-sized arrays are supported.</p> <p>Structs are spelled <code class="language-plaintext highlighter-rouge">{T1, T2, ...}</code>. E.g., <code class="language-plaintext highlighter-rouge">{i64, ptr}</code> is a Rust slice. Struct fields do not have names and are indexed, instead. The form <code class="language-plaintext highlighter-rouge">&lt;{...}&gt;</code> is a <em>packed</em> struct, which removes inter-field padding. E.g. <code class="language-plaintext highlighter-rouge">#[repr(packed)]</code> compiles down to this.</p> <p>Vectors are like arrays but spelled <code class="language-plaintext highlighter-rouge">&lt;n x T&gt;</code>. These are used to represent types used in SIMD operations. For example, adding two <code class="language-plaintext highlighter-rouge">&lt;4 x i32&gt;</code> would lower to an AVX2 vector add on x86. I will not touch on SIMD stuff beyond this, although at higher optimization levels LLVM will merge scalar operations into vector operations, so you may come across them.</p> <p>Type aliases can be created at file scope with the syntax</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Slice</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This means that <code class="language-plaintext highlighter-rouge">%T</code> can be either a type or a register/label inside of a function, depending on syntactic position.</p> <h3 id="operations-on-aggregates"><a href="#operations-on-aggregates">Operations on Aggregates</a></h3> <p>The <code class="language-plaintext highlighter-rouge">insertvalue</code> and <code class="language-plaintext highlighter-rouge">extractvalue</code> can be used with struct or array types to statically access a field. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%MyStruct</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span><span class="kt">i32</span><span class="p">,</span> <span class="p">{[</span><span class="m">5</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">],</span> <span class="kt">i64</span><span class="p">}}</span>

<span class="c1">; In Rust-like syntax, this is `let v = s.1.0[4];`</span>
<span class="nv">%v</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><code class="language-plaintext highlighter-rouge">insertvalue</code> is the reverse: it produces a copy of the aggregate with a specific field changed. It <em>does not</em> mutate in-place, because SSA forbids that.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; In Rust-like syntax, this is</span>
<span class="c1">;   let s2 = { let mut s = s; s2.1.1 = 42; s };</span>
<span class="nv">%s2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%MyStruct</span> <span class="nv">%s</span><span class="p">,</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>There are similar operations called <code class="language-plaintext highlighter-rouge">insertelement</code> and <code class="language-plaintext highlighter-rouge">extractelement</code> work on vectors, but have slightly different syntax and semantics.</p> <p>Finally, there’s <code class="language-plaintext highlighter-rouge">getelementptr</code>, the “pointer arithmetic instruction”, often abbreviated to GEP. A GEP can be used to calculate an offset pointer into a struct. For example,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="err">ptr</span> <span class="vg">@get_inner_in_array</span><span class="p">(</span><span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%q</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%MyStruct</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%idx</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="err">ptr</span> <span class="nv">%q</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>This function takes in a pointer, ostensibly pointing to an array of <code class="language-plaintext highlighter-rouge">%MyStruct</code>s, and an index. This returns a pointer to the <code class="language-plaintext highlighter-rouge">i64</code> field of the <code class="language-plaintext highlighter-rouge">%idx</code>th element of <code class="language-plaintext highlighter-rouge">%p</code>.</p> <p>A few important differences between GEP and <code class="language-plaintext highlighter-rouge">extractvalue</code>:</p> <ol> <li>It takes an untyped pointer instead of a value of a particular struct/array type.</li> <li>There is an extra parameter that specifies an index; from the perspective of GEP, every pointer is a pointer to an array of unspecified bound. When operating on a pointer that does not (at runtime) point to an array, an index operand of <code class="language-plaintext highlighter-rouge">0</code> is still required. (Alternatively, you can view a pointer to <code class="language-plaintext highlighter-rouge">T</code> as being a pointer to a one-element array.)</li> <li>The index parameters need explicit types.</li> </ol> <p>LLVM provides a helpful<sup id="fnref:sarcasm" role="doc-noteref"><a href="#fn:sarcasm" class="footnote" rel="footnote">8</a></sup> FAQ on the GEP instruction: <a href="https://llvm.org/docs/GetElementPtr.html">https://llvm.org/docs/GetElementPtr.html</a>.</p> <h2 id="other-operations"><a href="#other-operations">Other Operations</a></h2> <p>Some other operations are very relevant for reading IR, but don’t fit into any specific category. As always, the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> provides a full description of what all of these instructions do.</p> <h3 id="function-calls"><a href="#function-calls">Function Calls</a></h3> <p><code class="language-plaintext highlighter-rouge">call</code>, which calls any <code class="language-plaintext highlighter-rouge">ptr</code> as a function. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; Arguments are passed in parentheses.</span>
<span class="nv">%r</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@my_func</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Note that this could have been a <code class="language-plaintext highlighter-rouge">%reg</code> instead of a <code class="language-plaintext highlighter-rouge">@global</code>, which indicates a function pointer call.</p> <p>Sometimes you will see <code class="language-plaintext highlighter-rouge">invoke</code>, which is used to implement “call a function inside of a C++ <code class="language-plaintext highlighter-rouge">try {}</code> block”. This is rare in Rust, but can occur in some C++ code.</p> <p>Function calls are often noisy areas of IR, because they will be very heavily annotated.</p> <h3 id="synchronization"><a href="#synchronization">Synchronization</a></h3> <p>The <code class="language-plaintext highlighter-rouge">load</code> and <code class="language-plaintext highlighter-rouge">store</code> instructions we’ve already seen can be annotated as <code class="language-plaintext highlighter-rouge">atomic</code>, which is used to implement e.g. <code class="language-plaintext highlighter-rouge">AtomicU32::load</code> in Rust; this requires that an atomic ordering be specified, too. E.g.,</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%v</span> <span class="p">=</span> <span class="k">load</span> <span class="k">atomic</span> <span class="kt">i32</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span> <span class="k">acquire</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">fence</code> operation is a general memory fence operation corresponding to e.g. Rust’s <code class="language-plaintext highlighter-rouge">std::sync::atomic::fence</code> function.</p> <p><code class="language-plaintext highlighter-rouge">cmpxchg</code> provides the CAS (compare-and-swap) primitive. It returns a <code class="language-plaintext highlighter-rouge">{T, i1}</code> containing the old value and whether the CAS succeeded. <code class="language-plaintext highlighter-rouge">cmpxchg weak</code> implements the spuriously-failing “weak CAS” primitive.</p> <p>Finally, <code class="language-plaintext highlighter-rouge">atomicrmw</code> performs a read-modify-write (e.g., <code class="language-plaintext highlighter-rouge">*p = op(*p, val)</code>) atomically. This is used to implement things like <code class="language-plaintext highlighter-rouge">AtomicU32::fetch_add</code> and friends.</p> <p>All of these operations, except for <code class="language-plaintext highlighter-rouge">fence</code>, can also be marked as <code class="language-plaintext highlighter-rouge">volatile</code>. In LLVM IR, much like in Rust but unlike in C/C++, individual loads and stores are volatile (i.e., have compiler-invisible side-effects). <code class="language-plaintext highlighter-rouge">volatile</code> <em>can</em> be combined with atomic operations (e.g. <code class="language-plaintext highlighter-rouge">load atomic volatile</code>), although most languages don’t provide access to these (except older C++ versions).</p> <h3 id="reinterpret-shenanigans"><a href="#reinterpret-shenanigans">Reinterpret Shenanigans</a></h3> <p><code class="language-plaintext highlighter-rouge">bitcast</code> is what <code class="language-plaintext highlighter-rouge">mem::transmute</code> and <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> in Rust and C++, respectively, ultimately compile into. It can convert any non-aggregate type (integers, vectors) to any other type of the same bit width. For example, it can be used to get at the bits of a floating-point value:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%bits</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span> <span class="nv">%fp</span> <span class="k">to</span> <span class="kt">i64</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>It also used to be what was used to cast pointer types (e.g. <code class="language-plaintext highlighter-rouge">i32*</code> to <code class="language-plaintext highlighter-rouge">i8*</code>). Pointers are now all untyped (<code class="language-plaintext highlighter-rouge">ptr</code>) so this use is no longer present.</p> <p>However, <code class="language-plaintext highlighter-rouge">bitcast</code> cannot cast between pointer and integer data. For this we must use the <code class="language-plaintext highlighter-rouge">inttoptr</code> and <code class="language-plaintext highlighter-rouge">ptrtoint</code><sup id="fnref:i2p" role="doc-noteref"><a href="#fn:i2p" class="footnote" rel="footnote">9</a></sup> instructions. These have the same syntax, but interact with the sketchy semantics of pointer-to-integer conversion and pointer provenance. This part of LLVM’s semantics is a bit of an ongoing trashfire; see <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">Ralf Jung’s post</a> for an introduction to this problem.</p> <h3 id="intrinsics"><a href="#intrinsics">Intrinsics</a></h3> <p>There is also a vast collection of LLVM intrinsics, which are specified in the <a href="https://llvm.org/docs/LangRef.html">LangRef</a>. For example, if we need a particular built-in memcpy, we can bring it into scope with a <code class="language-plaintext highlighter-rouge">declare</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; ptr %dst, ptr %src, i64 %len, i1 %volatile</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.memcpy.p0.p0.i64</span><span class="p">(</span><span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>All of the LLVM intrinsics are functions that start with <code class="language-plaintext highlighter-rouge">llvm.</code>; diving into all of them is far beyond what we can do here.</p> <p>I’m also leaving out discussion of floating point, SIMD, and exception handling, each of which would require their own articles!</p> <h2 id="undefined-behavior"><a href="#undefined-behavior">Undefined Behavior</a></h2> <p>LLVM exists to generate optimized code, and optimizations require that we declare certain machine states “impossible”, so that we can detect when we can simplify what the programmer has said. This is “undefined behavior”.</p> <p>For example, we’ve already encountered <code class="language-plaintext highlighter-rouge">unreachable</code>, which LLVM assumes cannot be executed. Division by zero and accessing memory out of bounds is also undefined.</p> <p>Most LLVM UB factors through the concept of “poisoned values”. A poison value can be thought of as “taking on every value at once”, whichever is convenient for the current optimization pass with no respect to any other passes. This also means that if optimizations <em>don’t</em> detect a use of poison, it is ok from LLVM’s perspective to give you a garbage value. This is most visible at <code class="language-plaintext highlighter-rouge">-O0</code>, which performs minimal optimization.</p> <p>Using a poison value as a pointer in a <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">store</code>, or <code class="language-plaintext highlighter-rouge">call</code> must be UB, because LLVM can choose it to be a null pointer. It also can’t be the denominator of a <code class="language-plaintext highlighter-rouge">udiv</code> or similar, because LLVM can choose it to be zero, which is UB. Passing poison into a <code class="language-plaintext highlighter-rouge">br</code> or a <code class="language-plaintext highlighter-rouge">switch</code> is also defined to be UB.</p> <p>LLVM can perform dataflow analysis to try to determine what operations a poisonous value that was used in a UB way came from, and thus assume those operations cannot produce poison. Because all operations (other than <code class="language-plaintext highlighter-rouge">select</code> and <code class="language-plaintext highlighter-rouge">phi</code>) with a poison input produce poison, backwards reasoning allows LLVM to propagate UB forward. This is where so-called “time traveling UB” comes from.</p> <p>Many operations generate poison. For example, in C, signed overflow is UB, so addition lowers to an <code class="language-plaintext highlighter-rouge">add nsw</code> (<code class="language-plaintext highlighter-rouge">nsw</code> stands for no signed wrap). Instead of wrapping on overflow, the instruction produces poison. There is also an unsigned version of the annotation, <code class="language-plaintext highlighter-rouge">nuw</code>.</p> <p>Many other operations have “less defined” versions, which are either generated by optimizations, or inserted directly by the compiler that invokes LLVM when the language rules allow it (see C above). More examples include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">udiv</code> and friends have an <code class="language-plaintext highlighter-rouge">exact</code> annotation, which requires that the division have a zero remainder, else poison.</li> <li><code class="language-plaintext highlighter-rouge">getelementptr</code> has an <code class="language-plaintext highlighter-rouge">inbounds</code> annotation, which produces poison if the access is actually out of bounds. This changes it from a pure arithmetic operation to one more closely matching C’s pointer arithmetic restrictions. GEP without <code class="language-plaintext highlighter-rouge">inbounds</code> corresponds to Rust’s <code class="language-plaintext highlighter-rouge">&lt;*mut T&gt;::wrapping_offset()</code> function.</li> <li>Floating point operations marked with <code class="language-plaintext highlighter-rouge">nnan</code> and <code class="language-plaintext highlighter-rouge">ninf</code> will produce poison instead of a NaN or an infinite value, respectively (or when a NaN or infinity is an argument).</li> </ul> <p>Creating poison is <em>not</em> UB; only using it is. This is weaker than the way UB works in most languages; in C, overflow is instantly UB, but in LLVM overflow that is never “witnessed” is simply ignored. This is a simpler operational semantics for reasoning about the validity of optimizations: UB must often be viewed as a side-effect, because the compiler will generate code that puts the program into a broken state. For example, division by zero will cause a fault in many architectures. This means UB-causing operations cannot always be reordered soundly. Replacing “causes UB” with “produces poison” ensures the vast majority of operations are pure and freely reorderable.</p> <h2 id="reading-some-codegen"><a href="#reading-some-codegen">Reading Some Codegen</a></h2> <p>Let’s go back to our original Rust example!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBzcXVhcmUoeDogaTMyKSAtPiBpMzIge1xuICB4ICogeFxu fSIsImNvbXBpbGVycyI6W3siaWQiOiJiZXRhIiwib3B0aW9ucyI6Ii0tZW1p dD1sbHZtLWlyIn1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This is the output, with metadata redacted and some things moved around for readability.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">source_filename</span> <span class="p">=</span> <span class="s">"example.b6eb2c7a6b40b4d2-cgu.0"</span>
<span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"</span>
<span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">"x86_64-unknown-linux-gnu"</span>

<span class="c1">; example::square</span>
<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@_ZN7example6square17hb32bcde4463f37c3E</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
<span class="nl">start:</span>
  <span class="nv">%0</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%x</span><span class="p">)</span>
  <span class="nv">%_2.0</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%_2.1</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span> <span class="nv">%_2.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="k">false</span><span class="p">)</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%panic</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb1</span>

<span class="nl">bb1:</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%_2.0</span>

<span class="nl">panic:</span>
  <span class="c1">; core::panicking::panic</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span> <span class="vg">@str.0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="m">33</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span> <span class="vg">@alloc_1368addac7d22933d93af2809439e507</span>
  <span class="p">)</span>
  <span class="k">unreachable</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">)</span> <span class="vg">#1</span>
<span class="k">declare</span> <span class="kt">i1</span> <span class="vg">@llvm.expect.i1</span><span class="p">(</span><span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">)</span> <span class="vg">#2</span>

<span class="c1">; core::panicking::panic</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@_ZN4core9panicking5panic17ha338a74a5d65bf6fE</span><span class="p">(</span><span class="err">ptr</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">align</span> <span class="m">8</span><span class="p">)</span> <span class="k">unnamed_addr</span> <span class="vg">#3</span>

<span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span>
  <span class="p">&lt;{</span> <span class="p">[</span><span class="m">15</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"/app/example.rs"</span> <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">1</span>

<span class="vg">@alloc_1368addac7d22933d93af2809439e507</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span>
  <span class="p">&lt;{</span> <span class="err">ptr</span><span class="p">,</span> <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="p">}&gt;</span> <span class="p">&lt;{</span>
    <span class="err">ptr</span> <span class="vg">@alloc_9be5c135c0f7c91e35e471f025924b11</span><span class="p">,</span>
    <span class="p">[</span><span class="m">16</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"\0F\00\00\00\00\00\00\00\02\00\00\00\03\00\00\00"</span>
  <span class="p">}&gt;,</span> <span class="k">align</span> <span class="m">8</span>

<span class="vg">@str.0</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">33</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="s">c"attempt to multiply with overflow"</span>

<span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#1</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">speculatable</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#2</span> <span class="p">=</span> <span class="p">{</span> <span class="err">nocallback</span> <span class="k">nofree</span> <span class="k">nosync</span> <span class="k">nounwind</span> <span class="k">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="p">}</span>
<span class="k">attributes</span> <span class="vg">#3</span> <span class="p">=</span> <span class="p">{</span> <span class="k">cold</span> <span class="k">noinline</span> <span class="k">noreturn</span> <span class="k">nonlazybind</span> <span class="k">uwtable</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>The main function is <code class="language-plaintext highlighter-rouge">@_ZN7example6square17hb32bcde4463f37c3E</code>, which is the mangled name of <code class="language-plaintext highlighter-rouge">example::square</code>. Because this code was compiled in debug mode, overflow panics, so we need to generate code for that. The first operation is a <code class="language-plaintext highlighter-rouge">call</code> to the LLVM intrinsic for “multiply and tell us if it overflowed”. This returns the equivalent of a <code class="language-plaintext highlighter-rouge">(i32, bool)</code>; we extract both value out of it with <code class="language-plaintext highlighter-rouge">extractvalue</code>. We then pass the bool through <code class="language-plaintext highlighter-rouge">@llvm.expect</code>, which is used to tell the optimizer to treat the panicking branch as “cold”. The success branch goes to a return, which returns the product; otherwise, we go to a function that calls <code class="language-plaintext highlighter-rouge">core::panicking::panic()</code> to panic the current thread. This function never returns, so we can terminate the block with an <code class="language-plaintext highlighter-rouge">unreachable</code>.</p> <p>The rest of the file consists of:</p> <ul> <li><code class="language-plaintext highlighter-rouge">declare</code>s for the llvm intrinsics we used.</li> <li>A <code class="language-plaintext highlighter-rouge">declare</code> for <code class="language-plaintext highlighter-rouge">core::panicking::panic</code>. Any external function we call needs to be <code class="language-plaintext highlighter-rouge">declare</code>d. This also gives us a place to hang attributes for the function off of.</li> <li>Global constants for a <code class="language-plaintext highlighter-rouge">core::panic::Location</code> and a panic message.</li> <li>Attributes for the functions above.</li> </ul> <p>This is a good place to mention attributes: LLVM has all kinds of attributes that can be placed on functions (and function calls) to record optimization-relevant information. For example, <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code> is annotated as <code class="language-plaintext highlighter-rouge">willreturn</code>, which means this function will eventually return; this means that, for example, any UB that comes after the function is guaranteed to occur after finite time, so LLVM can conclude that the code is unreachable despite the call to <code class="language-plaintext highlighter-rouge">@llvm.expect.i1</code>. The full set of attributes is vast, but the <a href="https://llvm.org/docs/LangRef.html">LangRef</a> documents all of them!</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>LLVM IR is huge, bigger than any individual ISA, because it is intended to capture <em>every</em> interesting operation. It also has a rich annotation language, so passes can record information for future passes to make use of. Its operational semantics attempt to leave enough space for optimizations to occur, while ensuring that multiple sound optimizations in sequence are not unsound (this last part is a work in progress).</p> <p>Being able to read assembly reveals what will happen, exactly, when code is executed, but reading IR, before and after optimization, shows how the compiler is <em>thinking</em> about your code. Using <code class="language-plaintext highlighter-rouge">opt</code> to run individual optimization passes can also help further this understanding (in fact, “bisecting on passes” is a powerful debugging technique in compiler development).</p> <p>I got into compilers by reading LLVM IR. Hopefully this article inspires you to learn more, too!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:numeric-names" role="doc-endnote"> <p>Registers within a function may have a numeric name. They must be defined in order: you must define <code class="language-plaintext highlighter-rouge">%0</code> (either as a register or a label), then <code class="language-plaintext highlighter-rouge">%1</code>, then <code class="language-plaintext highlighter-rouge">%2</code>, etc. These are often used to represent “temporary results”.</p> <p>If a function does not specify names for its parameters, they will be given the names <code class="language-plaintext highlighter-rouge">%0</code>, <code class="language-plaintext highlighter-rouge">%1</code>, etc implicitly, which affect what the first explicit numeric register name you can use is. Similarly, if the function does not start with a label, it will be implicitly be given the next numeric name.</p> <p>This can result in significant confusion, because if we have <code class="language-plaintext highlighter-rouge">define void @foo(i32, i32) { ... }</code>, the arguments will be <code class="language-plaintext highlighter-rouge">%0</code> and <code class="language-plaintext highlighter-rouge">%1</code>, but if we tried to write <code class="language-plaintext highlighter-rouge">%2 = add i32 %0, %1</code>, we would get an extremely confusing parser error, because <code class="language-plaintext highlighter-rouge">%2</code> is already taken as the name of the first block. <a href="#fnref:numeric-names" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:divz" role="doc-endnote"> <p>For some reason, the optimizer can’t figure out that the <code class="language-plaintext highlighter-rouge">select</code> is redundant? Alive2 (an SMT-solver correctness checker for optimizations) <a href="https://alive2.llvm.org/ce/z/7nLDRe">seems to agree</a> this is a valid optimization.</p> <p><a href="https://github.com/llvm/llvm-project/issues/64240">So I’ve filed a bug.</a> :D <a href="#fnref:divz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:br-on-real-machines" role="doc-endnote"> <p>If you read my assembly article, you’ll recall that there are many branch instructions. On RV, we have <code class="language-plaintext highlighter-rouge">beq</code>, <code class="language-plaintext highlighter-rouge">bne</code>, <code class="language-plaintext highlighter-rouge">bgt</code>, and <code class="language-plaintext highlighter-rouge">bge</code>. Later on in the compilation process, after the optimizer runs, LLVM will perform <em>instruction selection</em> (isel) to choose the best machine instruction(s) to implement a particular LLVM instruction (or sequence), which is highly context-dependent: for example, we want to fuse an <code class="language-plaintext highlighter-rouge">icmp eq</code> followed by a <code class="language-plaintext highlighter-rouge">br</code> on the result into a <code class="language-plaintext highlighter-rouge">beq</code>.</p> <p>Isel is far outside my wheelhouse, and doing it efficiently and profitably is an active area of academic research. <a href="#fnref:br-on-real-machines" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:frontend-optimization" role="doc-endnote"> <p>Not exactly the same: language frontends like Clang and Rust will perform their own optimizations. For example, I have an <a href="https://github.com/llvm/llvm-project/issues/59484">open bug</a> for LLVM being unable to convert <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> into <code class="language-plaintext highlighter-rouge">&amp;</code> in some cases; this was never noticed, because Clang performs this optimization while lowering from C/C++ to LLVM, but Rust does not do the equivalent optimization. <a href="#fnref:frontend-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:block-args" role="doc-endnote"> <p>A more intuitive model is used in more modern IRs, like MLIR. In MLIR, you cannot use variables defined in other blocks; instead, each block takes a set of <em>arguments</em>, just like a function call. This is equivalent to <code class="language-plaintext highlighter-rouge">phi</code> instructions, except that now instead of selecting which value we want in the target, each predecessor specifies what it wants to send to the target.</p> <p>If we instead treat each block as having “arguments”, we can rewrite it in the following fantasy syntax where register names are scoped to their block.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">;; Not actual LLVM IR! ;;</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@pow</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span><span class="p">)</span>

<span class="err">loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%done</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i32</span> <span class="nv">%i.0</span><span class="p">,</span> <span class="nv">%y</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%done</span><span class="p">,</span> <span class="nv">%exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">),</span> <span class="nv">%loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">loop</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="nv">%r.new</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">,</span> <span class="nv">%x</span>
  <span class="nv">%i.new</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="nv">%loop_start</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%i</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>

<span class="err">exit</span><span class="p">(</span><span class="kt">i32</span> <span class="nv">%r</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%r</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p><a href="#fnref:block-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:viz" role="doc-endnote"> <p>What does the CFG look like? LLVM contains “optimization” passes that print the CFG as a file as a <code class="language-plaintext highlighter-rouge">.dot</code> file, which can be rendered with the <code class="language-plaintext highlighter-rouge">dot</code> command. For <code class="language-plaintext highlighter-rouge">@safe_div</code>, we get something like the following.</p> <figure style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/safe_div.svg" alt=""/></p> </figure> <p>This is useful for understanding complex functions. Consider this Rust hex-parsing function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// hex.rs</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">parse_hex</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0u64</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.bytes</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">digit</span> <span class="o">=</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
      <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="p">,</span>
      <span class="sc">b'a'</span><span class="o">..=</span><span class="sc">b'f'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="sc">b'A'</span><span class="o">..=</span><span class="sc">b'F'</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">b'A'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_mul</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="nf">.checked_add</span><span class="p">(</span><span class="n">digit</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Then, we can generate our CFG with some shell commands.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>rustc <span class="nt">-O</span> <span class="nt">--crate-type</span> lib <span class="nt">--emit</span> llvm-ir hex.rs
<span class="nv">$ </span>opt <span class="nt">-p</span> dot-cfg <span class="nt">-o</span> /dev/null hex.ll
Writing <span class="s1">'.parse_hex.dot'</span>...
<span class="nv">$ </span>dot <span class="nt">-Tsvg</span> .parse_hex.dot <span class="nt">-o</span> parse_hex.svg</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Shell</div></div></div> <p>The result is this mess.</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex.svg" alt=""/></p> </div> <p>Without optimizations, we get a bigger mess (most optimization passes are various CFG cleanups).</p> <div style="filter:invert(100%);"> <p><img src="https://mcyoung.xyz/public/images/cfg-svg/parse_hex_unopt.svg" alt=""/></p> </div> <p>Exercise: try to trace through what each basic block is doing. You will want to open the SVGs in a separate tab to do that. I recommend following the optimized version, since it is much less noisy.</p> <p>Comparing optimized vs. unoptimized is a good way to see how much the compiler does to simplify the stuff the language frontend gives it. At -O0? All allocas. At -O2? No allocas! <a href="#fnref:viz" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:typed-pointers" role="doc-endnote"> <p>Once upon a time we had typed pointers, like <code class="language-plaintext highlighter-rouge">i32*</code>. These turned out to generate more problems than they solved, requiring frequent casts in IR in exchange for mediocre type safety. See <a href="https://llvm.org/docs/OpaquePointers.html">https://llvm.org/docs/OpaquePointers.html</a> for a more complete history. <a href="#fnref:typed-pointers" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:sarcasm" role="doc-endnote"> <p>Sarcasm. <a href="#fnref:sarcasm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:i2p" role="doc-endnote"> <p>I quietly judge LLVM for having instructions named <code class="language-plaintext highlighter-rouge">inttoptr</code> when <code class="language-plaintext highlighter-rouge">int2ptr</code> just reads so much nicer. <a href="#fnref:i2p" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="dark-arts"/><category term="assembly"/><category term="toolchains"/><summary type="html"><![CDATA[The other day, I saw this tweet. In it, Andrew Gallant argues that reaching for LLVM IR, instead of assembly, is a useful tool for someone working on performance. Unfortunately, learning material on LLVM is usually aimed at compiler engineers, not generalist working programmers.]]></summary></entry><entry><title type="html">Single Abstract Method Traits</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2023/05/11/sam-closures/" rel="alternate" type="text/html" title="Single Abstract Method Traits"/><published>2023-05-11T00:00:00-04:00</published><updated>2023-05-11T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2023/05/11/sam-closures</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2023/05/11/sam-closures/"><![CDATA[<p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Java gets a bad rap but the core language does have some interesting features in it. A very handy one is an <em>anonymous class</em>.</p> <p>Let’s suppose I want to pass a callback into something. In Java 6, which I grew up on, you did it like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Interface() {...}</code> syntax mints a new class on the spot that implements <code class="language-plaintext highlighter-rouge">Interface</code>. You provide a standard class body between the braces, after the name of the type. You can also do this with a class type too.</p> <p>Now, this is a bit tedious: I need to re-type the signature of the one method. This is fine if I need to implement a bunch of methods, but it’s a little annoying in the one-method case.</p> <p>In Java 8 we got lambdas (syntax: <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>). Java made the interesting choice of not adding a <code class="language-plaintext highlighter-rouge">Function</code> type to be “the type of lambdas”. For a long time I thought this was a weird cop-out but I have since come to regard it as a masterclass in language design.</p> <p>Instead, Java’s lambdas are a sort of syntax sugar over this anonymous class syntax.<sup id="fnref:invokedynamic" role="doc-noteref"><a href="#fn:invokedynamic" class="footnote" rel="footnote">1</a></sup> Instead, you need to assign a lambda to an interface type with a single abstract method, and it will use the body of the lambda to implement that one method.</p> <p>Interfaces compatible with lambdas are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation, which must satisfy the following constraints:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the aforementioned <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts and no GATs.</li> <li>All of its supertraits are <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, or <code class="language-plaintext highlighter-rouge">Sync</code>.</li> </ol> <p>These restrictions are chosen so that we have a shot at actually implementing the entire trait.</p> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, ordinary closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate.</p> <p>None of these traits are SAM, so we can safely allow them to be automatically derived for SAM closures to, under the same rules as for ordinary closures.</p> </blockquote> <p>To request a SAM closure, I will use the tentative syntax of <code class="language-plaintext highlighter-rouge">impl Trait |args| expr</code>. This syntax is unambiguously an expression rather than an <code class="language-plaintext highlighter-rouge">impl</code> item, because a <code class="language-plaintext highlighter-rouge">|</code> cannot appear in a path-in-type, and <code class="language-plaintext highlighter-rouge">impl $path</code> must be followed by <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">where</code>. The precise syntax is unimportant.</p> <p>Applied to the <code class="language-plaintext highlighter-rouge">call_many</code> example above, we get this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="n">Callback</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The compiler rewrites this into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">CallbackImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CallbackImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CallbackImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This rewrite can happen relatively early, before we need to infer a type for <code class="language-plaintext highlighter-rouge">x</code>. We also need to verify that this trait’s captures are compatible with an <code class="language-plaintext highlighter-rouge">&amp;self</code> receiver The same rules for when a trait implements <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">FnOnce</code> would decide which of the three receiver types the closure is compatible with.</p> <p>Note that SAM closures WOULD NOT implement any <code class="language-plaintext highlighter-rouge">Fn</code> traits.</p> <h3 id="more-complicated-examples"><a href="#more-complicated-examples">More Complicated Examples</a></h3> <p>We are required to name the trait we want but its type parameters can be left up in the air. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Out</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Display</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Out</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// We can infer `T = i32` and `Tr::Out = String`.</span>
<span class="k">let</span> <span class="n">tr</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">Tr</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>In general, unspecified parameters and associated types result in inference variables, which are resolved in the same way as the parameters of the <code class="language-plaintext highlighter-rouge">Fn</code> closures are.</p> <p>In fact, we can emulate ordinary closures using SAM closures.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.map</span><span class="p">(</span><span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">_</span> <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note that because <code class="language-plaintext highlighter-rouge">Fn</code> and <code class="language-plaintext highlighter-rouge">FnMut</code> have non-trival supertraits we can’t make them out of SAM closures.</p> <p>One application is to completely obsolete <code class="language-plaintext highlighter-rouge">std::iter::from_fn</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">u64</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Copy</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Or, if you need a quick helper implementation of <code class="language-plaintext highlighter-rouge">Debug</code>…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="n">f</span><span class="nf">.debug_list</span><span class="p">()</span>
    <span class="nf">.entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">impl</span> <span class="n">Debug</span> <span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="p">{</span>
      <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"something something {}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.next_thingy</span><span class="p">())</span>
    <span class="p">})</span>
    <span class="nf">.finish</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are probably additional restrictions we will want to place on the SAM trait, but it’s not immediately clear what the breadth of those are. For example, we probably shouldn’t try to make this work:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">UniversalFactory</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="n">make</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">impl</span> <span class="n">UniversalFactory</span> <span class="p">||</span> <span class="p">{</span>
  <span class="c1">// How do I name T so that I can pass it to size_of?</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>There are definitely clever tricks you <em>can</em> play to make this work, but the benefit seems slim.</p> <h2 id="future-work"><a href="#future-work">Future Work</a></h2> <p>There’s two avenues for how we could extend this concept. The first is straightforward and desireable; the second is probably unimplementable.</p> <h3 id="anonymous-trait-impls"><a href="#anonymous-trait-impls">Anonymous Trait Impls</a></h3> <p>Backing up from the Java equivalent of lambdas, it seems not unreasonable to have a full-fledged expression version of <code class="language-plaintext highlighter-rouge">impl</code> that can make captures.</p> <p>Syntactically, I will use <code class="language-plaintext highlighter-rouge">impl Trait for { ... }</code>. This is currently unambiguous, although I think that making it so that <code class="language-plaintext highlighter-rouge">{</code> cannot start a type is probably a non-starter.</p> <p>Let’s pick something mildly complicated… like <code class="language-plaintext highlighter-rouge">Iterator</code> with an overriden method. Then we might write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">[</span><span class="o">...</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">my_iterator</span> <span class="o">=</span> <span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="o">*</span><span class="n">my_list</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">my_list</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The contents of the braces after <code class="language-plaintext highlighter-rouge">for</code> is an item list, except that variables from the outside are available, having the semantics of captures; they are, in effect, accesses of <code class="language-plaintext highlighter-rouge">self</code> without the <code class="language-plaintext highlighter-rouge">self.</code> prefix.</p> <p>Hammering out precisely how this would interact with the self types of the functions in the body seems… complicated. Pretty doable, just fussy. There are also awkward questions about what <code class="language-plaintext highlighter-rouge">Self</code> is here and to what degree you’re allowed to interact with it.</p> <h3 id="trait-inference"><a href="#trait-inference">Trait Inference</a></h3> <p>Suppose that we could instead “just” write <code class="language-plaintext highlighter-rouge">impl |x| x * x</code> and have the compiler figure out what trait we want (to say nothing of making this the default behavior and dropping the leading <code class="language-plaintext highlighter-rouge">impl</code> keyword).</p> <p>This means that I could just write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="k">impl</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We get into trouble fast.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <p>Currently, rustc does not have to produce impls “on demand”; the trait solver has a finite set of impls to look at. What we are asking the trait solver to do is to, for certain types, attempt to reify impls based on <em>usage</em>. I.e., I have my opaque closure type <code class="language-plaintext highlighter-rouge">T</code> and I the compiler decided it needed to prove a <code class="language-plaintext highlighter-rouge">T: Foo</code> bound so now it gets to perform type checking to validate whether it has an <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>This seems unimplementable with how the solver currently works. It is not insurmountable! But it would be very hard.</p> <p>It is possible that there are relaxations of this that are not insane to implement, e.g. the <code class="language-plaintext highlighter-rouge">impl ||</code> expression is used to initialize an argument to a function that happens to be generic, so we can steal the bounds off of that type variable and hope it’s SAM. But realistically, this direction is more trouble than its worth.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:invokedynamic" role="doc-endnote"> <p>Except for the part where they are extremely not. Where <code class="language-plaintext highlighter-rouge">new T() {}</code> mints a brand new class and accompanying <code class="language-plaintext highlighter-rouge">.class</code> file, Java lambdas use this complicated machinery from Java 7 to generate method handles on the fly, via the <code class="language-plaintext highlighter-rouge">invokedynamic</code> JVM instruction. This, I’m told, makes them much easier to optimize. <a href="#fnref:invokedynamic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="rust"/><category term="language-design"/><summary type="html"><![CDATA[Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.]]></summary></entry><entry><title type="html">Better Trait Resolution in Rust</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2023/04/04/trait-rez-wishlist/" rel="alternate" type="text/html" title="Better Trait Resolution in Rust"/><published>2023-04-04T00:00:00-04:00</published><updated>2023-04-04T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2023/04/04/trait-rez-wishlist</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2023/04/04/trait-rez-wishlist/"><![CDATA[<p>Traits are the core of polymorphism in Rust. Let’s review:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{self}"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Prints `42`.</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="mi">42</span><span class="nf">.string</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xudHJhaXQgU3RyaW5nZXIge1xuICBmbiBz dHJpbmcoJnNlbGYpIC0+IFN0cmluZztcbn1cblxuaW1wbCBTdHJpbmdlciBm b3IgaTMyIHtcbiAgZm4gc3RyaW5nKCZzZWxmKSAtPiBTdHJpbmcge1xuICAg IGZvcm1hdCEoXCJ7c2VsZn1cIilcbiAgfVxufVxuXG4vLyBQcmludHMgYDQy YC5cbnByaW50bG4hKFwie31cIiwgNDIuc3RyaW5nKCkpO1xufVxuIiwiY29t cGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlclZpc2libGUiOmZh bHNlLCJjb21waWxlck91dHB1dFZpc2libGUiOnRydWUsImNvbXBpbGVyIjp7 ImlkIjoiYmV0YSIsIm9wdGlvbnMiOiIifX1dfV19 ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>Notice that we call the trait method <code class="language-plaintext highlighter-rouge">Stringer::string</code> directly on the value in question. This means that traits (at least, those currently in scope) inject their methods into the namespace of anything that implements them.</p> <p>Now, this isn’t immediately a problem, because Rust’s namespace lookup rules are such that methods <em>inherent</em> to a type are searched for first:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Woofer</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"woof"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"bark"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Prints `bark`.</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">Woofer</span><span class="nf">.string</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoicnVzdCIsInNvdXJj ZSI6InB1YiBmbiBtYWluKCkge1xudHJhaXQgU3RyaW5nZXIge1xuICBmbiBz dHJpbmcoJnNlbGYpIC0+IFN0cmluZztcbn1cblxuc3RydWN0IFdvb2Zlcjtc bmltcGwgU3RyaW5nZXIgZm9yIFdvb2ZlciB7XG4gIGZuIHN0cmluZygmc2Vs ZikgLT4gU3RyaW5nIHtcbiAgICBmb3JtYXQhKFwid29vZlwiKVxuICB9XG59 XG5cbmltcGwgV29vZmVyIHtcbiAgZm4gc3RyaW5nKCZzZWxmKSAtPiBTdHJp bmcge1xuICAgIGZvcm1hdCEoXCJiYXJrXCIpXG4gIH1cbn1cblxuLy8gUHJp bnRzIGBiYXJrYC5cbnByaW50bG4hKFwie31cIiwgV29vZmVyLnN0cmluZygp KTtcbn1cbiIsImNvbXBpbGVycyI6W10sImV4ZWN1dG9ycyI6W3siY29tcGls ZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJPdXRwdXRWaXNpYmxlIjp0cnVl LCJjb21waWxlciI6eyJpZCI6ImJldGEiLCJvcHRpb25zIjoiIn19XX1dfQ== ">godbolt</a><div class="codeblock-button">Rust</div></div></div> <p>This means that traits cannot <em>easily</em> break downstream code by adding new methods, but there are a few possible hazards:</p> <ul> <li> <p>If the owner of a type adds a method with the same name as a trait method, it will override direct (i.e., <code class="language-plaintext highlighter-rouge">foo.string()</code>) calls to that trait method, even if the type owner is unaware of the trait method.</p> </li> <li> <p>If traits <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are in scope, and <code class="language-plaintext highlighter-rouge">String</code> implements both, and we call <code class="language-plaintext highlighter-rouge">str.foo()</code> (which resolves to <code class="language-plaintext highlighter-rouge">A::foo()</code>), and later <code class="language-plaintext highlighter-rouge">B</code> adds a new method <code class="language-plaintext highlighter-rouge">B::foo()</code>, the callsite for <code class="language-plaintext highlighter-rouge">String</code> will break. <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>’s owners do not need to be aware of each other for this to happen.</p> </li> </ul> <p>Of course, Rust has a disambiguation mechanism. Given any trait implementation <code class="language-plaintext highlighter-rouge">Foo: Bar</code>, we can reference its items by writing <code class="language-plaintext highlighter-rouge">&lt;Foo as Bar&gt;::baz</code>. However, this syntax is <em>very</em> unweildy (it doesn’t work with method chaining), so it doesn’t get used. As a result, small evolution hazards can build up in a large codebase.</p> <p>Those who know me know that I often talk about a syntax that I call <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>, or “qualified method call syntax”. In this post, I want to discuss this syntax in more detail, and some related ideas, and how they factor into type and trait design.</p> <h2 id="paths-as-methods"><a href="#paths-as-methods">Paths-as-Methods</a></h2> <p>This idea isn’t new; others have proposed it, and it forms the core of Carbon’s version of trait method calls (you can read more about Carbon’s name lookup story <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/member_access.md">here</a>).</p> <p>Let’s recreate the original example in Carbon (bear in mind that I am not an expert on this language, and the semantics are still up in the air).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">interface</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">external</span> <span class="k">impl</span> <span class="nb">i32</span> <span class="k">as</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Carbon</span><span class="nf">.Print</span><span class="p">(</span><span class="mf">42.</span><span class="p">(</span><span class="n">Stringer</span><span class="py">.String</span><span class="p">)())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Carbon</div></div></div> <p>Notice <code class="language-plaintext highlighter-rouge">42.(Stringer.String)()</code>: Carbon <em>requires</em> that we qualify the method call, because <code class="language-plaintext highlighter-rouge">42</code> has the concrete type <code class="language-plaintext highlighter-rouge">i32</code>. If this were in a generic context and we had a type variable bounded by <code class="language-plaintext highlighter-rouge">Stringer</code>, we could just write <code class="language-plaintext highlighter-rouge">x.String()</code>; no ambiguity.</p> <p>In Carbon, all qualification uses <code class="language-plaintext highlighter-rouge">.</code>, so they have to add parens. Because Rust uses <code class="language-plaintext highlighter-rouge">::</code> for qualifying paths, we don’t have this syntactic abiguity, so we can augment the syntax to allow more path expressions after the <code class="language-plaintext highlighter-rouge">.</code>.</p> <p>The current grammar is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">MethodCallExpression :
   Expression . PathExprSegment (CallParams?)

PathExprSegment :
   PathIdentSegment (:: GenericArgs)?</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>That is, exactly one identifier and an optional turbofish. I would like to see this extended to allow any <code class="language-plaintext highlighter-rouge">QualifiedPathInExpression</code> after the <code class="language-plaintext highlighter-rouge">.</code> and before the parens. This would allow, for example:</p> <ul> <li><code class="language-plaintext highlighter-rouge">expr.Trait::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.Self::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.&lt;Foo as Trait&gt;::method()</code></li> <li><code class="language-plaintext highlighter-rouge">expr.::path::to::Trait::&lt;Args&gt;::method::&lt;MoreArgs&gt;()</code></li> </ul> <p>These would all be desugared as the equivalent UFCS, taking into account that method call syntax can trigger autoref.</p> <ul> <li><code class="language-plaintext highlighter-rouge">Trait::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">Self::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">&lt;Foo as Trait&gt;::method(expr)</code></li> <li><code class="language-plaintext highlighter-rouge">::path::to::Trait::&lt;Args&gt;::method::&lt;MoreArgs&gt;(expr)</code></li> </ul> <p>The method would still need to be valid to have been called via <code class="language-plaintext highlighter-rouge">.</code> syntax; I’m not proposing we add the following, even though it is unambiguous.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span>

<span class="c1">// Would be equivalent to `square(42)`.</span>
<span class="mi">42</span><span class="py">.self</span><span class="p">::</span><span class="nf">square</span><span class="p">()</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Trait method callers can now use qualified method call syntax where they might want to use UFCS without issues around wordiness.</p> <h2 id="impl-modality"><a href="#impl-modality">Impl Modality</a></h2> <p>Of course, this isn’t the only idea from Carbon’s interfaces worth stealing; Carbon also has a notion of “external” and “internal” <code class="language-plaintext highlighter-rouge">impl</code>s; I will call these “<code class="language-plaintext highlighter-rouge">impl</code> modes”.</p> <p>An external <code class="language-plaintext highlighter-rouge">impl</code> is like the one we showed above, whose methods can only be found by qualified lookup: <code class="language-plaintext highlighter-rouge">foo.(Bar.Baz)()</code>. An internal <code class="language-plaintext highlighter-rouge">impl</code> is one which is “part” of a type.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">interface</span> <span class="n">Stringer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">class</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">impl</span> <span class="k">as</span> <span class="n">Stringer</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nb">String</span><span class="p">[</span><span class="k">self</span><span class="p">:</span> <span class="k">Self</span><span class="p">]()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">w</span><span class="p">:</span> <span class="n">Woofer</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
  <span class="n">w</span><span class="nf">.String</span><span class="p">()</span>  <span class="c1">// Unqualified!</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Carbon</div></div></div> <p>This also implies that we don’t need to import <code class="language-plaintext highlighter-rouge">Stringer</code> to call <code class="language-plaintext highlighter-rouge">w.String()</code>.</p> <p>There are definitely traits in Rust which fit into these modes.</p> <p><code class="language-plaintext highlighter-rouge">Clone</code> and <code class="language-plaintext highlighter-rouge">Iterator</code> almost always want to be internal. An iterator exists to implement <code class="language-plaintext highlighter-rouge">Iterator</code>, and cloning is a fundamental operation. Because both of these traits are in the prelude, it’s not a problem, but it is a problem for traits provided by a non-<code class="language-plaintext highlighter-rouge">std</code> crate, like <a href="https://docs.rs/rand/latest/rand/trait.Rng.html"><code class="language-plaintext highlighter-rouge">rand::Rng</code></a>. The lack of a way to do this leads to the proliferation of <code class="language-plaintext highlighter-rouge">prelude</code> modules and namespace pollution. (I think that <code class="language-plaintext highlighter-rouge">prelude</code>s are bad library design.)</p> <p>On the other hand, something like <code class="language-plaintext highlighter-rouge">Debug</code> wants to be external very badly. It almost never makes sense to call <code class="language-plaintext highlighter-rouge">foo.fmt()</code>, since that gets called for you by <code class="language-plaintext highlighter-rouge">println!</code> and friends; not to mention that all of the <code class="language-plaintext highlighter-rouge">std::fmt</code> traits have a method <code class="language-plaintext highlighter-rouge">fmt()</code>, making such a call likely to need disambiguation with UFCS. <code class="language-plaintext highlighter-rouge">Borrow</code> is similar; it exists to be a bound for things like <code class="language-plaintext highlighter-rouge">Cow</code> more than to provide the <code class="language-plaintext highlighter-rouge">.borrow()</code> method.</p> <p>There’s also a third mode, which I will call “extension impls”. These want to inject methods into a type, either to extend it, like <a href="https://docs.rs/itertools/latest/itertools/"><code class="language-plaintext highlighter-rouge">itertools</code></a>, or as part of some framework, like <a href="https://docs.rs/tap/latest/tap/"><code class="language-plaintext highlighter-rouge">tap</code></a>. This use of traits is somewhat controversial, but I can sympathize with wanting to have this.</p> <p>If we have paths-as-methods, we can use this classification to move towards something more like the Carbon model of method lookup, without impacting existing uses.</p> <p>My strawman is to add a <code class="language-plaintext highlighter-rouge">#[mode]</code> attribute to place on trait <code class="language-plaintext highlighter-rouge">impls</code>, which allows a caller to select the behavior:</p> <ul> <li><code class="language-plaintext highlighter-rouge">#[mode(extension)]</code> is today’s behavior. The <code class="language-plaintext highlighter-rouge">impl</code>’s trait must be in scope so that unqualified calls like <code class="language-plaintext highlighter-rouge">foo.method()</code> resolve to it.</li> <li><code class="language-plaintext highlighter-rouge">#[mode(internal)]</code> makes it so that <code class="language-plaintext highlighter-rouge">foo.method()</code> can resolve to a method from this <code class="language-plaintext highlighter-rouge">impl</code> without its trait being in scope<sup id="fnref:internal-restrictions" role="doc-noteref"><a href="#fn:internal-restrictions" class="footnote" rel="footnote">1</a></sup>. It can only be applied to <code class="language-plaintext highlighter-rouge">impl</code>s that are such that you could write a corresponding inherent impl, so things like <code class="language-plaintext highlighter-rouge">#[mode(internal)] impl&lt;T&gt; Trait for T { .. }</code> are forbidden.</li> <li><code class="language-plaintext highlighter-rouge">#[mode(external)]</code> makes it so that <code class="language-plaintext highlighter-rouge">foo.method()</code> never resolves to a method from this <code class="language-plaintext highlighter-rouge">impl</code>. It must be called as <code class="language-plaintext highlighter-rouge">Trait::method(foo)</code> or <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>.</li> </ul> <p>Every trait would be <code class="language-plaintext highlighter-rouge">#[mode(extension)]</code> if not annotated, and it would be easy to migrate to external-by-default across an edition. Similarly, we could change whether a <code class="language-plaintext highlighter-rouge">std</code> impl is external vs extension based on the edition of the caller, and provide a <code class="language-plaintext highlighter-rouge">cargo fix</code> rewrite to convert from <code class="language-plaintext highlighter-rouge">foo.method()</code> to <code class="language-plaintext highlighter-rouge">foo.Trait::method()</code>.</p> <p>It may also make sense for traits to be able to specify the default modality of their <code class="language-plaintext highlighter-rouge">impl</code>s, but I haven’t thought very carefully about this.</p> <p>Note that moving in the external -&gt; extension -&gt; internal direction is not a breaking change, but moving the other way is.</p> <h2 id="what-about-delegation"><a href="#what-about-delegation">What about Delegation?</a></h2> <p>A related feature that I will touch on lightly is delegation; that is, being able to write something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// crate a</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">boing</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// crate b</span>
<span class="k">trait</span> <span class="n">Bar</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">boing</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Bar</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nn">Foo</span><span class="p">::</span><span class="n">boing</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">use</code> in the <code class="language-plaintext highlighter-rouge">impl</code> indicates that we want to re-use <code class="language-plaintext highlighter-rouge">Foo::boing</code> to implement <code class="language-plaintext highlighter-rouge">&lt;Foo as Bar&gt;::boing</code>. This saves us having to write out a function signature, and results in less work for the compiler because that’s one less function we risk asking LLVM to codegen for us (at scale, this is a Big Deal).</p> <p>You could imagine using delegation instead of <code class="language-plaintext highlighter-rouge">#[mode]</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Woofer</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Stringer</span> <span class="k">for</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"woof"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Woofer</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nn">Stringer</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The reason I haven’t gone down this road is because delegation is a very large feature, and doesn’t give us a clean way to express <code class="language-plaintext highlighter-rouge">#[mode(external)]</code>, which is a big part of what I want. A delegation-compatible way to express this proposal is to not add <code class="language-plaintext highlighter-rouge">#[mode(internal)]</code>, and add <code class="language-plaintext highlighter-rouge">use Trait::method;</code> and <code class="language-plaintext highlighter-rouge">use Trait::*;</code> (and no other variations) inside of inherent <code class="language-plaintext highlighter-rouge">impl</code> blocks.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>I don’t have the personal bandwidth to write RFCs for any of this stuff, but it’s something I talk about a lot as a potential evolution hazard for Rust. I hope that putting these ideas to paper can help make name resolution in Rust more robust.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:internal-restrictions" role="doc-endnote"> <p>This needs to carry a bunch of other restrictions, because it’s equivalent to adding inherent methods to the implee. For example, none of the methods can have the same name as a method in any other inherent or internal impl block, and internal impl methods should take lookup priority over extension impl methods during name lookup. <a href="#fnref:internal-restrictions" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="rust"/><category term="language-design"/><summary type="html"><![CDATA[Traits are the core of polymorphism in Rust. Let’s review:]]></summary></entry><entry><title type="html">Atomicless Concurrency</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2023/03/29/rseq-checkout/" rel="alternate" type="text/html" title="Atomicless Concurrency"/><published>2023-03-29T00:00:00-04:00</published><updated>2023-03-29T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2023/03/29/rseq-checkout</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2023/03/29/rseq-checkout/"><![CDATA[<p>Let’s say we’re building an allocator. Good allocators need to serve many threads simultaneously, and as such any lock they take is going to be highly contended. One way to work around this, pioneered by TCMalloc, is to have thread-local caches of blocks (hence, the “TC” - thread cached).</p> <p>Unfortunately threads can be ephemeral, so book-keeping needs to grow dynamically, and large, complex programs (like the Google Search ranking server) can have tens of thousands of threads, so per-thread cost can add up. Also, any time a thread context-switches and resumes, its CPU cache will contain different cache lines – likely the wrong ones. This is because either another thread doing something compeltely different executed on that CPU, or the switched thread <em>migrated</em> to execute on a different core.</p> <p>These days, instead of caching per-thread, TCMalloc uses <em>per-CPU</em> data. This means that book-keeping is fixed, and this is incredibly friendly to the CPU’s cache: in the steady-state, each piece of the data will only ever be read or written to by a single CPU. It also has the amazing property that <em>there are no atomic operations involved</em> in the fast path, because operations on per-CPU data, by definition, do not need to be synchronized with other cores.</p> <p>This post gives an overview of how to build a CPU-local data structure on modern Linux. The exposition will be for x86, but other than the small bits of assembly you need to write, the technique is architecture-independent.</p> <h2 id="the-kernel-primitive"><a href="#the-kernel-primitive">The Kernel Primitive</a></h2> <p>Concurrency primitives require cooperating with the kernel, which is responsible for global scheduling decisions on the system. However, making syscalls is quite expensive; to alieviate this, there has been a trend in Linux to use shared memory as a kernelspace/userspace communication channel.</p> <p><a href="https://en.wikipedia.org/wiki/Futex">Futexes</a> are the classic “cas-with-the-kernel” syscall (I’m assuming basic knowledge of atomic operations like cas in this article). In the happy path, we just need to cas on some memory to lock a futex, and only make a syscall if we need to go to sleep because of contention. The kernel will perform its own cas on this variable if necessary.</p> <p><em>Restartable sequences</em> are another such proto-primitive, which are used for per-CPUuprogramming. The relevant syscall for us, <code class="language-plaintext highlighter-rouge">rseq(2)</code>, was added in Linux 4.18. Its manpage reads</p> <blockquote> <p>A restartable sequence is a sequence of instructions guaranteed to be executed atomically with respect to other threads and signal handlers on the current CPU. If its execution does not complete atomically, the kernel changes the execution flow by jumping to an abort handler defined by userspace for that restartable sequence.</p> </blockquote> <p>A restartable sequence, or “rseq” is a special kind of critical section that the kernel guarantees executes from start to finish without any kind of preemption. If preemption <em>does</em> happen (because of a signal or whatever), userspace observes this as a jump to a special handler for that critical section. Conceptually it’s like handling an exception:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">try</span> <span class="p">{</span>
  <span class="c1">// Per-CPU code here.</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">PremptionException</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Handle having been preempted, which usally just means</span>
  <span class="c1">// "try again".</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>These critical sections are usually of the following form:</p> <ol> <li>Read the current CPU index (the rseq mechanism provides a way to do this).</li> <li>Index into some data structure and do something to it.</li> <li>Complete the operation with a single memory write. This is the “commit”.</li> </ol> <p>All the kernel tells us is that we couldn’t finish successfully. We can always try again, but the critical section needs to be such that executing any prefix of it, up to the commit, has no effect on the data structure. We get no opportunity to perform “partial rollbacks”.</p> <p>In other words, the critical section must be a <em>transaction</em>.</p> <h3 id="enabling-rseq"><a href="#enabling-rseq">Enabling <code class="language-plaintext highlighter-rouge">rseq</code></a></h3> <p>Using rseqs requires turning on support for it for a particular thread; this is what calling <code class="language-plaintext highlighter-rouge">rseq(2)</code> (the syscall) accomplishes.</p> <p>The signature for this syscall looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// This type is part of Linux's ABI.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="n">cpu_id_start</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">cpu_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">crit_sec</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Note: this is a syscall, not an actual Rust function.</span>
<span class="k">fn</span> <span class="nf">rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The syscall registers “the” <code class="language-plaintext highlighter-rouge">Rseq</code> struct for the current thread; there can be at most one, per thread.</p> <p><code class="language-plaintext highlighter-rouge">rseq</code> is a pointer to this struct. <code class="language-plaintext highlighter-rouge">len</code> should be <code class="language-plaintext highlighter-rouge">size_of::&lt;Rseq&gt;()</code>, and <code class="language-plaintext highlighter-rouge">signature</code> can be any 32-bit integer (more on this later). For our purposes, we can ignore <code class="language-plaintext highlighter-rouge">flags</code> on the struct.</p> <p><code class="language-plaintext highlighter-rouge">flags</code> on the syscall, on the other hand, is used to indicate whether we’re unregistering the struct; this is explained below.</p> <p>In the interest of exposition, we’ll call the syscall directly. If you’ve never seen how a Linux syscall is done (on x86), you load the syscall number into <code class="language-plaintext highlighter-rouge">rax</code>, then up to six arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">r10</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code><sup id="fnref:mnemonic" role="doc-noteref"><a href="#fn:mnemonic" class="footnote" rel="footnote">1</a></sup>. We only need the first four.</p> <p>The return value comes out in <code class="language-plaintext highlighter-rouge">rax</code>, which is 0 on success, and a negative of an <code class="language-plaintext highlighter-rouge">errno</code> code otherwise. In particular, we need to check for <code class="language-plaintext highlighter-rouge">EINTR</code> to deal with syscall interruption. (every Linux syscall can be interrupted).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span><span class="p">,</span> <span class="n">unregister</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Perform an open-coded Linux syscall.</span>
  <span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rax</span> <span class="o">=</span> <span class="mi">334</span><span class="p">;</span>  <span class="c1">// rseq(2) syscall number; x86-specific.</span>
    <span class="nd">asm!</span> <span class="p">{</span>
      <span class="s">"syscall"</span><span class="p">,</span>
      <span class="nf">inout</span><span class="p">(</span><span class="s">"rax"</span><span class="p">)</span> <span class="n">rax</span><span class="p">,</span>
      <span class="cm">/* rseq:      */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdi"</span><span class="p">)</span> <span class="n">rseq</span><span class="p">,</span>
      <span class="cm">/* len:       */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rsi"</span><span class="p">)</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;</span><span class="p">(),</span>
      <span class="cm">/* flags:     */</span> <span class="k">in</span><span class="p">(</span><span class="s">"rdx"</span><span class="p">)</span> <span class="n">unregister</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">,</span>
      <span class="cm">/* signature: */</span> <span class="k">in</span><span class="p">(</span><span class="s">"r10"</span><span class="p">)</span> <span class="n">signature</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">match</span> <span class="n">rax</span> <span class="p">{</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>      <span class="c1">// Success, we're done.</span>
      <span class="o">-</span><span class="mi">4</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>  <span class="c1">// EINTR, try again.</span>
      <span class="n">errno</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"error calling rseq(2): {}"</span><span class="p">,</span> <span class="o">-</span><span class="n">errno</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Note the <code class="language-plaintext highlighter-rouge">unregister</code> parameter: this is used to tear down <code class="language-plaintext highlighter-rouge">rseq</code> support on the way out of a thread. Generally, <code class="language-plaintext highlighter-rouge">rseq</code> will be a thread-local, and registration happens at thread startup. Glibc will do this and has a mechanism for acquiring the <code class="language-plaintext highlighter-rouge">rseq</code> pointer. Unfortunately, the glibc I have isn’t new enough to know to do this, so I hacked up something to register my own thread local.</p> <p>I had the bright idea of putting my <code class="language-plaintext highlighter-rouge">Rseq</code> struct in a box, which triggered an interesting bug: when a thread exits, it destroys all of the thread local variables, including the box to hold our <code class="language-plaintext highlighter-rouge">Rseq</code>. But if the thread then syscalls to deallocate its stack, when the kernel goes to resume, it will attempt to write the current CPU index to the <code class="language-plaintext highlighter-rouge">rseq.cpu_id</code> field.</p> <p>This presents a problem, because the kernel is probably going to write to a garbage location. This is all but guaranteed to result in a segfault. Debuggers observe this as a segfault on the instruction right after the <code class="language-plaintext highlighter-rouge">syscall</code> instruction; I spent half an hour trying to figure out what was causing a call to <code class="language-plaintext highlighter-rouge">madvise(2)</code> to segfault.</p> <p>Hence, we need to wrap our thread local in something that will call <code class="language-plaintext highlighter-rouge">rseq(2)</code> to unregister the struct. Putting everything together we get something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">current_thread_rseq</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Rseq</span> <span class="p">{</span>
  <span class="c1">// This has to be its own struct so we can run a thread-exit destructor.</span>
  <span class="k">pub</span> <span class="k">struct</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">Rseq</span><span class="o">&gt;&gt;</span><span class="p">);</span>
  <span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">RseqBox</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="k">true</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nd">thread_local!</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">RSEQ</span><span class="p">:</span> <span class="n">RseqBox</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// Has to be in a box, since we need pointer stability.</span>
      <span class="k">let</span> <span class="n">rseq</span> <span class="o">=</span> <span class="nf">RseqBox</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Rseq</span> <span class="p">{</span>
        <span class="n">cpu_id_start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">cpu_id</span><span class="p">:</span> <span class="o">!</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">crit_sec</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="p">})));</span>

      <span class="c1">// Register it!!!</span>
      <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">raw_rseq</span><span class="p">(</span><span class="n">rseq</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="n">RSEQ_SIG</span><span class="p">);</span> <span class="p">}</span>
      <span class="n">rseq</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="n">RSEQ</span><span class="nf">.with</span><span class="p">(|</span><span class="n">ra</span><span class="p">|</span> <span class="n">ra</span><span class="na">.0</span><span class="nf">.get</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Per Rust’s semantics, this will execute the first time we access this thread local, instead of at thread startup. Not <em>ideal</em>, since now we pay for an (uncontended) atomic read every time we touch RSEQ, but it will do.</p> <h3 id="creating-a-critical-section"><a href="#creating-a-critical-section">Creating a Critical Section</a></h3> <p>To set up and execute a restartable sequence, we need to assemble a struct that describes it. The following struct is also defined by Linux’s syscall ABI:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">32</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CritSec</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="n">abort_handler</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">start</code> is the address of the first instruction in the sequence, and <code class="language-plaintext highlighter-rouge">len</code> is the length of the sequence in bytes. <code class="language-plaintext highlighter-rouge">abort_handler</code> is the address of the abort handler. <code class="language-plaintext highlighter-rouge">version</code> must be 0 and we can ignore <code class="language-plaintext highlighter-rouge">flags</code>.</p> <p>Once we have a value of this struct (on the stack or as a constant), we grab <code class="language-plaintext highlighter-rouge">RSEQ</code> and atomically store the address of our <code class="language-plaintext highlighter-rouge">CritSec</code> to <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code>. This needs to be atomic because the kernel may decide to look at this pointer from a different CPU core, but it likely will not be contended.</p> <p>Note that <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> should be null before we do this; restartable sequences can’t nest.</p> <p>Next time the kernel preempts our thread (and later gets ready to resume it), it will look at <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to decide if it preempted a restartable sequence and, if so, jump to the abort handler.</p> <p>Once we finish our critical section, we must reset <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> to 0.</p> <blockquote> <h4 id="labels-and-constants-oh-my"><a href="#labels-and-constants-oh-my">Labels and Constants, Oh My</a></h4> <p>There is a wrinkle: we would like for our <code class="language-plaintext highlighter-rouge">CritSec</code> value to be a constant, but Rust doesn’t provide us with a way to initialize the <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">abort_handler</code> fields directly, since it doesn’t have a way to refer<sup id="fnref:relocations" role="doc-noteref"><a href="#fn:relocations" class="footnote" rel="footnote">2</a></sup> to the labels (jump targets) inside the inline assembly. The simplest way to get around this is to assemble (lol) the <code class="language-plaintext highlighter-rouge">CritSec</code> on the stack, with inline assembly. The overhead is quite minimal.</p> </blockquote> <p>On x86, this is what our boilerplate will look like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">cs</span> <span class="o">=</span> <span class="nn">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">CritSec</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">uninit</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nd">asm!</span> <span class="p">{</span><span class="s">r"
  // We meed to do `rip`-relative loads so that this code is PIC;
  // otherwise we'll get linker errors. Thus, we can't `mov`
  // directly; we need to compute the address with a `lea`
  // first.

  // Initialize the first two fields to zero.
  mov qword ptr [{_cs}], 0

  // Load `90f` into `cs.start`. Note that this is 'forward
  // reference' to the jump target `90:` below.
  lea {_pc}, [90f + rip]
  mov qword ptr [{_cs} + 8], {_pc}

  // We need to get the difference `91f - 90f` into `cs.len`.
  // To do that, we write `-90f` to it, and then add `91f`.
  neg {_pc}
  mov qword ptr [{_cs} + 16], {_pc}
  lea {_pc}, [91f + rip]
  add qword ptr [{_cs} + 16], {_pc}

  // Same as the first line, but loading `cs.abort_handler`.
  lea {_pc}, [92f + rip]
  mov qword ptr [{_cs} + 24], {_pc}

  // Write `&amp;cs` to `RSEQ.crit_sec`. This turns on
  // restartable sequence handling.
  mov qword ptr [{rseq} + 8], {_cs}

90:
  // Do something cool here (coming soon).

91:
  // Jump over the abort handler.
  jmp 93f

  .int 0x53053053  // The signature!
92:
  // Nothing special, just zero `ok` to indicate this was a failure.
  // This is written this way simply because we can't early-return
  // out of inline assembly.
  xor {_ok:e}, {_ok:e}

93:
  // Clear `RSEQ.crit_sec`, regardless of which exit path
  // we took.
  mov qword ptr [{rseq} + 8], 0
  "</span><span class="p">,</span>
  <span class="n">_pc</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
  <span class="n">_ok</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ok</span><span class="p">,</span>
  <span class="n">_cs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cs</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CritSec</span><span class="p">,</span>
  <span class="n">rseq</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="nf">current_thread_rseq</span><span class="p">(),</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>A few things to note:</p> <ol> <li>Because this is inline assembly, we need to use numeric labels. I’ve chosen labels in the 90s for no particular reason. <code class="language-plaintext highlighter-rouge">90:</code> declares a jump target, and <code class="language-plaintext highlighter-rouge">90f</code> is a forward reference to that instruction address.</li> <li>Most of this assembly is just initalizing a struct<sup id="fnref:cs-init" role="doc-noteref"><a href="#fn:cs-init" class="footnote" rel="footnote">3</a></sup>. It’s not until the <code class="language-plaintext highlighter-rouge">mov</code> right before <code class="language-plaintext highlighter-rouge">90:</code> (the critical section start) that anything interesting happens.</li> <li>Immediately before <code class="language-plaintext highlighter-rouge">92:</code> (the abort handler) is an <code class="language-plaintext highlighter-rouge">.int</code> directive that emits the same four-byte signature we passed to <code class="language-plaintext highlighter-rouge">rseq(2)</code> into the instruction stream. This <em>must</em> be here, otherwise the kernel will issue a segfault to the thread. This is a very basic control-flow integrity feature.</li> <li>We clear <code class="language-plaintext highlighter-rouge">RSEQ.crit_sec</code> at the very end.</li> </ol> <p>This is a lot of boilerplate. In an ideal world, we could have something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">run_rseq</span><span class="p">(</span><span class="n">cs</span><span class="p">:</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">unsafe</span> <span class="k">fn</span><span class="p">(</span><span class="nb">u32</span><span class="p">));</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this is very hard to do, because the constraints on restartable sequences are draconian:</p> <ul> <li>Can’t jump out of the critical section until it completes or aborts. This means you can’t call functions or make syscalls!</li> <li>Last instruction must be the commit, which is a memory store operation, <em>not</em> a return.</li> </ul> <p>This means that you can’t have the compiler generating code for you; it might outline things or move things around in ways you don’t want. In something like ASAN mode, it might inject function calls that will completely break the primitive.</p> <p>This means we muyst write our critical section in assembly. That assembly also almost unavoidably needs to be part of the boilerplate given above, and it means it can’t participate in ASAN or TSAN instrumentation.</p> <p>In the interest of exposition, we can build a wrapper over this inline assembly boilerplate that looks something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
    // Assembly for our critical section...
  "</span><span class="p">,</span>
  <span class="c1">// Inline asm constraints.</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>When I wrote the snippet above, I chose numeric labels in the 90s to avoid potential conflicts with whatever assembly gets pasted here. This is also why I used a leading <code class="language-plaintext highlighter-rouge">_</code> on the names of some of the assembly constraints; thise are private to the macro. <code class="language-plaintext highlighter-rouge">rseq</code> isn’t, though, since callers will want to access the CPU id in it.</p> <p>The intent is for the assembly string to be pasted over the <code class="language-plaintext highlighter-rouge">// Do something cool here</code> comment, and for the constraints to be tacked on after the boilerplate’s constraints.</p> <p>But with that we now have access to the full rseq primitive, in slightly sketchy macro form. Let’s use it to build a CPU-local data structure.</p> <h2 id="a-checkout-desk"><a href="#a-checkout-desk">A Checkout Desk</a></h2> <p>Let’s say we have a pool of objects that are needed to perform an allocation, our putative page caches. Let’s say we have the following interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">FreeList</span> <span class="p">{</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">get_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">return_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">get_cache()</code> grabs a cache of pages off the global free list. This requires taking a lock or traversing a lockless linked list, so it’s pretty expensive. <code class="language-plaintext highlighter-rouge">return_cache()</code> returns a cache back to the global free list for re-use; it is a similarly expensive operation. Both of these operations are going to be contended like crazy, so we want to memoize them.</p> <p>To achieve this, we want one slot for every CPU to hold the cache it (or rather, a thread running on it) most recently acquired, so that it can be reused. These slots will have “checkout desk” semantics: if you take a thing, you must put something in its place, even if it’s just a sign that says you took the thing.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/golden-idol.gif" alt=""/></p> </figure> <p><a href="https://fowles.github.io/">Matthew Kulukundis</a> came up with this idea, and he’d totally put this gif in a slide deck about this data structure.</p> <p>As a function signature, this is what it looks like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We can then use it like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">free_list</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FreeList</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">per_cpu</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">PageCache</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">iou</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">PageCache</span><span class="p">;</span>

<span class="c1">// Check out this CPU's cache pointer, and replace it with</span>
<span class="c1">// an IOU note (a null pointer).</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">iou</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">==</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// If we got an IOU ourselves, this means another thread that</span>
  <span class="c1">// was executing on this CPU took the cache and left *us* with</span>
  <span class="c1">// a null, so we need to perform the super-expensive operation</span>
  <span class="c1">// to acquire a new one.</span>
  <span class="n">cache</span> <span class="o">=</span> <span class="n">free_list</span><span class="nf">.get_cache</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Do stuff with `cache` here. We have unique access to it.</span>
<span class="n">cache</span><span class="nf">.alloc_page</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

<span class="c1">// Return the pointer to the checkout desk.</span>
<span class="n">cache</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="nf">.checkout</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cache</span> <span class="o">!=</span> <span class="n">iou</span> <span class="p">{</span>
  <span class="c1">// Usually, we expect to get back the IOU we put into the cache.</span>
  <span class="c1">// If we don't, that probably means another thread (or</span>
  <span class="c1">// hundreds) are hammering this slot and fighting for page caches.</span>
  <span class="c1">// If this happens, we need to throw away the cache.</span>
  <span class="n">free_list</span><span class="nf">.return_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The semantics of <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> is that it is an array of <code class="language-plaintext highlighter-rouge">nprocs</code> (the number of logical cores on the system) pointers, all initialized to null. <code class="language-plaintext highlighter-rouge">checkout()</code> swaps the pointer stored in the current CPU’s slot in the <code class="language-plaintext highlighter-rouge">PerCpu&lt;T&gt;</code> with the replacement argument.</p> <h3 id="building-the-checkout-desk"><a href="#building-the-checkout-desk">Building the Checkout Desk</a></h3> <p>The implementation of this type is relatively simple, but the devil is in the details. Naively, you’d think you literally want an array of pointers:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Unfortunately, this is cache-hostile. We expect that (depending on how <code class="language-plaintext highlighter-rouge">ptrs</code> is aligned in memory) for eight CPUs’ checkout pointers to be on the same cache line. This means eight separate cores are going to be writing to the same cache line, which is going to result in a lot of cache thrash. This memory wants to be in L1 cache, but will probably wind up mostly in shared L3 cache.</p> <p>This effect is called “false sharing”, and is a fundamental part of the design of modern processors. We have to adjust for this.</p> <p>Instead, we want to give each core a full cache line (64 bytes aligned to a 64-byte boundary) for it to store its pointer in. This sounds super wasteful (56 of those bytes will go unused), but this is the right call for a perf-sensitive primitive.</p> <p>This amount of memory can add up pretty fast (two whole pages of memory for a 128-core server!), so we’ll want to lazilly initialize them. Our cache-friendly struct will look more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">ptrs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">AtomicPtr</span><span class="o">&lt;</span><span class="n">CacheLine</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// This struct wraps a T and forces it to take up an entire cache line.</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">64</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">CacheLine</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Initializing it requires finding out how many cores there are on the machine. This is a… fairly platform-specific affair. Rust <em>does</em> offer a “maximum paralellism” query in its standard library, but it is intended as a hint for how many worker threads to spawn, as opposed to a hard upper bound on the number of CPU indices.</p> <p>Instead, we call <code class="language-plaintext highlighter-rouge">get_nprocs_conf()</code>, which is fine since we’re already extremely non-portable already. This is a GNU libc extension.</p> <p>In code…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
      <span class="c1">// #include &lt;sys/sysinfo.h&gt;</span>
      <span class="c1">//</span>
      <span class="c1">// This function returns the maximum number of cores the</span>
      <span class="c1">// kernel knows of for the current machine. This function</span>
      <span class="c1">// is very expensive to call, so we need to cache it.</span>
      <span class="k">fn</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">mut</span> <span class="n">NPROCS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">INIT</span><span class="p">:</span> <span class="n">Once</span> <span class="o">=</span> <span class="nn">Once</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">INIT</span><span class="nf">.call_once</span><span class="p">(||</span> <span class="k">unsafe</span> <span class="p">{</span>
      <span class="n">NPROCS</span> <span class="o">=</span> <span class="nf">get_nprocs_conf</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">NPROCS</span> <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="p">{</span>
      <span class="n">ptrs</span><span class="nf">.push</span><span class="p">(</span><span class="nn">AtomicPtr</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">Self</span> <span class="p">{</span> <span class="n">ptrs</span><span class="p">:</span> <span class="n">ptrs</span><span class="nf">.into_boxed_slice</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(I’m not going to implement <code class="language-plaintext highlighter-rouge">Drop</code> for this type. That’s an exercise for the reader.)</p> <h3 id="implementing-checkout"><a href="#implementing-checkout">Implementing <code class="language-plaintext highlighter-rouge">checkout()</code></a></h3> <p>Now’s the moment we’ve all be waiting for: writing our restartable sequence. As critical sections go, this one’s pretty simple:</p> <ol> <li>Index into the <code class="language-plaintext highlighter-rouge">ptrs</code> array to get this CPU’s pointer-to-cache-line.</li> <li>If that pointer is null, bail out of the rseq and initialize a fresh cache line (and then try again).</li> <li>If it’s not null, swap <code class="language-plaintext highlighter-rouge">replacement</code> with the value in the cache line.</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PerCpu</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">replacement</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
    <span class="c1">// We need to try this operation in a loop, to deal with</span>
    <span class="c1">// rseq aborts.</span>
    <span class="k">loop</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="nf">.as_ptr</span><span class="p">();</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">vcpu</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">need_alloc</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RseqAbort</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">rseq!</span> <span class="p">{</span><span class="s">r"
        // Load the current CPU number.
        mov {vcpu:e}, dword ptr [{rseq} + 4]

        // Load the `vcpu`th pointer from `ptrs`.
        // On x86, `mov` is atomic. The only threads we might
        // be condending with are those that are trying to
        // initialize this pointer if it's null.
        mov {scratch}, qword ptr [{ptrs} + 8 * {vcpu:r}]

        // If null, exit early and trigger an allocation
        // for this vcpu.
        test {scratch}, {scratch}
        jz 1f

        // Make sure the outer code knows not to allocate
        // a new cache line.
        xor {need_alloc:e}, {need_alloc:e}

        // Commit the checkout by exchanging `replacement`.
        xchg {ptr}, qword ptr [{scratch}]
      1:
        "</span><span class="p">,</span>
        <span class="n">ptrs</span> <span class="o">=</span> <span class="k">in</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">ptrs</span><span class="p">,</span>
        <span class="n">scratch</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">_</span><span class="p">,</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">replacement</span><span class="p">,</span>
        <span class="n">vcpu</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">vcpu</span><span class="p">,</span>
        <span class="n">need_alloc</span> <span class="o">=</span> <span class="nf">inout</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">need_alloc</span><span class="p">,</span>
      <span class="p">};</span>

      <span class="c1">// We got preempted, so it's time to try again.</span>
      <span class="k">if</span> <span class="n">result</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>

      <span class="c1">// If we don't need to allocate, we're done.</span>
      <span class="k">if</span> <span class="n">need_alloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="n">replacement</span> <span class="p">}</span>

      <span class="c1">// Otherwise, allocate a new cache line and cas it into</span>
      <span class="c1">// place. This is Atomics 101, nothing fancy.</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache_line</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">CacheLine</span><span class="p">(</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()));</span>
      <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cas</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ptrs</span><span class="p">[</span><span class="n">vcpu</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span><span class="nf">.compare_exchange_weak</span><span class="p">(</span>
          <span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span> <span class="n">cache_line</span><span class="nf">.as_mut</span><span class="p">(),</span>
          <span class="nn">Ordering</span><span class="p">::</span><span class="n">AcqRel</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="k">match</span> <span class="n">cas</span> <span class="p">{</span>
          <span class="nf">Ok</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Successful allocation.</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_null</span><span class="p">());</span>
            <span class="c1">// Make sure to stop `cache_line`'s memory</span>
            <span class="c1">// from being freed by `Box`'s dtor.</span>
            <span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">cache_line</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Try again: this is a spurious failure.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="nf">.is_null</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
          <span class="c1">// Someone got here first; we can just discard</span>
          <span class="c1">// `Box`.</span>
          <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This code listing is a lot to take in. It can be broken into two parts: the restartable sequence itself, and the allocation fallback if the pointer-to-cache-line happens to be null.</p> <p>The restartable sequence is super short. It looks at the pointer-to-cache-line, bails if its null (this triggers the later part of the function) and then does an <code class="language-plaintext highlighter-rouge">xchg</code> between the actual <code class="language-plaintext highlighter-rouge">*mut T</code> in the per-CPU cache line, and the replacement.</p> <p>If the rseq aborts, we just try again. This is short enough that preemption in the middle of the rseq is quite rare. Then, if <code class="language-plaintext highlighter-rouge">need_alloc</code> was zeroed, that means we successfully committed, so we’re done.</p> <p>Otherwise we need to allocate a cache line for this CPU. We’re now outside of the rseq, so we’re back to needing atomics. Many threads might be racing to be the thread that initializes the pointer-to-cache-line; we use a basic cas loop to make sure that we only initialize from null, and if someone beats us to it, we don’t leak the memory we had just allocated. This is an RMW operation, so we want both acquire and release ordering. Atomics 101!</p> <p>Then, we try again. Odds are good we won’t have migrated CPUs when we execute again, so we won’t need to allocate again. Eventually all of the pointers in the <code class="language-plaintext highlighter-rouge">ptrs</code> array will be non-null, so in the steady state this <code class="language-plaintext highlighter-rouge">needs_alloc</code> case doesn’t need to happen.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is just a glimpse of what per-CPU concurrent programming looks like. I’m pretty new to it myself, and this post was motivated by building an end-to-end example in Rust. You can read more about how TCMalloc makes use of restartable sequences <a href="https://google.github.io/tcmalloc/rseq.html">here</a>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:mnemonic" role="doc-endnote"> <p>This is annoyingly <em>different</em> from the function calling convention, which passes arguments in <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, with the mnemonic “Diana’s silk dress cost $89.” I don’t know a cute mnemonic for the syscall registers. <a href="#fnref:mnemonic" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:relocations" role="doc-endnote"> <p>It’s actually worse than that. You’d think you could do</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">jmp</span> <span class="n">foo</span>
<span class="n">pointers</span><span class="o">:</span>
  <span class="p">.</span><span class="kt">int</span> <span class="n">foo</span>

<span class="n">foo</span><span class="o">:</span>
  <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">pointers</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>but this makes the resulting code non-position-independent on x86. What this means is that the code must know at link time what address it will be loaded at, which breaks the position-independent requirement of many modern platforms.</p> <p>Indeed, this code will produce a linker error like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">= note: /usr/bin/ld: /home/mcyoung/projects/cpulocal/target/debug/deps/cpulocal-a7eeabaf0b1f2c43.2l48u2rfiak1q1ik.rcgu.o:
      relocation R_X86_64_32 against `.text._ZN8cpulocal15PerCpu$LT$T$GT$8checkout17h42fde3ce3bd0180aE'
      can not be used when making a PIE object; recompile with -fPIE
      collect2: error: ld returned 1 exit status</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Not only is <code class="language-plaintext highlighter-rouge">.int foo</code> a problem, but so is referring to <code class="language-plaintext highlighter-rouge">pointers</code>. Instead we must write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">lea</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">pointers</span> <span class="o">+</span> <span class="n">rip</span><span class="p">]</span>
<span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>to be able to load the address of <code class="language-plaintext highlighter-rouge">pointers</code> at all. This <em>can</em> be worked around if you’re smart; after all, it is possible to put the addresses of functions into static variables and not have the linker freak out. It’s too hard to do in inline assembly tho. <a href="#fnref:relocations" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:cs-init" role="doc-endnote"> <p>Basically this code, which can’t be properly-expressed in Rust.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">CrtiticalSection</span> <span class="p">{</span>
  <span class="n">version</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">flags</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">start</span><span class="p">:</span> <span class="cm">/* &amp;90f */</span><span class="p">,</span>
  <span class="n">len</span><span class="p">:</span> <span class="cm">/* &amp;91f - &amp;90f */</span><span class="p">,</span>
  <span class="n">abort</span><span class="p">:</span> <span class="cm">/* &amp;92f */</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><a href="#fnref:cs-init" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="dark-arts"/><category term="assembly"/><category term="concurrency"/><category term="rust"/><summary type="html"><![CDATA[Let’s say we’re building an allocator. Good allocators need to serve many threads simultaneously, and as such any lock they take is going to be highly contended. One way to work around this, pioneered by TCMalloc, is to have thread-local caches of blocks (hence, the “TC” - thread cached).]]></summary></entry><entry><title type="html">3Hz Computer, Hold the Transistors</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2022/07/24/curta/" rel="alternate" type="text/html" title="3Hz Computer, Hold the Transistors"/><published>2022-07-24T00:00:00-04:00</published><updated>2022-07-24T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2022/07/24/curta</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2022/07/24/curta/"><![CDATA[<p>I’m not really one to brag publicly about expensive toys, but a few weeks ago I managed to get one that’s really something special. It is a <em>Curta Type II</em>, a mechanical digital<sup id="fnref:mech-digital" role="doc-noteref"><a href="#fn:mech-digital" class="footnote" rel="footnote">1</a></sup> calculator manufactured in Liechtenstein between the 50s and 70s, before solid-state calculators killed them and the likes of slide-rules.</p> <p>I have wanted one since I was a kid, and I managed to win an eBay auction for one.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/with_case.jpg" alt="The Curta"/></p> <figcaption>The Curta Type II (and Solomon the cat)</figcaption> </figure> <p>It’s a funny looking device, somewhere between a peppermill and a scifi grenade. Mine has serial number 544065, for those keeping score, and comes in a cute little bakelite pod (which has left hand thread?!).</p> <p>I wanna talk about this thing because unlike something like a slide rule, it shares many features with modern computers. It has operations, flags, and registers. Its core primitive is an adder, but many other operations can be built on top of it: it is very much a platform for complex calculations.</p> <p>I’m the sort of person who read <em>Hacker’s Delight</em> for fun, so I really like simple numerical algorithms. This article is a survey of the operation of a Curta calculator and algorithms you can implement on it, from the perspective of a professional assembly programmer.</p> <p>Many of the algorithms I’m going to describe here exist online, but I’ve found them to be a bit difficult to wrap my head around, so this article is also intended as a reference card for myself.</p> <p>Let’s dive in!</p> <h2 id="a-well-lubricated-alu"><a href="#a-well-lubricated-alu">A Well-Lubricated ALU</a></h2> <p>There are two Curta models, Type I and Type II, which primarily differ in the sizes of their registers. I have a Type II, so I will focus on the layout of that one.</p> <p>The Curta is not a <em>stored program</em> computer like the one you’re reading this article on. An operator needs to manually execute operations. It is as if we had taken a CPU and pared it down to two of its most basic components: a register file and an arithmetic logic unit (ALU).</p> <h3 id="the-register-file"><a href="#the-register-file">The Register File</a></h3> <p>The Curta’s register file consists of three digital registers, each of which contains a decimal integer (i.e., each digit is from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">9</code>, rather than <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">1</code> like on a binary computer):</p> <ul> <li><code class="language-plaintext highlighter-rouge">sr</code>, the <em>setting register</em>, is located on the side of the device. The value in <code class="language-plaintext highlighter-rouge">sr</code> can be set manually by the operator using a set of knobs on the side of the device. The machine will never write to it, only read from it. It has 11 digits.</li> <li><code class="language-plaintext highlighter-rouge">rr</code>, the <em>results register</em>, is located at the top of the device along the black part of the dial. It is readable and writable by the machine, but not directly modifiable by the operator. It has 15 digits.</li> <li><code class="language-plaintext highlighter-rouge">cr</code>, the <em>counting register</em>, is located next to <code class="language-plaintext highlighter-rouge">rr</code> along the silver part of the dial. Like <code class="language-plaintext highlighter-rouge">rr</code>, it is only machine-modifiable. It has 8 digits.</li> </ul> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/sr.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">sr</code>, set to <code class="language-plaintext highlighter-rouge">1997</code>.</p> </figcaption> </figure> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/cr_rr.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">rr</code> is the black dial; <code class="language-plaintext highlighter-rouge">cr</code> is the silver one.</p> </figcaption> </figure> <p>There are also two settings on the device that aren’t really registers, but, since they are changed as part of operation, they are a lot like the control registers of a modern computer.</p> <p>The <em>carriage</em> (there isn’t an abbreviation for this one, so I’ll call it <code class="language-plaintext highlighter-rouge">ca</code>) is the upper knurled ring on the machine. It can be set to a value from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">7</code><sup id="fnref:one-index" role="doc-noteref"><a href="#fn:one-index" class="footnote" rel="footnote">2</a></sup>. To set it, the operator lifts the ring up (against spring tension), twists it, and lets it spring back into the detent for the chosen value. This is a one-hand motion.</p> <p>There is a small triangle in the middle of the top of the device that points at which of the digits in <code class="language-plaintext highlighter-rouge">cr</code> will get incremented.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/ca.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">ca</code> raised and in motion.</p> </figcaption> </figure> <p>Finally, <code class="language-plaintext highlighter-rouge">rl</code>, the <em>reversing lever</em>, is a small switch near the back of the device that can be in the up or down position. This is like a flag register: up is cleared, down is set.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/rl.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">rl</code> in the up position.</p> </figcaption> </figure> <h3 id="the-instruction-set"><a href="#the-instruction-set">The Instruction Set</a></h3> <p>We have all this memory, but the meat of a machine is what it can <em>do</em>. I will provide an <em>instruction set</em> for the Curta to aid in giving rigorous descriptions of operations you can perform with it.</p> <p>The core operation of the Curta is “add-with-shift-and-increment”. This is a mouthful. At the very top of the machine is the handle, which is analogous to a clock signal pin. Every clockwise turn of this handle executes one of these operations. Internally, this is implemented using a variation on the <a href="https://en.wikipedia.org/wiki/Leibniz_wheel">Leibniz gear</a>, a common feature of mechanical calculators.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/pturn.jpg" alt=""/></p> <figcaption>The handle in "addition" mode.</figcaption> </figure> <p>This operation is not that complicated, it just does a lot of stuff. It takes the value of <code class="language-plaintext highlighter-rouge">sr</code>, left-shifts it (in decimal) by the value in <code class="language-plaintext highlighter-rouge">ca</code>, and adds it to <code class="language-plaintext highlighter-rouge">rr</code>. Also, it increments <code class="language-plaintext highlighter-rouge">CR</code> by <code class="language-plaintext highlighter-rouge">1</code> shifted by <code class="language-plaintext highlighter-rouge">ca</code>. In other words:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">rr += sr &lt;&lt; ca
cr += 1 &lt;&lt; ca</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Recall that this is a decimal machine, so <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> is the same as multiplication by a power of 10, not a power of 2.</p> <p>Addition can overflow, and it wraps around as expected: adding one to <code class="language-plaintext highlighter-rouge">999_999_999_999_999_999</code> already in <code class="language-plaintext highlighter-rouge">rr</code> will fill it with zeroes.</p> <p>Pulling the handle up reveals a red ring, indicating the machine is in <em>subtraction mode</em>. This flips the signs of both the <code class="language-plaintext highlighter-rouge">rr</code> and <code class="language-plaintext highlighter-rouge">cr</code> modifications:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">rr -= sr &lt;&lt; ca
cr -= 1 &lt;&lt; ca</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/mturn.jpg" alt=""/></p> <figcaption>The handle in "subtraction" mode.</figcaption> </figure> <p>The Curta cannot handle negative numbers, so it will instead display the ten’s complement<sup id="fnref:10s-cmp" role="doc-noteref"><a href="#fn:10s-cmp" class="footnote" rel="footnote">3</a></sup> of a negative result. For example, subtracting <code class="language-plaintext highlighter-rouge">1</code> from <code class="language-plaintext highlighter-rouge">0</code> will produce all-nines.</p> <p>You can detect when underflow or overflow occurs when the resulting value is unexpectedly larger or smaller than the prior value in <code class="language-plaintext highlighter-rouge">rr</code>, respectively. (This trick is necessary on architectures that lack a carry flags register, like RISC-V.)</p> <p>Setting <code class="language-plaintext highlighter-rouge">rl</code> will reverse the sign of the operation done on <code class="language-plaintext highlighter-rouge">cr</code> during a turn of the handle. In addition mode, it will cause <code class="language-plaintext highlighter-rouge">cr</code> to be subtracted from, while in subtraction mode, it will cause it to be added to. Some complex algorithms make use of this.</p> <p>Finally, the <em>clearing lever</em> can be used to clear (to zero) <code class="language-plaintext highlighter-rouge">sr</code> or <code class="language-plaintext highlighter-rouge">rr</code>, independently. It is a small ring-shaped lever that, while the carriage is raised, can be wiped past digits to clear them. Registers cannot be partially cleared.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/pturn.jpg" alt=""/></p> <figcaption>The clearing lever.</figcaption> </figure> <h3 id="notation"><a href="#notation">Notation</a></h3> <p>Let’s give names to all the instructions the operator needs to follow, so we can write some assembly:</p> <ul> <li><code class="language-plaintext highlighter-rouge">mr</code>, or <em>Machine Ready!</em>, means to clear/zero every register. All Curta instructions use the term “Machine Ready” to indicate the beginning of a calculation session.</li> <li><code class="language-plaintext highlighter-rouge">pturn</code> is the core addition operation, a “plus turn”.</li> <li><code class="language-plaintext highlighter-rouge">mturn</code> is its subtraction twin, a “minus turn”.</li> <li><code class="language-plaintext highlighter-rouge">set &lt;flag&gt;</code> requests the operator set one of <code class="language-plaintext highlighter-rouge">rl</code> or <code class="language-plaintext highlighter-rouge">sm</code>.</li> <li><code class="language-plaintext highlighter-rouge">clr &lt;flag&gt;</code> is the opposite of <code class="language-plaintext highlighter-rouge">set</code>.</li> <li><code class="language-plaintext highlighter-rouge">zero &lt;reg&gt;</code> request a clear of one of <code class="language-plaintext highlighter-rouge">rr</code> or <code class="language-plaintext highlighter-rouge">cr</code> using the clearing lever.</li> <li><code class="language-plaintext highlighter-rouge">add &lt;reg&gt;, &lt;imm&gt;</code> requests manual addition of an immediate to <code class="language-plaintext highlighter-rouge">sr</code> or <code class="language-plaintext highlighter-rouge">ca</code>. This is limited by what mental math we can ask of the operator.</li> <li><code class="language-plaintext highlighter-rouge">copy &lt;reg&gt;, sr</code> requests a copy of the value in <code class="language-plaintext highlighter-rouge">rr</code> or <code class="language-plaintext highlighter-rouge">cr</code> to <code class="language-plaintext highlighter-rouge">sr</code>.</li> <li><code class="language-plaintext highlighter-rouge">wrnp &lt;reg&gt;, &lt;symbol&gt;</code> indicates we need to write down a value in any register to a handy notepad (hence <code class="language-plaintext highlighter-rouge">wr</code>ite <code class="language-plaintext highlighter-rouge">n</code>ote<code class="language-plaintext highlighter-rouge">p</code>ad), marked with <code class="language-plaintext highlighter-rouge">&lt;symbol&gt;</code>.</li> <li><code class="language-plaintext highlighter-rouge">rdnp &lt;reg&gt;, &lt;symbol&gt;</code> asks the operator to <code class="language-plaintext highlighter-rouge">re</code>ad a value recorded with <code class="language-plaintext highlighter-rouge">wrnp</code>.</li> <li><code class="language-plaintext highlighter-rouge">if &lt;cond&gt;, &lt;label&gt;</code> asks the operator to check a condition (in terms of <code class="language-plaintext highlighter-rouge">cr</code>, <code class="language-plaintext highlighter-rouge">rr</code>, and <code class="language-plaintext highlighter-rouge">sr</code>) and, if true, proceed to the instruction at the given <code class="language-plaintext highlighter-rouge">label:</code>. Here’s some examples of conditions we’ll use: <ul> <li><code class="language-plaintext highlighter-rouge">rr == 42</code>, i.e., <code class="language-plaintext highlighter-rouge">rr</code> equals some constant value.</li> <li><code class="language-plaintext highlighter-rouge">rr.ovflow</code>, i.e., <code class="language-plaintext highlighter-rouge">rr</code> overflowed/underflowed due to the most recent <code class="language-plaintext highlighter-rouge">pturn</code>/<code class="language-plaintext highlighter-rouge">mturn</code>.</li> <li><code class="language-plaintext highlighter-rouge">cr[1] == 9</code>, i.e. <code class="language-plaintext highlighter-rouge">cr</code>’s second digit (zero-indexed, not like the physical device!) equals <code class="language-plaintext highlighter-rouge">9</code>.</li> <li><code class="language-plaintext highlighter-rouge">cr[0..ca] &lt; sr[0..ca]</code>, i.e., <code class="language-plaintext highlighter-rouge">cr</code>, considering only the digits up to the setting of <code class="language-plaintext highlighter-rouge">ca</code>, is less than those same digits in <code class="language-plaintext highlighter-rouge">sr</code>.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">goto &lt;label&gt;</code> is like <code class="language-plaintext highlighter-rouge">if</code> without a condition.</li> <li><code class="language-plaintext highlighter-rouge">done</code> means we’re done and the result can be read off of <code class="language-plaintext highlighter-rouge">rr</code> (or <code class="language-plaintext highlighter-rouge">cr</code>).</li> </ul> <p>Note that there is a lot of mental math in some of the conditions. Algorithms on the Curta are aimed to minimize what work the operator needs to do to compute a result, but remember that it is only an ALU: all of the control flow logic needs to be provided by the human operator.</p> <p>None of this is real code, and it is specifically for the benefit of readers.</p> <h2 id="some-algorithms"><a href="#some-algorithms">Some Algorithms</a></h2> <p>So, addition and subtraction are easy, because there are hardware instructions for those. There is, however, no direct way to do multiplication or division. Let’s take a look at some of our options.</p> <p>Given that a Curta is kinda expensive, you can try out an online simulator if you want to follow along. <a href="https://www.cailliau.org/en/Alphabetical/C/Computing/Curta/Simulator/">This one</a> is pretty simple and runs in your browser.</p> <h3 id="multiplication"><a href="#multiplication">Multiplication</a></h3> <p>The easiest way to do multiplication is by repeated addition; <code class="language-plaintext highlighter-rouge">cr</code> helps us check our work.</p> <p>Given a value like <code class="language-plaintext highlighter-rouge">8364</code>, we can multiply it by <code class="language-plaintext highlighter-rouge">5</code> like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">mul_by_5:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">8364</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="mi">5</span><span class="p">,</span> <span class="n">end</span>
    <span class="n">pturn</span>
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Here, we input the larger factor into <code class="language-plaintext highlighter-rouge">sr</code>, and then keep turning until <code class="language-plaintext highlighter-rouge">cr</code> contains the other factor. The result is <code class="language-plaintext highlighter-rouge">41820</code>:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/mul.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">8364 * 5 == 41820</code></p> </figcaption> </figure> <p>Of course, this does not work well for complex products, such as squaring <code class="language-plaintext highlighter-rouge">41820</code>. You could sit there and turn the handle forty thousand times if you wanted to, or you might decided that you should get a better hobby, since modern silicon can do this in nanoseconds.</p> <p>We can speed this up exponentially by making use of the distributive property and the fact that <code class="language-plaintext highlighter-rouge">turn</code> can incorporate multiplication by a power of <code class="language-plaintext highlighter-rouge">10</code>.</p> <p>Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">41820 * 41820
= 41820 * (40000 + 1000 + 800 + 20)
= 41820 * 40000 + 41820 * 1000 + 41820 * 800 + 41820 * 20</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Each nice round number here can be achieved in <code class="language-plaintext highlighter-rouge">cr</code> by use of <code class="language-plaintext highlighter-rouge">ca</code>. Our algorithm will look a bit like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="c1">// Check if we're done.</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="mi">41820</span><span class="p">,</span> <span class="n">end</span>
  <span class="n">inner</span><span class="o">:</span>
      <span class="c1">// Turn until the first `ca` digits of `cr` and the</span>
      <span class="c1">// other factor match.</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="mi">41802</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">ca</span><span class="p">],</span> <span class="n">inner_end</span>
      <span class="n">pturn</span>
      <span class="k">goto</span>  <span class="n">inner</span>
  <span class="n">inner_end</span><span class="o">:</span>
    <span class="c1">// Increment `ca` and repeat until done.</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span> 
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>There are two loops. The inner loop runs as many turns as is necessary to get the next prefix of the factor into <code class="language-plaintext highlighter-rouge">cr</code>, then incrementing <code class="language-plaintext highlighter-rouge">ca</code> to do the next digit, and on and on until <code class="language-plaintext highlighter-rouge">cr</code> contains the entire other factor, at which point we can read off the result.</p> <p>The actual trace of operations (omitting control flow), and the resulting contents of the registers <code class="language-plaintext highlighter-rouge">sr/rr/mr/ca</code> at each step, looks something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="c1">// 00000041820/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000000000/00000000/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000418200/00000010/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000083640/00000020/1</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000083640/00000020/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000005018400/00000120/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000009200400/00000220/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000013382400/00000320/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000017564400/00000420/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000021746400/00000520/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000025928400/00000620/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000030110400/00000720/2</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000034292400/00000820/2</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000034292400/00000820/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000076112400/00001820/3</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000494312400/00011820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000912512400/00021820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001330712400/00031820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001748912400/00041820/4</span>
<span class="n">pturn</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>The result can be read off from <code class="language-plaintext highlighter-rouge">rr</code>: <code class="language-plaintext highlighter-rouge">1748912400</code>. In the trace, you can see <code class="language-plaintext highlighter-rouge">cr</code> get built up digit by digit, making this operation rather efficient.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/square.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">41820 * 41820 == 1748912400</code></p> </figcaption> </figure> <p>We can do even better, if we use subtraction. For example, note that <code class="language-plaintext highlighter-rouge">18 = 20 - 2</code>; we can build up <code class="language-plaintext highlighter-rouge">18</code> in <code class="language-plaintext highlighter-rouge">cr</code> by doing only 4 turns rather than nine, according to this formula. Here’s the general algorithm for <code class="language-plaintext highlighter-rouge">n * m</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">mul:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="n">n</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">cr</span> <span class="o">==</span> <span class="n">m</span><span class="p">,</span> <span class="n">end</span>
    <span class="c1">// Same as before, but if the next digit is large,</span>
    <span class="c1">// go into subtraction mode.</span>
    <span class="k">if</span>    <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_sub</span>
  <span class="n">inner</span><span class="o">:</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">ca</span><span class="p">],</span> <span class="n">inner_end</span>
      <span class="n">pturn</span>
      <span class="k">goto</span>  <span class="n">inner</span>
  <span class="n">by_sub</span><span class="o">:</span>
    <span class="c1">// Store the current `ca` position.</span>
    <span class="n">wrnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">sub_from</span>
    <span class="c1">// Find the next small digit (eg. imagine n * 199, we</span>
    <span class="c1">// want to find the 1).</span>
  <span class="n">find_small</span><span class="o">:</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span>
    <span class="k">if</span>    <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">find_small</span>
    <span class="c1">// Set the digit to one plus the desired value for that</span>
    <span class="c1">// digit.</span>
  <span class="n">outer_turns</span><span class="o">:</span>
    <span class="n">pturn</span>
    <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">outer_turns</span>
    <span class="c1">// Store how far we need to re-advance `ca`.</span>
    <span class="n">wrnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">continue_from</span>
    <span class="c1">// Go back to the original `ca` position and enter</span>
    <span class="c1">// subtraction mode.</span>
    <span class="n">rdnp</span>  <span class="n">ca</span><span class="p">,</span>   <span class="n">sub_from</span>
  <span class="n">subs</span><span class="o">:</span>
  <span class="n">subs_inner</span><span class="o">:</span>
      <span class="c1">// Perform subtractions until we get the value we want.</span>
      <span class="k">if</span>    <span class="n">cr</span><span class="p">[</span><span class="n">ca</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="n">ca</span><span class="p">],</span>  <span class="n">subs_end</span>
      <span class="n">mturn</span>
      <span class="k">goto</span>  <span class="n">subs_inner</span>
  <span class="n">subs_end</span><span class="o">:</span>
    <span class="c1">// Advance `ca` and keep going until we're done.</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span>
    <span class="k">if</span>    <span class="n">ca</span> <span class="o">!=</span> <span class="n">continue_from</span><span class="p">,</span> <span class="n">subs</span>
    <span class="k">goto</span>  <span class="n">loop</span>
  <span class="n">inner_end</span><span class="o">:</span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">1</span> 
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Although more complicated, if we execute it step by step, we’ll see we get to our answer in fewer turns:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">41820</span>
<span class="c1">// 00000041820/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">1</span>
<span class="c1">// 00000041820/000000000000000/00000000/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000418200/00000010/1</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000000835400/00000020/1</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">2</span>
<span class="c1">// 00000041820/000000000835400/00000020/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000042656400/00001020/3</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000084476400/00002020/3</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000041820/000000084476400/00002020/2</span>
<span class="n">mturn</span>
<span class="c1">// 00000041820/000000080294400/00001920/2</span>
<span class="n">mturn</span>
<span class="c1">// 00000041820/000000076112400/00001820/2</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span> <span class="mi">2</span>
<span class="c1">// 00000041820/000000494312400/00011820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000000912512400/00021820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001330712400/00031820/4</span>
<span class="n">pturn</span>
<span class="c1">// 00000041820/000001748912400/00041820/4</span>
<span class="n">pturn</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>In exchange for a little overhead, the number of turns drops from 15 to 10. This is the fastest <em>general</em> algorithm, but some techniques from <em>Hacker’s Delight</em> can likely be applied here to make it faster for some products.</p> <h4 id="cubes"><a href="#cubes">Cubes</a></h4> <p>As a quick note, computing the cube of a number without taking extra notes is easy, so long as the number is already written down somewhere you can already see it. After computing <code class="language-plaintext highlighter-rouge">n^2</code> by any of the methods above, we can do</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">cube:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span>
  <span class="c1">// Perform a multiplication by `n`, then copy the result</span>
  <span class="c1">// into `sr`.</span>
  <span class="n">copy</span>  <span class="n">sr</span><span class="p">,</span>   <span class="n">rr</span>
  <span class="n">zero</span>  <span class="n">rr</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="c1">// Perform another multiplication by `n`, but now with</span>
  <span class="c1">// its square in `sr`.</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>This sequence can be repeated over and over to produce higher powers, and is only limited by the size of <code class="language-plaintext highlighter-rouge">rr</code>.</p> <h3 id="division"><a href="#division">Division</a></h3> <p>Division is way more interesting, because it can be <em>inexact</em>, and thus produces a <em>remainder</em> in addition to the quotient. There are a few different algorithms, but the simplest one is division by repeated subtraction. Some literature calls this “division by breaking down”.</p> <p>For small numbers, this is quite simple, such as <code class="language-plaintext highlighter-rouge">21 / 4</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">div_by_4:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">21</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">4</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">oflow</span><span class="p">,</span> <span class="n">end</span>
    <span class="n">mturn</span>
    <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">pturn</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>This works by first getting the dividend into <code class="language-plaintext highlighter-rouge">rr</code> and resetting the rest of the machine. Then, with <code class="language-plaintext highlighter-rouge">rl</code> set, we subtract the divisor from <code class="language-plaintext highlighter-rouge">rr</code> until we get overflow, at which point we add to undo the overflow. The quotient will appear in <code class="language-plaintext highlighter-rouge">cr</code>: we set <code class="language-plaintext highlighter-rouge">rl</code>, so each subtraction <em>increments</em> <code class="language-plaintext highlighter-rouge">cr</code>, giving us a count of <code class="language-plaintext highlighter-rouge">mturn</code>s executed. The remainder appears in <code class="language-plaintext highlighter-rouge">rr</code>.</p> <p>In this case, we get down to <code class="language-plaintext highlighter-rouge">1</code> before the next <code class="language-plaintext highlighter-rouge">mturn</code> underflows; the result of that underflow is to <code class="language-plaintext highlighter-rouge">99...97</code>, the ten’s complement of -3. We then undo the last operation by <code class="language-plaintext highlighter-rouge">pturn</code>ing, getting <code class="language-plaintext highlighter-rouge">5</code> in <code class="language-plaintext highlighter-rouge">cr</code>: this is our quotient. <code class="language-plaintext highlighter-rouge">1</code> in <code class="language-plaintext highlighter-rouge">rr</code> is the remainder.</p> <p>The same tricks from earlier work here, using <code class="language-plaintext highlighter-rouge">ca</code> to make less work, effectively implementing decimal long division of <code class="language-plaintext highlighter-rouge">n/m</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">div:</span>
  <span class="c1">// Set up the registers.</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">m</span>
  <span class="n">set</span>   <span class="n">rl</span>
  <span class="c1">// Move `ca` to be such that the highest digit of</span>
  <span class="c1">// `sr` lines up with the highest digit of `rr`.</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="n">log</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="c1">// Make subtractive turns until we underflow.</span>
  <span class="n">inner</span><span class="o">:</span>
    <span class="n">mturn</span>
    <span class="k">if</span>    <span class="o">!</span><span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span> <span class="n">inner</span>
  <span class="c1">// Undo the turn that underflowed by doing an addition.</span>
  <span class="c1">// Because `rl` is set, this will also conveniently subtract</span>
  <span class="c1">// from `cr`, to remove the extra count from the</span>
  <span class="c1">// underflowing turn.</span>
  <span class="n">pturn</span>
  <span class="c1">// We're done if this is the last digit we can be subtracting.</span>
  <span class="c1">// Otherwise, decrement `ca` and start over.</span>
  <span class="k">if</span>    <span class="n">ca</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
  <span class="k">goto</span>  <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Let’s execute this on <code class="language-plaintext highlighter-rouge">3141592653 / 137</code>, with an instruction trace as before.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span> <span class="mi">3141592653</span>
<span class="c1">// 03141592653/000000000000000/00000000/0</span>
<span class="n">pturn</span>
<span class="c1">// 03141592653/000003141592653/00000001/0</span>
<span class="n">zero</span>  <span class="n">cr</span>
<span class="c1">// 03141592653/000003141592653/00000000/0</span>
<span class="n">zero</span>  <span class="n">sr</span>
<span class="c1">// 00000000000/000003141592653/00000000/0</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">137</span>
<span class="c1">// 00000000137/000003141592653/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">7</span>
<span class="c1">// 00000000137/000003141592653/00000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000001771592653/10000000/7</span>
<span class="n">turn</span>
<span class="c1">// 00000000137/000000401592653/20000000/7</span>
<span class="n">turn</span>
<span class="c1">// 00000000137/999990031592653/30000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00000000137/000000401592653/20000000/7</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000401592653/20000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000000264592653/21000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/000000127592653/22000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00000000137/999999990592653/23000000/6</span>
<span class="n">pturn</span>
<span class="c1">// 00000000137/000000127592653/22000000/6</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000127592653/22000000/5</span>
<span class="c1">// More turns...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000004292653/22900000/4</span>
<span class="c1">// More turns...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000182653/22930000/3</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000045653/22931000/2</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000004553/22931300/1</span>
<span class="c1">// ...</span>
<span class="n">add</span> <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00000000137/000000000000443/22931330/0</span>
<span class="c1">// ...</span>
<span class="n">done</span>
<span class="c1">// 00000000137/000000000000032/22931333/0</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>For a quotient this big, you’ll need to work through all eight <code class="language-plaintext highlighter-rouge">cr</code> digits, which is a ton of work. At the end, we get a quotient of <code class="language-plaintext highlighter-rouge">22931333</code> and reminder <code class="language-plaintext highlighter-rouge">32</code>.</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/quot.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">3141592653 / 137 == 22931333, rem 32</code></p> </figcaption> </figure> <p>Unfortunately, we can’t as easily “cheat” with subtraction as we did with multiplication, because we don’t know the value that needs to appear in <code class="language-plaintext highlighter-rouge">cr</code>.</p> <h3 id="square-roots"><a href="#square-roots">Square Roots</a></h3> <p>Computing square roots by approximation is one of the premiere operations on the Curta. There’s a number of approaches. Newton’s method is the classic, but requires a prior approximation, access to lookup tables, or a lot of multiplication.</p> <p>A slower, but much more mechanical approach is to use <em>Töpler’s method</em>. This consists of observing that the sum of the first <code class="language-plaintext highlighter-rouge">n</code> odd numbers is the square of <code class="language-plaintext highlighter-rouge">n</code>. Thus, we can use an approach similar to that for division, only that we now subtract off consecutive odd numbers. Let’s take the square root of <code class="language-plaintext highlighter-rouge">92</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">sqrt_of_92:</span>
  <span class="n">mr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">92</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="n">mturn</span>
  <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span> <span class="n">end</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>  
  <span class="k">goto</span>  <span class="n">loop</span> 
<span class="n">end</span><span class="o">:</span>
  <span class="n">pturn</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>We get <code class="language-plaintext highlighter-rouge">9</code> as our result, but that’s pretty awful precision. We can improve precision by multiplying <code class="language-plaintext highlighter-rouge">92</code> by a large, even power of ten, and then dividing the result by that power of ten’s square root (half the zeroes).</p> <p>Unfortunately, this runs into the same problem as naive multiplication: we have to turn the handle <em>a lot</em>. Turning this algorithm into something that can be done exponentially faster is a bit fussier.</p> <p>One approach (which I found on <curta.org>) allows us to compute the root by shifting. Several programmers appear to have independently discovered this in the 70s or 80s.</curta.org></p> <p>It is based on the so-called <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation">“digit-by-digit”</a> algorithm, dating back to at least the time of Napier. Wikipedia provides a good explanation of why this method works. However, I have not been able to write down a proof that this specific version works, since it incorporates borrowing to compute intermediate terms with successive odd numbers in a fairly subtle way. I would really appreciate a proof, if anyone knows of one!</p> <p>The algorithm is thus, for a radicand <code class="language-plaintext highlighter-rouge">n</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">sqrt:</span>
  <span class="n">mr</span>
  <span class="c1">// Put `ca` as far as it will go, and then enter</span>
  <span class="c1">// the radicand as far right as it will go, so you</span>
  <span class="c1">// get as many digits as possible to work with.</span>
  <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">8</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="n">pturn</span>
  <span class="n">zero</span>  <span class="n">cr</span>
  <span class="n">zero</span>  <span class="n">sr</span>
  <span class="c1">// Put a 1 under the leftmost pair of digits. This</span>
  <span class="c1">// assumes a number with an even number of digits.</span>
  <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">set</span>   <span class="n">rl</span>
<span class="n">loop</span><span class="o">:</span>
  <span class="n">sqrt_loop</span><span class="o">:</span>
      <span class="c1">// Add an odd number (with a bunch of zeros</span>
      <span class="c1">// after it.)</span>
      <span class="n">mturn</span>
      <span class="k">if</span>    <span class="n">rr</span><span class="p">.</span><span class="n">ovflow</span><span class="p">,</span>  <span class="n">sqrt_end</span>
      <span class="c1">// Increment sr by 2 (again, with a bunch of</span>
      <span class="c1">// zeros after it). This gives us our next odd</span>
      <span class="c1">// number.</span>
      <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">goto</span>  <span class="n">sqrt_loop</span>
  <span class="n">sqrt_end</span><span class="o">:</span>
    <span class="c1">// Note that we do NOT undo the increment of `sr`</span>
    <span class="c1">// that caused overflow, but we do undo the last</span>
    <span class="c1">// mturn.</span>
    <span class="n">pturn</span>
    <span class="c1">// If `ca` is all the way to the right, we're out of</span>
    <span class="c1">// space, so these are all the digits we're getting.</span>
    <span class="c1">// Zeroing out `rr` also means we're done.</span>
    <span class="k">if</span>    <span class="n">ca</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">rr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span>
    <span class="c1">// Subtract ONE from the digit in `sr` we were</span>
    <span class="c1">// incrementing in the loop. This results in an even</span>
    <span class="c1">// number.</span>
    <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1">// Decrement `ca` and keep cranking. </span>
    <span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
    <span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">loop</span>
<span class="n">end</span><span class="o">:</span>
  <span class="n">done</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Let’s compute some digits of <code class="language-plaintext highlighter-rouge">sqrt(2)</code>. Here’s the instruction trace.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">mr</span>
<span class="c1">// 00000000000/000000000000000/00000000/0</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="mi">7</span>
<span class="c1">// 00000000000/000000000000000/00000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="c1">// 00020000000/000000000000000/00000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00020000000/200000000000000/10000000/7</span>
<span class="n">zero</span>  <span class="n">cr</span>
<span class="c1">// 00020000000/200000000000000/00000000/7</span>
<span class="n">zero</span>  <span class="n">sr</span>
<span class="c1">// 00000000000/200000000000000/00000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00010000000/200000000000000/00000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00010000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00030000000/100000000000000/10000000/7</span>
<span class="n">mturn</span>
<span class="c1">// 00030000000/800000000000000/10000000/7</span>
<span class="n">pturn</span>
<span class="c1">// 00030000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">// 00020000000/100000000000000/10000000/7</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00020000000/100000000000000/10000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00021000000/100000000000000/10000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00021000000/079000000000000/11000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00023000000/079000000000000/11000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00023000000/056000000000000/12000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00025000000/056000000000000/12000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00025000000/031000000000000/13000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00027000000/031000000000000/13000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00027000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 00029000000/004000000000000/14000000/6</span>
<span class="n">mturn</span>
<span class="c1">// 00029000000/975000000000000/15000000/6</span>
<span class="n">pturn</span>
<span class="c1">// 00029000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">sr</span><span class="p">,</span>   <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">// 00028000000/004000000000000/14000000/6</span>
<span class="n">add</span>   <span class="n">ca</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span>
<span class="c1">// 00028000000/004000000000000/14000000/5</span>
<span class="c1">// More of the same...</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Curta "Assembly"</div></div></div> <p>Over time, the digits <code class="language-plaintext highlighter-rouge">14121356</code> will appear in <code class="language-plaintext highlighter-rouge">cr</code>. This is the square root (although we do need to place the decimal point; the number of digits before it will be half of what we started with, rounded up).</p> <figure> <p><img src="https://mcyoung.xyz/public/images/curta/sqrt.jpg" alt=""/></p> <figcaption> <p><code class="language-plaintext highlighter-rouge">sqrt(2) ~ 1.4121356</code></p> </figcaption> </figure> <h2 id="wrap-up"><a href="#wrap-up">Wrap-up</a></h2> <p>There’s a quite a few other algorithms out there, but most of them boil down to clever use of lookup tables and combinations of the above techniques. For example, the so-called “rule of 3” is simply performing a multiplication to get a product into <code class="language-plaintext highlighter-rouge">rr</code>, and then using it as the dividend to produce a quotient of the form <code class="language-plaintext highlighter-rouge">a * b / c</code> in <code class="language-plaintext highlighter-rouge">cr</code>.</p> <p>I hope that these simple numeric algorithms, presented in a style resembling assembly, helps illustrate that programming at such a low level is not <em>hard</em>, but merely requires learning a different bag of tricks.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:mech-digital" role="doc-endnote"> <p>Although this seems like an oxymoron, it is accurate! The Curta contains no electrical or electronic components, and its registers contain discrete symbols, not continuous values. It is <em>not</em> an analog computer! <a href="#fnref:mech-digital" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:one-index" role="doc-endnote"> <p>The Curta is a one-indexed machine, insofar as the values engraved on <code class="language-plaintext highlighter-rouge">ca</code> are not <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">7</code> but <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">8</code>. However, as we all know, zero-indexing is far more convenient. Any place where I say “set <code class="language-plaintext highlighter-rouge">ca</code> to <code class="language-plaintext highlighter-rouge">n</code>”, I mean the <code class="language-plaintext highlighter-rouge">n + 1</code>th detent.</p> <p>Doing this avoids a lot of otherwise unnecessary <code class="language-plaintext highlighter-rouge">-1</code>s in the prose. <a href="#fnref:one-index" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:10s-cmp" role="doc-endnote"> <p>The <em>ten’s complement</em> of a number <code class="language-plaintext highlighter-rouge">x</code> is analogous to the two’s complement (i.e., the value of <code class="language-plaintext highlighter-rouge">-x</code> when viewed as an unsigned integer on a binary machine). It is equal to <code class="language-plaintext highlighter-rouge">MAX_VALUE - x + 1</code>, where <code class="language-plaintext highlighter-rouge">MAX_VALUE</code> is the largest value that <code class="language-plaintext highlighter-rouge">x</code> could be. For example, this is <code class="language-plaintext highlighter-rouge">999_999_999_999_999_999</code> (fifteen nines) for <code class="language-plaintext highlighter-rouge">rr</code>. <a href="#fnref:10s-cmp" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="etc"/><category term="assembly"/><summary type="html"><![CDATA[I’m not really one to brag publicly about expensive toys, but a few weeks ago I managed to get one that’s really something special. It is a Curta Type II, a mechanical digital[^mech-digital] calculator manufactured in Liechtenstein between the 50s and 70s, before solid-state calculators killed them and the likes of slide-rules.]]></summary></entry><entry><title type="html">std::tuple the Hard Way</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2022/07/13/tuples-the-hard-way/" rel="alternate" type="text/html" title="std::tuple the Hard Way"/><published>2022-07-13T00:00:00-04:00</published><updated>2022-07-13T00:00:00-04:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2022/07/13/tuples-the-hard-way</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2022/07/13/tuples-the-hard-way/"><![CDATA[<p>Let’s talk about C++ templates.</p> <p>C++ is famous for relegating important functionality often built into the language to its standard library<sup id="fnref:iso" role="doc-noteref"><a href="#fn:iso" class="footnote" rel="footnote">1</a></sup>. C++11 added a number of very useful class templates intended to make generic programming easier. By far the most complicated is <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>, which is literally just a tuple.</p> <p>It turns out that implementing <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code> is complicated. <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/tuple">Very, very complicated.</a></p> <p>Naively, we think that we can just splat a variadic pack into a struct:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">tuple</span> <span class="p">{</span>
  <span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoidGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVzPlxuY2xhc3MgdHVwbGUg e1xuICBUeXBlcy4uLiB2YWx1ZXM7XG59OyIsImNvbXBpbGVycyI6W10sImV4 ZWN1dG9ycyI6W3siY29tcGlsZXJWaXNpYmxlIjpmYWxzZSwiY29tcGlsZXJP dXRwdXRWaXNpYmxlIjp0cnVlLCJjb21waWxlciI6eyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6IiJ9fV19XX0=">godbolt</a><div class="codeblock-button">C++</div></div></div> <p>If you click through to Godbolt, you’ll see it doesn’t: this feature doesn’t exist in C++<sup id="fnref:circle-cxx" role="doc-noteref"><a href="#fn:circle-cxx" class="footnote" rel="footnote">2</a></sup> (normally, you’d do <code class="language-plaintext highlighter-rouge">std::tuple&lt;Types...&gt;</code>, but we need to write down <code class="language-plaintext highlighter-rouge">std::tuple</code> somehow). The usual approach is to use some kind of recursive template, which can tend to generate a lot of code.</p> <p>However, C++ does actually have tuples built into the language, as a C++11 feature… lambdas! As an extra challenge, we’re going to try to minimize the number of templates that the compiler needs to instantiate; <code class="language-plaintext highlighter-rouge">std::tuple</code> is famously bad about this and can lead to very poor build performance.</p> <p>For our tuple library type, we need to solve the following problems:</p> <ul> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple()</code> and <code class="language-plaintext highlighter-rouge">std::tuple(args...)</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::apply</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::tuple_element</code>?</li> <li>How do we implement <code class="language-plaintext highlighter-rouge">std::get</code>?</li> </ul> <h2 id="the-power-of-"><a href="#the-power-of-">The Power of [](){}</a></h2> <p>Alright, let’s back up. In C++11, we got <em>lambdas</em>, which are expressions that expand to anonymous functions. In C++, lambdas are <em>closures</em>, meaning that they capture (“close over”) their environment.</p> <p>This is a lambda in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">// 13</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">[x]</code> syntax is the <em>captures</em>. To represent a lambda, C++ creates an anonymous, one-time-use class. It has the captures as members (whether they be references or values) and provides the necessary <code class="language-plaintext highlighter-rouge">operator()</code>. In other words, this is approximately the desugaring:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Note the <code class="language-plaintext highlighter-rouge">const</code>s in <code class="language-plaintext highlighter-rouge">_Lambda</code>. By default, captured values are stored inline but marked <code class="language-plaintext highlighter-rouge">const</code>, and the <code class="language-plaintext highlighter-rouge">operator()</code> member is also <code class="language-plaintext highlighter-rouge">const</code>. We can remove that specifier in both location with the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// ^^^^^^^</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">MakeFn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">_Lambda</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_Lambda</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> </div> <p>Lambdas can capture anything from their scope. In addition to values, they will capture any types visible from that location. This means that, if constructed in a function template, the generated class will effectively capture that template’s arguments. Thus:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">CaptureMany</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/*whatever*/</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This will create a new anonymous class capturing an arbitrary number of arguments, depending on the <em>parameters passed to <code class="language-plaintext highlighter-rouge">CaptureMany()</code></em>. This will form the core of our tuple type.</p> <p>Now, let’s stick it into a class.</p> <h2 id="lambda-typed-data-members"><a href="#lambda-typed-data-members">Lambda-Typed Data Members</a></h2> <p>We don’t want to leak the lambda into the template parameters of our tuple class, so we need it to be strictly in terms of the class’s template parameters. This is straightforward with <code class="language-plaintext highlighter-rouge">decltype</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">Types</span><span class="p">{}...))</span> <span class="n">lambda_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Regardless of what our C++ compiler calls the type, we are able to use it as a field. However, a problem arises when we try to write down the main “in-place” constructor, which consists of the usual forwarding-reference and <code class="language-plaintext highlighter-rouge">std::forward</code> boilerplate<sup id="fnref:in-place" role="doc-noteref"><a href="#fn:in-place" class="footnote" rel="footnote">3</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">lambda_</span><span class="p">(</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The initialization for lambda_ doesn’t work, because the return type of <code class="language-plaintext highlighter-rouge">TupleLambda</code> is wrong! The compiler is required to synthesize a new type for every specialization of <code class="language-plaintext highlighter-rouge">TupleLambda</code>, and so <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Types...&gt;()</code> and <code class="language-plaintext highlighter-rouge">TupleLambda&lt;Args...&gt;</code> return different types!</p> <h3 id="a-new-kind-of-initialization"><a href="#a-new-kind-of-initialization">A <code class="language-plaintext highlighter-rouge">new</code> Kind of Initialization</a></h3> <p>This requires a major workaround. We’d still like to use our lambda, but we need to give it a type that allows us to construct it before calling the constructors of <code class="language-plaintext highlighter-rouge">Types...</code>. We can’t use <code class="language-plaintext highlighter-rouge">Types...</code>, so we’ll do a switcheroo.</p> <p>The following is boilerplate for a type that can hold a <code class="language-plaintext highlighter-rouge">T</code> in it but which can be constructed before we construct the <code class="language-plaintext highlighter-rouge">T</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Constructor does nothing.</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructs a T inside of data_.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="c1">// Allow dereferencing a StorageFor into a T, like</span>
  <span class="c1">// a smart pointer.</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>There’s a lot going on here. Let’s break it down.</p> <ol> <li><code class="language-plaintext highlighter-rouge">alignof(T)</code> ensures that even though the only member is a <code class="language-plaintext highlighter-rouge">char</code> array, this</li> </ol> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <ol> <li> <p>The constructor does nothing; the <code class="language-plaintext highlighter-rouge">T</code> within is only constructed when <code class="language-plaintext highlighter-rouge">Init()</code> is called with <code class="language-plaintext highlighter-rouge">T</code>’s constructor arguments.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init()</code> forwards its arguments just like our non-functional constructor for <code class="language-plaintext highlighter-rouge">Tuple</code>. This time, the arguments get sent into <code class="language-plaintext highlighter-rouge">T</code>’s constructor via <em>placement-<code class="language-plaintext highlighter-rouge">new</code></em>. Placement-<code class="language-plaintext highlighter-rouge">new</code> is special syntax that allows us to call a constructor directly on existing memory. It’s spelled like this: <code class="language-plaintext highlighter-rouge">new (dest) T(args);</code>.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">operator*</code>/<code class="language-plaintext highlighter-rouge">operator-&gt;</code> turn <code class="language-plaintext highlighter-rouge">StorageFor</code> into a smart pointer over <code class="language-plaintext highlighter-rouge">T</code>, which will be useful later. The signatures of these functions aren’t important; it’s library boilerplate.</p> </li> </ol> <p>We can use this type like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Create some storage.</span>
<span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_string</span><span class="p">;</span>

<span class="c1">// Separately, initialize it using std::string's constructor</span>
<span class="c1">// form char[N].</span>
<span class="n">my_string</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="s">"cool type!"</span><span class="p">);</span>

<span class="c1">// Print it out.</span>
<span class="n">absl</span><span class="o">::</span><span class="n">PrintF</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_string</span><span class="p">);</span>

<span class="c1">// Destroy it. This must be done manually because StorageFor&lt;T&gt;</span>
<span class="c1">// has a trivial destructor.</span>
<span class="k">using</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">my_string</span><span class="o">-&gt;~</span><span class="n">string</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>How does this help us?</p> <h3 id="constructors-inside-out"><a href="#constructors-inside-out">Constructors Inside-Out</a></h3> <p><code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will be the types that our lambda captures, making it possible to give it a consistent type without knowing which arguments we’ll use to initialize the contents.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">{</span> <span class="cm">/* ??? */</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>But now we’re in another bind: how do we <em>call</em> the constructors? Even with placement-new, we can’t reach into the lambda’s data, and the layout of a lambda is compiler-specific. However, that’s from the outside. What if we accessed the lambda from the <em>inside</em>?</p> <p>We modify the lambda to itself be generic and take a pack of forwarding references as arguments, which we can then pass into <code class="language-plaintext highlighter-rouge">Init()</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">init_args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init_args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>That’s a serious mouthful. Let’s break it down.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">[args...] (auto&amp;&amp;... init_args) {</code> declares a <em>generic</em> lambda. This means that there’s an imaginary <code class="language-plaintext highlighter-rouge">template &lt;typename... Args&gt;</code> on the <code class="language-plaintext highlighter-rouge">operator()</code> of the generated class. Because the argument type is <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code>, and <code class="language-plaintext highlighter-rouge">Args</code> is a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>, <code class="language-plaintext highlighter-rouge">init_args</code> is a pack of forwarding references. This is a C++14 feature.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Init(std::forward&lt;decltype(init_args)&gt;(init_args))</code> is a forwarded constructor argument. Nothing new here.</p> </li> <li> <p>The outer <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...)</code> that the placement-<code class="language-plaintext highlighter-rouge">new</code> is wrapped in is a <em>pack fold</em>, which uses an operator to fold a pack of values into one. For example, <code class="language-plaintext highlighter-rouge">(foo + ...)</code> computes the sum of all elements in a pack. In our case, we’re folding with the comma operator <code class="language-plaintext highlighter-rouge">,</code>. All this does is discard the elements of the pack (which are all <code class="language-plaintext highlighter-rouge">void</code>, regardless). This is a C++17 feature<sup id="fnref:polyfill-fold" role="doc-noteref"><a href="#fn:polyfill-fold" class="footnote" rel="footnote">4</a></sup></p> </li> </ol> <p>Taken together, this causes the constructor of each type in <code class="language-plaintext highlighter-rouge">Types...</code> to be run on the respective <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> captures by the lambda when <code class="language-plaintext highlighter-rouge">TupleLambda()</code> was originally called. The double-nesting of a function-within-a-function can be a bit confusing: <code class="language-plaintext highlighter-rouge">TupleLambda()</code> is not what calls <code class="language-plaintext highlighter-rouge">T</code>’s constructor!</p> <p>Actually, this won’t compile because <code class="language-plaintext highlighter-rouge">Init()</code> is not <code class="language-plaintext highlighter-rouge">const</code>, but the lambda’s <code class="language-plaintext highlighter-rouge">operator()</code> is. This is easily fixed by adding the <code class="language-plaintext highlighter-rouge">mutable</code> keyword:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">...]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">init_args</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
      <span class="c1">// ...                               ^^^^^^^</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We also need to mark the <code class="language-plaintext highlighter-rouge">lambda_</code> parameter as <code class="language-plaintext highlighter-rouge">mutable</code> so that <code class="language-plaintext highlighter-rouge">const</code> functions can all it. We’ll just need to be careful we don’t actually mutate through it. This is necessary because we cannot (at least until C++23) write to the captures of a lambda and still be able to call it in <code class="language-plaintext highlighter-rouge">const</code> contexts:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now, our constructor looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="more-constructors"><a href="#more-constructors">More Constructors!</a></h3> <p>We have <code class="language-plaintext highlighter-rouge">std::tuple(args)</code> but we still need <code class="language-plaintext highlighter-rouge">std::tuple</code>. But, we’ve already used up our one chance to touch the captures of the lambda… we can’t write down a lambda that has both a variadic <code class="language-plaintext highlighter-rouge">operator()</code> (many generic arguments) and a niladic <code class="language-plaintext highlighter-rouge">operator()</code> (no arguments).</p> <p>But we can make it take a lambda itself! In this case, all that our “storage lambda” does now is call a callback with a pack of references. Calling <code class="language-plaintext highlighter-rouge">lambda_()</code> effectively “unpacks” it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">decltype(auto)</code> bit simply ensures that if <code class="language-plaintext highlighter-rouge">callback</code> returns a reference, then so does <code class="language-plaintext highlighter-rouge">lambda_</code>. By default, lambdas return <code class="language-plaintext highlighter-rouge">auto</code>, which will never deduce a reference (you’d need to write <code class="language-plaintext highlighter-rouge">auto&amp;</code>, which conversely cannot deduce a value). Instead of using “<code class="language-plaintext highlighter-rouge">auto</code> deduction”, we can use the special <code class="language-plaintext highlighter-rouge">decltype(auto)</code> type to request “<code class="language-plaintext highlighter-rouge">decltype</code> deduction”, which <em>can</em> deduce both references and non-references. This comes in handy later.</p> <p>Now we can refactor the two constructors to call <code class="language-plaintext highlighter-rouge">lambda_</code> with different lambda arguments. Our original constructor will pass in the original body of <code class="language-plaintext highlighter-rouge">lambda_</code>, which calls Init() with <code class="language-plaintext highlighter-rouge">args</code>. The new constructor will simply call <code class="language-plaintext highlighter-rouge">Init()</code> with no args.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We need to implement the destructor too, since <code class="language-plaintext highlighter-rouge">StorageFor&lt;T&gt;</code> will not destroy the <code class="language-plaintext highlighter-rouge">T</code> we’re squirreling away inside, but this is still really easy:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy and move are similar, but require interleaving two calls of <code class="language-plaintext highlighter-rouge">lambda_</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Carefully take a const&amp;, to make sure we don't call a</span>
      <span class="c1">// mutable-ref constructor.</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Avoid std::move to cut down on instantiation.</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Copy/move assignment are basically identical; I’ll leave those as an exercise!</p> <p>This gives us our complete set of constructors. We’ll throw in deduction guides<sup id="fnref:deduction-guides" role="doc-noteref"><a href="#fn:deduction-guides" class="footnote" rel="footnote">5</a></sup> to avoid needing to implement <code class="language-plaintext highlighter-rouge">make_tuple</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This works up until we try to write <code class="language-plaintext highlighter-rouge">Tuple tup2 = tup;</code> Overload resolution will incorrectly route to the variadic constructor rather than the copy constructor, so a little bit of SFINAE is needed to grease the compiler’s wheels.</p> <p>Keeping in the spirit of avoiding extra instantiation logic, we’ll use placement-<code class="language-plaintext highlighter-rouge">new</code> inside of a <code class="language-plaintext highlighter-rouge">decltype</code> as an ersatz <code class="language-plaintext highlighter-rouge">std::enable_if</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
          <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
            <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This verifies that we can actually construct a <code class="language-plaintext highlighter-rouge">Types</code> from a <code class="language-plaintext highlighter-rouge">Args</code> (for each member of the pack). Because this is occurring in an unevaluated context, we can safely placement-<code class="language-plaintext highlighter-rouge">new</code> on <code class="language-plaintext highlighter-rouge">nullptr</code>. All <code class="language-plaintext highlighter-rouge">new</code> expressions produce a pointer value, and a comma-fold produces the last value in the fold, so the overall <code class="language-plaintext highlighter-rouge">decltype()</code> is <code class="language-plaintext highlighter-rouge">T*</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the last element of the pack.</p> <p>This <code class="language-plaintext highlighter-rouge">decltype()</code> is the type of a non-type template parameter, which we can default to <code class="language-plaintext highlighter-rouge">nullptr</code>, so the user never notices it.</p> <p>Ok. We have all of our constructors. The code so far is at this footnote: <sup id="fnref:code-so-far-1" role="doc-noteref"><a href="#fn:code-so-far-1" class="footnote" rel="footnote">6</a></sup>.</p> <p>Onwards to <code class="language-plaintext highlighter-rouge">std::apply</code>.</p> <h2 id="unpacking-again"><a href="#unpacking-again">Unpacking, Again</a></h2> <p><code class="language-plaintext highlighter-rouge">std::apply(f, tup)</code> is a relatively straight-forward function: call <code class="language-plaintext highlighter-rouge">f</code> by splatting <code class="language-plaintext highlighter-rouge">tup</code>’s elements int <code class="language-plaintext highlighter-rouge">f</code> as a pack. Because of how we’ve implemented <code class="language-plaintext highlighter-rouge">lambda_</code>, this is actually super simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re possibly returning a reference, so note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>s.)</p> <p><code class="language-plaintext highlighter-rouge">lambda_</code> is basically a funny <code class="language-plaintext highlighter-rouge">std::apply</code> already, just with the wrong arguments. The <code class="language-plaintext highlighter-rouge">*places</code> fixes this up. With some repetition, we can write down <code class="language-plaintext highlighter-rouge">const</code>- and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>-qualified overloads. We can even introduce a free function just like the one in the standard library:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The other unpacking operation, <code class="language-plaintext highlighter-rouge">std::get</code>, is trickier. This is usually where things get really hairy, because we need to get the <code class="language-plaintext highlighter-rouge">i</code>th type out of the lambda. There are many approaches for doing this, most of which involve recursive templates. I’ll present two approaches that don’t use recursive templates directly, but which can still be a bit slow, built-time-wise.</p> <p>This is the function we need to implement:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <h3 id="cheating-with-stdmake_index_sequence"><a href="#cheating-with-stdmake_index_sequence">Cheating with <code class="language-plaintext highlighter-rouge">std::make_index_sequence</code></a></h3> <p><code class="language-plaintext highlighter-rouge">std::make_index_sequence</code> is a funny type-level function that produces a pack of integers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i</code>, given just <code class="language-plaintext highlighter-rouge">i</code>. This is usually fast, since most compilers will have intrinsics for doing it without needing to instantiate <code class="language-plaintext highlighter-rouge">i</code> templates. For example, in Clang, this is <code class="language-plaintext highlighter-rouge">__make_integer_seq</code>, which is used by <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/integer_sequence.h">libc++</a>.</p> <p>Thus, we can turn the problem of implementing <code class="language-plaintext highlighter-rouge">get</code> with a single <code class="language-plaintext highlighter-rouge">i</code> to implementing <code class="language-plaintext highlighter-rouge">get</code> with a pack:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="cm">/* ??? */</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then use this pack to cook up just the right lambda to grab just the capture we want out of <code class="language-plaintext highlighter-rouge">lambda_</code>. Specifically, we want a lambda that picks out its <code class="language-plaintext highlighter-rouge">i</code>th argument. Basically we want to write something with arguments like <code class="language-plaintext highlighter-rouge">(auto..., auto, auto...)</code>, but somehow use the <code class="language-plaintext highlighter-rouge">less_than_i</code> pack to control the size of the first argument pack.</p> <p>We can whip up a class template for this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">Sink&lt;n&gt;</code> is a type that is implicitly convertible from anything, and has a dummy parameter we can key an expansion off-of. Hence <code class="language-plaintext highlighter-rouge">GetImpl()</code> looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>We can then provide the type of the <code class="language-plaintext highlighter-rouge">i</code>th element as a member type alias, using <code class="language-plaintext highlighter-rouge">decltype</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(The <code class="language-plaintext highlighter-rouge">template</code> keyword isn’t doing anything interesting; it’s just for syntactic disambiguation.)</p> <p>We can, as usual, repeat implementations for <code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> qualifiers.</p> <h3 id="cheating-harder-with-__type_pack_element"><a href="#cheating-harder-with-__type_pack_element">Cheating Harder with <code class="language-plaintext highlighter-rouge">__type_pack_element</code></a></h3> <p>If we’re ok being Clang-specific, Clang just gives us a magic type function that selects out of a pack. This means we can implement <code class="language-plaintext highlighter-rouge">TupleType</code> in terms of it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Then, we can use <code class="language-plaintext highlighter-rouge">void*</code> to swindle the type system, since we don’t need to go to any effort to learn the <code class="language-plaintext highlighter-rouge">i</code>th type now:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>(We’re returning a reference, so again note the <code class="language-plaintext highlighter-rouge">decltype(auto)</code>.)</p> <p>With that we have all of the functions we set out to implement. For kicks, we can add the relevant <code class="language-plaintext highlighter-rouge">std</code> specializations to enable structured bindings on our type (along with our <code class="language-plaintext highlighter-rouge">get</code> member function):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Now we can see everything in action:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The full code can be found at this footnote: <sup id="fnref:code-so-far-2" role="doc-noteref"><a href="#fn:code-so-far-2" class="footnote" rel="footnote">7</a></sup>.</p> <h2 id="the-damage"><a href="#the-damage">The Damage</a></h2> <p>So, the end result is most of an implementation of <code class="language-plaintext highlighter-rouge">std::tuple&lt;&gt;</code>. Let’s see how well it builds. We’re going to compile the following code for <code class="language-plaintext highlighter-rouge">n</code> from 0 to 150 and measure how long it takes.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span> <span class="n">t</span><span class="p">{</span><span class="cm">/* 0 repeated n times */</span><span class="p">};</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And here’s the results on Clang 11 (what I had on-hand) on my Zen 2 machine:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/tuple-benchmark.png" alt=""/></p> </figure> <p>We seem to beat libstdc++ by a factor of around 2, but libc++ appears to have us beat. This is because libc++ makes even more aggressive use of Clang’s intrinsics than we did, allowing them to do significantly better. Interestingly, using the builtin makes us perform <em>worse</em>. I’m actually not sure why this is.</p> <p>But ultimately, this wasn’t really about beating libc++: it’s about having fun with C++ templates.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:iso" role="doc-endnote"> <p>Arguably, because WG21, the body that standardizes C++, is bad at language evolution, but that’s not why we’re here. <a href="#fnref:iso" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:circle-cxx" role="doc-endnote"> <p>The Circle compiler totally laughs in our faces, though, because it <em>has this exact syntax</em>. <a href="https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple">https://github.com/seanbaxter/circle/tree/master/tuple#circle-tuple</a> <a href="#fnref:circle-cxx" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:in-place" role="doc-endnote"> <p>Basically every in-place constructor in C++ looks like this. It takes a variadic pack as a template parameter, and then takes <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> if that as its arguments. <code class="language-plaintext highlighter-rouge">Args&amp;&amp;</code> here is a <em>forwarding reference</em>, which means it is <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> depending on the callsite. This overrides the usual template deduction rules, and is important for making sure that e.g. <code class="language-plaintext highlighter-rouge">std::move</code> propagates correctly.</p> <p>We cannot write <code class="language-plaintext highlighter-rouge">Types&amp;&amp;</code> instead, because that would not be a forwarding reference. <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> refers to a forwarding reference argument only on a function template where <code class="language-plaintext highlighter-rouge">T</code> is a parameter of <em>that function</em> and not an enclosing entity. <a href="#fnref:in-place" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:polyfill-fold" role="doc-endnote"> <p>If C++17 is too much to ask, polyfilling isn’t too hard. Instead of <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, ...);</code>, we can write <code class="language-plaintext highlighter-rouge">(void)(int[]){(&lt;expr&gt;, 0)...};</code>, even if <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> is a void expression. <code class="language-plaintext highlighter-rouge">(&lt;expr&gt;, 0)</code> is still a comma operator call, which discards the result of <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> as before. The pack expands into an array of integers (a <code class="language-plaintext highlighter-rouge">int[]</code>), which we then discard with <code class="language-plaintext highlighter-rouge">(void)</code>. This still has the behavior of evaluating <code class="language-plaintext highlighter-rouge">&lt;expr&gt;</code> once for each element of the pack. <a href="#fnref:polyfill-fold" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:deduction-guides" role="doc-endnote"> <p>A <em>deduction guide</em> is a special piece of syntax introduced in C++17 intended to aid deducing the types of constructor calls. When we write <code class="language-plaintext highlighter-rouge">std::tuple(a, b, c)</code>, the template arguments of <code class="language-plaintext highlighter-rouge">std::tuple</code> are deduced. However, the constructor call may not give sufficient information to properly deduce them, because we may be calling a constructor template.</p> <p>The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">args</span><span class="p">&gt;</span>
<span class="n">MyType</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MyType</span><span class="o">&lt;</span><span class="n">types</span><span class="o">&gt;</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This tells the compiler that when it encounters a call to a constructor of <code class="language-plaintext highlighter-rouge">MyTypes</code> that deduces the given types as its arguments, it should deduce the type after the <code class="language-plaintext highlighter-rouge">-&gt;</code> for the template arguments of <code class="language-plaintext highlighter-rouge">MyType</code>, which can be arbitrary template argument expressions. <a href="#fnref:deduction-guides" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-1" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">};</span>
  <span class="n">Tuple</span> <span class="n">tup2</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNl IjoiXG4jaW5jbHVkZSA8bmV3PiBcbiNpbmNsdWRlIDx1dGlsaXR5PiBcblxu ICAgIHRlbXBsYXRlIDx0eXBlbmFtZSBUPlxuICAgIGNsYXNzIGFsaWduYXMo VCkgU3RvcmFnZUZvciB7XG4gICAgIHB1YmxpYzpcbiAgICAgIFN0b3JhZ2VG b3IoKSA9IGRlZmF1bHQ7XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4g QXJncz5cbiAgICAgIHZvaWQgSW5pdChBcmdzJiYuLi4gYXJncykge1xuICAg ICAgICBuZXcgKHJlaW50ZXJwcmV0X2Nhc3Q8VCo+KCZkYXRhXykpIFQoXG4g ICAgICAgICAgc3RkOjpmb3J3YXJkPEFyZ3M+KGFyZ3MpLi4uKTtcbiAgICAg IH1cblxuICAgICAgY29uc3QgVCogZ2V0KCkgY29uc3QgeyByZXR1cm4gcmVp bnRlcnByZXRfY2FzdDxjb25zdCBUKj4oJmRhdGFfKTsgfVxuICAgICAgVCog Z2V0KCkgeyByZXR1cm4gcmVpbnRlcnByZXRfY2FzdDxUKj4oJmRhdGFfKTsg fVxuICAgICAgY29uc3QgVCYgb3BlcmF0b3IqKCkgY29uc3QgeyByZXR1cm4g KmdldCgpOyB9XG4gICAgICBUJiBvcGVyYXRvciooKSB7IHJldHVybiAqZ2V0 KCk7IH1cbiAgICAgIGNvbnN0IFQqIG9wZXJhdG9yLT4oKSBjb25zdCB7IHJl dHVybiBnZXQoKTsgfVxuICAgICAgVCogb3BlcmF0b3ItPigpIHsgcmV0dXJu IGdldCgpOyB9XG4gICAgIHByaXZhdGU6XG4gICAgICBjaGFyIGRhdGFfW3Np emVvZihUKV07XG4gICAgfTtcblxuICAgIHRlbXBsYXRlIDx0eXBlbmFtZS4u LiBUeXBlcz5cbiAgICBjbGFzcyBUdXBsZSB7XG4gICAgIHB1YmxpYzpcbiAg ICAgIFR1cGxlKCkge1xuICAgICAgICBsYW1iZGFfKFtdIChTdG9yYWdlRm9y PFR5cGVzPiYuLi4gcGxhY2VzKSB7XG4gICAgICAgICAgKHBsYWNlcy5Jbml0 KCksIC4uLik7XG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgdGVt cGxhdGUgPHR5cGVuYW1lLi4uIEFyZ3MsXG4gICAgICAgICAgICAgICAgZGVj bHR5cGUoKG5ldyAobnVsbHB0cikgVHlwZXMoc3RkOjpkZWNsdmFsPEFyZ3M+ KCkpLCAuLi4pKVxuICAgICAgICAgICAgICAgICAgPSBudWxscHRyPlxuICAg ICAgVHVwbGUoQXJncyYmLi4uIGFyZ3MpIHtcbiAgICAgICAgbGFtYmRhXyhb Jl0gKFN0b3JhZ2VGb3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAg ICAocGxhY2VzLkluaXQoc3RkOjpmb3J3YXJkPGRlY2x0eXBlKGFyZ3MpPihh cmdzKSksIC4uLik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBU dXBsZShjb25zdCBUdXBsZSYgdGhhdCkge1xuICAgICAgICBsYW1iZGFfKFsm XSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRoZXNlKSB7XG4gICAgICAgICAg dGhhdC5sYW1iZGFfKFsmXSAoY29uc3QgU3RvcmFnZUZvcjxUeXBlcz4mLi4u IHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVzZS5nZXQoKSkgVHlw ZXMoKnRob3NlKSwgLi4uKTsgICBcbiAgICAgICAgICB9KTtcbiAgICAgICAg fSk7XG4gICAgICB9XG5cbiAgICAgIFR1cGxlKFR1cGxlJiYgdGhhdCkge1xu ICAgICAgICBsYW1iZGFfKFsmXSAoU3RvcmFnZUZvcjxUeXBlcz4mLi4uIHRo ZXNlKSB7XG4gICAgICAgICAgdGhhdC5sYW1iZGFfKFsmXSAoU3RvcmFnZUZv cjxUeXBlcz4mLi4uIHRob3NlKSB7XG4gICAgICAgICAgICAobmV3ICh0aGVz ZSkgVHlwZXMoc3RhdGljX2Nhc3Q8VHlwZXMmJj4oKnRob3NlKSksIC4uLik7 ICAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4g ICAgICB+VHVwbGUoKSB7XG4gICAgICAgIGxhbWJkYV8oW10gKFN0b3JhZ2VG b3I8VHlwZXM+Ji4uLiBwbGFjZXMpIHtcbiAgICAgICAgICAocGxhY2VzLT5+ VHlwZXMoKSwgLi4uKTtcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAg IHByaXZhdGU6XG4gICAgICB0ZW1wbGF0ZSA8dHlwZW5hbWUuLi4gQXJncz5c biAgICAgIHN0YXRpYyBhdXRvIFR1cGxlTGFtYmRhKEFyZ3MuLi4gYXJncykg e1xuICAgICAgICByZXR1cm4gWz1dIChhdXRvIGNhbGxiYWNrKSBtdXRhYmxl IC0+IGRlY2x0eXBlKGF1dG8pIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJh Y2soYXJncy4uLik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG11 dGFibGUgZGVjbHR5cGUoVHVwbGVMYW1iZGEoU3RvcmFnZUZvcjxUeXBlcz57 fS4uLikpIGxhbWJkYV8gPVxuICAgICAgICBUdXBsZUxhbWJkYShTdG9yYWdl Rm9yPFR5cGVzPnt9Li4uKTtcbiAgICB9O1xuXG4gICAgdGVtcGxhdGUgPHR5 cGVuYW1lLi4uIFR5cGVzPlxuICAgIFR1cGxlKFR5cGVzLi4uKSAtPiBUdXBs ZTxUeXBlcy4uLj47XG4gICAgdGVtcGxhdGUgPHR5cGVuYW1lLi4uIFR5cGVz PlxuICAgIFR1cGxlKGNvbnN0IFR1cGxlPFR5cGVzLi4uPiYpIC0+IFR1cGxl PFR5cGVzLi4uPjtcblxuICAgIGludCBtYWluKCkge1xuICAgICAgVHVwbGUg dHVwezEsIDIsIFwiZm9vXCIsIFwiYmFyXCJ9O1xuICAgICAgVHVwbGUgdHVw MiA9IHR1cDtcbiAgICB9IiwiY29tcGlsZXJzIjpbeyJpZCI6ImNsYW5nX3Ry dW5rIiwib3B0aW9ucyI6Ii0tc3RkPWMrKzE3In1dfV19 ">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:code-so-far-2" role="doc-endnote"> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">StorageFor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">StorageFor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">get</span><span class="p">();</span> <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Sink</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">Sink</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">__type_pack_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="cp">#endif
</span>
 <span class="nl">public:</span>
  <span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span>
            <span class="k">decltype</span><span class="p">((</span><span class="k">new</span> <span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">&gt;()),</span> <span class="p">...))</span>
              <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
  <span class="n">Tuple</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">Types</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="n">Tuple</span><span class="p">(</span><span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">these</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">that</span><span class="p">.</span><span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">those</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">these</span><span class="p">)</span> <span class="n">Types</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">those</span><span class="p">)),</span> <span class="p">...);</span>   
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Tuple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">places</span><span class="o">-&gt;~</span><span class="n">Types</span><span class="p">(),</span> <span class="p">...);</span>
    <span class="p">});</span> 
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">places</span><span class="p">...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="n">lambda_</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">places</span><span class="p">)...);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">apply</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cp">#if USE_CLANG_INTRINSIC
</span>      <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="k">const</span> <span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lambda_</span><span class="p">([]</span> <span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;&amp;</span><span class="p">...</span> <span class="n">places</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">erased</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">places</span><span class="p">.</span><span class="n">get</span><span class="p">()...};</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span>
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">erased</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">});</span>
  <span class="p">}</span>
  
  <span class="cp">#else // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span>  <span class="n">GetImpl</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">{});</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cp">#endif // USE_CLANG_INTRINSIC
</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Tup</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="k">static</span> <span class="k">auto</span> <span class="n">TupleLambda</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">callback</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tup</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">less_than_i</span><span class="p">&gt;</span>
  <span class="k">friend</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">GetImpl</span><span class="p">(</span><span class="n">Tup</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Tup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">lambda_</span><span class="p">(</span>
      <span class="p">[]</span> <span class="p">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">less_than_i</span><span class="o">&gt;</span><span class="p">...,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">the_one</span><span class="p">,</span> <span class="k">auto</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">the_one</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">mutable</span> <span class="k">decltype</span><span class="p">(</span><span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...))</span> <span class="n">lambda_</span> <span class="o">=</span>
    <span class="n">TupleLambda</span><span class="p">(</span><span class="n">StorageFor</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">{}...);</span>
<span class="p">};</span>

<span class="cp">#if USE_CLANG_INTRINSIC
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">::</span><span class="k">template</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;;</span>
<span class="cp">#else
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">TupleType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">i</span><span class="p">&gt;())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="n">Tuple</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Types</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TupleType</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace std</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Tuple</span> <span class="n">tup</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">tup</span><span class="p">.</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">,</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><a class="codeblock-button godbolt" href="https://godbolt.org/z/eYeb9Y6cn">godbolt</a><div class="codeblock-button">C++</div></div></div> <p><a href="#fnref:code-so-far-2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="c++"/><category term="templates"/><category term="metaprogramming"/><summary type="html"><![CDATA[Let’s talk about C++ templates.]]></summary></entry></feed>