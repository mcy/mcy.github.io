<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://mcyoung.xyz/https://mcyoung.xyz/feed.xml" rel="self" type="application/atom+xml"/><link href="https://mcyoung.xyz/https://mcyoung.xyz/" rel="alternate" type="text/html"/><updated>2025-07-16T11:57:03-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/feed.xml</id><title type="html">mcyoung</title><subtitle>I&apos;m Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </subtitle><author><name>Miguel Young de la Sota</name></author><entry><title type="html">Parsing Protobuf Like Never Before</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/07/16/hyperpb/" rel="alternate" type="text/html" title="Parsing Protobuf Like Never Before"/><published>2025-07-16T00:00:00-07:00</published><updated>2025-07-16T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/07/16/hyperpb</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/07/16/hyperpb/"><![CDATA[<p>Historically I have worked on many projects related to high-performance Protobuf, be that on the C++ runtime, on the Rust runtime, or on integrating <a href="https://github.com/protocolbuffers/protobuf/tree/main/upb">UPB</a>, the fastest Protobuf runtime, written by my colleague <a href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html">Josh Haberman</a>. I <em>generally</em> don’t post directly about my current job, but my most recent toy-turned-product is something I’m very excited to talk about: <code class="language-plaintext highlighter-rouge">hyperpb</code>.</p> <p>Here’s how we measure up against other Go Protobuf parsers. This is a subset of my benchmarks, since the benchmark suite contains many dozens of specimens. This was recorded on an AMD Zen 4 machine.</p> <figure style="max-width: 95%;"> <p><img src="https://mcyoung.xyz/public/images/hyperpb/benches.svg" alt=""/></p> <figcaption> <p>Throughput for various configurations of <code class="language-plaintext highlighter-rouge">hyperpb</code> (colored bars) vs. competing parsers (grey bars). Each successive <code class="language-plaintext highlighter-rouge">hyperpb</code> includes all previous optimizations, corresponding to <a href="#zerocopy-strings">zerocopy mode</a>, <a href="#arena-reuse">arena reuse</a>, and <a href="#tdptype">profile-guided optimization</a>. Bigger is better.</p> </figcaption> </figure> <p>Traditionally, Protobuf backends would generate parsers by generating a very large amount of code that are specialized to each type. Naively, this would give the best performance, because everything would be “right-sized” to a particular message type. Unfortunately, now that we know better, there are a bunch of drawbacks:</p> <ol> <li>Every type you care about must be compiled ahead-of-time. Tricky for when you want to build something generic over schemas your users provide you.</li> <li>Every type contributes to a cost on the instruction cache, meaning that if your program parses a lot of different types, it will essentially flush your instruction cache any time you enter a parser. Worse still, if a parse involves enough types, the parser itself will hit instruction decoding throughput issues.</li> </ol> <p>These effects are not directly visible in normal workloads, but other side-effects are visible: for example, giant switches on field numbers can turn into chains of branch instructions, meaning that higher-numbered fields will be quite slow. Even binary-searching on field numbers isn’t exactly ideal. However, we know that every Protobuf codec ever emits fields in index order (i.e., declaration order in the <code class="language-plaintext highlighter-rouge">.proto</code> file), which is a data conditioning fact we don’t take advantage of with a switch.</p> <p>UPB solves this problem. It is a small C kernel for parsing Protobuf messages, which is completely dynamic: a UPB “parser” is actually a collection of data tables that are evaluated by a <em>table-driven parser</em>. In other words, a UPB parser is actually configuration for an interpreter VM, which executes Protobuf messages as its bytecode. UPB also contains many arena optimizations to improve allocation throughput when parsing complex messages.</p> <p><code class="language-plaintext highlighter-rouge">hyperpb</code> is a brand new library, written in the most cursed Go imaginable, which brings many of the optimizations of UPB to Go, and many new ones, while being tuned to Go’s own weird needs. The result leaves the competition in the dust in virtually every benchmark, while being completely runtime-dynamic. This means it’s faster than Protobuf Go’s own generated code, <a href="https://github.com/planetscale/vtprotobuf"><code class="language-plaintext highlighter-rouge">vtprotobuf</code></a> (a popular but non-conforming<sup id="fnref:vtproto" role="doc-noteref"><a href="#fn:vtproto" class="footnote" rel="footnote">1</a></sup> parser generator for Go).</p> <p>This post is about some of the internals of <code class="language-plaintext highlighter-rouge">hyperpb</code>. I have also prepared a more sales-oriented pitch of this work, which you can read about on <a href="https://buf.build/blog/introducing-hyperpb">the Buf blog</a>.</p> <h2 id="why-reinvent-upb"><a href="#why-reinvent-upb">Why Reinvent UPB?</a></h2> <p>UPB is awesome. It can slot easily into any language that has C FFI, which is basically every language ever.</p> <p>Unfortunately, Go’s C FFI is really, really bad. It’s hard to overstate how bad cgo is. There isn’t a good way to cooperate with C on memory allocation (C can’t really handle Go memory without a lot of problems, due to the GC). Having C memory get cleaned up by the GC requires finalizers, which are very slow. Calling into C is very slow, because Go pessimistically assumes that C requires a large stack, and also calling into C does nasty things to the scheduler.</p> <p>All of these things can be worked around, of course. For a while I considered compiling UPB to assembly, and rewriting that assembly into Go’s awful assembly syntax<sup id="fnref:go-asm" role="doc-noteref"><a href="#fn:go-asm" class="footnote" rel="footnote">2</a></sup>, and then having Go assemble UPB out of that. This presents a few issues though, particularly because Go’s assembly calling convention is still in the stone age (arguments are passed on the stack), and because we would still need to do a lot of work to get UPB to match the <code class="language-plaintext highlighter-rouge">protoreflect</code> API.</p> <p>Go also has a few… unique qualities that make writing a Protobuf interpreter an interesting challenge with unique optimization opportunities.</p> <p>First, of course, is the register ABI, which on <code class="language-plaintext highlighter-rouge">x86_64</code> gives us a whopping <em>nine</em> argument and return registers, meaning that we can simply pass the entire parser state in registers all the time.</p> <p>Second is that Go does not have much UB to speak of, so we can get away with a lot of very evil pointer crimes that we could not in C++ or Rust.</p> <p>Third is that Protobuf Go has a robust reflection system that we can target if we design specifically for it.</p> <p>Also, the Go ecosystem seems much more tolerant of less-than-ideal startup times (because the language <em>loves</em> life-before-main due to <code class="language-plaintext highlighter-rouge">init()</code> functions), so unlike UPB, we can require that the interpreter’s program be generated at runtime, meaning that we can design for online PGO. In other words, we have the perfect storm to create the first-ever Protobuf JIT compiler (which we also refer to as “online PGO” or “real-time PGO”).</p> <h2 id="hyperpbs-api"><a href="#hyperpbs-api"><code class="language-plaintext highlighter-rouge">hyperpb</code>’s API</a></h2> <p>Right now, <code class="language-plaintext highlighter-rouge">hyperpb</code>’s API is very simple. There are <code class="language-plaintext highlighter-rouge">hyperpb.Compile*</code> functions that accept some representation of a message descriptor, and return a <code class="language-plaintext highlighter-rouge">*hyperpb.MessageType</code>, which implements the <code class="language-plaintext highlighter-rouge">protoreflect</code> type APIs. This can be used to allocate a new <code class="language-plaintext highlighter-rouge">*hyperpb.Message</code> , which you can shove into <code class="language-plaintext highlighter-rouge">proto.Unmarshal</code> and do reflection on. However, you can’t mutate <code class="language-plaintext highlighter-rouge">hyperpb.Message</code>s currently, because the original use-case envisioned is read-only. All mutations panic instead.</p> <p>The hero use-case, using Buf’s <code class="language-plaintext highlighter-rouge">protovalidate</code> library, which uses reflection to execute validation predicates, looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// Compile a new message type, deserializing an encoded FileDescriptorSet.</span>
<span class="n">msgType</span> <span class="o">:=</span> <span class="n">hyperpb</span><span class="o">.</span><span class="n">CompileForBytes</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="s">"my.api.v1.Request"</span><span class="p">)</span>

<span class="c">// Allocate a new message of that type.</span>
<span class="n">msg</span> <span class="o">:=</span> <span class="n">hyperpb</span><span class="o">.</span><span class="n">NewMessage</span><span class="p">(</span><span class="n">msgType</span><span class="p">)</span>

<span class="c">// Unmarshal like you would any other message, using proto.Unmarshal.</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">proto</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="c">// Handle parse failure.</span>
<span class="p">}</span>

<span class="c">// Validate the message. Protovalidate uses reflection, so this Just Works.</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">protovalidate</span><span class="o">.</span><span class="n">Validate</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="c">// Handle validation failure.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>We tell users to make sure to cache the compilation step because compilation can be arbitrarily slow: it’s an optimizing compiler! This is not unlike the same warning on <code class="language-plaintext highlighter-rouge">regexp.Compile</code> , which makes it easy to teach users how to use this API correctly.</p> <p>In addition to the main API, there’s a bunch of performance tuning knobs for the compiler, for unmarshalling, and for recording profiles. Types can be recompiled using a recorded profile to be more optimized for the kinds of messages that actually come on the wire. <code class="language-plaintext highlighter-rouge">hyperpb</code> PGO<sup id="fnref:go-pgo" role="doc-noteref"><a href="#fn:go-pgo" class="footnote" rel="footnote">3</a></sup> affects a number of things that we’ll get into as I dive into the implementation details.</p> <h2 id="the-guts"><a href="#the-guts">The Guts</a></h2> <p>Most of the core implementation lives under <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/tdp"><code class="language-plaintext highlighter-rouge">internal/tdp</code></a>. The main components are as follows:</p> <ol> <li><code class="language-plaintext highlighter-rouge">tdp</code>, which defines the “object code format” for the interpreter. This includes definitions for describing types and fields to the parser.</li> <li><code class="language-plaintext highlighter-rouge">tdp/compiler</code>, which contains all of the code for converting a <code class="language-plaintext highlighter-rouge">protoreflect.MessageDescriptor</code> into a <code class="language-plaintext highlighter-rouge">tdp.Library</code>, which contains all of the types relevant to a particular parsing operation.</li> <li><code class="language-plaintext highlighter-rouge">tdp/dynamic</code> defines what dynamic message types look like. The compiler does a bunch of layout work that gets stored in <code class="language-plaintext highlighter-rouge">tdp.Type</code> values, which a <code class="language-plaintext highlighter-rouge">dynamic.Message</code> interprets to find the offsets of fields within itself.</li> <li><code class="language-plaintext highlighter-rouge">tdp/vm</code> contains the core interpreter implementation, including the VM state that is passed in registers everywhere. It also includes hand-optimized routines for parsing varints and validating UTF-8.</li> <li><code class="language-plaintext highlighter-rouge">tdp/thunks</code> defines <em>archetypes</em>, which are classes of fields that all use the same layout and parsers. This corresponds roughly to a <code class="language-plaintext highlighter-rouge">(presence, kind)</code> pair, but not exactly. There are around 200 different archetypes.</li> </ol> <p>This article won’t be a deep-dive into everything in the parser, and even this excludes large portions of <code class="language-plaintext highlighter-rouge">hyperpb</code>. For example, the <a href="https://mcyoung.xyz/2025/04/21/go-arenas/"><code class="language-plaintext highlighter-rouge">internal/arena</code></a> package is already described in a different blogpost of mine. I recommend taking a look at that to learn about how we implement a GC-friendly arena for <code class="language-plaintext highlighter-rouge">hyperpb</code> .</p> <p>Instead, I will give a brief overview of how the object code is organized and how the parser interprets it. I will also go over a few of the more interesting optimizations we have.</p> <h3 id="tdptype"><a href="#tdptype">tdp.Type</a></h3> <p>Every <code class="language-plaintext highlighter-rouge">MessageDescriptor</code> that is reachable from the root message (either as a field or as an extension) becomes a <code class="language-plaintext highlighter-rouge">tdp.Type</code> . This contains the dynamic size of the corresponding message type, a pointer to the type’s default parser (there can be more than one parser for a type) and a variable number of <code class="language-plaintext highlighter-rouge">tdp.Field</code> values. These specify the offset of each field and provide accessor thunks, for actually extracting the value of the field.</p> <p>A <code class="language-plaintext highlighter-rouge">tdp.TypeParser</code> is what the parser VM interprets alongside encoded Protobuf data. It contains all of the information needed for decoding a message in compact form, including <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code>s for each of its fields (and extensions), as well as a hashtable for looking up a field by tag, which is used by the VM as a fallback.</p> <p>The <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code>s each contain:</p> <ol> <li>The same offset information as a <code class="language-plaintext highlighter-rouge">tdp.Field</code>.</li> <li>The field’s tag, in a special format.</li> <li>A function pointer that gets called to parse the field.</li> <li>The next field(s) to try parsing after this one is parsed.</li> </ol> <p>Each <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code> actually corresponds to a possible tag on a record for this message. Some fields have multiple different tags: for example, a <code class="language-plaintext highlighter-rouge">repeated int32</code> can have a <code class="language-plaintext highlighter-rouge">VARINT</code>-type tag for the repeated representation, and a <code class="language-plaintext highlighter-rouge">LEN</code>-type tag for the packed representation.</p> <p>Each field specifies which fields to try next. This allows the compiler to perform <em>field scheduling</em>, by carefully deciding which order to try fields in based both on their declaration order and a rough estimation of their “hotness”, much like branch scheduling happens in a program compiler. This avoids almost all of the work of looking up the next field in the common case, because we have already pre-loaded the correct guess.</p> <p>I haven’t managed to nail down a good algorithm for this yet, but I am working on a system for implementing a type of “branch prediction” for PGO, that tries to provide better predictions for the next fields to try based on what has been seen before.</p> <p>The offset information for a field is more than just a memory offset. A <code class="language-plaintext highlighter-rouge">tdp.Offset</code> includes a bit offset, for fields which request allocation of individual bits in the message’s bitfields. These are used to implement the hasbits of <code class="language-plaintext highlighter-rouge">optional</code> fields (and the values of <code class="language-plaintext highlighter-rouge">bool</code> fields). It also includes a byte offset for larger storage. However, this byte offset can be negative, in which case it’s actually an offset into the <em>cold region</em>.</p> <p>In many messages, most fields won’t be set, particularly extensions. But we would like to avoid having to allocate memory for the very rare (i.e., “cold”) fields. For this, a special “cold region” exists in a separate allocation from the main message, which is referenced via a compressed pointer. If a message happens to need a cold field set, it takes a slow path to allocate a cold region only if needed. Whether a field is cold is a dynamic property that can be affected by PGO.</p> <h3 id="the-parser-vm"><a href="#the-parser-vm">The Parser VM</a></h3> <p>The parser is designed to make maximal use of Go’s generous ABI without spilling anything to the stack that isn’t absolutely necessary. The parser state consists of eight 64-bit integers, split across two types: <code class="language-plaintext highlighter-rouge">vm.P1</code> and <code class="language-plaintext highlighter-rouge">vm.P2</code>. Unfortunately, these can’t be merged due to a <a href="https://github.com/golang/go/issues/72897">compiler bug</a>, as documented in <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/tdp/vm/vm.go#L50"><code class="language-plaintext highlighter-rouge">vm/vm.go</code></a>.</p> <p>Every parser function takes these two structs as its first two arguments, and returns them as its first two results. This ensures that register allocation tries its darnedest to keep those eight integers in the first eight argument registers, even across calls. This leads to the common idiom of</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">n</span> <span class="kt">int</span>
<span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Overwriting the parser state like this ensures that future uses of p1 and p2 use the values that <code class="language-plaintext highlighter-rouge">DoSomething</code> places in registers for us.</p> <p>I spent a lot of time and a lot of profiling catching all of the places where Go would incorrectly spill parser state to the stack, which would result in stalls. I found quite a few codegen bugs in the process. Particularly notable is https://github.com/golang/go/issues/73589, which shocked me. Go has somehow made it a decade without a very basic pointer-to-registers lifting pass (for comparison, this is a heavy-lifting SSA cleanup pass in LLVM).</p> <p>The core loop of the VM goes something like this:</p> <ol> <li>Are we out of bytes to parse? If so, pop a parser stack frame<sup id="fnref:stack" role="doc-noteref"><a href="#fn:stack" class="footnote" rel="footnote">4</a></sup>. If we popped the last stack frame, parsing is done; return success.</li> <li>Parse a tag. This does not fully decode the tag, because <code class="language-plaintext highlighter-rouge">tdp.FieldParser</code>s contain a carefully-formatted, partially-decoded tag to reduce decoding work.</li> <li>Check if the next field we would parse matches the tag. <ol> <li>If yes, call the function pointer <code class="language-plaintext highlighter-rouge">tdp.Field.Parser</code>; update the current field to <code class="language-plaintext highlighter-rouge">tdp.Field.NextOk</code>; goto 1.</li> <li>If no, update the current field to <code class="language-plaintext highlighter-rouge">tdp.Field.NextErr</code>; goto 3.</li> <li>If no “enough times”, fall through.</li> </ol> </li> <li>Slow path: hit <code class="language-plaintext highlighter-rouge">tdp.Field.Tags</code> to find the matching field for that tag. <ol> <li>If matched, go to 3a.</li> <li>If not, this is an unknown field; put it into the unknown field set; parse a tag and goto 4.</li> </ol> </li> </ol> <p>Naturally, this is implemented as a single function whose control flow consists exclusively of <code class="language-plaintext highlighter-rouge">if</code>s and <code class="language-plaintext highlighter-rouge">goto</code>s, because getting Go to generate good control flow otherwise proved too hard.</p> <p>Now, you might be wondering why the hot loop for the parser includes <em>calling a virtual function</em>. Conventional wisdom holds that virtual calls are slow. After all, the actual virtual call instruction is quite slow, because it’s an indirect branch, meaning that it can easily stall the CPU. However, it’s actually <em>much faster than the alternatives</em> in this case, due to a few quirks of our workload and how modern CPUs are designed:</p> <ol> <li>Modern CPUs are not <em>great</em> at traversing complex “branch mazes”. This means that selecting one of ~100 alternatives using branches, even if they are well-predicted and you use unrolled binary search, is still likely to result in frequent mispredictions, and is an obstacle to other JIT optimizations in the processor’s backend.</li> <li>Predicting a single indirect branch with dozens of popular targets <em>is</em> something modern CPUs are pretty good at. Chips and Cheese have a <a href="https://chipsandcheese.com/i/138977313/indirect-branch-prediction">great writeup</a> on the indirect prediction characteristics of Zen 4 chips.</li> </ol> <p>In fact, the “optimized” form of a large switch is a jump table, which is essentially an array of function pointers. Rather than doing a large number of comparisons and direct branches, a jump table turns a switch into a load and an indirect branch.</p> <p>This is great news for us, because it means we can make use of a powerful assumption about most messages: most messages only feature a handful of field archetypes. How often is it that you see a message which has more in it than <code class="language-plaintext highlighter-rouge">int32</code>, <code class="language-plaintext highlighter-rouge">int64</code>, <code class="language-plaintext highlighter-rouge">string</code> , and submessages? In effect, this allows us to have a very large “instruction set”, consisting of all of the different field archetypes, but a particular message only pays for what it uses. The fewer archetypes it uses <em>at runtime</em>, the better the CPU can predict this indirect jump.</p> <p>On the other hand, we can just keep adding archetypes over time to specialize for common parse workloads, which PGO can select for. Adding new archetypes that are not used by most messages does not incur a performance penalty.</p> <h2 id="other-optimizations"><a href="#other-optimizations">Other Optimizations</a></h2> <p>We’ve already discussed the hot/cold split, and briefly touched on the message bitfields used for <code class="language-plaintext highlighter-rouge">bool</code>s and hasbits. I’d like to mention a few other cool optimizations that help cover all our bases, as far as high-performance parsing does.</p> <h3 id="zerocopy-strings"><a href="#zerocopy-strings">Zerocopy Strings</a></h3> <p>The fastest <code class="language-plaintext highlighter-rouge">memcpy</code> implementation is the one you don’t call. For this reason, we try to, whenever possible, avoid copying anything out of the input buffer. <code class="language-plaintext highlighter-rouge">string</code>s and <code class="language-plaintext highlighter-rouge">bytes</code> are represented as <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/zc/zc.go"><code class="language-plaintext highlighter-rouge">zc.Range</code>s</a>, which are a packed pair of offset+length in a <code class="language-plaintext highlighter-rouge">uint64</code>. Protobuf is not able to handle lengths greater than 2GB properly, so we can assume that this covers all the data we could ever care about. This means that a <code class="language-plaintext highlighter-rouge">bytes</code> field is 8 bytes, rather than 24, in our representation.</p> <p>Zerocopy is also used for packed fields. For example, a <code class="language-plaintext highlighter-rouge">repeated double</code> will typically be encoded as a <code class="language-plaintext highlighter-rouge">LEN</code> record. The number of <code class="language-plaintext highlighter-rouge">float64</code>s in this record is equal to its length divided by 8, and the <code class="language-plaintext highlighter-rouge">float64</code>s are already encoded in IEEE754 format for us. So we can just retain the whole repeated fields as a <code class="language-plaintext highlighter-rouge">zc.Range</code> . Of course, we need to be able to handle cases where there are multiple disjoint records, so the backing <code class="language-plaintext highlighter-rouge">repeated.Scalars</code> can also function as a 24-byte arena slice. Being able to switch between these modes gracefully is a delicate and carefully-tested part of the repeated field thunks.</p> <p>Surprisingly, we also use zerocopy for varint fields, such as <code class="language-plaintext highlighter-rouge">repeated int32</code>. Varints are variable-length, so we can’t just index directly into the packed buffer to get the <code class="language-plaintext highlighter-rouge">n</code> th element… unless all of the elements happen to be the same size. In the case that every varint is one byte (so, between 0 and 127), we can zerocopy the packed field. This is a relatively common scenario, too, so it results in big savings<sup id="fnref:rep-benches" role="doc-noteref"><a href="#fn:rep-benches" class="footnote" rel="footnote">5</a></sup>. We <em>already</em> have to count the number of varints in the packed field in order to preallocate space for it, so this doesn’t add extra cost. Plus, I had already hand-vectorized our varint-counting code (it checks bytes in groups of 8).</p> <h3 id="repeated-preloads"><a href="#repeated-preloads">Repeated Preloads</a></h3> <p>PGO records the median size of each repeated/map field, and that is used to calculate a “preload” for each repeated field. Whenever the field is first allocated, it is pre-allocated using the preload to try to right-size the field with minimal waste.</p> <p>Using the median ensures that large outliers don’t result in huge memory waste; instead, this guarantees that at least 50% of repeated fields will only need to allocate from the arena once. Packed fields don’t use the preload, since in the common case only one record appears for packed fields. This mostly benefits string- and message-typed repeated fields, which can’t be packed.</p> <h3 id="map-optimizations"><a href="#map-optimizations">Map Optimizations</a></h3> <p>We don’t use Go’s built-in map, because it has significant overhead in some cases: in particular, it has to support Go’s mutation-during-iteration semantics, as well as deletion. Although both are Swisstables<sup id="fnref:map-benches" role="doc-noteref"><a href="#fn:map-benches" class="footnote" rel="footnote">6</a></sup> under the hood, my implementation can afford to take a few shortcuts. It also allows our implementation to use arena-managed memory. <a href="https://github.com/bufbuild/hyperpb-go/tree/main/internal/swiss/table.go"><code class="language-plaintext highlighter-rouge">swiss.Table</code>s</a> are used both for the backing store of <code class="language-plaintext highlighter-rouge">map</code> fields, and for maps inside of <code class="language-plaintext highlighter-rouge">tdp.Type</code>s.</p> <p>Currently, the hash used is the variant of <a href="https://github.com/rust-lang/rustc-hash">fxhash used by the Rust compiler</a>. This greatly out-performs Go’s <a href="https://pkg.go.dev/hash/maphash">maphash</a> for integers, but maphash is better for larger strings. I hope to maybe switch to maphash at some point for large strings, but it hasn’t been a priority.</p> <h3 id="arena-reuse"><a href="#arena-reuse">Arena Reuse</a></h3> <p>Hitting the Go allocator is always going to be a little slow, because it’s a general-case allocator. Ideally, we should learn the estimated memory requirements for a particular workload, and then allocate a single block of that size for the arena to portion out.</p> <p>The best way to do this is via <em>arena reuse</em>. In the context of a service, each request has a bounded lifetime on the message that it parses. Once that lifetime is over (the request is complete), the message is discarded. This gives the programmer an opportunity to <em>reset</em> the backing arena, so that it keeps its largest memory block for re-allocation.</p> <p>You can show that over time, this will cause the arena to never hit the Go allocator. If the largest block is too small for a message, a block twice as large will wind up getting allocated. Messages that use the same amount of memory will keep doubling the largest block, until the largest block is large enough to fit the whole message. Memory usage will be at worst 2x the size of this message. Note that, thanks to extensive use of zero-copy optimizations, we can often avoid allocating memory for large portions of the message.</p> <p>Of course, arena re-use poses a memory safety danger, if the previously allocated message is kept around after the arena is reset. For this reason, it’s not the default behavior. Using arena resets is a double-digit percentage improvement, however.</p> <h3 id="oneof-unions"><a href="#oneof-unions">Oneof Unions</a></h3> <p>Go does not properly support unions, because the GC does not keep the necessary book-keeping to distinguish a memory location that may be an integer <em>or</em> a pointer at runtime. Instead, this gets worked around using interfaces, which is always a pointer to some memory. Go’s GC can handle untyped pointers just fine, so this just works.</p> <p>The generated API for Protobuf Go uses interface values for <code class="language-plaintext highlighter-rouge">oneof</code>s. This API is… pretty messy to use, unfortunately, and triggers unnecessary allocations, (much like <code class="language-plaintext highlighter-rouge">optional</code> fields do in the open API).</p> <p>However, my arena design (<a href="https://mcyoung.xyz/2025/04/21/go-arenas/">read about it here</a>) makes it possible to store arena pointers on the arena as if they are integers, since the GC does not need to scan through arena memory. Thus, our <code class="language-plaintext highlighter-rouge">oneof</code>s are true unions, like in C++.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p><code class="language-plaintext highlighter-rouge">hyperpb</code> is really exciting because its growing JIT capabilities offer an improvement in the state of the art over UPB. It’s also been a really fun challenge working around Go compiler bugs to get the best assembly possible. The code is already so well-optimized that re-building the benchmarks with the Go compiler’s own PGO mode (based on a profile collected from the benchmarks) didn’t really seem to move the needle!</p> <p>I’m always working on making <code class="language-plaintext highlighter-rouge">hyperpb</code> better (I get paid for it!) and I’m always excited to try new optimizations. If you think of something, file an issue! I have meticulously commented most things within <code class="language-plaintext highlighter-rouge">hyperpb</code> , so it should be pretty easy to get an idea of where things are if you want to contribute.</p> <p>I would like to write more posts diving into some of the weeds of the implementation. I can’t promise anything, but there’s lots to talk about. For now… have fun source-diving!</p> <p>There’s a lot of other things we could be doing: for example, we could be using SIMD to parse varints, we could have smarter parser scheduling, we could be allocating small submessages inline to improve locality… there’s still so much we can do!</p> <p>And most importantly, I hope you’ve learned something new about performance optimization.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:vtproto" role="doc-endnote"> <p>vtprotobuf gets <em>a lot</em> of things wrong that make it beat us in like two benchmarks, because it is slow sloppy. For example, vtprotobuf believes that it’s ok to not validate UTF-8 strings. This is <em>non-conforming</em> behavior. It also believes that map entries’ fields are always in order and always populated, meaning that valid Protobuf messages containing maps can be parsed <em>incorrectly</em>. This sloppiness is unacceptable, which is why <code class="language-plaintext highlighter-rouge">hyperpb</code> goes to great lengths to implement all of Protobuf correctly. <a href="#fnref:vtproto" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:go-asm" role="doc-endnote"> <p>Never gonna let Rob live that one down. Of all of Rob’s careless design decisions, the assembler is definitely one of the least forgivable ones. <a href="#fnref:go-asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:go-pgo" role="doc-endnote"> <p>This is PGO performed by <code class="language-plaintext highlighter-rouge">hyperpb</code> itself; this is unrelated to <code class="language-plaintext highlighter-rouge">gc</code>’s own PGO mode, which seems to not actually make <code class="language-plaintext highlighter-rouge">hyperpb</code> faster. <a href="#fnref:go-pgo" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:stack" role="doc-endnote"> <p>Yes, the parser manages its own stack separate from the goroutine stack. This ensures that nothing in the parser has to be reentrant. The only time the stack is pushed to is when we “recurse” into a submessage. <a href="#fnref:stack" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rep-benches" role="doc-endnote"> <p>Large packed repeated fields are where the biggest wins are for us. Being able to zero-copy large packed <code class="language-plaintext highlighter-rouge">int32</code> fields full of small values allows us to eliminate all of the overhead that the other runtimes are paying for; we also choose different parsing strategies depending on the byte-to-varint ratio of the record.</p> <figure style="max-width: 95%;"> <p><img src="https://mcyoung.xyz/public/images/hyperpb/repeated.svg" alt=""/></p> <figcaption> <p>Throughput for various repeated field benchmarks. This excludes the <code class="language-plaintext highlighter-rouge">repeated fixed32</code> benchmarks, since those achieve such high throughputs (~20 Gbps) that they make the chart unreadable.</p> </figcaption> </figure> <p>These optimizations account for the performance difference between <code class="language-plaintext highlighter-rouge">descriptor/#00</code> and <code class="language-plaintext highlighter-rouge">descriptor/#01</code> in the first benchmark chart. The latter is a <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> full of <code class="language-plaintext highlighter-rouge">SourceCodeInfo</code>, which is dominated by <code class="language-plaintext highlighter-rouge">repeated int32</code> fields.</p> <p>NB: This chart is currently missing the Y-axis, I need to have it re-made. <a href="#fnref:rep-benches" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:map-benches" role="doc-endnote"> <p>Map parsing performance has been a bit of a puzzle. <code class="language-plaintext highlighter-rouge">vtprotobuf</code> cheats by rejecting some valid map entry encodings, such as (in Protoscope) and <code class="language-plaintext highlighter-rouge">{1: {"key"}}</code>, while mis-parsing others, such as <code class="language-plaintext highlighter-rouge">{2: {"value"} 1: {"key"}}</code>, since they don’t actually validate the field numbers like <code class="language-plaintext highlighter-rouge">hyperpb</code> does.</p> <p>Here’s where the benchmarks currently stand for maps:</p> <figure style="max-width: 95%;"> <p><img src="https://mcyoung.xyz/public/images/hyperpb/maps.svg" alt=""/></p> <figcaption> <p>Throughput for various map parsing benchmarks.</p> </figcaption> </figure> <p>Maps, I’m told, are not very popular in Protobuf, so they’re not something I have tried to optimize as hard as packed repeated fields. <a href="#fnref:map-benches" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="go"/><category term="dark-arts"/><category term="protobuf"/><summary type="html"><![CDATA[Historically I have worked on many projects related to high-performance Protobuf, be that on the C++ runtime, on the Rust runtime, or on integrating UPB, the fastest Protobuf runtime, written by my colleague Josh Haberman. I generally don’t post directly about my current job, but my most recent toy-turned-product is something I’m very excited to talk about: hyperpb.]]></summary></entry><entry><title type="html">The Best C++ Library</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/07/14/best/" rel="alternate" type="text/html" title="The Best C++ Library"/><published>2025-07-14T00:00:00-07:00</published><updated>2025-07-14T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/07/14/best</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/07/14/best/"><![CDATA[<p>It’s no secret that my taste in programming languages is very weird for a programming language <del>enthusiast</del> professional. Several of my <a href="https://mcyoung.xyz/2025/07/07/nosplit/">last</a> <a href="https://mcyoung.xyz/2025/04/21/go-arenas/">few</a> <a href="https://mcyoung.xyz/2024/12/16/rangefuncs/">posts</a> are about Go, broadly regarded as the programming language equivalent of eating plain oatmeal for breakfast.</p> <p>To make up for that, I’m going to write about the programming language equivalent of diluting your morning coffee with <a href="https://en.wikipedia.org/wiki/Everclear">Everclear</a>. I am, of course, talking about C++.</p> <p>If you’ve ever had the misfortune of doing C++ professionally, you’ll know that the C++ standard library is really bad. Where to begin?</p> <p>Well, the associative containers are terrible. Due to bone-headed API decisions, <a href="https://en.cppreference.com/w/cpp/container/unordered_map.html"><code class="language-plaintext highlighter-rouge">std::unordered_map</code></a> MUST be a closed-addressing, array-of-linked-lists map, not a Swisstable, despite closed-addressing being an outdated technology. <a href="https://www.cppreference.com/w/cpp/container/map.html"><code class="language-plaintext highlighter-rouge">std::map</code></a>, which is not what you usually want, <em>must</em> be a red-black tree. It can’t be a b-tree, like every sensible language provides for the ordered map.</p> <p><a href="https://en.cppreference.com/w/cpp/utility/optional.html"><code class="language-plaintext highlighter-rouge">std::optional</code></a> is a massive pain in the ass to use, and is full of footguns, like <code class="language-plaintext highlighter-rouge">operator*</code>. <code class="language-plaintext highlighter-rouge">std::variant</code> is also really annoying to use. <a href="https://en.cppreference.com/w/cpp/filesystem.html"><code class="language-plaintext highlighter-rouge">std::filesystem</code></a> is full of sharp edges. And where are the APIs for signals?</p> <p>Everything is extremely wordy. <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size.html"><code class="language-plaintext highlighter-rouge">std::hardware_destructive_interference_size</code></a> could have been called <code class="language-plaintext highlighter-rouge">std::cache_line</code>. <a href="https://en.cppreference.com/w/cpp/container/span/subspan"><code class="language-plaintext highlighter-rouge">std::span::subspan</code></a> could have used <code class="language-plaintext highlighter-rouge">opeartor[]</code>. The standard algorithms are super wordy, because they deal with iterator pairs. Oh my god, iterator pairs. They added <a href="https://en.cppreference.com/w/cpp/ranges.html"><code class="language-plaintext highlighter-rouge">std::ranges</code></a>, which do not measure up to Rust’s <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code class="language-plaintext highlighter-rouge">Iterator</code></a> at all!</p> <p>I’m so mad about all this! The people in charge of C++ clearly, actively hate their users!<sup id="fnref:terrible-people" role="doc-noteref"><a href="#fn:terrible-people" class="footnote" rel="footnote">1</a></sup> They want C++ to be as hard and unpleasant as possible to use. Many brilliant people that I am lucky to consider friends and colleagues, including Titus Winters, JeanHeyd Meneide, Matt Fowles-Kulukundis, and Andy Soffer, have tried and mostly failed<sup id="fnref:jh" role="doc-noteref"><a href="#fn:jh" class="footnote" rel="footnote">2</a></sup> to improve the language.</p> <p>This is much to say that I believe C++ in its current form is unfixable. But that’s only due to the small-mindedness of a small cabal based out of Redmond. What if we could do whatever we wanted? What if we used C++’s incredible library-building language features to build a brand-new language?</p> <p>For the last year-or-so I’ve been playing with a wild idea: what would C++ look like if we did it over again? Starting from an empty C++20 file with no access to the standard library, what can we build in its place?</p> <h2 id="starting-over"><a href="#starting-over">Starting Over</a></h2> <p>Titus started Abseil while at Google, whose namespace, <code class="language-plaintext highlighter-rouge">absl</code>, is sometimes said to stand for “a better standard library”<sup id="fnref:abcl" role="doc-noteref"><a href="#fn:abcl" class="footnote" rel="footnote">3</a></sup>. To me, Abseil is important because it was an attempt to work with the existing standard library and make it better, while retaining a high level of implementation quality that a C++ shop’s home-grown utility library won’t have, and a uniformity of vision that <a href="https://www.boost.org/">Boost</a> is too all-over-the-place to achieve.</p> <p>Rather than trying to coexist with the standard library, I want to surpass it. As a form of performance art, I want to discover what the standard library would look like if we designed it <em>today</em>, in 2025.</p> <p>In this sense, I want to build something that isn’t just <em>better</em>. It should be the C++ standard library from the best possible world. It is the best possible library. This is why my library’s namespace is <code class="language-plaintext highlighter-rouge">best</code>.</p> <p>In general, I am trying not to directly copy either what C++, or Abseil, or Rust, or Go did. However, each of them has really interesting ideas, and the best library probably lies in some middle-ground somewhere.</p> <p>The rest of this post will be about what I have achieved with <code class="language-plaintext highlighter-rouge">best</code> so far, and where I want to take it. You can look at the code <a href="https://github.com/mcy/best">here</a>.</p> <h3 id="building-a-foundation"><a href="#building-a-foundation">Building a Foundation</a></h3> <p>We’re throwing out everything, and that includes <code class="language-plaintext highlighter-rouge">&lt;type_traits&gt;</code>. This is a header which shows its age: alias templates were’t added until C++14, and variable templates were added in C++17. As a result, many things that really aught to be concepts have names like <code class="language-plaintext highlighter-rouge">best::is_same_v</code>. All of these now have concept equivalents in <code class="language-plaintext highlighter-rouge">&lt;concepts&gt;</code>.</p> <p>I have opted to try to classify type traits into separate headers to make them easier to find. They all live under <code class="language-plaintext highlighter-rouge">//best/meta/traits</code>, and they form the leaves of the dependency graph.</p> <p>For example, <code class="language-plaintext highlighter-rouge">arrays.h</code> contains all of the array traits, such as <code class="language-plaintext highlighter-rouge">best::is_array</code>, <code class="language-plaintext highlighter-rouge">best::un_array</code> (to remove an array extent), and <code class="language-plaintext highlighter-rouge">best::as_array</code>, which applies an extent to a type T, such that <code class="language-plaintext highlighter-rouge">best::as_array&lt;T, 0&gt;</code> is not an error.</p> <p><code class="language-plaintext highlighter-rouge">types.h</code> contains very low-level metaprogramming helpers, such as:</p> <ul> <li><code class="language-plaintext highlighter-rouge">best::id</code> and <code class="language-plaintext highlighter-rouge">best::val</code>, the identity traits for type- and value-kinded traits.</li> <li><code class="language-plaintext highlighter-rouge">best::same&lt;...&gt;</code>, which returns whether an entire <em>pack</em> of types is all equal.</li> <li><code class="language-plaintext highlighter-rouge">best::lie</code>, our version of <code class="language-plaintext highlighter-rouge">std::declval</code>.</li> <li><code class="language-plaintext highlighter-rouge">best::select</code>, our <code class="language-plaintext highlighter-rouge">std::conditional_t</code>.</li> <li><code class="language-plaintext highlighter-rouge">best::abridge</code>, a “symbol compression” mechanism for shortening the names of otherwise huge symbols.</li> </ul> <p><code class="language-plaintext highlighter-rouge">funcs.h</code> provides <code class="language-plaintext highlighter-rouge">best::tame</code>, which removes the qualifiers from an <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html">abominable function type</a>. <code class="language-plaintext highlighter-rouge">quals.h</code> provides <code class="language-plaintext highlighter-rouge">best::qualifies_to</code>, necessary for determining if a type is “more const” than another. <code class="language-plaintext highlighter-rouge">empty.h</code> provides a standard empty type that interoperates cleanly with <code class="language-plaintext highlighter-rouge">void</code>.</p> <p>On top of the type traits is the metaprogramming library <code class="language-plaintext highlighter-rouge">//best/meta</code>, which includes generalized constructibility traits in <code class="language-plaintext highlighter-rouge">init.h</code> (e.g., to check that you can, in fact, initialize a <code class="language-plaintext highlighter-rouge">T&amp;</code> from a <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>, for example). <code class="language-plaintext highlighter-rouge">tlist.h</code> provides a very general type-level heterogenous list abstraction; a parameter pack as-a-type.</p> <p>The other part of “the foundation” is <code class="language-plaintext highlighter-rouge">//best/base</code>, which mostly provides access to intrinsics, portability helpers, macros, and “tag types” such as our versions of <code class="language-plaintext highlighter-rouge">std::in_place</code>. For example, <code class="language-plaintext highlighter-rouge">macro.h</code> provides <code class="language-plaintext highlighter-rouge">BEST_STRINGIFY()</code>, <code class="language-plaintext highlighter-rouge">port.h</code> provides <code class="language-plaintext highlighter-rouge">BEST_HAS_INCLUDE()</code>, and <code class="language-plaintext highlighter-rouge">hint.h</code> provides <code class="language-plaintext highlighter-rouge">best::unreachable()</code>.</p> <p><code class="language-plaintext highlighter-rouge">guard.h</code> provides our version of the Rust <code class="language-plaintext highlighter-rouge">?</code> operator, which is not an expression because statement expressions are broken in Clang.</p> <p>Finally, within <code class="language-plaintext highlighter-rouge">//best/container</code> we find <code class="language-plaintext highlighter-rouge">best::object</code>, a special type for turning any C++ type into an object (i.e., a type that you can form a reference to). This is useful for manipulating any type generically, without tripping over the assign-through semantics of references. For example, <code class="language-plaintext highlighter-rouge">best::object&lt;T&amp;&gt;</code> is essentially a pointer.</p> <h3 id="adt-containers"><a href="#adt-containers">“ADT” Containers</a></h3> <p>On top of this foundation we build the basic algebraic data types of <code class="language-plaintext highlighter-rouge">best</code>: <code class="language-plaintext highlighter-rouge">best::row</code> and <code class="language-plaintext highlighter-rouge">best::choice</code>, which replace <code class="language-plaintext highlighter-rouge">std::tuple</code> and <code class="language-plaintext highlighter-rouge">std::variant</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::row&lt;A, B, C&gt;</code> is a heterogenous collection of values, stored inside of <code class="language-plaintext highlighter-rouge">best::object</code>s. This means that <code class="language-plaintext highlighter-rouge">best::row&lt;int&amp;&gt;</code> has natural rebinding, rather than assign-through, semantics.</p> <p>Accessing elements is done with <code class="language-plaintext highlighter-rouge">at()</code>: <code class="language-plaintext highlighter-rouge">my_row.at&lt;0&gt;()</code> returns a reference to the first element. Getting the first element is so common that you can also use <code class="language-plaintext highlighter-rouge">my_row.first()</code>. Using <code class="language-plaintext highlighter-rouge">my_row.object&lt;0&gt;()</code> will return a reference to a <code class="language-plaintext highlighter-rouge">best::object</code> instead, which can be used for rebinding references. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">best</span><span class="o">::</span><span class="n">row</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="n">a</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>     <span class="c1">// Writes to x.</span>
<span class="n">a</span><span class="p">.</span><span class="n">object</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// Rebinds a.0 to y.</span>
<span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>    <span class="c1">// Writes to y.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>There is also <code class="language-plaintext highlighter-rouge">second()</code> and <code class="language-plaintext highlighter-rouge">last()</code>, for the other two most common elements to access.</p> <p><code class="language-plaintext highlighter-rouge">best::row</code> is named so in reference to database rows: it provides many operations for slicing and dicing that <code class="language-plaintext highlighter-rouge">std::tuple</code> does not.</p> <p>For example, in addition to extracting single elements, it’s also possible to access contiguous subsequences, using <code class="language-plaintext highlighter-rouge">best::bounds</code>: <code class="language-plaintext highlighter-rouge">a.at&lt;best::bounds{.start = 1, .end = 10}&gt;()</code>! There are also a plethora of mutation operations:</p> <ul> <li><code class="language-plaintext highlighter-rouge">a + b</code> concatenates tuples, copying or moving as appropriate (<code class="language-plaintext highlighter-rouge">a + BEST_MOVE(b)</code> will move out of the elements of <code class="language-plaintext highlighter-rouge">b</code>, for example).</li> <li><code class="language-plaintext highlighter-rouge">a.push(x)</code> returns a copy of <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">x</code> appended, while <code class="language-plaintext highlighter-rouge">a.insert&lt;n&gt;(x)</code> does the same at an arbitrary index.</li> <li><code class="language-plaintext highlighter-rouge">a.update&lt;n&gt;(x)</code> <em>replaces</em> the <code class="language-plaintext highlighter-rouge">n</code>th element with <code class="language-plaintext highlighter-rouge">x</code>, potentially of a different type.</li> <li><code class="language-plaintext highlighter-rouge">a.remove&lt;n&gt;()</code> deletes the <code class="language-plaintext highlighter-rouge">n</code>th element, while <code class="language-plaintext highlighter-rouge">a.erase&lt;...&gt;()</code> deletes a contiguous range.</li> <li><code class="language-plaintext highlighter-rouge">a.splice&lt;best::bounds{...}&gt;(...)</code> splices a row into another row, offering a general replace/delete operation that all of the above operations are implemented in terms of.</li> <li><code class="language-plaintext highlighter-rouge">gather()</code> and <code class="language-plaintext highlighter-rouge">scatter()</code> are even more general, allowing for non-contiguous indexing.</li> </ul> <p>Meanwhile, <code class="language-plaintext highlighter-rouge">std::apply</code> is a method now: <code class="language-plaintext highlighter-rouge">a.apply(f)</code> calls <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">a</code>’s elements as its arguments. <code class="language-plaintext highlighter-rouge">a.each(f)</code> is similar, but instead expands to <code class="language-plaintext highlighter-rouge">n</code> unary calls of <code class="language-plaintext highlighter-rouge">f</code>, one with each element.</p> <p>And <em>of course</em>, <code class="language-plaintext highlighter-rouge">best::row</code> supports structured bindings.</p> <p>Meanwhile, <code class="language-plaintext highlighter-rouge">best::choice&lt;A, B, C&gt;</code> contains precisely one value from various types. There is an underlying <code class="language-plaintext highlighter-rouge">best::pun&lt;A, B, C&gt;</code> type that implements a variadic untagged union that works around many of C++’s bugs relating to unions with members of non-trivial type.</p> <p>The most common way to operate on a choice is to <code class="language-plaintext highlighter-rouge">match</code> on it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">choice</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="o">*</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">match</span><span class="p">(</span>
  <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Which case gets called here is chosen by overload resolution, allowing us to write a default case as <code class="language-plaintext highlighter-rouge">[](auto&amp;&amp;) { ... }</code>.</p> <p>Which variant is currently selected can be checked with <code class="language-plaintext highlighter-rouge">z.which()</code>, while specific variants can be accessed with <code class="language-plaintext highlighter-rouge">z.at()</code>, just like a <code class="language-plaintext highlighter-rouge">best::row</code>, except that it returns a <code class="language-plaintext highlighter-rouge">best::option&lt;T&amp;&gt;</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::choice</code> is what all of the other sum types, like <code class="language-plaintext highlighter-rouge">best::option</code> and <code class="language-plaintext highlighter-rouge">best::result</code>, are built out of. All of the clever layout optimizations live here.</p> <p>Speaking of <code class="language-plaintext highlighter-rouge">best::option&lt;T&gt;</code>, that’s our option type. It’s close in spirit to what <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code></a> is in Rust. <code class="language-plaintext highlighter-rouge">best</code> has a generic niche mechanism that user types can opt into, allowing <code class="language-plaintext highlighter-rouge">best::option&lt;T&amp;&gt;</code> to be the same size as a pointer, using <code class="language-plaintext highlighter-rouge">nullptr</code> for the <code class="language-plaintext highlighter-rouge">best::none</code> variant.</p> <p><code class="language-plaintext highlighter-rouge">best::option</code> provides the usual transformation operations: <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">filter</code>. Emptiness can be checked with <code class="language-plaintext highlighter-rouge">is_empty()</code> or <code class="language-plaintext highlighter-rouge">has_value()</code>. You can even pass a predicate to <code class="language-plaintext highlighter-rouge">has_value()</code> to check the value with, if it’s present: <code class="language-plaintext highlighter-rouge">x.has_value([](auto&amp; x) { return x == 42; })</code>.</p> <p>The value can be accessed using <code class="language-plaintext highlighter-rouge">operator*</code> and <code class="language-plaintext highlighter-rouge">operator-&gt;</code>, like <code class="language-plaintext highlighter-rouge">std::optional</code>; however, this operation is checked, instead of causing UB if the option is empty. <code class="language-plaintext highlighter-rouge">value_or()</code> can be used to unwrap with a default; the default can be any number of arguments, which are used to construct the default, or even a callback. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">option</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>

<span class="c1">// Pass arguments to the constructor.</span>
<span class="n">do_something</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value_or</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">));</span>

<span class="c1">// Execute arbitrary logic if the value is missing.</span>
<span class="n">do_something</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value_or</span><span class="p">([]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Foo</span><span class="p">(...);</span>
<span class="p">}))</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::option&lt;void&gt;</code> also Just Works (in fact, <code class="language-plaintext highlighter-rouge">best::option&lt;T&gt;</code> is a <code class="language-plaintext highlighter-rouge">best::choice&lt;void, T&gt;</code> internally), allowing for truly generic manipulation of optional results.</p> <p><code class="language-plaintext highlighter-rouge">best::result&lt;T, E&gt;</code> is, unsurprisingly, the analogue of Rust’s <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code></a>. Because it’s a <code class="language-plaintext highlighter-rouge">best::choice</code> internally, <code class="language-plaintext highlighter-rouge">best::result&lt;void, E&gt;</code> works as you might expect, and is a common return value for I/O operations.</p> <p>It’s very similar to <code class="language-plaintext highlighter-rouge">best::option</code>, including offering <code class="language-plaintext highlighter-rouge">operator-&gt;</code> for accessing the “ok” variant. This enables succinct idioms:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fallible</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">r</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">best</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">err</span><span class="p">());</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">r.ok()</code> and <code class="language-plaintext highlighter-rouge">r.err()</code> return <code class="language-plaintext highlighter-rouge">best::option</code>s containing references to the ok and error variants, depending on which is actually present; meanwhile, a <code class="language-plaintext highlighter-rouge">best::option</code> can be converted into a <code class="language-plaintext highlighter-rouge">best::result</code> using <code class="language-plaintext highlighter-rouge">ok_or()</code> or <code class="language-plaintext highlighter-rouge">err_or()</code>, just like in Rust.</p> <p><code class="language-plaintext highlighter-rouge">best::result</code>s are constructed using <code class="language-plaintext highlighter-rouge">best::ok</code> and <code class="language-plaintext highlighter-rouge">best::err</code>. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>These internally use <code class="language-plaintext highlighter-rouge">best::args</code>, a wrapper over <code class="language-plaintext highlighter-rouge">best::row</code> that represents a “delayed initialization” that can be stored in a value. It will implicitly convert into any type that can be constructed from its elements. For example:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span>  <span class="c1">// Calls Foo::Foo(args, to, foo).</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Also, every one of the above types is a structural type, meaning it can be used for non-type template parameters!</p> <h3 id="memory-and-pointers"><a href="#memory-and-pointers">Memory and Pointers</a></h3> <p>Of course, all of these ADTs need to be built on top of pointer operations, which is where <code class="language-plaintext highlighter-rouge">//best/memory</code> comes in. <code class="language-plaintext highlighter-rouge">best::ptr&lt;T&gt;</code> is a generalized pointer type that provides many of the same operations as Rust’s raw pointers, including offsetting, copying, and indexing. Like Rust pointers, <code class="language-plaintext highlighter-rouge">best::ptr&lt;T&gt;</code> can be a fat pointer, i.e., it can carry additional metadata on top of the pointer. For example, <code class="language-plaintext highlighter-rouge">best::ptr&lt;int[]&gt;</code> remembers the size of the array.</p> <p>Providing metadata for a <code class="language-plaintext highlighter-rouge">best::ptr</code> is done through a member alias called <code class="language-plaintext highlighter-rouge">BestPtrMetadata</code>. This alias should be private, which <code class="language-plaintext highlighter-rouge">best</code> is given access to by befriending <code class="language-plaintext highlighter-rouge">best::access</code>. Types with custom metadata will usually not be directly constructible (because they are of variable size), and must be manipulated exclusively through types like <code class="language-plaintext highlighter-rouge">best::ptr</code>.</p> <p>Specifying custom metadata allows specifying what the pointer dereferences to. For example, <code class="language-plaintext highlighter-rouge">best::ptr&lt;int[]&gt;</code> dereferences to a <code class="language-plaintext highlighter-rouge">best::span&lt;int&gt;</code>, meaning that all the span operations are accessible through <code class="language-plaintext highlighter-rouge">operator-&gt;</code>: for example, <code class="language-plaintext highlighter-rouge">my_array_ptr-&gt;first()</code>.</p> <p>Most of this may seem a bit over-complicated, since ordinary C++ raw pointers and references are fine for most uses. However, <code class="language-plaintext highlighter-rouge">best::ptr</code> is the foundation upon which <code class="language-plaintext highlighter-rouge">best::box&lt;T&gt;</code> is built on. <code class="language-plaintext highlighter-rouge">best::box&lt;T&gt;</code> is a replacement for <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr.html"><code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code></a> that fixes its const correctness and adds Rust <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code class="language-plaintext highlighter-rouge">Box</code></a>-like helpers. <code class="language-plaintext highlighter-rouge">best::box&lt;T[]&gt;</code> also works, but unlike <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T[]&gt;</code>, it remembers its size, just like <code class="language-plaintext highlighter-rouge">best::ptr&lt;T[]&gt;</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::box</code> is parameterized by its allocator, which must satisfy <code class="language-plaintext highlighter-rouge">best::allocator</code>, a much less insane API than what <a href="https://en.cppreference.com/w/cpp/memory/allocator.html"><code class="language-plaintext highlighter-rouge">std::allocator</code></a> offers. <code class="language-plaintext highlighter-rouge">best::malloc</code> is a singleton allocator representing the system allocator.</p> <p><code class="language-plaintext highlighter-rouge">best::span&lt;T&gt;</code>, mentioned before, is the contiguous memory abstraction, replacing <a href="https://en.cppreference.com/w/cpp/container/span.html"><code class="language-plaintext highlighter-rouge">std::span</code></a>. Like <code class="language-plaintext highlighter-rouge">std::span</code>, <code class="language-plaintext highlighter-rouge">best::span&lt;T, n&gt;</code> is a fixed-length span of <code class="language-plaintext highlighter-rouge">n</code> elements. Unlike <code class="language-plaintext highlighter-rouge">std::span</code>, the second parameter is a <code class="language-plaintext highlighter-rouge">best::option&lt;size_t&gt;</code>, not a <code class="language-plaintext highlighter-rouge">size_t</code> that uses <code class="language-plaintext highlighter-rouge">-1</code> as a sentinel.</p> <p><code class="language-plaintext highlighter-rouge">best::span&lt;T&gt;</code> tries to approximate the API of <a href="https://doc.rust-lang.org/std/primitive.slice.html">Rust slices</a>, providing indexing, slicing, splicing, search, sort, and more. Naturally, it’s also iterable, both forwards and backwards, and provides splitting iterators, just like Rust.</p> <p>Slicing and indexing is always bounds-checked. Indexing can be done with <code class="language-plaintext highlighter-rouge">size_t</code> values, while slicing uses a <code class="language-plaintext highlighter-rouge">best::bounds</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[{.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="mi">6</span><span class="p">}];</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::bounds</code> is a generic mechanism for specifying slicing bounds, similar to Rust’s <a href="https://doc.rust-lang.org/std/ops/struct.Range.html">range types</a>. You can specify the start and end (exclusive), like <code class="language-plaintext highlighter-rouge">x..y</code> in Rust. You can also specify an inclusive end using <code class="language-plaintext highlighter-rouge">.inclusive_end = 5</code>, equivalent to Rust’s <code class="language-plaintext highlighter-rouge">x..=y</code>. And you can specify a count, like C++’s slicing operations prefer: <code class="language-plaintext highlighter-rouge">{.start = 1, .count = 5}</code>. <code class="language-plaintext highlighter-rouge">best::bounds</code> itself provides all of the necessary helpers for performing bounds checks and crashing with a nice error message. <code class="language-plaintext highlighter-rouge">best::bounds</code> is also iterable, as we’ll see shortly.</p> <p><code class="language-plaintext highlighter-rouge">best::layout</code> is a copy of Rust’s <a href="https://doc.rust-lang.org/std/alloc/struct.Layout.html"><code class="language-plaintext highlighter-rouge">Layout</code></a> type, providing similar helpers for performing C++-specific size and address calculations.</p> <h3 id="iterators"><a href="#iterators">Iterators</a></h3> <p>C++ iterator pairs suck. C++ ranges suck. <code class="language-plaintext highlighter-rouge">best</code> provides a new paradigm for iteration that is essentially just Rust <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code class="language-plaintext highlighter-rouge">Iterator</code>s</a> hammered into a C++ shape. This library lives in <code class="language-plaintext highlighter-rouge">//best/iter</code>.</p> <p>To define an iterator, you define an <em>iterator implementation type</em>, which must define a member function named <code class="language-plaintext highlighter-rouge">next()</code> that returns a <code class="language-plaintext highlighter-rouge">best::option</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">my_iter_impl</span> <span class="k">final</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">best</span><span class="o">::</span><span class="n">option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This type is an implementation detail; the actual iterator type is <code class="language-plaintext highlighter-rouge">best::iter&lt;my_iter_impl&gt;</code>. <code class="language-plaintext highlighter-rouge">best::iter</code> provides all kinds of helpers, just like <code class="language-plaintext highlighter-rouge">Iterator</code>, for adapting the iterator or consuming items out of it.</p> <p>Iterators can override the behavior of some of these adaptors to be more efficient, such as for making <code class="language-plaintext highlighter-rouge">count()</code> constant-time rather than linear. Iterators can also offer extra methods if they define the member alias <code class="language-plaintext highlighter-rouge">BestIterArrow</code>; for example, the iterators for <code class="language-plaintext highlighter-rouge">best::span</code> have a <code class="language-plaintext highlighter-rouge">-&gt;rest()</code> method for returning the part of the slice that has not been yielded by <code class="language-plaintext highlighter-rouge">next()</code> yet.</p> <p>One of the most important extension points is <code class="language-plaintext highlighter-rouge">size_hint()</code>, analogous to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint"><code class="language-plaintext highlighter-rouge">Iterator::size_hint()</code></a>, for right-sizing containers that the iterator is converted to, such as a <code class="language-plaintext highlighter-rouge">best::vec</code>.</p> <p>And of course, <code class="language-plaintext highlighter-rouge">best::iter</code> provides <code class="language-plaintext highlighter-rouge">begin/end</code> so that it can be used in a C++ range-for loop, just like C++20 ranges do. <code class="language-plaintext highlighter-rouge">best::int_range&lt;I&gt;</code><sup id="fnref:interval" role="doc-noteref"><a href="#fn:interval" class="footnote" rel="footnote">4</a></sup>, which <code class="language-plaintext highlighter-rouge">best::bounds</code> is an instantiation of, is also an iterator, and can be used much like Rust ranges would:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">best</span><span class="o">::</span><span class="n">int_range</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">200</span><span class="p">})</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::int_range</code> will carefully handle all of the awkward corner cases around overflow, such as <code class="language-plaintext highlighter-rouge">best::int_range&lt;uint8_t&gt;{.end_inclusive = 255}</code>.</p> <h3 id="heap-containers"><a href="#heap-containers">Heap Containers</a></h3> <p>Iterators brings us to the most complex container type that’s checked in right now, <code class="language-plaintext highlighter-rouge">best::vec</code>. Not only can you customize its allocator type, but you can customize its small vector optimization type.</p> <p>In <code class="language-plaintext highlighter-rouge">libc++</code>, <code class="language-plaintext highlighter-rouge">std::string</code>s of at most 23 bytes are stored <em>inline</em>, meaning that the strings’s own storage, rather than heap storage, is used to hold them. <code class="language-plaintext highlighter-rouge">best::vec</code> generalizes this, by allowing any trivially copyable type to be inlined. Thus, a <code class="language-plaintext highlighter-rouge">best::vec&lt;int&gt;</code> will hold at most five <code class="language-plaintext highlighter-rouge">int</code>s inline, on 64-bit targets.</p> <p><code class="language-plaintext highlighter-rouge">best::vec</code> mostly copies the APIs of <code class="language-plaintext highlighter-rouge">std::vector</code> and Rust’s <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code class="language-plaintext highlighter-rouge">Vec</code></a>. Indexing and slicing works the same as with <code class="language-plaintext highlighter-rouge">best::span</code>, and all of the <code class="language-plaintext highlighter-rouge">best::span</code> operations can be accessed through <code class="language-plaintext highlighter-rouge">-&gt;</code>, allowing for things like <code class="language-plaintext highlighter-rouge">my_vec-&gt;sort(...)</code>.</p> <p>I have an active (failing) PR which adds <code class="language-plaintext highlighter-rouge">best::table&lt;K, V&gt;</code>, a general hash table implementation that can be used as either a map or a set. Internally it’s backed by a Swisstable<sup id="fnref:swisstable" role="doc-noteref"><a href="#fn:swisstable" class="footnote" rel="footnote">5</a></sup> implementation. Its API resembles neither <code class="language-plaintext highlighter-rouge">std::unordered_map</code>, <code class="language-plaintext highlighter-rouge">absl::flat_hash_map</code>, or Rust’s <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code class="language-plaintext highlighter-rouge">HashMap</code></a>. Instead, everything is done through a general entry API, similar to that of Rust, but optimized for clarity and minimizing hash lookups. I want to get it merged soonish.</p> <p>Beyond <code class="language-plaintext highlighter-rouge">best::table</code>, I plan to add <em>at least</em> the following containers:</p> <ul> <li><code class="language-plaintext highlighter-rouge">best::tree</code>, a btree map/set with a similar API.</li> <li><code class="language-plaintext highlighter-rouge">best::heap</code>, a simple min-heap implementation.</li> <li><code class="language-plaintext highlighter-rouge">best::lru</code>, a <code class="language-plaintext highlighter-rouge">best::table</code> with a linked list running through it for in-order iteration and oldest-member eviction.</li> <li><code class="language-plaintext highlighter-rouge">best::ring</code>, a ring buffer like <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code class="language-plaintext highlighter-rouge">VecDeque</code></a>.</li> <li><code class="language-plaintext highlighter-rouge">best::trie</code>, a port of my <a href="https://docs.rs/twie/latest/twie/"><code class="language-plaintext highlighter-rouge">twie</code> crate</a>.</li> </ul> <p>Possible other ideas: <a href="https://research.swtch.com/sparse">Russ’s sparse array</a>, splay trees, something like Java’s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html"><code class="language-plaintext highlighter-rouge">EnumMap</code></a>, bitset types, and so on.</p> <h3 id="text-handling"><a href="#text-handling">Text Handling</a></h3> <p><code class="language-plaintext highlighter-rouge">best</code>’s string handling is intended to resemble Rust’s as much as possible; it lives within <code class="language-plaintext highlighter-rouge">//best/text</code>. <code class="language-plaintext highlighter-rouge">best::rune</code> is the Unicode scalar type, which is such that it is <em>always</em> within the valid range for a Unicode scalar, but including the unpaired surrogates. It offers a number of relatively simple character operations, but I plan to extend it to all kinds of character classes in the future.</p> <p><code class="language-plaintext highlighter-rouge">best::str</code> is our replacement for <a href="https://en.cppreference.com/w/cpp/string/basic_string_view.html"><code class="language-plaintext highlighter-rouge">best::string_view</code></a>, close to Rust’s <a href="https://doc.rust-lang.org/std/primitive.str.html"><code class="language-plaintext highlighter-rouge">str</code></a>: a sequence of valid UTF-8 bytes, with all kinds of string manipulation operations, such as rune search, splitting, indexing, and so on.</p> <p><code class="language-plaintext highlighter-rouge">best::rune</code> and <code class="language-plaintext highlighter-rouge">best::str</code> use compiler extensions to ensure that when constructed from literals, they’re constructed from <em>valid</em> literals. This means that the following won’t compile!</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">str</span> <span class="n">invalid</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xFF</span><span class="s">"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::str</code> is a <code class="language-plaintext highlighter-rouge">best::span</code> under the hood, which can be accessed and manipulated the same way as the underlying <code class="language-plaintext highlighter-rouge">&amp;[u8]</code> to <code class="language-plaintext highlighter-rouge">&amp;str</code> is.</p> <p><code class="language-plaintext highlighter-rouge">best::strbuf</code> is our <a href="https://en.cppreference.com/w/cpp/string/basic_string.html"><code class="language-plaintext highlighter-rouge">std::string</code></a> equivalent. There isn’t very much to say about it, because it works just like you’d expect, and provides a Rust <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code class="language-plaintext highlighter-rouge">String</code></a>-like API.</p> <p>Where this library really shines is that everything is parametrized over encodings. <code class="language-plaintext highlighter-rouge">best::str</code> is actually a <code class="language-plaintext highlighter-rouge">best::text&lt;best::utf8&gt;</code>; <code class="language-plaintext highlighter-rouge">best::str16</code> is then <code class="language-plaintext highlighter-rouge">best::text&lt;best::utf16&gt;</code>. You can write your own text encodings, too, so long as they are relatively tame and you provide rune encode/decode for them. <code class="language-plaintext highlighter-rouge">best::encoding</code> is the concept</p> <p><code class="language-plaintext highlighter-rouge">best::text</code> is always validly encoded; however, sometimes, that’s not possible. For this reason we have <code class="language-plaintext highlighter-rouge">best::pretext</code>, which is “presumed validly encoded”; its operations can fail or produce replacement characters if invalid code units are found. There is no <code class="language-plaintext highlighter-rouge">best::pretextbuf</code>; instead, you would generally use something like a <code class="language-plaintext highlighter-rouge">best::vec&lt;uint8_t&gt;</code> instead.</p> <p>Unlike C++, the fact that a <code class="language-plaintext highlighter-rouge">best::textbuf</code> is a <code class="language-plaintext highlighter-rouge">best::vec</code> under the hood is part of the public interface, allowing for cheap conversions and, of course, we get <code class="language-plaintext highlighter-rouge">best::vec</code>’s small vector optimization for free.</p> <p><code class="language-plaintext highlighter-rouge">best</code> provides the following encodings out of the box: <code class="language-plaintext highlighter-rouge">best::utf8</code>, <code class="language-plaintext highlighter-rouge">best::utf16</code>, <code class="language-plaintext highlighter-rouge">best::utf32</code>, <code class="language-plaintext highlighter-rouge">best::wtf8</code>, <code class="language-plaintext highlighter-rouge">best::ascii</code>, and <code class="language-plaintext highlighter-rouge">best::latin1</code>.</p> <h3 id="formatting"><a href="#formatting">Formatting</a></h3> <p><code class="language-plaintext highlighter-rouge">//best/text:format</code> provides a Rust <code class="language-plaintext highlighter-rouge">format!()</code>-style text formatting library. It’s as easy as:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"my number: 0x{:08x}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Through the power of compiler extensions and <code class="language-plaintext highlighter-rouge">constexpr</code>, the format is actually checked at compile time!</p> <p>The available formats are the same as Rust’s, including the <code class="language-plaintext highlighter-rouge">{}</code> vs <code class="language-plaintext highlighter-rouge">{:?}</code> distinction. But it’s actually way more flexible. You can use any ASCII letter, and types can provide multiple custom formatting schemes using letters. By convention, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">X</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">o</code> all mean numeric bases. <code class="language-plaintext highlighter-rouge">q</code> will quote strings, runes, and other text objects; <code class="language-plaintext highlighter-rouge">p</code> will print pointer addresses.</p> <p>The special format <code class="language-plaintext highlighter-rouge">{:!}</code> “forwards from above”; when used in a formatting implementation, it uses the format specifier the caller used. This is useful for causing formats to be “passed through”, such as when printing lists or <code class="language-plaintext highlighter-rouge">best::option</code>.</p> <p>Any type can be made formattable by providing a friend template ADL extension (FTADLE) called <code class="language-plaintext highlighter-rouge">BestFmt</code>. This is analogous to implementing a trait like <code class="language-plaintext highlighter-rouge">fmt::Debug</code> in Rust, however, all formatting operations use the same function; this is similar to <a href="https://pkg.go.dev/fmt#Formatter"><code class="language-plaintext highlighter-rouge">fmt.Formatter</code></a> in Go.</p> <p>The <code class="language-plaintext highlighter-rouge">best::formatter</code> type, which gets passed into <code class="language-plaintext highlighter-rouge">BestFmt</code>, is similar to Rust’s <a href="https://doc.rust-lang.org/std/fmt/struct.Formatter.html"><code class="language-plaintext highlighter-rouge">Formatter</code></a>. Beyond being a sink, it also exposes information on the specifier for the formatting operation via <code class="language-plaintext highlighter-rouge">current_spec()</code>, and helpers for printing indented lists and blocks.</p> <p><code class="language-plaintext highlighter-rouge">BestFmtQuery</code> is a related FTADLE that is called to determine what the valid format specifiers for this type are. This allows the format validator to reject formats that a type does not support, such as formatting a <code class="language-plaintext highlighter-rouge">best::str</code> with <code class="language-plaintext highlighter-rouge">{:x}</code>.</p> <p><code class="language-plaintext highlighter-rouge">best::format</code> returns (or appends to) a <code class="language-plaintext highlighter-rouge">best::strbuf</code>; <code class="language-plaintext highlighter-rouge">best::println</code> and <code class="language-plaintext highlighter-rouge">best::eprintln</code> can be used to write to stdout and stderr.</p> <h3 id="reflection"><a href="#reflection">Reflection</a></h3> <p>Within the metaprogramming library, <code class="language-plaintext highlighter-rouge">//best/meta:reflect</code> offers a basic form of reflection. It’s not C++26 reflection, because that’s wholely overkill. Instead, it provides a method for introspecting the members of structs and enums.</p> <p>For example, suppose that we want to have a default way of formatting arbitrary <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization.html">aggregate</a> structs. The code for doing this is actually devilishly simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">BestFmt</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">best</span><span class="o">::</span><span class="n">is_reflected_struct</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Reflect the type of the struct.</span>
  <span class="k">auto</span> <span class="n">refl</span> <span class="o">=</span> <span class="n">best</span><span class="o">::</span><span class="n">reflect</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// Start formatting a "record" (key-value pairs).</span>
  <span class="k">auto</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">.</span><span class="n">record</span><span class="p">(</span><span class="n">refl</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

  <span class="c1">// For each field in the struct...</span>
  <span class="n">refl</span><span class="p">.</span><span class="n">each</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">field</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Add a field to the formatting record...</span>
    <span class="n">rec</span><span class="p">.</span><span class="n">field</span><span class="p">(</span>
      <span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span>   <span class="c1">// ...whose name is the field...</span>
      <span class="n">value</span><span class="o">-&gt;*</span><span class="n">field</span><span class="p">,</span>  <span class="c1">// ...and with the appropriate value.</span>
    <span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::reflect</code> provides access to the fields (or enum variants) of a user-defined type that opts itself in by providing the <code class="language-plaintext highlighter-rouge">BestReflect</code> FTADLE, which tells the reflection framework what the fields are. The simplest version of this FTADLE looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">friend</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">BestReflect</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">mirror</span><span class="p">,</span> <span class="n">MyStruct</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">mirror</span><span class="p">.</span><span class="n">infer</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">best::mirror</code> is essentially a “reflection builder” that offers fine-grained control over what reflection actually shows of a struct. This allows for hiding fields, or attaching <em>tags</em> to specific fields, which generic functions can then introspect using <code class="language-plaintext highlighter-rouge">best::reflected_field::tags()</code>.</p> <p>The functions on <code class="language-plaintext highlighter-rouge">best::reflected_type</code> allow iterating over and searching for specific fields (or enum variants); these <code class="language-plaintext highlighter-rouge">best::reflected_field</code>s provide metadata about a field (such as its name) and allow accessing it, with the same syntax as a pointer-to-member: <code class="language-plaintext highlighter-rouge">value-&gt;*field</code>.</p> <p>Explaining the full breadth (and implementation tricks) of <code class="language-plaintext highlighter-rouge">best::reflect</code> would be a post of its own, so I’ll leave it at that.</p> <h3 id="unit-tests-and-apps"><a href="#unit-tests-and-apps">Unit Tests and Apps</a></h3> <p><code class="language-plaintext highlighter-rouge">best</code> provides a unit testing framework under <code class="language-plaintext highlighter-rouge">//best/test</code>, like any good standard library should. To define a test, you define a special kind of global variable:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">test</span> <span class="n">MyTest</span> <span class="o">=</span> <span class="p">[](</span><span class="n">best</span><span class="o">::</span><span class="n">test</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Test code.</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This is very similar to a Go unit test, which defines a function that starts with <code class="language-plaintext highlighter-rouge">Test</code> and takes a <code class="language-plaintext highlighter-rouge">*testing.T</code> as its argument. The <code class="language-plaintext highlighter-rouge">best::test&amp;</code> value offers test assertions and test failures. Through the power of looking at debuginfo, we can extract the name <code class="language-plaintext highlighter-rouge">MyTest</code> from the binary, and use that as the name of the test directly.</p> <p>That’s right, this is a C++ test framework with <em>no macros at all</em>!</p> <p>Meanwhile, at <code class="language-plaintext highlighter-rouge">//best/cli</code> we can find a robust CLI parsing library, in the spirit of <a href="https://docs.rs/clap/latest/clap/_derive/index.html"><code class="language-plaintext highlighter-rouge">#[derive(clap::Parser)]</code></a> and other similar Rust libraries. The way it works is you first define a reflectable struct, whose fields correspond to CLI flags. A very basic example of this can be found in <code class="language-plaintext highlighter-rouge">test.h</code>, since test binaries define their own flags:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">test</span><span class="o">::</span><span class="n">flags</span> <span class="k">final</span> <span class="p">{</span>
  <span class="n">best</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">best</span><span class="o">::</span><span class="n">strbuf</span><span class="o">&gt;</span> <span class="n">skip</span><span class="p">;</span>
  <span class="n">best</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">best</span><span class="o">::</span><span class="n">strbuf</span><span class="o">&gt;</span> <span class="n">filters</span><span class="p">;</span>

  <span class="k">constexpr</span> <span class="k">friend</span> <span class="k">auto</span> <span class="n">BestReflect</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">flags</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">infer</span><span class="p">()</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">app</span><span class="p">{.</span><span class="n">about</span> <span class="o">=</span> <span class="s">"a best unit test binary"</span><span class="p">})</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="o">::</span><span class="n">skip</span><span class="p">,</span>
            <span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">flag</span><span class="p">{</span>
              <span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="s">"FILTER"</span><span class="p">,</span>
              <span class="p">.</span><span class="n">help</span> <span class="o">=</span> <span class="s">"Skip tests whose names contain FILTER"</span><span class="p">,</span>
            <span class="p">})</span>
      <span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="o">::</span><span class="n">filters</span><span class="p">,</span>
            <span class="n">best</span><span class="o">::</span><span class="n">cli</span><span class="o">::</span><span class="n">positional</span><span class="p">{</span>
              <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FILTERS"</span><span class="p">,</span>
              <span class="p">.</span><span class="n">help</span> <span class="o">=</span> <span class="s">"Include only tests whose names contain FILTER"</span><span class="p">,</span>
            <span class="p">});</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Using <code class="language-plaintext highlighter-rouge">best::mirror::with</code>, we can apply tags to the individual fields that describe how they should be parsed and displayed as CLI flags. A more complicated, full-featured example can be found at <a href="https://github.com/mcy/best/blob/main/best/cli/toy_flags.h"><code class="language-plaintext highlighter-rouge">toy_flags.h</code></a>, which exercises most of the CLI parser’s features.</p> <p><code class="language-plaintext highlighter-rouge">best::parse_flags&lt;MyFlags&gt;(...)</code> can be used to parse a particular flag struct from program inputs, independent of the actual <code class="language-plaintext highlighter-rouge">argv</code> of the program. A <code class="language-plaintext highlighter-rouge">best::cli</code> contains the actual parser metadata, but this is not generally user-accessible; it is constructed automatically using reflection.</p> <p>Streamlining top-level app execution can be done using <code class="language-plaintext highlighter-rouge">best::app</code>, which fully replaces the <code class="language-plaintext highlighter-rouge">main()</code> function. Defining an app is very similar to defining a test:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">best</span><span class="o">::</span><span class="n">app</span> <span class="n">MyApp</span> <span class="o">=</span> <span class="p">[](</span><span class="n">MyFlags</span><span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do something cool!</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>This will automatically record the program inputs, run the flag parser for <code class="language-plaintext highlighter-rouge">MyFlags</code> (printing <code class="language-plaintext highlighter-rouge">--help</code> and existing, when requested), and then call the body of the lambda.</p> <p>The lambda can either return <code class="language-plaintext highlighter-rouge">void</code>, an <code class="language-plaintext highlighter-rouge">int</code> (as an exit code) or even a <code class="language-plaintext highlighter-rouge">best::result</code>, like Rust. <code class="language-plaintext highlighter-rouge">best::app</code> is also where the <code class="language-plaintext highlighter-rouge">argv</code> of the program can be requested by other parts of the program.</p> <h2 id="whats-next"><a href="#whats-next">What’s Next?</a></h2> <p>There’s still a lot of stuff I want to add to <code class="language-plaintext highlighter-rouge">best</code>. There’s no synchronization primitives, neither atomics nor locks or channels. There’s no I/O; I have a work-in-progress PR to add <code class="language-plaintext highlighter-rouge">best::path</code> and <code class="language-plaintext highlighter-rouge">best::file</code>. I’d like to write my own math library, <code class="language-plaintext highlighter-rouge">best::rc</code> (reference-counting), and portable SIMD. There’s also some other OS APIs I want to build, such as signals and subprocesses. I want to add a robust PRNG, time APIs, networking, and stack symbolization.</p> <p>Building the best C++ library is a lot of work, not the least because C++ is a very tricky language and writing exhaustive tests is tedious. But it manages to make C++ fun for me again!</p> <p>I would love to see contributions some day. I don’t expect anyone to actually use this, but to me, it proves C++ could be so much better.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:terrible-people" role="doc-endnote"> <p>They are also <a href="https://patricia.no/2022/03/08/cppcon.html">terrible people</a>. <a href="#fnref:terrible-people" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:jh" role="doc-endnote"> <p>I will grant that JeanHeyd has made significant process where many people believed was impossible. He appears to have the indomitable willpower of a shōnen protagonist. <a href="#fnref:jh" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:abcl" role="doc-endnote"> <p>I have heard an apocryphal story that the namespace was going to be <code class="language-plaintext highlighter-rouge">abc</code> or <code class="language-plaintext highlighter-rouge">abcl</code>, because it was “Alphabet’s library”. This name was ultimately shot down by the office of the CEO, or so the legend goes. <a href="#fnref:abcl" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:interval" role="doc-endnote"> <p>This may get renamed to <code class="language-plaintext highlighter-rouge">best::interval</code> or even <code class="language-plaintext highlighter-rouge">best::range</code> We’ll see! <a href="#fnref:interval" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:swisstable" role="doc-endnote"> <p>The fourth time I’ve written one in my career, lmao. I also wrote a <a href="https://github.com/google/cwisstable">C implementation</a> at one point. My friend Matt has an <a href="https://www.youtube.com/watch?v=ncHmEUmJZf4">excellent introduction</a> to the Swisstable data structure. <a href="#fnref:swisstable" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="c++"/><category term="language-design"/><category term="metaprogramming"/><summary type="html"><![CDATA[It’s no secret that my taste in programming languages is very weird for a programming language enthusiast professional. Several of my last few posts are about Go, broadly regarded as the programming language equivalent of eating plain oatmeal for breakfast.]]></summary></entry><entry><title type="html">What’s //go:nosplit for?</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/07/07/nosplit/" rel="alternate" type="text/html" title="What’s //go:nosplit for?"/><published>2025-07-07T00:00:00-07:00</published><updated>2025-07-07T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/07/07/nosplit</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/07/07/nosplit/"><![CDATA[<p>Most people don’t know that Go has special syntax for directives. Unfortunately, it’s not real syntax, it’s just a comment. For example, <code class="language-plaintext highlighter-rouge">//go:noinline</code> causes the next function declaration to never get inlined, which is useful for changing the inlining cost of functions that call it.</p> <p>There are three types of directives:</p> <ol> <li> <p>The ones documented in <a href="https://pkg.go.dev/cmd/compile#hdr-Function_Directives"><code class="language-plaintext highlighter-rouge">gc</code>’s doc comment</a>. This includes <code class="language-plaintext highlighter-rouge">//go:noinline</code> and <code class="language-plaintext highlighter-rouge">//line</code>.</p> </li> <li> <p>The ones documented elsewhere, such as <code class="language-plaintext highlighter-rouge">//go:build</code> and <code class="language-plaintext highlighter-rouge">//go:generate</code>.</p> </li> <li> <p>The ones documented in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.24.4:src/runtime/HACKING.md">runtime/HACKING.md</a>, which can only be used if the <code class="language-plaintext highlighter-rouge">-+</code> flag is passed to <code class="language-plaintext highlighter-rouge">gc</code>. This includes <code class="language-plaintext highlighter-rouge">//go:nowritebarrier</code>.</p> </li> <li> <p>The ones not documented at all, whose existence can be discovered by searching the compiler’s tests. These include <code class="language-plaintext highlighter-rouge">//go:nocheckptr</code>, <code class="language-plaintext highlighter-rouge">//go:nointerface</code>, and <code class="language-plaintext highlighter-rouge">//go:debug</code>.</p> </li> </ol> <p>We are most interested in a directive of the first type, <code class="language-plaintext highlighter-rouge">//go:nosplit</code>. According to the documentation:</p> <blockquote> <p>The <code class="language-plaintext highlighter-rouge">//go:nosplit</code> directive must be followed by a function declaration. It specifies that the function must omit its usual stack overflow check. This is most commonly used by low-level runtime code invoked at times when it is unsafe for the calling goroutine to be preempted.</p> </blockquote> <p>What does this even mean? Normal program code can use this annotation, but its behavior is poorly specified. Let’s dig in.</p> <h2 id="go-stack-growth"><a href="#go-stack-growth">Go Stack Growth</a></h2> <p>Go allocates very small stacks for new goroutines, which grow their stack dynamically. This allows a program to spawn a large number of short-lived goroutines without spending a lot of memory on their stacks.</p> <p>This means that it’s very easy to overflow the stack. Every function knows how large its stack is, and <code class="language-plaintext highlighter-rouge">runtime.g</code>, the goroutine struct, contains the end position of the stack; if the stack pointer is less than it (the stack grows up) control passes to <code class="language-plaintext highlighter-rouge">runtime.morestack</code>, which effectively preempts the goroutine while its stack is resized.</p> <p>In effect, every Go function has the following code around it:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span>    <span class="p">.</span><span class="err">f</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="m">24-16</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JLS</span>     <span class="err">grow</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">//</span> <span class="err">Function</span> <span class="err">body</span><span class="p">...</span>
  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span>
<span class="nl">grow:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">MOVQ</span>    <span class="m">16</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">JMP</span>     <span class="p">.</span><span class="err">f</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>Note that <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the current <code class="language-plaintext highlighter-rouge">runtime.g</code>, and the stack limit is the third word-sized field (<code class="language-plaintext highlighter-rouge">runtime.g.stackguard0</code>) in that struct, hence the offset of 16. If the stack is about to be exhausted, it jumps to a special block at the end of the function that spills all of the argument registers, traps into the runtime, and, once that’s done, unspills the arguments and re-starts the function.</p> <p>Note that arguments are spilled <em>before</em> adjusting <code class="language-plaintext highlighter-rouge">rsp</code>, which means that the arguments are written to the <em>caller’s</em> stack frame. This is part of Go’s ABI; callers must allocate space at the top of their stack frames for any function that they call to spill all of its registers for preemption<sup id="fnref:unused-spill" role="doc-noteref"><a href="#fn:unused-spill" class="footnote" rel="footnote">1</a></sup>.</p> <p>Preemption is not reentrant, which means that functions that are running in the context of a preempted G or with no G at all must not be preempted by this check.</p> <h2 id="nosplit-functions"><a href="#nosplit-functions">Nosplit Functions</a></h2> <p>The <code class="language-plaintext highlighter-rouge">//go:nosplit</code> directive marks a function as “nosplit”, or a “non-splitting function”. “Splitting” has nothing to do with what this directive does.</p> <blockquote> <h4 id="segmented-stacks"><a href="#segmented-stacks">Segmented Stacks</a></h4> <p>In the bad old days, Go’s stacks were <em>split</em> up into <em>segments</em>, where each segment ended with a pointer to the next, effectively replacing the stack’s single array with a linked list of such arrays.</p> <p>Segmented stacks were terrible. Instead of triggering a resize, these prologues were responsible for updating <code class="language-plaintext highlighter-rouge">rsp</code> to the next (or previous) block by following this pointer, whenever the current segment bottomed out. This meant that if a function call happened to be on a segment boundary, it would be <em>extremely slow</em> in comparison to other function calls, due to the significant work required to update <code class="language-plaintext highlighter-rouge">rsp</code> correctly.</p> <p>This meant that unlucky sizing of stack frames meant sudden performance cliffs. Fun!</p> <p>Go has since figured out that segmented stacks are a terrible idea. In the process of implementing a correct GC stack scanning algorithm (which it did not have for many stable releases), it also gained the ability to copy the contents of a stack from one location to another, updating pointers in such a way that user code wouldn’t notice.</p> <p>This stack splitting code is where the name “nosplit” comes from.</p> </blockquote> <p>A nosplit function does not load and branch on <code class="language-plaintext highlighter-rouge">runtime.g.stackguard0</code>, and simply assumes it has enough stack. This means that nosplit functions will not preempt themselves, and, as a result, are noticeably faster to call in a hot loop. Don’t believe me?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">//go:noinline</span>
<span class="k">func</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">nosplit</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">yessplit</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">noinline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkCall</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"nosplit"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span> <span class="n">nosplit</span><span class="p">(</span><span class="m">42</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">})</span>
  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"yessplit"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span> <span class="n">yessplit</span><span class="p">(</span><span class="m">42</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If we profile this and pull up the timings for each function, here’s what we get:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="m">390</span><span class="err">ms</span>      <span class="m">390</span><span class="err">ms</span>           <span class="err">func</span> <span class="err">nosplit</span><span class="p">(x</span> <span class="err">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">noinline</span><span class="p">(x)</span> <span class="p">}</span>
 <span class="m">60</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd80:</span>     <span class="err">PUSHQ</span> <span class="err">BP</span>
 <span class="m">10</span><span class="err">ms</span>       <span class="m">10</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd81:</span>     <span class="err">MOVQ</span> <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fd84:</span>     <span class="err">SUBQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
 <span class="m">60</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd88:</span>     <span class="err">CALL</span> <span class="p">.</span><span class="k">noinline</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
<span class="m">190</span><span class="err">ms</span>      <span class="m">190</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd8d:</span>     <span class="err">ADDQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fd91:</span>     <span class="err">POPQ</span> <span class="err">BP</span>
 <span class="m">70</span><span class="err">ms</span>       <span class="m">70</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fd92:</span>     <span class="err">RET</span>

<span class="m">440</span><span class="err">ms</span>      <span class="m">490</span><span class="err">ms</span>           <span class="err">func</span> <span class="err">yessplit</span><span class="p">(x</span> <span class="err">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">noinline</span><span class="p">(x)</span> <span class="p">}</span>
 <span class="m">50</span><span class="err">ms</span>       <span class="m">50</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda0:</span>     <span class="err">CMPQ</span> <span class="err">SP</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
 <span class="m">20</span><span class="err">ms</span>       <span class="m">20</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda4:</span>     <span class="err">JBE</span> <span class="m">0x51fdb9</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fda6:</span>     <span class="err">PUSHQ</span> <span class="err">BP</span>
 <span class="m">20</span><span class="err">ms</span>       <span class="m">20</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fda7:</span>     <span class="err">MOVQ</span> <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdaa:</span>     <span class="err">SUBQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
 <span class="m">10</span><span class="err">ms</span>       <span class="m">60</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdae:</span>     <span class="err">CALL</span> <span class="p">.</span><span class="k">noinline</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
<span class="m">200</span><span class="err">ms</span>      <span class="m">200</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdb3:</span>     <span class="err">ADDQ</span> <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">SP</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdb7:</span>     <span class="err">POPQ</span> <span class="err">BP</span>
<span class="m">140</span><span class="err">ms</span>      <span class="m">140</span><span class="err">ms</span>   <span class="m">51</span><span class="nl">fdb8:</span>     <span class="err">RET</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdb9:</span>     <span class="err">MOVQ</span> <span class="err">AX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdbe:</span>     <span class="err">NOPW</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdc0:</span>     <span class="err">CALL</span> <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">.</span><span class="err">abi0</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdc5:</span>     <span class="err">MOVQ</span> <span class="m">0x8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
    <span class="p">.</span>          <span class="p">.</span>   <span class="m">51</span><span class="nl">fdca:</span>     <span class="err">JMP</span> <span class="p">.</span><span class="err">yessplit</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>The time spent at each instruction (for the whole benchmark, where I made sure equal time was spent on each test case with <code class="language-plaintext highlighter-rouge">-benchtime Nx</code>) is comparable for all of the instructions these functions share, but an additional ~2% cost is incurred for the stack check.</p> <p>This is a very artificial setup, because the <code class="language-plaintext highlighter-rouge">g</code> struct is always in L1 in the <code class="language-plaintext highlighter-rouge">yessplit</code> benchmark due to the fact that no other memory operations occur in the loop. However, for very hot code that needs to saturate the cache, this can have an outsized effect due to cache misses. We can enhance this benchmark by adding an assembly function that executes <code class="language-plaintext highlighter-rouge">clflush [r14]</code>, which causes the <code class="language-plaintext highlighter-rouge">g</code> struct to be ejected from all caches.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">.</span><span class="err">clflush</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CLFLUSH</span> <span class="p">(</span><span class="err">R14</span><span class="p">)</span>  <span class="err">//</span> <span class="err">Eject</span> <span class="err">the</span> <span class="err">pointee</span> <span class="err">of</span> <span class="err">r14</span> <span class="k">from</span> <span class="err">all</span> <span class="err">caches</span><span class="p">.</span>
  <span class="err">RET</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>If we add a call to this function to both benchmark loops, we see the staggering cost of a cold fetch from RAM show up in every function call: 120.1 nanosecods for <code class="language-plaintext highlighter-rouge">BenchmarkCall/nosplit</code>, versus 332.1 nanoseconds for <code class="language-plaintext highlighter-rouge">BenchmarkCall/yessplit</code>. The 200 nanosecond difference is a fetch from main memory. An L1 miss is about 15 times less expensive, so if the <code class="language-plaintext highlighter-rouge">g</code> struct manages to get kicked out of L1, you’re paying about 15 or so nanoseconds, or about two map lookups!</p> <p>Despite the language resisting adding an inlining heuristic, which programmers would place everywhere without knowing what it does, they <em>did</em> provide something worse that makes code noticeably faster: nosplit.</p> <h2 id="but-its-harmless"><a href="#but-its-harmless">But It’s Harmless…?</a></h2> <p>Consider the following program<sup id="fnref:consider" role="doc-noteref"><a href="#fn:consider" class="footnote" rel="footnote">2</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Naturally, this will instantly overflow the stack. Instead, we get a really scary linker error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">x.x: nosplit stack over 792 byte limit
</span><span class="gp">x.x&lt;1&gt;</span><span class="w">
</span><span class="gp">    grows 24 bytes, calls x.x&lt;1&gt;</span><span class="w">
</span><span class="go">    infinite cycle</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>The Go linker contains a check to verify that any chain of nosplit functions which call nosplit functions do not overflow a small window of extra stack, which is where the stack frames of nosplit functions live if they go past <code class="language-plaintext highlighter-rouge">stackguard0</code>.</p> <p>Every stack frame contributes some stack use (for the return address, at minimum), so the number of functions you can call before you get this error is limited. And because every function needs to allocate space for all of its callees to spill their arguments if necessary, you can hit this limit every fast if every one of these functions uses every available argument register (ask me how I know).</p> <p>Also, turning on fuzzing instruments the code by inserting nosplit calls into the fuzzer runtime around branches, meaning that turning on fuzzing can <em>previously fine code to no longer link</em>. Stack usage also varies slightly by architecture, meaning that code which builds in one architecture fails to link in others (most visible when going from 32-bit to 64-bit).</p> <p>There is no easy way to control directives using build tags (two poorly-designed features collide), so you cannot just “turn off” performance-sensitive nosplits for debugging, either.</p> <p>For this reason, you must be <em>very very careful</em> about using nosplit for performance.</p> <h3 id="virtual-nosplit-functions"><a href="#virtual-nosplit-functions">Virtual Nosplit Functions</a></h3> <p>Excitingly, nosplit functions whose addresses are taken do not have special codegen, allowing us to defeat the linker stack check by using virtual function calls.</p> <p>Consider the following program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">var</span> <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">x</span>
  <span class="n">f</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This will quickly exhaust the main G’s tiny stack and segfault in the most violent way imaginable, preventing the runtime from printing a debug trace. All this program outputs is <code class="language-plaintext highlighter-rouge">signal: segmentation fault</code>.</p> <p>This is <a href="https://github.com/golang/go/issues/74478">probably a bug</a>.</p> <h2 id="other-side-effects"><a href="#other-side-effects">Other Side Effects</a></h2> <p>It turns out that nosplit has various other fun side-effects that are not documented anywhere. The main thing it does is it contributes to whether a function is considered “unsafe” by the runtime.</p> <p>Consider the following program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"os"</span>
  <span class="s">"runtime"</span>
  <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="k">range</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">{}</span>
    <span class="p">}()</span>
  <span class="p">}</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Wait for all the other Gs to start.</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This program will make sure that every P becomes bound to a G that loops forever, meaning they will never trap into the runtime. Thus, this program will hang forever, never printing its result and exiting. But that’s not what happens.</p> <p>Thanks to asynchronous preemption, the scheduler will detect Gs that have been running for too long, and preempt its M by sending a signal to it (<a href="https://cs.opensource.google/go/go/+/master:src/runtime/signal_unix.go;l=43">due to happenstance</a>, this is <code class="language-plaintext highlighter-rouge">SIGURG</code> of all things.)</p> <p>However, asynchronous preemption is only possible when the M stops due to the signal at a safe point, as determined by <code class="language-plaintext highlighter-rouge">runtime.isAsyncSafePoint</code>. It includes the following block of code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go">	<span class="n">up</span><span class="p">,</span> <span class="n">startpc</span> <span class="o">:=</span> <span class="n">pcdatavalue2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">abi</span><span class="o">.</span><span class="n">PCDATA_UnsafePoint</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">up</span> <span class="o">==</span> <span class="n">abi</span><span class="o">.</span><span class="n">UnsafePointUnsafe</span> <span class="p">{</span>
		<span class="c">// Unsafe-point marked by compiler. This includes</span>
		<span class="c">// atomic sequences (e.g., write barrier) and nosplit</span>
		<span class="c">// functions (except at calls).</span>
		<span class="k">return</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span>
	<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If we chase down where this value is set, we’ll find that it is set explicitly for write barrier sequences, for any function that is “part of the runtime” (as defined by being built with the <code class="language-plaintext highlighter-rouge">-+</code> flag) and <em>for any nosplit function</em>.</p> <p>With a small modification of hoisting the <code class="language-plaintext highlighter-rouge">go</code> body into a nosplit function, the following program will run forever: it will never wake up from <code class="language-plaintext highlighter-rouge">time.Sleep</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"os"</span>
  <span class="s">"runtime"</span>
  <span class="s">"time"</span>
<span class="p">)</span>

<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">forever</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="k">range</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="n">forever</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Wait for all the other Gs to start.</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Even though there is work to do, every P is bound to a G that will never reach a safe point, so there will never be a P available to run the main goroutine.</p> <p>This represents another potential danger of using nosplit functions: those that do not call preemptable functions must terminate promptly, or risk livelocking the whole runtime.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>I use nosplit <em>a lot</em>, because I write high-performance, low-latency Go. This is a very insane thing to do, which has caused me to slowly generate bug reports whenever I hit strange corner cases.</p> <p>For example, there are many cases where spill regions are allocated for functions that never use them, for example, functions which only call nosplit functions allocate space for them to spill their arguments, which they don’t do.<sup id="fnref:spill-area" role="doc-noteref"><a href="#fn:spill-area" class="footnote" rel="footnote">3</a></sup></p> <p>This is a documented Go language feature which:</p> <ol> <li>Isn’t very well-documented (the async preemption behavior certainly isn’t)!</li> <li>Has very scary optimization-dependent build failures.</li> <li>Can cause livelock and mysterious segfaults.</li> <li>Can be used in user programs that don’t <code class="language-plaintext highlighter-rouge">import "unsafe"</code>!</li> <li>And it makes code faster!</li> </ol> <p>I’m surprised such a massive footgun exists at all, buuuut it’s a measureable benchmark improvement for me, so it’s impossible to tell if it’s bad or not.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:unused-spill" role="doc-endnote"> <p>The astute reader will observe that because preemption is not reentrant, only one of these spill regions will be in use at at time in a G. This is a known bug in the ABI, and is essentially a bodge to enable easy adoption of passing arguments by register, without needing all of the parts of the runtime that expect arguments to be spilled to the stack, as was the case in the slow old days when Go’s ABI on every platform was “<code class="language-plaintext highlighter-rouge">i386-unknown-linux</code> but worse”, i.e., arguments went on the stack and made the CPU’s store queue sad.</p> <p>I recently filed <a href="https://github.com/golang/go/issues/74413">a bug about this</a> that boils down to “add a field to <code class="language-plaintext highlighter-rouge">runtime.g</code> to use a spill space”, which seems to me to be simpler than the alternatives described in the <code class="language-plaintext highlighter-rouge">ABIInternal</code> spec. <a href="#fnref:unused-spill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:consider" role="doc-endnote"> <p>Basically every bug report I write starts with these four words and it means you’re about to see the worst program ever written. <a href="#fnref:consider" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:spill-area" role="doc-endnote"> <p>The spill area is also used for spilling arguments across calls, but in this case, it is not necessary for the caller to allocate it for a nosplit function. <a href="#fnref:spill-area" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="go"/><category term="dark-arts"/><summary type="html"><![CDATA[Most people don’t know that Go has special syntax for directives. Unfortunately, it’s not real syntax, it’s just a comment. For example, //go:noinline causes the next function declaration to never get inlined, which is useful for changing the inlining cost of functions that call it.]]></summary></entry><entry><title type="html">Protobuf Tip #7: Scoping It Out</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/06/03/protobuf-tip-7/" rel="alternate" type="text/html" title="Protobuf Tip #7: Scoping It Out"/><published>2025-06-03T00:00:00-07:00</published><updated>2025-06-03T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/06/03/protobuf-tip-7</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/06/03/protobuf-tip-7/"><![CDATA[<p><em>You’d need a very specialized electron microscope to get down to the level to actually see a single strand of DNA. – Craig Venter</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">buf convert</code> is a powerful tool for examining wire format dumps, by converting them to JSON and using existing JSON analysis tooling. <code class="language-plaintext highlighter-rouge">protoscope</code> can be used for lower-level analysis, such debugging messages that have been corrupted.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-7-scoping-it-out">buf.build blog</a>.</p> </blockquote> <h2 id="json-from-protobuf"><a href="#json-from-protobuf">JSON from Protobuf?</a></h2> <p>JSON’s human-readable syntax is a big reason why it’s so popular, possibly second only to built-in support in browsers and many languages. It’s easy to examine any JSON document using tools like online prettifiers and the inimitable <code class="language-plaintext highlighter-rouge">jq</code>.</p> <p>But Protobuf is a binary format! This means that you can’t easily use <code class="language-plaintext highlighter-rouge">jq</code> -like tools with it…or can you?</p> <h2 id="transcoding-with-buf-convert"><a href="#transcoding-with-buf-convert">Transcoding with <code class="language-plaintext highlighter-rouge">buf convert</code></a></h2> <p>The Buf CLI offers a utility for transcoding messages between the three Protobuf encoding formats: the wire format, JSON, and textproto; it also supports YAML. This is <code class="language-plaintext highlighter-rouge">buf convert</code>, and it’s very powerful.</p> <p>To perform a conversion, we need four inputs:</p> <ol> <li>A Protobuf source to get types out of. This can be a local <code class="language-plaintext highlighter-rouge">.proto</code> file, an encoded <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> , or a remote BSR module. <ul> <li>If not provided, but run in a directory that is within a local Buf module, that module will be used as the Protobuf type source.</li> </ul> </li> <li>The name of the top-level type for the message we want to transcode, via the <code class="language-plaintext highlighter-rouge">--type</code> flag.</li> <li>The input message, via the <code class="language-plaintext highlighter-rouge">--from</code> flag.</li> <li>A location to output to, via the <code class="language-plaintext highlighter-rouge">--to</code> flag.</li> </ol> <p><code class="language-plaintext highlighter-rouge">buf convert</code> supports input and output redirection, making it usable as part of a shell pipeline. For example, consider the following Protobuf code in our local Buf module:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// my_api.proto</span>
<span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>
<span class="kn">package</span> <span class="nn">my</span><span class="o">.</span><span class="n">api.v1</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Cart</span> <span class="p">{</span>
  <span class="kt">int32</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">repeated</span> <span class="n">Order</span> <span class="na">orders</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Order</span> <span class="p">{</span>
  <span class="kt">fixed64</span> <span class="na">sku</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">sku_name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int64</span> <span class="na">count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Then, let’s say we’ve dumped a message of type <code class="language-plaintext highlighter-rouge">my.api.v1.Cart</code> from a service to debug it. And let’s say…well—you can’t just <code class="language-plaintext highlighter-rouge">cat</code> it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>dump.pb | xxd <span class="nt">-ps</span>
<span class="go">08a946121b097ac8e80400000000120e76616375756d20636c65616e6572
18011220096709b519000000001213686570612066696c7465722c203220
7061636b1806122c093aa8188900000000121f69736f70726f70796c2061
6c636f686f6c203730252c20312067616c6c6f6e1802</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>However, we can use <code class="language-plaintext highlighter-rouge">buf convert</code> to turn it into some nice JSON. We can then pipe it into <code class="language-plaintext highlighter-rouge">jq</code> to format it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf convert <span class="nt">--type</span> my.api.v1.Cart <span class="nt">--from</span> dump.pb <span class="nt">--to</span> -#format<span class="o">=</span>json | jq
<span class="go">{
  "userId": 9001,
  "orders": [
    {
      "sku": "82364538",
      "skuName": "vacuum cleaner",
      "count": "1"
    },
    {
      "sku": "431294823",
      "skuName": "hepa filter, 2 pack",
      "count": "6"
    },
    {
	    "sku": "2300094522",
      "skuName": "isopropyl alcohol 70%, 1 gallon",
      "count": "2"
    }
  ]
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Now you have the full expressivity of <code class="language-plaintext highlighter-rouge">jq</code> at your disposal. For example, we could pull out the user ID for the cart:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="k">function </span>buf-jq<span class="o">()</span> <span class="o">{</span> buf convert <span class="nt">--type</span> <span class="nv">$1</span> <span class="nt">--from</span> <span class="nv">$2</span> <span class="nt">--to</span> -#format<span class="o">=</span>json | jq <span class="nv">$3</span> <span class="o">}</span>
<span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'.userId'</span>
<span class="go">9001</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Or we can extract all of the SKUs that appear in the cart:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].sku]'</span>
<span class="go">[
  "82364538",
  "431294823",
  "2300094522"
]</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Or we could try calculating how many items are in the cart, total:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count] | add'</span>
<span class="go">"162"</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Wait. That’s wrong. The answer should be <code class="language-plaintext highlighter-rouge">9</code>. This illustrates one pitfall to keep in mind when using <code class="language-plaintext highlighter-rouge">jq</code> with Protobuf. Protobuf will <em>sometimes</em> serialize numbers as quoted strings (the C++ reference implementation only does this when they’re integers outside of the IEEE754 representable range, but Go is somewhat lazier, and does it for all 64-bit values).</p> <blockquote> <p>You can test if an <code class="language-plaintext highlighter-rouge">x int64</code> is in the representable float range with this very simple check: <code class="language-plaintext highlighter-rouge">int64(float64(x)) == x)</code>. See <a href="https://go.dev/play/p/T81SbbFg3br">https://go.dev/play/p/T81SbbFg3br</a>. The <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/json/internal/unparser.cc#L96">equivalent version in C++</a> is much more complicated.</p> </blockquote> <p>This means we need to use the <code class="language-plaintext highlighter-rouge">tonumber</code> conversion function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>buf-jq my.api.v1.Cart dump.pb <span class="s1">'[.orders[].count | tonumber] | add'</span>
<span class="go">9</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p><code class="language-plaintext highlighter-rouge">jq</code> ’s whole deal is JSON, so it brings with it all of JSON’s pitfalls. This is notable for Protobuf when trying to do arithmetic on 64-bit values. As we saw above, Protobuf serializes integers outside of the 64-bit float representable range (and in some runtimes, some integers inside it).</p> <p>For example, if you have a <code class="language-plaintext highlighter-rouge">repeated int64</code> that you want to sum over, it may produce incorrect answers due to floating-point rounding. For notes on conversions in <code class="language-plaintext highlighter-rouge">jq</code>, see <a href="https://jqlang.org/manual/#identity">https://jqlang.org/manual/#identity</a>.</p> <h2 id="disassembling-with-protoscope"><a href="#disassembling-with-protoscope">Disassembling with <code class="language-plaintext highlighter-rouge">protoscope</code></a></h2> <p><a href="https://github.com/protocolbuffers/protoscope"><code class="language-plaintext highlighter-rouge">protoscope</code></a> is a tool provided by the Protobuf team (which I originally wrote!) for decoding arbitrary data as if it were encoded in the Protobuf wire format. This process is called <em>disassembly</em>. It’s designed to work without a schema available, although it doesn’t produce especially clean output.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>go <span class="nb">install </span>github.com/protocolbuffers/protoscope/cmd/protoscope...@latest
<span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {
  1: 82364538i64
  2: {"vacuum cleaner"}
  3: 1
}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>The field names are gone; only field numbers are shown. This example also reveals an especially glaring limitation of <code class="language-plaintext highlighter-rouge">protoscope</code>, which is that it can’t tell the difference between string and message fields, so it guesses according to some heuristics. For the first and third elements it was able to grok them as strings, but for <code class="language-plaintext highlighter-rouge">orders[1].sku_name</code>, it incorrectly guessed it was a message and produced garbage.</p> <p>The tradeoff is that not only does <code class="language-plaintext highlighter-rouge">protoscope</code> not need a schema, it also tolerates almost any error, making it possible to analyze messages that have been partly corrupted. If we flip a random bit somewhere in <code class="language-plaintext highlighter-rouge">orders[0]</code>, disassembling the message still succeeds:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope dump.pb
<span class="go">1: 9001
2: {`0f7ac8e80400000000120e76616375756d20636c65616e65721801`}
2: {
  1: 431294823i64
  2: {
    13: 101
    14: 97
    4: 102
</span><span class="gp">    13: 1.3518748403899336e-153   #</span><span class="w"> </span>0x2032202c7265746ci64
<span class="go">    14: 97
    12:SGROUP
    13:SGROUP
  }
  3: 6
}
2: {
  1: 2300094522i64
  2: {"isopropyl alcohol 70%, 1 gallon"}
  3: 2
}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Although <code class="language-plaintext highlighter-rouge">protoscope</code> did give up on disassembling the corrupted submessage, it still made it through the rest of the dump.</p> <p>Like <code class="language-plaintext highlighter-rouge">buf convert</code>, we can give <code class="language-plaintext highlighter-rouge">protoscope</code> a <code class="language-plaintext highlighter-rouge">FileDescriptorSet</code> to make its heuristic a little smarter.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>protoscope <span class="se">\</span>
<span class="go">  --descriptor-set &lt;(buf build -o -) \
  --message-type my.api.v1.Cart \
  --print-field-names \
  dump.pb
</span><span class="gp">1: 9001                   #</span><span class="w"> </span>user_id
<span class="gp">2: {                      #</span><span class="w"> </span>orders
<span class="gp">  1: 82364538i64          #</span><span class="w"> </span>sku
<span class="gp">  2: {"vacuum cleaner"}   #</span><span class="w"> </span>sku_name
<span class="gp">  3: 1                    #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                          #</span><span class="w"> </span>orders
<span class="gp">  1: 431294823i64             #</span><span class="w"> </span>sku
<span class="gp">  2: {"hepa filter, 2 pack"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 6                        #</span><span class="w"> </span>count
<span class="go">}
</span><span class="gp">2: {                                      #</span><span class="w"> </span>orders
<span class="gp">  1: 2300094522i64                        #</span><span class="w"> </span>sku
<span class="gp">  2: {"isopropyl alcohol 70%, 1 gallon"}  #</span><span class="w"> </span>sku_name
<span class="gp">  3: 2                                    #</span><span class="w"> </span>count
<span class="go">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Not only is the second order decoded correctly now, but <code class="language-plaintext highlighter-rouge">protoscope</code> shows the name of each field (via <code class="language-plaintext highlighter-rouge">--print-field-names</code> ). In this mode, <code class="language-plaintext highlighter-rouge">protoscope</code> still decodes partially-valid messages.</p> <p><code class="language-plaintext highlighter-rouge">protoscope</code> also provides a number of other flags for customizing its heuristic in the absence of a <code class="language-plaintext highlighter-rouge">FileDescriporSet</code>. This enables it to be used as a forensic tool for debugging messy data corruption bugs.</p>]]></content><author><name>Miguel Young de la Sota</name></author><category term="protobuf-tips"/><summary type="html"><![CDATA[You’d need a very specialized electron microscope to get down to the level to actually see a single strand of DNA. – Craig Venter]]></summary></entry><entry><title type="html">Protobuf Tip #6: The Subtle Dangers of Enum Aliases</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/05/20/protobuf-tip-6/" rel="alternate" type="text/html" title="Protobuf Tip #6: The Subtle Dangers of Enum Aliases"/><published>2025-05-20T00:00:00-07:00</published><updated>2025-05-20T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/05/20/protobuf-tip-6</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/05/20/protobuf-tip-6/"><![CDATA[<p><em>I’ve been very fortunate to dodge a nickname throughout my entire career. I’ve never had one. – Jimmie Johnson</em></p> <p>TL;DR: Enum values can have aliases. This feature is poorly designed and shouldn’t be used. The <a href="https://buf.build/docs/lint/rules/#enum_no_allow_alias"><code class="language-plaintext highlighter-rouge">ENUM_NO_ALLOW_ALIAS</code></a> Buf lint rule prevents you from using them by default.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-5-avoid-import-public-weak">buf.build blog</a>.</p> </blockquote> <h2 id="confusion-and-breakage"><a href="#confusion-and-breakage">Confusion and Breakage</a></h2> <p>Protobuf permits multiple enum values to have the same number. Such enum values are said to be <em>aliases</em> of each other. Protobuf used to allow this by default, but now you have to set a special option, <code class="language-plaintext highlighter-rouge">allow_alias</code>, for the compiler to not reject it.</p> <p>This can be used to effectively rename values without breaking existing code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">MyEnum</span> <span class="p">{</span>
  <span class="k">option</span> <span class="na">allow_alias</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="na">MY_ENUM_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">MY_ENUM_BAD</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[</span><span class="na">deprecated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">];</span>
  <span class="na">MY_ENUM_MORE_SPECIFIC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>This works perfectly fine, and is fully wire-compatible! And unlike renaming a field (see <a href="https://mcyoung.xyz//2025/05/08/protobuf-tip-1">TotW #1</a>), it won’t result in source code breakages.</p> <p>But if you use either reflection or JSON, or a runtime like Java that doesn’t cleanly allow enums with multiple names, you’ll be in for a nasty surprise.</p> <p>For example, if you request an enum value from an enum using reflection, such as with <code class="language-plaintext highlighter-rouge">protoreflect.EnumValueDescriptors.ByNumber()</code>, the value you’ll get is the one that appears in the file lexically. In fact, both <code class="language-plaintext highlighter-rouge">myapipb.MyEnum_MY_ENUM_BAD.String()</code> and <code class="language-plaintext highlighter-rouge">myapipb.MyEnum_MY_ENUM_MORE_SPECIFIC.String()</code> return the same value, leading to potential confusion, as the old “bad” value will be used in printed output like logs.</p> <p>You might think, “oh, I’ll switch the order of the aliases”. But that would be an <em>actual</em> wire format break. Not for the binary format, but for JSON. That’s because JSON preferentially stringifies enum values by using their declared name (if the value is in range). So, reordering the values means that what once serialized as <code class="language-plaintext highlighter-rouge">{"my_field": "MY_ENUM_BAD"}</code> now serializes as <code class="language-plaintext highlighter-rouge">{"my_field": "MY_ENUM_MORE_SPECIFIC"}</code> .</p> <p>If an old binary that hasn’t had the new enum value added sees this JSON document, it won’t parse correctly, and you’ll be in for a bad time.</p> <p>You can argue that this is a language bug, and it kind of is. Protobuf should include an equivalent of <code class="language-plaintext highlighter-rouge">json_name</code> for enum values, or mandate that JSON should serialize enum values with multiple names as a number, rather than an arbitrarily chosen enum name. The feature is intended to allow renaming of enum values, but unfortunately Protobuf hobbled it enough that it’s pretty dangerous.</p> <h1 id="what-to-do"><a href="#what-to-do">What To Do</a></h1> <p>Instead, if you <em>really</em> need to rename an enum value for usability or compliance reasons (ideally, not just aesthetics) you’re better off making a new enum type in a new version of your API. As long as the enum value numbers are the same, it’ll be binary-compatible, but it will <em>somewhat</em> reduce the risk of the above JSON confusion.</p> <p>Buf provides a lint rule against this feature, <a href="https://buf.build/docs/lint/rules/#enum_no_allow_alias"><code class="language-plaintext highlighter-rouge">ENUM_NO_ALLOW_ALIAS</code></a> , and Protobuf requires that you specify a magic option to enable this behavior, so in practice you don’t need to worry about this. But remember, the consequences of enum aliases go much further than JSON—they affect anything that uses reflection. So even if you don’t use JSON, you can still get burned.</p>]]></content><author><name>Miguel Young de la Sota</name></author><category term="protobuf-tips"/><summary type="html"><![CDATA[I’ve been very fortunate to dodge a nickname throughout my entire career. I’ve never had one. – Jimmie Johnson]]></summary></entry><entry><title type="html">Protobuf Tip #5: Avoid import public/weak</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/05/13/protobuf-tip-5/" rel="alternate" type="text/html" title="Protobuf Tip #5: Avoid import public/weak"/><published>2025-05-13T00:00:00-07:00</published><updated>2025-05-13T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/05/13/protobuf-tip-5</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/05/13/protobuf-tip-5/"><![CDATA[<p><em>My dad had a guitar but it was acoustic, so I smashed a mirror and glued broken glass to it to make it look more metal. It looked ridiculous! –Max Cavalera</em></p> <p>TL;DR: Avoid <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf lint rules <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> and <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> enforce this for you by default.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-5-avoid-import-public-weak">buf.build blog</a>.</p> </blockquote> <p>Protobuf <code class="language-plaintext highlighter-rouge">import</code>s allow you to specify two special modes: <code class="language-plaintext highlighter-rouge">import public</code> and <code class="language-plaintext highlighter-rouge">import weak</code>. The Buf CLI lints against these by default, but you might be tempted to try using them anyway, especially because <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19">some GCP APIs use <code class="language-plaintext highlighter-rouge">import public</code></a>. What are these modes, and why do they exist?</p> <h2 id="import-visibility"><a href="#import-visibility">Import Visibility</a></h2> <p>Protobuf imports are by file path, a fact that is very strongly baked into the language and its reflection model.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">"my/other/api.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Importing a file dumps all of its symbols into the current file. For the purposes of name resolution, it’s as if all if the declarations in that file have been pasted into the current file. However, this isn’t transitive. If:</p> <ul> <li><code class="language-plaintext highlighter-rouge">a.proto</code> imports <code class="language-plaintext highlighter-rouge">b.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">b.proto</code> imports <code class="language-plaintext highlighter-rouge">c.proto</code> …</li> <li>and <code class="language-plaintext highlighter-rouge">c.proto</code> defines <code class="language-plaintext highlighter-rouge">foo.Bar</code>…</li> <li>then, <code class="language-plaintext highlighter-rouge">a.proto</code> must import <code class="language-plaintext highlighter-rouge">c.proto</code> to refer to <code class="language-plaintext highlighter-rouge">foo.Bar</code>, even though <code class="language-plaintext highlighter-rouge">b.proto</code> imports it.</li> </ul> <p>This is similar to how importing a package as <code class="language-plaintext highlighter-rouge">.</code> works in Go. When you write <code class="language-plaintext highlighter-rouge">import . "strings"</code>, it dumps all of the declarations from the <code class="language-plaintext highlighter-rouge">strings</code> package into the current file, but not those of any files that <code class="language-plaintext highlighter-rouge">"strings"</code> imports.</p> <p>Now, what’s nice about Go is that packages can be broken up into files in a way that is transparent to users; users of a package import <em>the package</em>, not the files of that package. Unfortunately, Protobuf is not like that, so the file structure of a package leaks to its callers.</p> <p><code class="language-plaintext highlighter-rouge">import public</code> was intended as a mechanism for allowing API writers to break up files that were getting out of control. You can define a new file <code class="language-plaintext highlighter-rouge">new.proto</code> for some of the definitions in <code class="language-plaintext highlighter-rouge">big.proto</code>, move them to the new file, and then add <code class="language-plaintext highlighter-rouge">import public "new.proto";</code> to <code class="language-plaintext highlighter-rouge">big.proto</code>. Existing imports of <code class="language-plaintext highlighter-rouge">big.proto</code> won’t be broken, hooray!</p> <p>Except this feature was designed for C++. In C++, each <code class="language-plaintext highlighter-rouge">.proto</code> file maps to a <code class="language-plaintext highlighter-rouge">.proto.h</code> header, which you <code class="language-plaintext highlighter-rouge">#include</code> in your application code. In C++, <code class="language-plaintext highlighter-rouge">#include</code> behaves like <code class="language-plaintext highlighter-rouge">import public</code>, so marking an import as <code class="language-plaintext highlighter-rouge">public</code> only changes name resolution in Protobuf—the C++ backend doesn’t have to do anything to maintain source compatibility when an import is changed to <code class="language-plaintext highlighter-rouge">public</code>.</p> <p>But other backends, like Go, do not work this way: <code class="language-plaintext highlighter-rouge">import</code> in Go <em>doesn’t</em> pull in symbols transitively, so Go would need to explicitly add aliases for all of the symbols that come in through a public import. That is, if you had:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// foo.proto</span>
<span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// bar.proto</span>
<span class="kn">package</span> <span class="nn">myotherapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>
<span class="k">import</span> <span class="n">public</span> <span class="s">"foo.proto"</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Then the Go backend has to generate a <code class="language-plaintext highlighter-rouge">type Foo = foopb.Foo</code> in <code class="language-plaintext highlighter-rouge">bar.pb.go</code> to emulate this behavior (in fact, I was surprised to learn Go Protobuf implements this at all). Go <em>happens</em> to implement public imports correctly, but not all backends are as careful, because this feature is obscure.</p> <p>The <a href="https://github.com/googleapis/googleapis/blob/df58085901d8fb80c2c021e405923bb2351a6f29/google/spanner/v1/spanner.proto#L19"><code class="language-plaintext highlighter-rouge">spanner.proto</code></a> example of an <code class="language-plaintext highlighter-rouge">import public</code> isn’t even used for breaking up an existing file; instead, it’s used to not make a huge file bigger and avoid making callers have to add an additional import. This is a <em>bad use</em> of a <em>bad feature!</em></p> <p>Using <code class="language-plaintext highlighter-rouge">import public</code> to effectively “hide” imports makes it harder to understand what a <code class="language-plaintext highlighter-rouge">.proto</code> file is pulling in. If Protobuf imports were at the package/symbol level, like Go or Java, this feature would not need to exist. Unfortunately, Protobuf is closely tailored for C++, and this is one of the consequences.</p> <p>Instead of using <code class="language-plaintext highlighter-rouge">import public</code> to break up a file, simply plan to break up the file in the next version of the API.</p> <p>The <a href="https://buf.build/docs/lint/rules/#import_no_public"><code class="language-plaintext highlighter-rouge">IMPORT_NO_PUBLIC</code></a> Buf lint rule enforces that no one uses this feature by default. It’s tempting, but the footguns aren’t worth it.</p> <h2 id="weak-imports"><a href="#weak-imports">Weak Imports</a></h2> <p>Public imports have a good, if flawed, reason to exist. Their implementation details are the main thing that kneecaps them.</p> <p>Weak imports, however, simply should not exist. They were added to the language to make it easier for some of Google’s enormous binaries to avoid running out of linker memory, by making it so that message types could be dropped if they weren’t accessed. This means that weak imports are “optional”—if the corresponding descriptors are missing at runtime, the C++ runtime can handle it gracefully.</p> <p>This leads to all kinds of implementation complexity and subtle behavior differences across runtimes. Most runtimes implement (or implemented, in the case of those that removed support) <code class="language-plaintext highlighter-rouge">import weak</code> in a buggy or inconsistent way. It’s unlikely the feature will ever be truly removed, even though Google has tried.</p> <p>Don’t use <code class="language-plaintext highlighter-rouge">import weak</code>. It should be treated as completely non-functional. The <a href="https://buf.build/docs/lint/rules/#import_no_weak"><code class="language-plaintext highlighter-rouge">IMPORT_NO_WEAK</code></a> Buf lint rule takes care of this for you.</p>]]></content><author><name>Miguel Young de la Sota</name></author><category term="protobuf-tips"/><summary type="html"><![CDATA[My dad had a guitar but it was acoustic, so I smashed a mirror and glued broken glass to it to make it look more metal. It looked ridiculous! –Max Cavalera]]></summary></entry><entry><title type="html">Protobuf Tip #4: Accepting Mistakes We Can’t Fix</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/29/protobuf-tip-4/" rel="alternate" type="text/html" title="Protobuf Tip #4: Accepting Mistakes We Can’t Fix"/><published>2025-04-29T00:00:00-07:00</published><updated>2025-04-29T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/04/29/protobuf-tip-4</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/29/protobuf-tip-4/"><![CDATA[<p><em>Bad humor is an evasion of reality; good humor is an acceptance of it. –Malcolm Muggeridge</em></p> <p>TL;DR: Protobuf’s distributed nature introduces evolution risks that make it hard to fix some types of mistakes. Sometimes the best thing to do is to just let it be.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-4-accepting-mistakes">buf.build blog</a>.</p> </blockquote> <h2 id="a-different-mindset"><a href="#a-different-mindset">A Different Mindset</a></h2> <p>Often, you’ll design and implement a feature for the software you work on, and despite your best efforts to test it, something terrible happens in production. We have a playbook for this, though: fix the bug in your program and ship or deploy the new, fixed version to your users. It might mean working late for big emergencies, but turnaround for most organizations is a day to a week.</p> <p>Most bugs aren’t emergencies, though. Sometimes a function has a confusing name, or an integer type is just a bit too small for real-world data, or an API conflates “zero” and “null”. You fix the API, refactor all usages in your API in one commit, merge, and the fix rolls out gradually.</p> <p>Unless, of course, it’s a bug in a communication API, like a serialization format: your Protobuf types, or your JSON schema, or the not-too-pretty code that parses fields out of dict built from a YAML file. Here, you can’t <em>just</em> atomically fix the world. Fixing bugs in your APIs (from here on, “APIs” means “Protobuf definitions”) requires a different mindset than fixing bugs in ordinary code.</p> <h2 id="what-are-the-risks"><a href="#what-are-the-risks">What Are the Risks?</a></h2> <p>Protobuf’s wire format is designed so that you can safely add new fields to a type, or values to an enum, without needing to perform an atomic upgrade. But other changes, like renaming fields or changing their type, are very dangerous.</p> <p>This is because Protobuf types exist on a temporal axis: different versions of the same type exist simultaneously among programs in the field that are actively talking to each other. This means that <em>writers from the future</em> (that is, new serialization code) must be careful to not confuse the many <em>readers from the past</em> (old versions of the deserialization code). Conversely, future readers must tolerate anything past writers produce.</p> <p>In a modern distributed deployment, the number of versions that exist at once can be quite large. This is true even in self-hosted clusters, but becomes much more fraught whenever user-upgradable software is involved. This can include mobile applications that talk to your servers, or appliance software managed by a third-party administrator, or even just browser-service communication.</p> <p>The most important principle: you can’t easily control when old versions of a type or service are no longer relevant. As soon as a type escapes out of the scope of even a single team, upgrading types becomes a departmental effort.</p> <h2 id="learning-to-love-the-bomb"><a href="#learning-to-love-the-bomb">Learning to Love the Bomb</a></h2> <p>There are many places where Protobuf could have made schema evolution easier, but didn’t. For example, changing <code class="language-plaintext highlighter-rouge">int32 foo = 1;</code> to <code class="language-plaintext highlighter-rouge">sfixed32 foo = 1;</code> is a breakage, even though at the wire format level, it is <em>possible</em> for a parser to distinguish and accept both forms of <code class="language-plaintext highlighter-rouge">foo</code> correctly. There too many other examples to list, but it’s important to understand that the language is not always working in our favor.</p> <p>For example, if we notice a <code class="language-plaintext highlighter-rouge">int32</code> value is too small, and should have been 64-bit, you can’t upgrade it without readers from the past potentially truncating it. But we really have to upgrade it! What are our options?</p> <ol> <li>Issue a new version of the message and all of its dependencies. This is the main reason why sticking a version number in the package name, as enforced by Buf’s <a href="https://buf.build/docs/lint/rules/#package_version_suffix"><code class="language-plaintext highlighter-rouge">PACKAGE_VERSION_SUFFIX</code></a> lint rule, is so important.</li> <li>Do the upgrade anyway and hope nothing breaks. This <em>can</em> work for certain kinds of upgrades, if the underlying format is compatible, but it can have <strong>disastrous consequences</strong> if you don’t know what you’re doing, especially if it’s a type that’s not completely internal to a team’s project. <a href="https://buf.build/docs/breaking/overview/">Buf breaking change detection</a> helps you avoid changes with potential for breakage.</li> </ol> <p>Of course, there is a third option, which is to accept that some things aren’t worth fixing. When the cost of a fix is so high, fixes just aren’t worth it, especially when the language is working against us.</p> <p>This means that even in Buf’s own APIs, we sometimes do things in a way that isn’t quite ideal, or is inconsistent with our own best practices. Sometimes, the ecosystem changes in a way that changes best practice, but we can’t upgrade to it without breaking our users. In the same way, you shouldn’t rush to use new, better language features if they would cause protocol breaks: sometimes, the right thing is to do nothing, because not breaking your users is more important. <br/></p> <p> </p>]]></content><author><name>Miguel Young de la Sota</name></author><category term="protobuf-tips"/><summary type="html"><![CDATA[Bad humor is an evasion of reality; good humor is an acceptance of it. –Malcolm Muggeridge]]></summary></entry><entry><title type="html">Protobuf Tip #3: Enum Names Need Prefixes</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/22/protobuf-tip-3/" rel="alternate" type="text/html" title="Protobuf Tip #3: Enum Names Need Prefixes"/><published>2025-04-22T00:00:00-07:00</published><updated>2025-04-22T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/04/22/protobuf-tip-3</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/22/protobuf-tip-3/"><![CDATA[<p><em>Smart people learn from their mistakes. But the real sharp ones learn from the mistakes of others. –Brandon Mull</em></p> <p>TL;DR: <code class="language-plaintext highlighter-rouge">enum</code>s inherit some unfortunate behaviors from C++. Use the Buf lint rules <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a> and <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a>  to avoid this problem (they’re part of the <code class="language-plaintext highlighter-rouge">DEFAULT</code> category).</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-3-enum-names-need-prefixes">buf.build blog</a>.</p> </blockquote> <h2 id="c-style-enums"><a href="#c-style-enums">C++-Style Enums</a></h2> <p>Protobuf’s <code class="language-plaintext highlighter-rouge">enum</code>s define data types that represent a small set of valid values. For example, <code class="language-plaintext highlighter-rouge">google.rpc.Code</code> lists status codes used by various RPC frameworks, such as GRPC. Under the hood, every <code class="language-plaintext highlighter-rouge">enum</code> is just an <code class="language-plaintext highlighter-rouge">int32</code>  on the wire, although codegen backends will generate custom types and constants for the enum to make it easier to use.</p> <p>Unfortunately, <code class="language-plaintext highlighter-rouge">enum</code>s were originally designed to match C++ enums exactly, and they inadvertently replicate many of those behaviors.</p> <p>If you look at the source for <code class="language-plaintext highlighter-rouge">google.rpc.Code</code>, and compare it to, say, <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.Type</code>, you will notice a subtle difference:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="k">rpc</span><span class="p">;</span>
<span class="kd">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="na">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">UNKNOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="n">protobuf</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">FieldDescriptorProto</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="c1">// 0 is reserved for errors.</span>
    <span class="na">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">TYPE_INT64</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p><code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> has values starting with <code class="language-plaintext highlighter-rouge">TYPE_</code>, but <code class="language-plaintext highlighter-rouge">Code</code> ‘s values don’t have a <code class="language-plaintext highlighter-rouge">CODE_</code> prefix.  This is because the fully-qualified names (FQN) of an enum value <em>don’t include the name of the enum.</em> That is, <code class="language-plaintext highlighter-rouge">TYPE_DOUBLE</code> actually refers to <code class="language-plaintext highlighter-rouge">google.protobuf.FieldDescriptorProto.TYPE_DOUBLE</code>. Thus, <code class="language-plaintext highlighter-rouge">OK</code> is not <code class="language-plaintext highlighter-rouge">google.rpc.Code.OK</code>, but <code class="language-plaintext highlighter-rouge">google.rpc.OK</code>.</p> <p>This is because it matches the behavior of unscoped C++ enums. C++ is the “reference” implementation, so the language often bends for the sake of the C++ backend.</p> <p>When generating code, <code class="language-plaintext highlighter-rouge">protoc</code>’s C++ backend emits the above as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">rpc</span> <span class="p">{</span>
<span class="k">enum</span> <span class="n">Code</span> <span class="p">{</span>
  <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">CANCELLED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">FieldDescriptorProto</span> <span class="k">final</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">enum</span> <span class="n">Type</span> <span class="p">{</span>
   <span class="n">TYPE_DOUBLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">TYPE_FLOAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// ...</span>
  <span class="p">};</span>
<span class="p">};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>And in C++, <code class="language-plaintext highlighter-rouge">enum</code>s don’t scope their enumerators: you write <code class="language-plaintext highlighter-rouge">google::rpc::OK</code>, NOT <code class="language-plaintext highlighter-rouge">google::rpc::Code::OK</code>.</p> <p>If you know C++, you might be thinking, “why didn’t they use <code class="language-plaintext highlighter-rouge">enum class</code>?!”? Enums were added in <code class="language-plaintext highlighter-rouge">proto2</code>, which was developed around 2007-2008, but Google didn’t start using C++11, which introduced <code class="language-plaintext highlighter-rouge">enum class</code> , until much, much later.</p> <p>Now, if you’re a Go or Java programmer, you’re probably wondering why you even care about C++. Both Go and Java do scope enum values to the enum type (although Go does it in a somewhat grody way: <code class="language-plaintext highlighter-rouge">rpcpb.Code_OK</code>).</p> <p>Unfortunately, this affects name collision detection in Protobuf. You can’t write the following code:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Because the enum name is not part of the FQN for an enum value, both <code class="language-plaintext highlighter-rouge">UNSPECIFIED</code>s here have the FQN <code class="language-plaintext highlighter-rouge">myapi.v1.UNSPECIFIED</code>, so Protobuf complains about duplicate symbols.</p> <p>Thus, the convention we see in <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">myapi</span><span class="o">.</span><span class="n">v1</span><span class="p">;</span>

<span class="kd">enum</span> <span class="n">Stoplight</span> <span class="p">{</span>
  <span class="na">STOPLIGHT_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">STOPLIGHT_RED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">STOPLIGHT_YELLOW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="na">STOPLIGHT_GREEN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">Speed</span> <span class="p">{</span>
  <span class="na">SPEED_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">SPEED_SLOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">SPEED_FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>Buf provides a lint rule to enforce this convention: <a href="https://buf.build/docs/lint/rules/#enum_value_prefix"><code class="language-plaintext highlighter-rouge">ENUM_VALUE_PREFIX</code></a>. Even though you might think that an enum name will be unique, because top-level enums bleed their names into the containing package, the problem spreads across packages!</p> <h2 id="zero-values"><a href="#zero-values">Zero Values</a></h2> <p><code class="language-plaintext highlighter-rouge">proto3</code> relies heavily on the concept of “zero values” – all non-message fields that are neither <code class="language-plaintext highlighter-rouge">repeated</code> nor <code class="language-plaintext highlighter-rouge">optional</code> are implicitly zero if they are not present. Thus, <code class="language-plaintext highlighter-rouge">proto3</code> requires that enums specify a value equal to zero.</p> <p>By convention, this value shouldn’t be a specific value of the enum, but rather a value representing that no value is specified. <a href="https://buf.build/docs/lint/rules/#enum_zero_value_suffix"><code class="language-plaintext highlighter-rouge">ENUM_ZERO_VALUE_SUFFIX</code></a> enforces this, with a default of <code class="language-plaintext highlighter-rouge">_UNSPECIFIED</code>. Of course, there are situations where this might not make sense for you, and a suffix like <code class="language-plaintext highlighter-rouge">_ZERO</code> or <code class="language-plaintext highlighter-rouge">_UNKNOWN</code> might make more sense.</p> <p>It may be tempting to have a specific “good default” value for the zero value. Beware though, because that choice is forever. Picking a generic “unknown” as the default reduces the chance you’ll burn yourself.</p> <h2 id="why-dont-all-of-googles-protobuf-files-do-this"><a href="#why-dont-all-of-googles-protobuf-files-do-this">Why Don’t All of Google’s Protobuf Files Do This?</a></h2> <p>Name prefixes and zero values also teach us an important lesson: because Protobuf names are forever, it’s really hard to fix style mistakes, especially as we collectively get better at using Protobuf.</p> <p><code class="language-plaintext highlighter-rouge">google.rpc.Code</code> is intended to be source-compatible with very old existing C++ code, so it throws caution to the wind. <code class="language-plaintext highlighter-rouge">FieldDescriptorProto.Type</code> doesn’t have a zero value because in <code class="language-plaintext highlighter-rouge">proto2</code> , which doesn’t have zero value footguns in its wire format, you don’t need to worry about that. The lesson isn’t just to use Buf’s linter to try to avoid some of the known pitfalls, but also to remember that even APIs designed by the authors of the language make unfixable mistakes, so unlike other programming languages, imitating “existing practice” isn’t always the best strategy.</p>]]></content><author><name>Miguel Young de la Sota</name></author><category term="protobuf-tips"/><summary type="html"><![CDATA[Smart people learn from their mistakes. But the real sharp ones learn from the mistakes of others. –Brandon Mull]]></summary></entry><entry><title type="html">Cheating the Reaper in Go</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/21/go-arenas/" rel="alternate" type="text/html" title="Cheating the Reaper in Go"/><published>2025-04-21T00:00:00-07:00</published><updated>2025-04-21T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/04/21/go-arenas</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/21/go-arenas/"><![CDATA[<p>Even though I am a C++ programmer at heart, Go fascinates me for none of the reasons you think. Go has made several interesting design decisions:</p> <ol> <li> <p>It has virtually no Undefined Behavior<sup id="fnref:goub" role="doc-noteref"><a href="#fn:goub" class="footnote" rel="footnote">1</a></sup>.</p> </li> <li> <p>It has very simple GC semantics that they’re mostly stuck with due to design decisions in the surface language.</p> </li> </ol> <p>These things mean that despite Go having a GC, it’s possible to do manual memory management in pure Go and in cooperation with the GC (although without any help from the <code class="language-plaintext highlighter-rouge">runtime</code> package). To demonstrate this, we will be building an untyped, garbage-collected arena abstraction in Go which relies on several GC implementation details.</p> <p>I would never play this kind of game in Rust or C++, because LLVM is extremely intelligent and able to find all kinds of ways to break you over the course of frequent compiler upgrades. On the other hand, although Go does not promise any compatibility across versions for code that imports <code class="language-plaintext highlighter-rouge">unsafe</code>, in practice, two forces work against Go doing this:</p> <ol> <li> <p>Go does not attempt to define what is and isn’t allowed: <code class="language-plaintext highlighter-rouge">unsafe</code> lacks any <a href="https://en.wikipedia.org/wiki/Operational_semantics">operational semantics</a>.</p> </li> <li> <p>Go prioritizes not breaking the ecosystem; this allows to assume that <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a> will protect certain observable behaviors of the runtime, from which we may infer what can or cannot break easily.</p> </li> </ol> <p>This is in contrast to a high-performance native compiler like LLVM, which has a carefully defined boundary around all UB, allowing them to arbitrarily break programs that cross it (mostly) without fear of breaking the ecosystem.</p> <p>So, let’s dive in and cheat death.</p> <h2 id="what-are-we-building"><a href="#what-are-we-building">What Are We Building?</a></h2> <p>Our goal is to build an <em>arena</em>, which is a data structure for efficient allocation of memory that has the same lifetime. This reduces pressure on the general-purpose allocator by only requesting memory in large chunks and then freeing it all at once.</p> <p>For a comparison in Go, consider the following program:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">s</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="m">1000</span> <span class="p">{</span>
    <span class="n">prev</span> <span class="o">:=</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This program will print successive powers of 2: this is because <code class="language-plaintext highlighter-rouge">append</code> is implemented approximately like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="nb">append</span><span class="p">[</span><span class="n">S</span> <span class="err">~</span><span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">S</span><span class="p">)</span> <span class="n">S</span> <span class="p">{</span>
  <span class="c">// If needed, grow the allocation.</span>
  <span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Either double the size, or allocate just enough if doubling is</span>
    <span class="c">// too little.</span>
    <span class="n">newCap</span> <span class="o">:=</span> <span class="n">max</span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="c">// Grow a.</span>
    <span class="n">a2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">newCap</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a2</span>
  <span class="p">}</span>

  <span class="c">// Increase the length of a to fit b, then write b into the freshly</span>
  <span class="c">// grown region.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span>
  <span class="nb">copy</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>For appending small pieces, <code class="language-plaintext highlighter-rouge">make</code> is only called <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> times, a big improvement over calling it for every call to <code class="language-plaintext highlighter-rouge">append</code>. Virtually every programming language’s dynamic array abstraction makes this optimization.</p> <p>An arena generalizes this concept, but instead of resizing exponentially, it allocates <em>new</em> blocks and vends pointers into them. The interface we want to conform to is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Allocator</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>In go a size and and an alignment, out comes a pointer fresh memory with that layout. Go does not have user-visible uninitialized memory, so we additionally require that the returned region be zeroed. We also require that <code class="language-plaintext highlighter-rouge">align</code> be a power of two.</p> <p>We can give this a type-safe interface by writing a generic <code class="language-plaintext highlighter-rouge">New</code> function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// New allocates a fresh zero value of type T on the given allocator, and</span>
<span class="c">// returns a pointer to it.</span>
<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="n">Allocator</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This all feels very fine and dandy to anyone used to hurting themselves with <code class="language-plaintext highlighter-rouge">malloc</code> or <code class="language-plaintext highlighter-rouge">operator new</code> in C++, but there is a small problem. What happens when we allocate pointer-typed memory into this allocator?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// Allocate a pointer in our custom allocator, and then</span>
<span class="c">// initialize it to a pointer on the Go heap.</span>
<span class="n">p</span> <span class="o">:=</span> <span class="n">New</span><span class="p">[</span><span class="o">*</span><span class="kt">int</span><span class="p">](</span><span class="n">myAlloc</span><span class="p">)</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="n">runtime</span><span class="o">.</span><span class="n">GC</span><span class="p">()</span>
<span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="m">42</span>  <span class="c">// Use after free!</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">Allocator.Alloc</code> takes a size and an alignment, which is sufficient to describe the <em>layout</em> of any type. For example, on 64-bit systems, <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">*int</code> have the same layout: 8 bytes of size, and 8 bytes of alignment.</p> <p>However, the Go GC (and all garbage collectors, generally) require one additional piece of information, which is somewhere between the layout of a value (how it is placed in memory) and the type of a value (rich information on its structure). To understand this, we need a brief overview on what a GC does.</p> <h2 id="mark-and-sweep"><a href="#mark-and-sweep">Mark and Sweep</a></h2> <blockquote> <p>For a complete overview on how to build a simple GC, take a look at a toy GC I designed some time ago: <a href="https://mcyoung.xyz/2022/06/07/alkyne-gc/">The Alkyne GC</a>.</p> </blockquote> <p>A garbage collector’s responsibility is to maintain a memory allocator and an accounting of:</p> <ol> <li>What memory has been allocated.</li> <li>Whether that memory is still in use.</li> </ol> <p>Memory that is not in use can be reclaimed and marked as unallocated, for re-use.</p> <p>The most popular way to accomplish this is via a “mark and sweep” architecture. The GC will periodically walk the entire object graph of the program from certain pre-determined <em>roots</em>; anything it finds is “marked” as alive. After a mark is complete, all other memory is “swept”, which means to mark it is unallocated for future re-use, or to return it to the OS, in the case of significant surplus.</p> <p>The roots are typically entities that are actively being manipulated by the program. In the case of Go, this is anything currently on the stack of some G<sup id="fnref:g" role="doc-noteref"><a href="#fn:g" class="footnote" rel="footnote">2</a></sup>, or anything in a global (of which there is a compile-time-known set).</p> <p>The marking phase begins with <em>stack scanning</em>, which looks at the stack of each G and locates any pointers contained therein. The Go compiler generates metadata for each function that specifies which stack slots in a function’s frame contain pointers. All of these pointers are live by definition.</p> <p>These pointers are placed into a queue, and each pointer is traced to its allocation on the heap. If the GC does not know anything about a particular address, it is discarded as foreign memory that does not need to be marked. If it does, each pointer in that allocation is pushed onto the queue if it has not already been marked as alive. The process continues until the queue is empty.</p> <p>The critical step here is to take the address of some allocation, and convert it into all of the pointer values within. Go has precise garbage collection, which means that it only treats things declared as pointers in the surface language as pointers: an integer that happens to look like an address will not result in sweeping. This results in more efficient memory usage, but trades off some more complexity in the GC.</p> <p>For example, the types <code class="language-plaintext highlighter-rouge">*int</code>, <code class="language-plaintext highlighter-rouge">map[int]byte</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">struct {A int; B *int}</code> all contain at least one pointer, while <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">[1000]byte</code>, <code class="language-plaintext highlighter-rouge">struct {X bool; F uintptr}</code> do not. The latter are called <em>pointer-free</em> types.</p> <p>Go enhances the layout of a type into a <em>shape</em> by adding a bitset that specifies which pointer-aligned, pointer-sized words of the type’s memory region contain a pointer. These are called the <em>pointer bits</em>. For example, here are the shapes of a few Go types on a 64-bit system.</p> <table> <thead> <tr> <th>Type</th> <th>Size/Align</th> <th>Pointer Bits<sup id="fnref:ptr-bits-endian" role="doc-noteref"><a href="#fn:ptr-bits-endian" class="footnote" rel="footnote">3</a></sup></th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">byte</code></td> <td>1/1</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">rune</code></td> <td>4/4</td> <td><code class="language-plaintext highlighter-rouge">0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">*int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">unsafe.Pointer</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">string</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">10</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[]int</code></td> <td>24/8</td> <td><code class="language-plaintext highlighter-rouge">100</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[3]string</code></td> <td>48/8</td> <td><code class="language-plaintext highlighter-rouge">101010</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">map[int]byte</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">map[int]string</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">any</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">01</code><sup id="fnref:itab" role="doc-noteref"><a href="#fn:itab" class="footnote" rel="footnote">4</a></sup></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">error</code></td> <td>16/8</td> <td><code class="language-plaintext highlighter-rouge">01</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">func(int) int</code></td> <td>8/8</td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">runtime.hchan</code><sup id="fnref:hchan" role="doc-noteref"><a href="#fn:hchan" class="footnote" rel="footnote">5</a></sup></td> <td>104/8</td> <td><code class="language-plaintext highlighter-rouge">0010110011110</code></td> </tr> </tbody> </table> <p>In the Go GC, each allocation is tagged with its shape (this is done in a variety of ways in the GC, either through an explicit header on the allocation, itself (a “malloc header”), a runtime type stored in the allocation’s <code class="language-plaintext highlighter-rouge">runtime.mspan</code>, or another mechanism). When scanning a value, it uses this information to determine where the pointers to scan through are.</p> <p>The most obvious problem with our <code class="language-plaintext highlighter-rouge">Allocator.Alloc</code> type is that it does not discriminate shapes, so it cannot allocate memory that contains pointers: the GC will not be able to find the pointers, and will free them prematurely!</p> <p>In our example where we allocated an <code class="language-plaintext highlighter-rouge">*int</code> in our custom allocator, we wind up with a <code class="language-plaintext highlighter-rouge">**int</code> on the stack. You would think that Go would simply trace through the first <code class="language-plaintext highlighter-rouge">*</code> to find an <code class="language-plaintext highlighter-rouge">*int</code> and mark it as being alive, but that is not what happens! Go instead finds a pointer into some chunk that the custom allocator grabbed from the heap, which is missing the pointer bits of its shape!</p> <p>Why does go not look at the type of the pointer it steps through? Two reasons.</p> <ol> <li> <p>All pointers in Go are untyped from the runtime’s perspective; every <code class="language-plaintext highlighter-rouge">*T</code> gets erased into an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>. This allows much of the Go runtime to be “generic” without using actual generics.</p> </li> <li> <p>Pointee metadata can be aggregated, so that each pointer to an object does not have to remember its type at runtime.</p> </li> </ol> <p>The end result for us is that we can’t put pointers on the arena. This makes our <code class="language-plaintext highlighter-rouge">New</code> API unsafe, especially since Go does not provide a standard constraint for marking generic parameters as pointer-free: unsurprisingly, the don’t expect most users to care about such a detail.</p> <p>It <em>is</em> possible to deduce the pointer bits of a type using reflection, but that’s very slow, and the whole point of using arenas is to go fast. As we design our arena, though, it will become clear that there is a safe way to have pointers on it.</p> <h2 id="designing-the-arena"><a href="#designing-the-arena">Designing The Arena</a></h2> <p>Now that we have a pretty good understanding about what the Go GC is doing, we can go about designing a fast arena structure.</p> <p>The ideal case is that a call to <code class="language-plaintext highlighter-rouge">Alloc</code> is very fast: just offsetting a pointer in the common case. One assumption we can make off the bat is that all memory can be forced to have maximum alignment: most objects are a pointer or larger, and Go does have a maximum alignment for ordinary user types, so we can just ignore the <code class="language-plaintext highlighter-rouge">align</code> parameter and always align to say, 8 bytes. This means that the pointer to the next unallocated chunk will always be well-aligned. Thus, we might come up with a structure like this one:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>
<span class="p">}</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="c">// Power of two size of the minimum allocation granularity.</span>
  <span class="n">wordBytes</span> <span class="o">=</span> <span class="m">8</span>  <span class="c">// Depends on target, this is for 64-bit.</span>
  <span class="n">minWords</span>  <span class="o">=</span> <span class="m">8</span>
<span class="p">)</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// First, round the size up to the alignment of every object in</span>
  <span class="c">// the arena.</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="c">// Then, replace the size with the size in pointer-sized words.</span>
  <span class="c">// This does not result in any loss of size, since size is now</span>
  <span class="c">// a multiple of the uintptr size.</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">wordBytes</span>

  <span class="c">// Next, check if we have enough space left for this chunk. If</span>
  <span class="c">// there isn't, we need to grow.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size,</span>
    <span class="c">// twice the last allocation, or the next power of two</span>
    <span class="c">// after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
  <span class="p">}</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// Beware, offsetting to one-past-the-end is one of the few</span>
    <span class="c">// things explicitly not allowed by Go.</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="c">// nextPow2 returns the smallest power of two greater than n.</span>
<span class="k">func</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="o">.</span><span class="n">Len</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>How fast is this really? Here’s a simple benchmark for it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">BenchmarkArena</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bench</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">64</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
  <span class="n">bench</span><span class="p">[[</span><span class="m">1024</span><span class="p">]</span><span class="kt">int</span><span class="p">](</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">runs</span> <span class="o">=</span> <span class="m">100000</span>

<span class="k">var</span> <span class="n">sink</span> <span class="n">any</span>

<span class="k">func</span> <span class="n">bench</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">z</span> <span class="n">T</span>
  <span class="n">n</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">runs</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
  <span class="n">name</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%v"</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">T</span><span class="p">]())</span>

  <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"arena"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">Arena</span><span class="p">)</span>
        <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
          <span class="n">sink</span> <span class="o">=</span> <span class="n">arena</span><span class="o">.</span><span class="n">New</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">a</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})</span>

    <span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"new"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
          <span class="n">sink</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The focus of this benchmark is to measure the cost of allocating many objects of the same size. The number of times the <code class="language-plaintext highlighter-rouge">for b.Loop()</code> loop will execute is unknown, and determined by the benchmarking framework to try to reduce statistical anomaly. This means that if we instead just benchmark a single allocation, the result will be <em>very</em> sensitive to the number of runs.</p> <p>We also use <code class="language-plaintext highlighter-rouge">b.SetBytes</code> to get a throughput measurement on the benchmark. This is a bit easier to interpret than the gross <code class="language-plaintext highlighter-rouge">ns/op</code>, the benchmark would otherwise produce. It tells us how much memory each allocator can allocate per unit time.</p> <p>We want to compare against <code class="language-plaintext highlighter-rouge">new</code>, but just writing <code class="language-plaintext highlighter-rouge">_ = new(T)</code> will get optimized out, since the resulting pointer does not escape. Writing it to a global is sufficient to convince Go that it escapes.</p> <p>Here’s the results, abbreviated to show only the bytes per second. All benchmarks were performed on my AMD Ryzen Threadripper 3960X. Larger is better.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         794.84 MB/s
BenchmarkArena/int/new-48           390.59 MB/s
BenchmarkArena/[2]int/arena-48      1263.58 MB/s
BenchmarkArena/[2]int/new-48        528.06 MB/s
BenchmarkArena/[64]int/arena-48     7370.08 MB/s
BenchmarkArena/[64]int/new-48       2865.24 MB/s
BenchmarkArena/[1024]int/arena-48   9889.20 MB/s
BenchmarkArena/[1024]int/new-48     2875.75 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>This is quite nice, and certainly worth pursuing! The performance increase seems to scale up with the amount of memory allocated, for a 2x-4x improvement across different cases.</p> <p>Now we need to contend with the fact that our implementation is completely broken if we want to have pointers in it.</p> <h3 id="not-dropping-memory-on-the-ground"><a href="#not-dropping-memory-on-the-ground">Not Dropping Memory on the Ground</a></h3> <p>In <code class="language-plaintext highlighter-rouge">(*Arena).Alloc</code>, when we assign a freshly-allocated chunk, we overwrite <code class="language-plaintext highlighter-rouge">a.next</code>, which means the GC can reclaim it. But this is fine: as long as pointers into that arena chunk are alive, the GC will not free it, independent of the arena. So it seems like we don’t need to worry about it?</p> <p>However, the whole point of an arena is to allocate lots of memory that has the same lifetime. This is common for graph data structures, such as an AST or a compiler IR, which performs a lot of work that allocates a lot and then throws the result away.</p> <p>We are not allowed to put pointers in the arena, because they would disappear from the view of the GC and become freed too soon. But, if a pointer wants to go on an arena, it necessarily outlive the whole arena, since it outlives part of the arena, and the arena is meant to have the same lifetime.</p> <p>In particular, if we could make it so that holding any pointer returned by <code class="language-plaintext highlighter-rouge">Alloc</code> prevents the <em>entire arena</em> from being swept by the GC, the arena can safely contain pointers into itself! Consider this:</p> <ol> <li> <p>We have a pointer <code class="language-plaintext highlighter-rouge">p **int</code>. It is allocated on some arena <code class="language-plaintext highlighter-rouge">a</code>.</p> </li> <li> <p>The GC sees our pointer (as a type-erased <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>) and marks its allocation as live.</p> </li> <li> <p>Somehow, the GC also marks <code class="language-plaintext highlighter-rouge">a</code> as alive as a consequence.</p> </li> <li> <p>Somehow, the GC then marks every chunk <code class="language-plaintext highlighter-rouge">a</code> has allocated as alive.</p> </li> <li> <p>Therefore he chunk that <code class="language-plaintext highlighter-rouge">*p</code> points to is also alive, so <code class="language-plaintext highlighter-rouge">*p</code> does not need to be marked directly, and will not be freed early.</p> </li> </ol> <p>The step (3) is crucial. By forcing the whole arena to be marked, any pointers stored in the arena into itself will be kept alive automatically, without the GC needing to know how to scan for them.</p> <p>So, even though <code class="language-plaintext highlighter-rouge">*New[*int](a) = new(int)</code> is still going to result in a use-after-free, <code class="language-plaintext highlighter-rouge">*New[*int](a) = New[int](a)</code> would not! This small improvement does not make arenas themselves safe, but a data structure with an internal arena can be completely safe, so long as the only pointers that go into the arena are from the arena itself.</p> <p>How can we make this work? The easy part is (4), which we can implement by adding a <code class="language-plaintext highlighter-rouge">[]unsafe.Pointer</code> to the arena, and sticking every pointer we allocate into it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>

  <span class="n">chunks</span> <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>  <span class="c">// New field.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip ...</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size,</span>
    <span class="c">// twice the last allocation, or the next power of two</span>
    <span class="c">// after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// ... snip ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The cost of the <code class="language-plaintext highlighter-rouge">append</code> is amortized: to allocate <code class="language-plaintext highlighter-rouge">n</code> bytes, we wind up allocating an additional <span class="katex-inl"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> times. But what does this do to our benchmarks?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         800.08 MB/s
BenchmarkArena/int/new-48           386.81 MB/s
BenchmarkArena/[2]int/arena-48      1236.00 MB/s
BenchmarkArena/[2]int/new-48        520.84 MB/s
BenchmarkArena/[64]int/arena-48     7999.71 MB/s
BenchmarkArena/[64]int/new-48       2706.68 MB/s
BenchmarkArena/[1024]int/arena-48   9998.00 MB/s
BenchmarkArena/[1024]int/new-48     2816.28 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Seems pretty much the same, which is a good sign.</p> <h3 id="back-pointers"><a href="#back-pointers">Back Pointers</a></h3> <p>Now that the arena does not discard any allocated memory, we can focus on condition (3): making it so that if any pointer returned by <code class="language-plaintext highlighter-rouge">Alloc</code> is alive, then so is the whole arena.</p> <p>Here we can make use of an important property of how Go’s GC works: any pointer into an allocation will keep it alive, as well as <em>anything reachable from that pointer</em>. But the chunks we’re allocating are <code class="language-plaintext highlighter-rouge">[]uintptr</code>s, which will not be scanned. If there could <em>somehow</em> be a single pointer in this slice that was scanned, we would be able to stick the pointer <code class="language-plaintext highlighter-rouge">a *Arena</code> there, and so when anything that <code class="language-plaintext highlighter-rouge">Alloc</code> returns is scanned, it would cause <code class="language-plaintext highlighter-rouge">a</code> to be marked as alive.</p> <p>So far, we have been allocating <code class="language-plaintext highlighter-rouge">[N]uintptr</code> using <code class="language-plaintext highlighter-rouge">make([]T)</code>, but we would actually like to allocate <code class="language-plaintext highlighter-rouge">struct { A [N]uintptr; P unsafe.Pointer }</code>, where <code class="language-plaintext highlighter-rouge">N</code> is some dynamic value.</p> <p>In its infintie wisdom, the Go standard library actually gives us a dedicated mechanism to do this: <code class="language-plaintext highlighter-rouge">reflect.StructOf</code>. This can be used to construct arbitrary anonymous <code class="language-plaintext highlighter-rouge">struct</code> types at runtime, which we can then allocate on the heap.</p> <p>So, instead of calling <code class="language-plaintext highlighter-rouge">make</code>, we might call this function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
    <span class="p">{</span>
      <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
      <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">words</span><span class="p">),</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()},</span>
  <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This appears to have a minor but noticeable effect on performance<sup id="fnref:type-cache" role="doc-noteref"><a href="#fn:type-cache" class="footnote" rel="footnote">6</a></sup>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         763.91 MB/s
BenchmarkArena/int/new-48           385.49 MB/s
BenchmarkArena/[2]int/arena-48      1174.00 MB/s
BenchmarkArena/[2]int/new-48        524.32 MB/s
BenchmarkArena/[64]int/arena-48     7563.54 MB/s
BenchmarkArena/[64]int/new-48       2649.63 MB/s
BenchmarkArena/[1024]int/arena-48   8668.02 MB/s
BenchmarkArena/[1024]int/new-48     2648.10 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <h2 id="more-optimizations"><a href="#more-optimizations">More Optimizations</a></h2> <p>Looking back at <code class="language-plaintext highlighter-rouge">Arena.Alloc</code>, the end of this function has a branch:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip...</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// Beware, offsetting to one-past-the-end is one of the few</span>
    <span class="c">// things explicitly not allowed by Go.</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is the absolute hottest part of allocation, since it is executed every time we call this function. The branch is a bit unfortunate, but it’s necessary, as noted by the comment.</p> <p>In C++, if we have an array of <code class="language-plaintext highlighter-rouge">int</code> with <code class="language-plaintext highlighter-rouge">n</code> elements in it, and <code class="language-plaintext highlighter-rouge">int* p</code> is a pointer to the start of the array, <code class="language-plaintext highlighter-rouge">p + n</code> is a valid pointer, even though it can’t be dereferenced; it points “one past the end” of the array. This is a useful construction, since, for example, you can use it to eliminate a loop induction variable:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Naive for loop, has an induction variable i.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// Faster: avoids the extra variable increment in the loop</span>
<span class="c1">// body for doing p[i].</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>Go, however, gets very upset if you do this, because it confuses the garbage collector. The GC can’t tell the difference between a one-past-the-end pointer for allocation A, and for the start of allocation B immediately after it. At best this causes memory to stay alive for longer, and at worst it triggers safety interlocks in the GC. The GC will panic if it happens to scan a pointer for an address that it knows has been freed.</p> <p>But in our code above, every chunk now has an extra element at the very end that is not used for allocation, so we <em>can</em> have a pointer that <em>is</em> one-past-the-end of the <code class="language-plaintext highlighter-rouge">[N]uintptr</code> that we are vending memory from.</p> <p>The updated allocation function would look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// ... snip ...</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Notably, we do not replace <code class="language-plaintext highlighter-rouge">a.left</code> with an end pointer, because of the <code class="language-plaintext highlighter-rouge">if a.left &lt; words</code> comparison. We can’t actually avoid the subtraction <code class="language-plaintext highlighter-rouge">a.left -= words</code> because we would have to do it to make this comparison work if we got rid of <code class="language-plaintext highlighter-rouge">a.left</code>.</p> <p>So how much better is this?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         780.07 MB/s
BenchmarkArena/int/new-48           383.16 MB/s
BenchmarkArena/[2]int/arena-48      1245.73 MB/s
BenchmarkArena/[2]int/new-48        530.39 MB/s
BenchmarkArena/[64]int/arena-48     7684.39 MB/s
BenchmarkArena/[64]int/new-48       2679.94 MB/s
BenchmarkArena/[1024]int/arena-48   8859.99 MB/s
BenchmarkArena/[1024]int/new-48     2611.33 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Remarkably, not very! This is an improvement on the order of magnitude of one or two percentage points. This is because the branch we deleted is extremely predictable. Because Go’s codegen is relatively mediocre, the effect of highly predictable branches (assuming Go actually schedules the branches correctly 🙄) is quite minor.</p> <p>Turns out there’s a bigger improvement we can make.</p> <h3 id="write-barriers"><a href="#write-barriers">Write Barriers</a></h3> <p>Here’s the assembly Go generated for this function, heavily abridged, and annotated with the corresponding Go source code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">(*</span><span class="err">Arena</span><span class="p">).</span><span class="err">Alloc</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JBE</span>     <span class="err">moreStack</span>  <span class="c1">; Stack growth prologue.</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">0x58</span><span class="p">,</span> <span class="err">SP</span>

  <span class="c1">; size = (size + mask) &amp;^ mask</span>
  <span class="err">LEAQ</span>    <span class="m">0x7</span><span class="p">(</span><span class="err">BX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">ANDQ</span>    <span class="err">$</span><span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">,</span> <span class="err">DX</span>
  <span class="c1">; words := size / wordBytes</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">SI</span>
  <span class="err">SHRQ</span>    <span class="err">$</span><span class="m">0x3</span><span class="p">,</span> <span class="err">DX</span>

  <span class="c1">; if a.left &lt; words</span>
  <span class="err">CMPQ</span>    <span class="m">0x8</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">JAE</span>     <span class="err">alloc</span>

  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">SI</span><span class="p">,</span> <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>

  <span class="c1">; nextPow2(words)</span>
  <span class="err">MOVZX</span>   <span class="err">runtime</span><span class="p">.x</span><span class="m">86</span><span class="err">HasPOPCNT</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">DI</span>
  <span class="err">TESTL</span>   <span class="err">DI</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">XORL</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">POPCNTQ</span> <span class="err">DX</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">JMP</span>     <span class="m">2</span><span class="err">f</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">CALL</span>    <span class="err">math/bits</span><span class="p">.</span><span class="err">OnesCount</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">CMPQ</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">$</span><span class="m">0x1</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">BSRQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">$</span><span class="m">-0</span><span class="p">x</span><span class="m">1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">CMOVE</span>   <span class="err">DI</span><span class="p">,</span> <span class="err">CX</span>
  <span class="err">INCQ</span>    <span class="err">CX</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">SHLQ</span>    <span class="err">CL</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">$</span><span class="m">0x40</span>
  <span class="err">SBBQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">R8</span>
  <span class="err">ANDQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">MOVQ</span>    <span class="err">DI</span><span class="p">,</span> <span class="err">DX</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="m">0x10</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">SHLQ</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">CX</span>

  <span class="c1">; a.cap = max(minWords, a.cap*2, nextPow2(words))</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">$</span><span class="m">0x8</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x8</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMOVA</span>   <span class="err">CX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMPQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">CMOVA</span>   <span class="err">DX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0x10</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; a.next = a.allocChunk(a.cap)</span>
  <span class="err">CALL</span>    <span class="err">github</span><span class="p">.</span><span class="err">com/mcy/go-arena</span><span class="p">.(*</span><span class="err">Arena</span><span class="p">).</span><span class="err">allocChunk</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JNE</span>     <span class="m">1</span><span class="err">f</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">JMP</span>     <span class="m">2</span><span class="err">f</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>

  <span class="c1">; a.left = a.cap</span>
  <span class="err">MOVQ</span>    <span class="m">0x10</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x28</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="m">0x20</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">INCQ</span>    <span class="err">BX</span>
  <span class="err">MOVQ</span>    <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">R8</span>
  <span class="err">CMPQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">BX</span>
  <span class="err">JAE</span>     <span class="m">2</span><span class="err">f</span>

  <span class="c1">; a.chunks = append(a.chunks, a.next)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x50</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">R8</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">MOVL</span>    <span class="err">$</span><span class="m">0x1</span><span class="p">,</span> <span class="err">DI</span>
  <span class="err">LEAQ</span>    <span class="m">0x28f70</span><span class="p">(</span><span class="err">IP</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">growslice</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x68</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x28</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0x18</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">R8</span>
  <span class="err">MOVQ</span>    <span class="m">0x50</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
<span class="m">2</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0x20</span><span class="p">(</span><span class="err">DX</span><span class="p">)</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">(</span><span class="err">R8</span><span class="p">)(</span><span class="err">BX</span><span class="p">*</span><span class="m">8</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">-0</span><span class="p">x</span><span class="m">8</span><span class="p">(</span><span class="err">R8</span><span class="p">)(</span><span class="err">BX</span><span class="p">*</span><span class="m">8</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">MOVQ</span>    <span class="m">0x40</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">MOVQ</span>    <span class="m">0x48</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">SI</span>

<span class="nl">alloc:</span>
  <span class="c1">; p := a.next</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">CX</span>

  <span class="c1">; a.next = unsafe.Add(a.next, size)</span>
  <span class="err">LEAQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">CX</span><span class="p">)(</span><span class="err">SI</span><span class="p">*</span><span class="m">1</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0x0</span>
  <span class="err">JE</span>      <span class="m">1</span><span class="err">f</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">),</span> <span class="err">SI</span>
  <span class="err">MOVQ</span>    <span class="err">SI</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="m">1</span><span class="err">:</span>
  <span class="err">MOVQ</span>    <span class="err">BX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; a.left -= words</span>
  <span class="err">LEAQ</span>    <span class="m">0</span><span class="p">(</span><span class="err">CX</span><span class="p">)(</span><span class="err">SI</span><span class="p">*</span><span class="m">1</span><span class="p">),</span> <span class="err">BX</span>
  <span class="err">SUBQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">0x8</span><span class="p">(</span><span class="err">AX</span><span class="p">)</span>

  <span class="c1">; return p</span>
  <span class="err">MOVQ</span>    <span class="err">CX</span><span class="p">,</span> <span class="err">AX</span>
  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">0x58</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>There’s a lot going on in this function, but most of it is a mix of Go not being great at register allocation, and lots of <em>write barriers</em>.</p> <p>A write barrier is a mechanism for synchronizing ordinary user code with the GC. Go generates code for one any time a non-pointer-free type is stored. For example, writing to a <code class="language-plaintext highlighter-rouge">**int</code>, <code class="language-plaintext highlighter-rouge">*string</code>, or <code class="language-plaintext highlighter-rouge">*[]int</code> requires a write barrier.</p> <p>Write barriers are implemented as follows:</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">runtime.writeBarrier</code> is checked, which determines whether the write barrier is necessary, which is only when the GC is in the mark phase. Otherwise the branch is taken to skip the write barrier.</p> </li> <li> <p>A call to one of the <code class="language-plaintext highlighter-rouge">runtime.gcWriteBarrierN</code> functions happens. <code class="language-plaintext highlighter-rouge">N</code> is the number of pointers that the GC needs to be informed of.</p> </li> <li> <p>This function calls <code class="language-plaintext highlighter-rouge">runtime.gcWriteBarrier</code>, which returns a buffer onto which pointers the GC needs to now trace through should be written to.</p> </li> <li> <p>The actual store happens.</p> </li> </ol> <p>A write barrier is required for a case like the following. Consider the following code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">alloc</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This function will call <code class="language-plaintext highlighter-rouge">runtime.newobject</code> to allocate eight bytes of memory. The resulting pointer will be returned in <code class="language-plaintext highlighter-rouge">rax</code>. This function then stores <code class="language-plaintext highlighter-rouge">rax</code> into <code class="language-plaintext highlighter-rouge">n</code> and returns. If we Godbolt this function, we’ll find that it does, in fact, generate a write barrier:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="err">TEXT</span> <span class="p">x.</span><span class="err">alloc</span>
  <span class="err">CMPQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="err">R14</span><span class="p">)</span>
  <span class="err">JLS</span>     <span class="err">growStack</span>
  <span class="err">PUSHQ</span>   <span class="err">BP</span>
  <span class="err">MOVQ</span>    <span class="err">SP</span><span class="p">,</span> <span class="err">BP</span>
  <span class="err">SUBQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>

  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="err">main</span><span class="p">.</span><span class="err">n+</span><span class="m">32</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>

  <span class="c1">; new(int)</span>
  <span class="err">LEAQ</span>    <span class="nl">type:</span><span class="err">int</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">newobject</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>

  <span class="err">MOVQ</span>    <span class="err">main</span><span class="p">.</span><span class="err">n+</span><span class="m">32</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">CX</span>
  <span class="err">TESTB</span>   <span class="err">AL</span><span class="p">,</span> <span class="p">(</span><span class="err">CX</span><span class="p">)</span>

  <span class="c1">; This is the write barrier.</span>
  <span class="err">CMPL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">writeBarrier</span><span class="p">(</span><span class="err">SB</span><span class="p">),</span> <span class="err">$</span><span class="m">0</span>
  <span class="err">JEQ</span>     <span class="err">skip</span>
  <span class="err">MOVQ</span>    <span class="p">(</span><span class="err">CX</span><span class="p">),</span> <span class="err">DX</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">gcWriteBarrier2</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="p">(</span><span class="err">R11</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="err">DX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">R11</span><span class="p">)</span>
<span class="nl">skip:</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="p">(</span><span class="err">CX</span><span class="p">)</span>  <span class="c1">; The actual store.</span>

  <span class="err">ADDQ</span>    <span class="err">$</span><span class="m">16</span><span class="p">,</span> <span class="err">SP</span>
  <span class="err">POPQ</span>    <span class="err">BP</span>
  <span class="err">RET</span>

<span class="nl">growStack:</span>
  <span class="err">NOP</span>
  <span class="err">MOVQ</span>    <span class="err">AX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">)</span>
  <span class="err">CALL</span>    <span class="err">runtime</span><span class="p">.</span><span class="err">morestack_noctxt</span><span class="p">(</span><span class="err">SB</span><span class="p">)</span>
  <span class="err">MOVQ</span>    <span class="m">8</span><span class="p">(</span><span class="err">SP</span><span class="p">),</span> <span class="err">AX</span>
  <span class="err">JMP</span>     <span class="p">x.</span><span class="err">alloc</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly (Go Syntax)</div></div></div> <p>Note that two pointers get written: the pointer returned by <code class="language-plaintext highlighter-rouge">new(int)</code>, and the old value of <code class="language-plaintext highlighter-rouge">*n</code>. This ensures that regardless of where in this function the GC happens to be scanning through <code class="language-plaintext highlighter-rouge">*n</code>, it sees both values during the mark phase.</p> <p>Now, this isn’t necessary if the relevant pointers are already reachable in some other way… which is exactly the case in our arena (thanks to the <code class="language-plaintext highlighter-rouge">chunks</code> slice). So the write barrier in the fast path is redundant.</p> <p>But, how do we get rid of it? There is <code class="language-plaintext highlighter-rouge">//go:nowritebarrier</code>, but that’s not allowed outside of a list of packages allowlisted in the compiler. It also doens’t disable write barriers; it simply generates a diagnostic if any are emitted.</p> <p>But remember, write barriers only occur when storing pointer-typed memory… so we can just replace <code class="language-plaintext highlighter-rouge">next unsafe.Pointer</code> with <code class="language-plaintext highlighter-rouge">next uintptr</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="kt">uintptr</span> <span class="c">// A real pointer!</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>

  <span class="n">chunks</span> <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">wordBytes</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>

    <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">allocChunk</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>
    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">+=</span> <span class="n">size</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">go vet</code> hates this, because it doesn’t know that we’re smarter than it is. Does This make the code faster? To make it a little bit more realistic, I’ve written a separate variant of the benchmarks that hammers the GC really hard in a separate G:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GC</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}()</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The result indicates that this is a worthwhile optimization for churn-heavy contexts. Performance is much worse overall, but that’s because the GC is pre-empting everyone. The improvement seems to be on the order of 20% for very small allocations.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">#</span><span class="w"> </span>Before
<span class="go">BenchmarkArena/int/arena-48         169.09 MB/s
BenchmarkArena/int/new-48           84.73 MB/s
BenchmarkArena/[2]int/arena-48      309.40 MB/s
BenchmarkArena/[2]int/new-48        120.23 MB/s
BenchmarkArena/[64]int/arena-48     1954.16 MB/s
BenchmarkArena/[64]int/new-48       950.48 MB/s
BenchmarkArena/[1024]int/arena-48   3341.13 MB/s
BenchmarkArena/[1024]int/new-48     1413.26 MB/s

</span><span class="gp">#</span><span class="w"> </span>After
<span class="go">BenchmarkArena/int/arena-48         195.58 MB/s
BenchmarkArena/int/new-48           83.67 MB/s
BenchmarkArena/[2]int/arena-48      352.49 MB/s
BenchmarkArena/[2]int/new-48        120.13 MB/s
BenchmarkArena/[64]int/arena-48     1987.22 MB/s
BenchmarkArena/[64]int/new-48       903.78 MB/s
BenchmarkArena/[1024]int/arena-48   3342.67 MB/s
BenchmarkArena/[1024]int/new-48     1439.99 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <h3 id="cutting-out-the-heap-entirely"><a href="#cutting-out-the-heap-entirely">Cutting Out The Heap Entirely</a></h3> <p>Another source of slowdown is the fact that any time we allocate from the heap, it’s forced to eagerly clear the huge allocated chunk every time, because it contains pointers. If you profile this code, a ton of time is spent in <code class="language-plaintext highlighter-rouge">runtime.memclrNoHeapPointers</code>. Because the chunks of memory we allocate are always of a specific size, we can use an array of <code class="language-plaintext highlighter-rouge">sync.Pool</code>s to amortize the cost of allocating and clearing chunks.</p> <p>First, we need an entry in this array of pools, one for each size of memory we allocate. Then, we need to set a finalizer on the arena to reclaim its memory once we’re done. Finally, we can change the contract of <code class="language-plaintext highlighter-rouge">Alloc</code> to require the caller to clear the value for us, and change <code class="language-plaintext highlighter-rouge">New</code> take a value as its argument:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="n">Allocator</span><span class="p">,</span> <span class="n">v</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>What’s nice about this is that it avoids having to clear the value if a non-zero value would be allocated to it instead.</p> <p>Putting this all together, it would look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">pools</span> <span class="p">[</span><span class="m">64</span><span class="p">]</span><span class="n">sync</span><span class="o">.</span><span class="n">Pool</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">pools</span> <span class="p">{</span>
    <span class="n">pools</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">New</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="n">any</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
        <span class="p">{</span>
          <span class="n">Name</span><span class="o">:</span> <span class="s">"A"</span><span class="p">,</span>
          <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
        <span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"P"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()},</span>
      <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="c">// If this is the first chunk allocated, set a finalizer.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">SetFinalizer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">Arena</span><span class="p">)</span><span class="o">.</span><span class="n">finalize</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Place the returned chunk at the offset in a.chunks that</span>
  <span class="c">// corresponds to its log, so we can identify its size easily</span>
  <span class="c">// in the loop above.</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">log</span><span class="o">+</span><span class="m">1</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">finalize</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">log</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="n">words</span> <span class="o">:=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">log</span>
    <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// Make sure that we don't leak the arena.</span>

    <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>How does this perform?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48        1260.73 MB/s
BenchmarkArena/int/new-48          712.94 MB/s
BenchmarkArena/[2]int/arena-48     2457.27 MB/s
BenchmarkArena/[2]int/new-48       1167.57 MB/s
BenchmarkArena/[64]int/arena-48    4491.49 MB/s
BenchmarkArena/[64]int/new-48      6800.76 MB/s
BenchmarkArena/[1024]int/arena-48  3992.32 MB/s
BenchmarkArena/[1024]int/new-48    4320.65 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>Well. That’s a surprise. It does much better for small allocations, but it made really big allocations worse! It’s not immediately clear to me why this is, but note that <code class="language-plaintext highlighter-rouge">new</code> also got <em>much</em> faster, which tells me that because the allocations from the arena are longer-lived, the GC behaves somewhat differently, causing some of the cost from allocating really large things with <code class="language-plaintext highlighter-rouge">new</code> to be amortized.</p> <p>Whether this optimization makes sense would require some profiling. An alternative is to manually manage arena re-use, by adding a very unsafe <code class="language-plaintext highlighter-rouge">Reset()</code> function that causes the arena to behave as if it was just constructed, but <em>keeping all of its allocated chunks</em>. This is analogous to reslicing to zero: <code class="language-plaintext highlighter-rouge">x = x[:0]</code>.</p> <p>This is very unsafe because it can lead to the same memory being allocated twice: this is <em>only</em> ok if the memory is not re-used.</p> <p>Implementing this is very simple.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">log</span> <span class="p">{</span>
    <span class="c">// If we've already allocated a chunk of this size in a previous arena</span>
    <span class="c">// generation, return it.</span>
    <span class="c">//</span>
    <span class="c">// This relies on the fact that an arena never tries to allocate the same</span>
    <span class="c">// size of chunk twice between calls to Reset().</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="c">// ... snip ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Then, if we modify our arena benchmark to take advantage of this…</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">b</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"arena"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">b</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">Arena</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">b</span><span class="o">.</span><span class="n">Loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>  <span class="c">// Important!</span>
    <span class="k">for</span> <span class="k">range</span> <span class="n">runs</span> <span class="p">{</span>
      <span class="n">sink</span> <span class="o">=</span> <span class="n">arena</span><span class="o">.</span><span class="n">New</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">a</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>What does the performance look like now?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">BenchmarkArena/int/arena-48         2376.01 MB/s
BenchmarkArena/int/new-48           377.64 MB/s
BenchmarkArena/[2]int/arena-48      4314.98 MB/s
BenchmarkArena/[2]int/new-48        530.62 MB/s
BenchmarkArena/[64]int/arena-48     10496.49 MB/s
BenchmarkArena/[64]int/new-48       3959.85 MB/s
BenchmarkArena/[1024]int/arena-48   9735.19 MB/s
BenchmarkArena/[1024]int/new-48     6160.73 MB/s</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Console</div></div></div> <p>That’s a massive improvement! There’s a couple of reasons this is faster. First, it doesn’t require waiting for the GC to collect old arenas to make their memory get reused. Second, the fast path is <em>very</em> fast with no synchronization.</p> <p>On the flipside, this is very dangerous: arena re-use needs to be carefully managed, because you can wind up with unique pointers that aren’t.</p> <h3 id="realloc"><a href="#realloc">Realloc</a></h3> <p>Go does not offer an easy mechanism to “reallocate” an allocation, as with <code class="language-plaintext highlighter-rouge">realloc()</code> in C. This is because it has no mechanism for freeing pointers explicitly, which is necessary for a reallocation abstraction.</p> <p>But we already don’t care about safety, so we can offer reallocation on our arena. Now, the reallocation we can offer is quite primitive: if a chunk happens to be the most recent one allocated, we can grow it. Otherwise we just allocate a new chunk and don’t free the old one.</p> <p>This makes it possible to implement “arena slices” that can be constructed by appending, which will not trigger reallocation on slice growth as long as nothing else gets put on the arena.</p> <p><code class="language-plaintext highlighter-rouge">Realloc</code> would look something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Realloc</span><span class="p">(</span>
  <span class="n">ptr</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span>
  <span class="n">oldSize</span><span class="p">,</span> <span class="n">newSize</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">,</span>
<span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">wordBytes</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">oldSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldSize</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="n">newSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">newSize</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>

  <span class="k">if</span> <span class="n">newSize</span> <span class="o">&lt;=</span> <span class="n">oldSize</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ptr</span>
  <span class="p">}</span>

  <span class="c">// Check if this is the most recent allocation. If it is,</span>
  <span class="c">// we can grow in-place.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">-</span> <span class="n">oldSize</span> <span class="o">==</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Check if we have enough space available for the</span>
    <span class="c">// requisite extra space.</span>
    <span class="n">need</span> <span class="o">:=</span> <span class="p">(</span><span class="n">newSize</span> <span class="o">-</span> <span class="n">oldSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">wordBytes</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">need</span> <span class="p">{</span>
      <span class="c">// Grow in-place.</span>
      <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">need</span>
      <span class="k">return</span> <span class="n">ptr</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c">// Can't grow in place, allocate new memory and copy to it.</span>
  <span class="nb">new</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
  <span class="nb">copy</span><span class="p">(</span>
    <span class="n">unsafe</span><span class="o">.</span><span class="n">Slice</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nb">new</span><span class="p">),</span> <span class="n">newSize</span><span class="p">),</span>
    <span class="n">unsafe</span><span class="o">.</span><span class="n">Slice</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">oldSize</span><span class="p">),</span>
  <span class="p">)</span>

  <span class="k">return</span> <span class="nb">new</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Then, whenever we append to our arena slice, we can call <code class="language-plaintext highlighter-rouge">a.Realloc()</code> to grow it. However, this does not work if the slice’s base pointer is not the original address returned by <code class="language-plaintext highlighter-rouge">Alloc</code> or <code class="language-plaintext highlighter-rouge">Realloc</code>. It is an exercise for the reader to:</p> <ol> <li> <p>Implement a <code class="language-plaintext highlighter-rouge">Slice[T]</code> type that uses an arena for allocation.</p> </li> <li> <p>Make this work for any value of <code class="language-plaintext highlighter-rouge">ptr</code> within the most recent allocation, not just the base offset. This requires extra book-keeping.</p> </li> </ol> <h2 id="all-together"><a href="#all-together">All Together</a></h2> <p>Here is the entirety of the code that we have developed, not including the reallocation function above.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">arena</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"math/bits"</span>
  <span class="s">"reflect"</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">New</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">,</span> <span class="n">v</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span><span class="n">T</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">Alloc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Arena</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">next</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
  <span class="n">left</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">uintptr</span>
  <span class="n">chunks</span>    <span class="p">[]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="n">maxAlign</span> <span class="kt">uintptr</span> <span class="o">=</span> <span class="m">8</span> <span class="c">// Depends on target, this is for 64-bit.</span>
  <span class="n">minWords</span> <span class="kt">uintptr</span> <span class="o">=</span> <span class="m">8</span>
<span class="p">)</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="c">// First, round the size up to the alignment of every object in the arena.</span>
  <span class="n">mask</span> <span class="o">:=</span> <span class="n">maxAlign</span> <span class="o">-</span> <span class="m">1</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="n">mask</span>
  <span class="c">// Then, replace the size with the size in pointer-sized words. This does not</span>
  <span class="c">// result in any loss of size, since size is now a multiple of the uintptr</span>
  <span class="c">// size.</span>
  <span class="n">words</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">maxAlign</span>

  <span class="c">// Next, check if we have enough space left for this chunk. If there isn't,</span>
  <span class="c">// we need to grow.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="p">{</span>
    <span class="c">// Pick whichever is largest: the minimum allocation size, twice the last</span>
    <span class="c">// allocation, or the next power of two after words.</span>
    <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">minWords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="o">*</span><span class="m">2</span><span class="p">,</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">allocChunk</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nb">cap</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span>

    <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Allocate the chunk by incrementing the pointer.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">words</span>

  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="nb">cap</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">pools</span> <span class="p">[</span><span class="m">64</span><span class="p">]</span><span class="n">sync</span><span class="o">.</span><span class="n">Pool</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">pools</span> <span class="p">{</span>
    <span class="n">pools</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">New</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="n">any</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
        <span class="p">{</span>
          <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
          <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
        <span class="p">},</span>
        <span class="p">{</span> <span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()</span> <span class="p">},</span>
      <span class="p">}))</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">log</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="c">// If this is the first chunk allocated, set a finalizer.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">SetFinalizer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">Arena</span><span class="p">)</span><span class="o">.</span><span class="n">finalize</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Place the returned chunk at the offset in a.chunks that</span>
  <span class="c">// corresponds to its log, so we can identify its size easily</span>
  <span class="c">// in the loop above.</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">log</span><span class="o">+</span><span class="m">1</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">finalize</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">log</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="n">words</span> <span class="o">:=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">log</span>
    <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// Make sure that we don't leak the arena.</span>

    <span class="n">pools</span><span class="p">[</span><span class="n">log</span><span class="p">]</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">nextPow2</span><span class="p">(</span><span class="n">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="o">.</span><span class="n">Len</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>There are other optimizations that we could make here that I haven’t discussed. For example, arenas could be re-used; once an arena is done, it could be “reset” and placed into a <code class="language-plaintext highlighter-rouge">sync.Pool</code>. This arena would not need to go into the GC to request new chunks, re-using the ones previously allocated (and potentially saving on the cost of zeroing memory over and over again).</p> <p>I did say that this relies very heavily on Go’s internal implementation details. Whats the odds that they get broken in the future? Well, the requirement that allocations know their shape is forced by the existence of <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code>, and the requirement that a pointer into any part of an allocation keeps the whole thing alive essentially comes from slices being both sliceable and mutable; once a slice escapes to the heap (and thus multiple goroutines) coordinating copies for shrinking a slice would require much more complexity than the current write barrier implementation.</p> <p>And in my opinion, it’s pretty safe to say that Hyrum’s Law has us covered here. ;)</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:goub" role="doc-endnote"> <p>Go <em>does</em> have some UB. For example, Go assumes that a G’s stack is never read or written to by any other G, except by the GC across a write barrier.</p> <p>That said, what UB does exist is very, very difficult to trip on purpose. <a href="#fnref:goub" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:g" role="doc-endnote"> <p>I almost exclusively refer to goroutines as Gs here, since it makes it easy to refer to Ps and Ms as needed. See <a href="https://go.dev/src/runtime/HACKING#scheduler-structures">https://go.dev/src/runtime/HACKING#scheduler-structures</a>. <a href="#fnref:g" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:ptr-bits-endian" role="doc-endnote"> <p>The pointer bits are in big endian order, so the first bit in left-to-right order corresponds to the first word. <a href="#fnref:ptr-bits-endian" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:itab" role="doc-endnote"> <p>The “itab”, or interface table part of an interface value is not managed by the GC; it is allocated in persistent memory, so even though it is a pointer, it is not a pointer the GC needs to care about. <a href="#fnref:itab" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:hchan" role="doc-endnote"> <p>Internal implementation of the <code class="language-plaintext highlighter-rouge">chan T</code> type, which is implemented as a <code class="language-plaintext highlighter-rouge">*runtime.hchan</code>. See <a href="https://cs.opensource.google/go/go/+/master:src/runtime/chan.go;l=34;drc=a204ed53d907c3b325e3c2bdd6f847a8f97e90d9">https://cs.opensource.google/go/go/+/master:src/runtime/chan.go;l=34;drc=a204ed53d907c3b325e3c2bdd6f847a8f97e90d9</a>. <a href="#fnref:hchan" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:type-cache" role="doc-endnote"> <p>This can be made better by caching the <code class="language-plaintext highlighter-rouge">reflect.Type</code>s, but that is only a very slight improvement on the order of 1% speedup. Most of the slowdown is because Go is a bit more eager about zeroing allocations of values that contain pointers.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">var</span> <span class="n">types</span> <span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Pre-allocate the whole array. There aren't that many powers</span>
  <span class="c">// of two. Don't need to go beyond 1&lt;&lt;61, since that's about as</span>
  <span class="c">// large of an allocation as Go will service (trying to create</span>
  <span class="c">// a larger array will panic).</span>
  <span class="n">types</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span> <span class="m">61</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">types</span> <span class="p">{</span>
    <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">StructField</span><span class="p">{</span>
      <span class="p">{</span>
        <span class="n">Name</span><span class="o">:</span> <span class="s">"X0"</span><span class="p">,</span>
        <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="kt">uintptr</span><span class="p">]()),</span>
      <span class="p">},</span>
      <span class="p">{</span> <span class="n">Name</span><span class="o">:</span> <span class="s">"X1"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeFor</span><span class="p">[</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">]()</span> <span class="p">},</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span> <span class="n">allocChunk</span><span class="p">(</span><span class="n">words</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
  <span class="n">log</span> <span class="o">:=</span> <span class="n">bits</span><span class="o">.</span><span class="n">TrailingZeros</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
  <span class="n">chunk</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">log</span><span class="p">])</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="p">()</span>

  <span class="c">// Offset to the end of the chunk, and write a to it.</span>
  <span class="n">end</span> <span class="o">:=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">words</span> <span class="o">*</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
  <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">Arena</span><span class="p">)(</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>

  <span class="k">return</span> <span class="n">chunk</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>However, with this in place, we can be assured that property (3) now holds, so it’s perfectly safe to place arena pointers into arena-allocated memory, so long as it’s across the same arena. <a href="#fnref:type-cache" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Miguel Young de la Sota</name></author><category term="dark-arts"/><category term="pointers"/><category term="go"/><summary type="html"><![CDATA[Even though I am a C++ programmer at heart, Go fascinates me for none of the reasons you think. Go has made several interesting design decisions:]]></summary></entry><entry><title type="html">Protobuf Tip #2: Compress Your Protos!</title><link href="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/15/protobuf-tip-2/" rel="alternate" type="text/html" title="Protobuf Tip #2: Compress Your Protos!"/><published>2025-04-15T00:00:00-07:00</published><updated>2025-04-15T00:00:00-07:00</updated><id>https://mcyoung.xyz/https://mcyoung.xyz/2025/04/15/protobuf-tip-2</id><content type="html" xml:base="https://mcyoung.xyz/https://mcyoung.xyz/2025/04/15/protobuf-tip-2/"><![CDATA[<p><em>As a matter of fact, when compression technology came along, we thought the future in 1996 was about voice. We got it wrong. It is about voice, video, and data, and that is what we have today on these cell phones. –Steve Buyer</em></p> <p>TL;DR: Compression is everywhere: CDNs, HTTP servers, even in RPC frameworks like Connect. This pervasiveness means that wire size tradeoffs matter less than they used to twenty years ago, when Protobuf was designed.</p> <blockquote> <p>I’m editing a series of best practice pieces on Protobuf, a language that I work on which has lots of evil corner-cases.These are shorter than what I typically post here, but I think it fits with what you, dear reader, come to this blog for. These tips are also posted on the <a href="https://buf.build/blog/totw-2-compress-protos">buf.build blog</a>.</p> </blockquote> <h2 id="varints-from-1998"><a href="#varints-from-1998">Varints from 1998</a></h2> <p>Protobuf’s wire format is intended to be relatively small. It makes use of <em>variable-width integers</em> so that smaller values take up less space on the wire. Fixed width integers might be larger on the wire, but often have faster decoding times.</p> <p>But what if I told you that doesn’t matter?</p> <p>See, most internet traffic is compressed. Bandwidth is precious, and CDN operators don’t want to waste time sending big blobs full of zeros. There are many compression algorithms available, but the state of the art for HTTP requests (which dominates much of global internet traffic) is <a href="https://en.wikipedia.org/wiki/Brotli">Brotli</a>, an algorithm developed at Google in 2013 and standardized in IETF <a href="https://datatracker.ietf.org/doc/html/rfc7932">RFC7932</a> in 2016. There is a very good chance that this article was delivered to your web browser as a Brotli-compressed blob.</p> <h2 id="using-compression"><a href="#using-compression">Using Compression</a></h2> <p>How compression is applied in your case will vary, but both Connect RPC and gRPC support native compression. For example, Connect has an API for injecting compression providers: <a href="https://pkg.go.dev/connectrpc.com/connect#WithCompression">https://pkg.go.dev/connectrpc.com/connect#WithCompression</a>.</p> <p>Connect uses <code class="language-plaintext highlighter-rouge">gzip</code> by default, which uses the DEFLATE compression algorithm. Providing your own compression algorithm (such as Brotli) is pretty simple, as shown by <a href="https://github.com/mattrobenolt/connect-brotli/blob/921ee0236bcd2d66827590c6890bb850e56516ad/connect_brotli.go">this third-party package</a>.</p> <p>Other services may compress for you transparently. Any competent CDN will likely use Brotli (or <code class="language-plaintext highlighter-rouge">gzip</code> or <code class="language-plaintext highlighter-rouge">zlib</code>, but probably Brotli) to compress any files it serves for you. (In fact, JavaScript and HTML minimization can often be rendered irrelevant by HTTP compression, too.)</p> <p>It’s important to remember that Protobuf predates pervasive compression: if it didn’t, it would almost certainly not use variable-width integers for anything. It only uses them because they offer a primitive form of compression in exchange for being slower to decode. If that tradeoff was eliminated, Protobuf would almost certainly only use fixed-width integers on the wire.</p> <h2 id="how-good-is-it-really"><a href="#how-good-is-it-really">How Good Is It Really?</a></h2> <p>Let’s do some apples-to-apples comparisons. Consider the following Protobuf type.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
	<span class="k">repeated</span> <span class="kt">int32</span> <span class="na">varints</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">repeated</span> <span class="kt">sfixed32</span> <span class="na">fixeds</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protobuf</div></div></div> <p>There are two fields that contain essentially the same data, which can be encoded in four different ways: as old-style repeated fields, as packed fields, and the integers can be encoded as varints or fixed32 values.</p> <p>Using <a href="https://github.com/protocolbuffers/protoscope">Protoscope</a>, we can create some data that exercises these four cases:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># a.pb, repeated varint
</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">2</span>
<span class="mi">1</span><span class="p">:</span> <span class="mi">3</span>
<span class="c1"># ...
</span>
<span class="c1"># b.pb, packed varint
</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
  <span class="c1"># ...
</span><span class="p">}</span>

<span class="c1"># c.pb, repeated fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="n">i32</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="n">i32</span>

<span class="c1"># d.pb, packed fixed32
</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
  <span class="mi">1</span><span class="n">i32</span> <span class="mi">2</span><span class="n">i32</span> <span class="mi">3</span><span class="n">i32</span>
  <span class="c1"># ...
</span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Protoscope</div></div></div> <p>Each blob contains the integers from 1 to 1000 encoded in different ways. I’ll compress each one using gzip, zlib, and Brotli, using their default compression levels, and arrange their sizes, in bytes, in the table below.</p> <table> <thead> <tr> <th>File</th> <th>Uncompressed</th> <th><code class="language-plaintext highlighter-rouge">gzip</code> (DEFLATE)</th> <th><code class="language-plaintext highlighter-rouge">zlib</code></th> <th>Brotli</th> </tr> </thead> <tbody> <tr> <td>a.pb</td> <td>2875</td> <td>1899</td> <td>1878</td> <td>1094</td> </tr> <tr> <td>b.pb</td> <td>1877</td> <td>1534</td> <td>1524</td> <td>885</td> </tr> <tr> <td>c.pb</td> <td>5005</td> <td>1577</td> <td>1567</td> <td>1140</td> </tr> <tr> <td>d.pb</td> <td>4007</td> <td>1440</td> <td>1916</td> <td>1140</td> </tr> </tbody> </table> <p>Compression achieves incredible results: Brotli manages to get all of the files down to around 1.1 kB, except for the packed varints, which it gets about 250 bytes smaller! Of course, that’s only because most of the values in that repeated field are small. If the values range from 100000 to 101000, b.pb and d.pb are 3006 and 4007 bytes respectively (see that d.pb’s size is unchanged!), but when compressed with brotli, the lead for b.pb starts to disappear: 1039 bytes vs. 1163 bytes. Now it’s only 120 bytes smaller.</p> <h2 id="are-varints-still-better"><a href="#are-varints-still-better">Are Varints Still Better?</a></h2> <p>Applying compression can often have similar results to replacing everything with varints, but not exactly: using a varint will likely always be slightly smaller, at least when using state-of-the-art compression like Brotli. But you can pretty much always assume you <em>will</em> be using compression, such as to compress HTTP headers and other ancillary content in your request. Compression is generic and highly optimized—it applies to all data, regardless of schema, and is often far more optimized than application-level codecs like those in a Protobuf library.</p> <p>Not to mention, you should definitely be compressing any large data blobs you’re storing on disk, too!</p> <p>As a result, you can usually disregard many encoded size concerns when making tradeoffs in designing a Protobuf type. Fixed integer types will decode faster, so if decoding speed is important to you, and you’re worried about the size on the wire, don’t. It’s almost certainly already taken care of at a different layer of the stack.</p>]]></content><author><name>Miguel Young de la Sota</name></author><category term="protobuf-tips"/><summary type="html"><![CDATA[As a matter of fact, when compression technology came along, we thought the future in 1996 was about voice. We got it wrong. It is about voice, video, and data, and that is what we have today on these cell phones. –Steve Buyer]]></summary></entry></feed>