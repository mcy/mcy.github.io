<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> The Rust Calling Convention We Deserve &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="The Rust Calling Convention We Deserve &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/calling-convention-04eff0c6b00d89e8041f91f2dd6af487ea2e3cc0.png"> <meta property="og:title" content="The Rust Calling Convention We Deserve &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/calling-convention-04eff0c6b00d89e8041f91f2dd6af487ea2e3cc0.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2024/04/17/calling-convention/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2024-04-17 • 3689 words • 30 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2024/04/17/calling-convention/"> The Rust Calling Convention We Deserve </a></h1> </div> <div class="post"> <p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified0- calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>However, we are too conservative. We get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>Not only does clang produce patently <em>bad</em> code for passing things by value, but it also knows how to do it better, if you request a standard calling convention! We could be generating <em>way</em> better code than Clang, but we don’t!</p> <p>Hereforth, I will describe how to do it.</p> <h3 id="-zcallconv"><a href="#-zcallconv"><code class="language-plaintext highlighter-rouge">-Zcallconv</code></a></h3> <p>Let’s suppose that we keep the current calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code><sup id="fnref:just-use-extern-c" role="doc-noteref"><a href="#fn:just-use-extern-c" class="footnote" rel="footnote">1</a></sup>, but we add a flag <code class="language-plaintext highlighter-rouge">-Zcallconv</code> that sets the calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code> when compiling a crate. The supported values will be <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> for the current one, and <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for the one we’re going to design. We could even let <code class="language-plaintext highlighter-rouge">-O</code> set <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> automatically.</p> <p>Why keep the old calling convention? Although I did sweep debugability under the rug, one nice property <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> will not have is that it does not place arguments in the C ABI order, which means that a reader replying on the “Diana’s silk dress cost $89” mnemonic on x86 will get fairly confused.</p> <p>I am also assuming we may not even support <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for some targets, like WASM, where there is no concept of “registers” and “spilling”. It may not even make sense to enable it for for debug builds, because it will produce much worse code with optimizations turned off.</p> <p>There is also a mild wrinkle with function pointers, and <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code> blocks. Because this flag is per-crate, even though functions can advertise which version of <code class="language-plaintext highlighter-rouge">extern "Rust"</code> they use, function pointers have no such luxury. However, calling through a function pointer is slow and rare, so we can simply force them to use <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. We can generate a shim to translate calling conventions as needed.</p> <p>Similarly, we can, in principle, call any Rust function like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">secret_call</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">my_func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">my_func</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this mechanism can only be used to call unmangled symbols. Thus, we can simply force <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> symbols to use the legacy calling convention.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following procedure.</p> <ol> <li> <p>First, determine, for a given target triple, the maximum number of values that can be passed “by register”. I will explain how to do this below.</p> </li> <li> <p>Decide how to pass the return value. It will either fit in the output registers, or it will need to be returned “by reference”, in which case we pass an extra <code class="language-plaintext highlighter-rouge">ptr</code> argument to the function (tagged with the <code class="language-plaintext highlighter-rouge">sret</code> attribute) and the actual return value of the function is that pointer.</p> </li> <li> <p>Decide which arguments that have been passed by value need to be demoted to being passed by reference. This will be a heuristic, but generally will be approximately “arguments larger than the by-register space”. For example, on x86, this comes out to 176 bytes.</p> </li> <li> <p>Decide which arguments get passed by register, so as to maximize register space usage. This problem is NP-hard (it’s the knapsack problem) so it will require a heuristic. All other arguments are passed on the stack.</p> </li> <li> <p>Generate the function signature in LLVM IR. This will be all of the arguments that are passed by register encoded as various non-aggregates, such as <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">ptr</code>, <code class="language-plaintext highlighter-rouge">double</code>, and <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>. What valid choices are for said non-aggregates depends on the target, but the above are what you will generally get on a 64-bit architecture. Arguments passed on the stack will follow the “register inputs”.</p> </li> <li> <p>Generate a function prologue. This is code to decode each Rust-level argument from the register inputs, so that there are <code class="language-plaintext highlighter-rouge">%ssa</code> values corresponding to those that would be present when using <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This allows us to generate the same code for the body of the function regardless of calling convention. Redundant decoding code will be eliminated by DCE passes.</p> </li> <li> <p>Generate a function exit block. This is a block that contains a single <code class="language-plaintext highlighter-rouge">phi</code> instruction for the return type as it would be for <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This block will encode it into the requisite output format and then <code class="language-plaintext highlighter-rouge">ret</code> as appropriate. All exit paths through the function should <code class="language-plaintext highlighter-rouge">br</code> to this block instead of <code class="language-plaintext highlighter-rouge">ret</code>-ing.</p> </li> <li> <p>If a non-polymorphic, non-inline function may have its address taken (as a function pointer), either because it is exported out of the crate or the crate takes a function pointer to it, generate a shim that uses <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> and immediately tail-calls the real implementation. This is necessary to preserve function pointer equality.</p> </li> </ol> <p>The main upshot here is that we need to cook up heuristics for figuring out what goes in registers (since we allow reordering arguments to get better throughput). This is equivalent to the knapsack problem; knapsack heuristics are beyond the scope of this article. This should happen early enough that this information can be stuffed into <code class="language-plaintext highlighter-rouge">rmeta</code> to avoid needing to recompute it. We may want to use different, faster heuristics depending on <code class="language-plaintext highlighter-rouge">-Copt-level</code>. Note that correctness requires that we forbid linking code generated by multiple different Rust compilers, which is already the case, since Rust breaks ABI from release to release.</p> <h3 id="what-is-llvm-willing-to-do"><a href="#what-is-llvm-willing-to-do">What Is LLVM Willing to Do?</a></h3> <p>Assuming we do that, how do we actually get LLVM to pass things in the way we want it to? We need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of<sup id="fnref:doubles-and-vectors" role="doc-noteref"><a href="#fn:doubles-and-vectors" class="footnote" rel="footnote">2</a></sup>).</p> <p>The above values are for x86<sup id="fnref:official-support" role="doc-noteref"><a href="#fn:official-support" class="footnote" rel="footnote">3</a></sup>. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>I recommend that <em>every function</em> have the same number of by-register arguments. So on x86, EVERY <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> function’s signature should look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">declare</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span> <span class="vg">@my_func</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span><span class="p">,</span>
  <span class="c1">; other args...</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When passing pointers, the appropriate <code class="language-plaintext highlighter-rouge">i64</code>s should be replaced by <code class="language-plaintext highlighter-rouge">ptr</code>, and when passing <code class="language-plaintext highlighter-rouge">double</code>s, they replace <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>s.</p> <p>But you’re probably saying, “Miguel, that’s crazy! Most functions don’t pass 176 bytes!” And you’d be right, if not for the magic of LLVM’s very well-specified <code class="language-plaintext highlighter-rouge">poison</code> semantics.</p> <p>We can get away with not doing extra work if every argument we do not use is passed <code class="language-plaintext highlighter-rouge">poison</code>. Because <code class="language-plaintext highlighter-rouge">poison</code> is equal to “the most convenient possible value at the present moment”, when LLVM sees <code class="language-plaintext highlighter-rouge">poison</code> passed into a function via register, it decides that the most convenient value is “whatever happens to be in the register already”, and so it doesn’t have to touch that register!</p> <p>For example, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we would generate the following code.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; This is a -Zcallconv=fast-style function.</span>
<span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@load_rcx</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%load</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%load</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="nv">%1</span><span class="p">,</span>     <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span>  <span class="n">rax</span>
  <span class="n">mov</span>   <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span>  <span class="n">malloc</span>
  <span class="n">mov</span>   <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>  <span class="n">load_rcx</span>
  <span class="n">add</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">pop</span>   <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any proscribed way. And as we see, <code class="language-plaintext highlighter-rouge">load_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into the other thirteen registers compiles down to nothing<sup id="fnref:requires-opt" role="doc-noteref"><a href="#fn:requires-opt" class="footnote" rel="footnote">4</a></sup>, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, it is not total. In an ideal world, the same registers are used for input and output, to allow easier pipelining of calls without introducing extra register traffic. This is true on ARM and RISC-V, but not x86. However, because register ordering is merely a suggestion for us, we can choose to allocate the return registers in whatever order we want. For example, we can pretend the order registers should be allocated in is <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code> for inputs, and <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rax</code> for outputs.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%sq</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%sq</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">ARM Assembly</div></div></div> </div> <h3 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h3> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>First, return values. This is relatively straightforward, since there is only one value to pass. The amount of data we need to return is <em>not</em> the size of the struct. For example, <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code> measures 32 bytes wide. However, eight of those bytes are padding! We do not need to preserve padding when returning by value, so we can flatten the struct into <code class="language-plaintext highlighter-rouge">(u64, u32, u64, u32)</code> and sort by size into <code class="language-plaintext highlighter-rouge">(u64, u64, u32, u32)</code>. This has no padding and is 24 bytes wide, which fits into the three return registers LLVM gives us on x86. We define the <em>effective size</em> of a type to be the number of non-<code class="language-plaintext highlighter-rouge">undef</code> bits it occupies. For <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code>, this is 192 bits, since it excludes the padding. For <code class="language-plaintext highlighter-rouge">bool</code>, this is one. For <code class="language-plaintext highlighter-rouge">char</code> this is technically 21, but it’s simpler to treat <code class="language-plaintext highlighter-rouge">char</code> as an alias for <code class="language-plaintext highlighter-rouge">u32</code>.</p> <p>The reason for counting bits this way is that it permits significant compaction. For example, returning a struct full of bools can simply bit-pack the bools into a single register.</p> <p>So, a return value is converted to a by-ref return if its effective size is smaller than the output register space (on x86, this is three integer registers and four SSE registers, so we get 88 bytes total, or 704 bits).</p> <p>Argument registers are much harder, because we hit the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, which is NP-hard. The following relatively naive heuristic is where I would start, but it can be made infinitely smarter over time.</p> <p>First, demote to by-ref any argument whose effective size is larget than the total by-register input space (on x86, 176 bytes or 1408 bits). This means we get a pointer argument instead. This is beneficial to do first, since a single pointer might pack better than the huge struct.</p> <p>Enums should be replaced by the appropriate discriminant-union pair. For example, <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> is, internally, <code class="language-plaintext highlighter-rouge">(union { i32, () }, i1)</code>, while <code class="language-plaintext highlighter-rouge">Option&lt;Option&lt;i32&gt;&gt;</code> is <code class="language-plaintext highlighter-rouge">(union { i32, (), () }, i2)</code>. Using a small non-power-of-two integer improves our ability to pack things, since enum discriminants are often quite tiny.</p> <p>Next, we need to handle unions. Because mucking about with unions’ uninitialized bits behind our backs is allowed, we need to either pass it as an array of <code class="language-plaintext highlighter-rouge">u8</code>, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">5</a></sup>.</p> <p>Now, we can proceed to flatten everything. All of the converted arguments are flattened into their most primitive components: pointers, integers, floats, and bools. Every field should be no larger than the smallest argument register; this may require splitting large types such as <code class="language-plaintext highlighter-rouge">u128</code> or <code class="language-plaintext highlighter-rouge">f64</code>.</p> <p>This big list of primitives is next sorted by effective size, from smallest to largest. We take the largest prefix of this that will fit in the available register space; everything else goes on the stack.</p> <p>If part of a Rust-level input is sent to the stack in this way, and that part is larger than a small multiple of the pointer size (e.g., 2x), it is demoted to being passed by pointer-on-the-stack, to minimize memory traffic. Everything else is passed directly on the stack in the order those inputs were before the sort. This helps keep regions that need to be copied relatively contiguous, to minimize calls to <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>The things we choose to pass in registers are allocated to registers in reverse size order, so e.g. first 64-bit things, then 32-bit things, etc. This is the same layout algorithm that <code class="language-plaintext highlighter-rouge">repr(Rust)</code> structs use to move all the padding into the tail. Once we get to the <code class="language-plaintext highlighter-rouge">bool</code>s, those are bit-packed, 64 to a register.</p> <p>Here’s a relatively complicated example. My Rust function is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Context</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_thing</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">6</span><span class="p">],</span>
                <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">op_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">op_count</span> <span class="p">{</span>
    <span class="n">context</span><span class="nf">.check</span><span class="p">(</span><span class="n">op_count</span><span class="p">,</span> <span class="n">options</span><span class="py">.colorize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">code</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">suf</span><span class="p">))</span> <span class="o">=</span> <span class="n">name</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">suf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="s">"idk"</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The codegen for this function is quite complex, so I’ll only cover the prologue and epilogue. After sorting and flattening, our raw argument LLVM types are something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nl">gprs:</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm0:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm1:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Everything fits in registers! So, what does the LLVM function look like on x86?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@do_thing</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="c1">; Unused.</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">; First, unpack all the primitives.</span>
  <span class="nv">%r9.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%r9.1.i64</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span> <span class="m">32</span>
  <span class="nv">%r9.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9.1.i64</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%xmm0.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm0.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm0.2</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%xmm0.3</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span>
  <span class="nv">%xmm1.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm1.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.1.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.1.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.2.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%xmm1.1.2</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.2.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.3.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%xmm1.1.3</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.3.i32</span> <span class="k">to</span> <span class="kt">i1</span>

  <span class="c1">; Next, reassemble them into concrete values as needed.</span>
  <span class="nv">%op_count.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%op_count</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%op_count.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%context.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%context</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="nv">%context.0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%name.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%name</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="nv">%name.0</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%code.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.0</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.1</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.0</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%code.3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.2</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%code.4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.3</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.2</span><span class="p">,</span> <span class="m">4</span>
  <span class="nv">%code</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.4</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.3</span><span class="p">,</span> <span class="m">5</span>
  <span class="nv">%options.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm1.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%options.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%options.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.2</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%options</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.2</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.3</span><span class="p">,</span> <span class="m">3</span>

  <span class="c1">; Codegen as usual.</span>
  <span class="c1">; ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Above, <code class="language-plaintext highlighter-rouge">!dbg</code> metadata for the argument values should be attached to the instruction that actually materializes it. This ensures that gdb does something halfway intelligent when you ask it to print argument values.</p> <p>On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what returns <em>could</em> look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does)! When we’re generating the ABI that all callers will see (for <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code>), we can look at the function body. This means that a crate can advertise the <em>precise</em> ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABIs. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it.</p> <p>Another example: suppose that we know that an <code class="language-plaintext highlighter-rouge">&amp;T</code> argument is not retained (a question the borrow checker can answer at this point in the compiler) and is never converted to a raw pointer (or written to memory a raw pointer is taken of, etc). We also know that <code class="language-plaintext highlighter-rouge">T</code> is fairly small, and <code class="language-plaintext highlighter-rouge">T: Freeze</code>. Then, we can replace the reference with the pointee directly, passed by value.</p> <p>The most obvious candidates for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is a step further. We might know that some arguments are hotter than others, which might cause them to be prioritized in the register allocation order.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find really frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. But <code class="language-plaintext highlighter-rouge">-Zcallconv</code> is intended to only be used with optimizations turned on, so I don’t think this is a meaningful complaint. Nor do I think the project’s Goodhartization of compilation time as a metric is healthy… but I do not think this is ultimately a relevant drawback.</p> <p>I, unfortunately, do not have the spare time to dive into fixing rustc’s ABI code, but I do know LLVM really well, and I know that this is a place where Rust has a low bus factor. For that reason, I am happy to provide the Rust compiler team expert knowledge on getting LLVM to do the right thing in service of making optimized code faster.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:just-use-extern-c" role="doc-endnote"> <p>Or just switch it to the codepath for <code class="language-plaintext highlighter-rouge">extern "C"</code> or <code class="language-plaintext highlighter-rouge">extern "fastcall"</code> since those are clearly better. We will always need to know how to generate code for the non-<code class="language-plaintext highlighter-rouge">extern "Rust"</code> calling conventions. <a href="#fnref:just-use-extern-c" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:doubles-and-vectors" role="doc-endnote"> <p>It’s Complicated. Passing a <code class="language-plaintext highlighter-rouge">double</code> burns a whole <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code> slot. This seems bad, but it can be beneficial since keeping a <code class="language-plaintext highlighter-rouge">double</code> in vector registers reduces register traffic, since usually, fp instructions use the vector registers (or the fp registers shadow the vector registers, like on ARM). <a href="#fnref:doubles-and-vectors" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:official-support" role="doc-endnote"> <p>On the one hand, you might say this “extended calling convention” isn’t an explicitly supported part of LLVM’s <code class="language-plaintext highlighter-rouge">ccc</code> calling convention. On the other hand, <a href="hyrumslaw.com">Hyrum’s Law</a> cuts both ways: Rust is big enough of an LLVM user that LLVM cannot simply miscompile all Rust programs at this point, and the IR I propose Rust emits is extremely reasonable.</p> <p>If Rust causes LLVM to misbehave, that’s an LLVM bug, and we should fix LLVM bugs, not work around them. <a href="#fnref:official-support" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-opt" role="doc-endnote"> <p>Only on <code class="language-plaintext highlighter-rouge">-O1</code> or higher, bizarrely. At <code class="language-plaintext highlighter-rouge">-O0</code>, LLVM decides that all of the <code class="language-plaintext highlighter-rouge">poison</code>s must have the same value, so it copies a bunch of registers around needlessly. This seems like a bug? <a href="#fnref:requires-opt" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> <li> <span class="post-meta">2024-12-10</span> / <h6 style="display:inline"><a href="/2024/12/10/json-sucks/">Nobody Gets Fired for Picking JSON, but Maybe They Should?</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2024-04-17 • 3689 words • 30 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <h1><a href="/2024/04/17/calling-convention/"> The Rust Calling Convention We Deserve </a></h1> </div> <div class="post"> <p>I will often say that the so-called “C ABI” is a very bad one, and a relatively unimaginative one when it comes to passing complicated types effectively. A lot of people ask me “ok, what would you use instead”, and I just point them to the <a href="https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md">Go register ABI</a>, but it seems most people have trouble filling in the gaps of what I mean. This article explains what I mean in detail.</p> <p>I have discussed <a href="https://mcyoung.xyz//2021/11/09/assembly-1/#the-calling-convention">calling conventions</a> in the past, but as a reminder: the <em>calling convention</em> is the part of the ABI that concerns itself with how to pass arguments to and from a function, and how to actually call a function. This includes which registers arguments go in, which registers values are returned out of, what function prologues/epilogues look like, how unwinding works, etc.</p> <p>This particular post is primarily about x86, but I intend to be reasonably generic (so that what I’ve written applies just as well to ARM, RISC-V, etc). I will assume a general familiarity with x86 assembly, LLVM IR, and Rust (but not rustc’s internals).</p> <h2 id="the-problem"><a href="#the-problem">The Problem</a></h2> <p>Today, like many other natively compiled languages, Rust defines an unspecified0- calling convention that lets it call functions however it likes. In practice, Rust lowers to LLVM’s built-in C calling convention, which LLVM’s prologue/epilogue codegen generates calls for.</p> <p>Rust is fairly conservative: it tries to generate LLVM function signatures that Clang could have plausibly generated. This has two significant benefits:</p> <ol> <li> <p>Good probability debuggers won’t choke on it. This is not a concern on Linux, though, because DWARF is very general and does not bake-in the Linux C ABI. We will concern ourselves only with ELF-based systems and assume that debuggability is a nonissue.</p> </li> <li> <p>It is less likely to tickle LLVM bugs due to using ABI codegen that Clang does not exercise. I think that if Rust tickles LLVM bugs, we should actually fix them (a very small number of rustc contributors do in fact do this).</p> </li> </ol> <p>However, we are too conservative. We get terrible codegen for simple functions:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">arr</code> is 12 bytes wide, so you’d think it would be passed in registers, but no! It is passed by pointer! Rust is actually <em>more</em> conservative than what the Linux C ABI mandates, because it actually passes the <code class="language-plaintext highlighter-rouge">[i32; 3]</code> in registers when <code class="language-plaintext highlighter-rouge">extern "C"</code> is requested.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">extract</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">extract:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">shr</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>The array is passed in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code>, with the <code class="language-plaintext highlighter-rouge">i32</code>s packed into registers. The function moves <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rax</code>, the output register, and shifts the upper half down.</p> <p>Not only does clang produce patently <em>bad</em> code for passing things by value, but it also knows how to do it better, if you request a standard calling convention! We could be generating <em>way</em> better code than Clang, but we don’t!</p> <p>Hereforth, I will describe how to do it.</p> <h3 id="-zcallconv"><a href="#-zcallconv"><code class="language-plaintext highlighter-rouge">-Zcallconv</code></a></h3> <p>Let’s suppose that we keep the current calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code><sup id="fnref:just-use-extern-c" role="doc-noteref"><a href="#fn:just-use-extern-c" class="footnote" rel="footnote">1</a></sup>, but we add a flag <code class="language-plaintext highlighter-rouge">-Zcallconv</code> that sets the calling convention for <code class="language-plaintext highlighter-rouge">extern "Rust"</code> when compiling a crate. The supported values will be <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> for the current one, and <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for the one we’re going to design. We could even let <code class="language-plaintext highlighter-rouge">-O</code> set <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> automatically.</p> <p>Why keep the old calling convention? Although I did sweep debugability under the rug, one nice property <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> will not have is that it does not place arguments in the C ABI order, which means that a reader replying on the “Diana’s silk dress cost $89” mnemonic on x86 will get fairly confused.</p> <p>I am also assuming we may not even support <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> for some targets, like WASM, where there is no concept of “registers” and “spilling”. It may not even make sense to enable it for for debug builds, because it will produce much worse code with optimizations turned off.</p> <p>There is also a mild wrinkle with function pointers, and <code class="language-plaintext highlighter-rouge">extern "Rust" {}</code> blocks. Because this flag is per-crate, even though functions can advertise which version of <code class="language-plaintext highlighter-rouge">extern "Rust"</code> they use, function pointers have no such luxury. However, calling through a function pointer is slow and rare, so we can simply force them to use <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. We can generate a shim to translate calling conventions as needed.</p> <p>Similarly, we can, in principle, call any Rust function like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">secret_call</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">my_func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">my_func</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this mechanism can only be used to call unmangled symbols. Thus, we can simply force <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> symbols to use the legacy calling convention.</p> <h2 id="bending-llvm-to-our-will"><a href="#bending-llvm-to-our-will">Bending LLVM to Our Will</a></h2> <p>In an ideal world, LLVM would provide a way for us to specify the calling convention directly. E.g., this argument goes in that register, this return goes in that one, etc. Unfortunately, adding a calling convention to LLVM requires writing a bunch of C++.</p> <p>However, we can get away with specifying our own calling convention by following the following procedure.</p> <ol> <li> <p>First, determine, for a given target triple, the maximum number of values that can be passed “by register”. I will explain how to do this below.</p> </li> <li> <p>Decide how to pass the return value. It will either fit in the output registers, or it will need to be returned “by reference”, in which case we pass an extra <code class="language-plaintext highlighter-rouge">ptr</code> argument to the function (tagged with the <code class="language-plaintext highlighter-rouge">sret</code> attribute) and the actual return value of the function is that pointer.</p> </li> <li> <p>Decide which arguments that have been passed by value need to be demoted to being passed by reference. This will be a heuristic, but generally will be approximately “arguments larger than the by-register space”. For example, on x86, this comes out to 176 bytes.</p> </li> <li> <p>Decide which arguments get passed by register, so as to maximize register space usage. This problem is NP-hard (it’s the knapsack problem) so it will require a heuristic. All other arguments are passed on the stack.</p> </li> <li> <p>Generate the function signature in LLVM IR. This will be all of the arguments that are passed by register encoded as various non-aggregates, such as <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">ptr</code>, <code class="language-plaintext highlighter-rouge">double</code>, and <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>. What valid choices are for said non-aggregates depends on the target, but the above are what you will generally get on a 64-bit architecture. Arguments passed on the stack will follow the “register inputs”.</p> </li> <li> <p>Generate a function prologue. This is code to decode each Rust-level argument from the register inputs, so that there are <code class="language-plaintext highlighter-rouge">%ssa</code> values corresponding to those that would be present when using <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This allows us to generate the same code for the body of the function regardless of calling convention. Redundant decoding code will be eliminated by DCE passes.</p> </li> <li> <p>Generate a function exit block. This is a block that contains a single <code class="language-plaintext highlighter-rouge">phi</code> instruction for the return type as it would be for <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code>. This block will encode it into the requisite output format and then <code class="language-plaintext highlighter-rouge">ret</code> as appropriate. All exit paths through the function should <code class="language-plaintext highlighter-rouge">br</code> to this block instead of <code class="language-plaintext highlighter-rouge">ret</code>-ing.</p> </li> <li> <p>If a non-polymorphic, non-inline function may have its address taken (as a function pointer), either because it is exported out of the crate or the crate takes a function pointer to it, generate a shim that uses <code class="language-plaintext highlighter-rouge">-Zcallconv=legacy</code> and immediately tail-calls the real implementation. This is necessary to preserve function pointer equality.</p> </li> </ol> <p>The main upshot here is that we need to cook up heuristics for figuring out what goes in registers (since we allow reordering arguments to get better throughput). This is equivalent to the knapsack problem; knapsack heuristics are beyond the scope of this article. This should happen early enough that this information can be stuffed into <code class="language-plaintext highlighter-rouge">rmeta</code> to avoid needing to recompute it. We may want to use different, faster heuristics depending on <code class="language-plaintext highlighter-rouge">-Copt-level</code>. Note that correctness requires that we forbid linking code generated by multiple different Rust compilers, which is already the case, since Rust breaks ABI from release to release.</p> <h3 id="what-is-llvm-willing-to-do"><a href="#what-is-llvm-willing-to-do">What Is LLVM Willing to Do?</a></h3> <p>Assuming we do that, how do we actually get LLVM to pass things in the way we want it to? We need to determine what the largest “by register” passing LLVM will permit is. The following LLVM program is useful for determining this on a particular version of LLVM:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%InputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%InputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%InputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">8</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="nv">%OutputI</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">]</span>
<span class="nv">%OutputF</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">0</span> <span class="p">x</span> <span class="kt">double</span><span class="p">]</span>
<span class="nv">%OutputV</span> <span class="p">=</span> <span class="k">type</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@inputs</span><span class="p">({</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">4096</span> <span class="p">x</span> <span class="kt">i8</span><span class="p">]</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="p">{</span> <span class="nv">%InputI</span><span class="p">,</span> <span class="nv">%InputF</span><span class="p">,</span> <span class="nv">%InputV</span> <span class="p">}</span> <span class="nv">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%p</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="nv">%Output</span> <span class="p">=</span> <span class="p">{</span> <span class="nv">%OutputI</span><span class="p">,</span> <span class="nv">%OutputF</span><span class="p">,</span> <span class="nv">%OutputV</span> <span class="p">}</span>
<span class="vg">@gOutput</span> <span class="p">=</span> <span class="k">constant</span> <span class="nv">%Output</span> <span class="k">zeroinitializer</span>
<span class="k">define</span> <span class="nv">%Output</span> <span class="vg">@outputs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%Output</span><span class="p">,</span> <span class="err">ptr</span> <span class="vg">@gOutput</span>
  <span class="k">ret</span> <span class="nv">%Output</span> <span class="nv">%1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When you pass an aggregate by-value to an LLVM function, LLVM will attempt to “explode” that aggregate into as many registers as possible. There are distinct register classes on different systems. For example, on both x86 and ARM, floats and vectors share the same register class (kind of<sup id="fnref:doubles-and-vectors" role="doc-noteref"><a href="#fn:doubles-and-vectors" class="footnote" rel="footnote">2</a></sup>).</p> <p>The above values are for x86<sup id="fnref:official-support" role="doc-noteref"><a href="#fn:official-support" class="footnote" rel="footnote">3</a></sup>. LLVM will pass six integers and eight SSE vectors by register, and return half as many (3 and 4) by register. Increasing any of the values generates extra loads and stores that indicate LLVM gave up and passed arguments on the stack.</p> <p>The values for <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux</code> are 8 integers and 8 vectors for both inputs and outputs, respectively.</p> <p>This is the maximum number of registers we get to play with for each class. Anything extra gets passed on the stack.</p> <p>I recommend that <em>every function</em> have the same number of by-register arguments. So on x86, EVERY <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code> function’s signature should look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">declare</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span> <span class="vg">@my_func</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span><span class="p">,</span>
  <span class="c1">; other args...</span>
<span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>When passing pointers, the appropriate <code class="language-plaintext highlighter-rouge">i64</code>s should be replaced by <code class="language-plaintext highlighter-rouge">ptr</code>, and when passing <code class="language-plaintext highlighter-rouge">double</code>s, they replace <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code>s.</p> <p>But you’re probably saying, “Miguel, that’s crazy! Most functions don’t pass 176 bytes!” And you’d be right, if not for the magic of LLVM’s very well-specified <code class="language-plaintext highlighter-rouge">poison</code> semantics.</p> <p>We can get away with not doing extra work if every argument we do not use is passed <code class="language-plaintext highlighter-rouge">poison</code>. Because <code class="language-plaintext highlighter-rouge">poison</code> is equal to “the most convenient possible value at the present moment”, when LLVM sees <code class="language-plaintext highlighter-rouge">poison</code> passed into a function via register, it decides that the most convenient value is “whatever happens to be in the register already”, and so it doesn’t have to touch that register!</p> <p>For example, if we wanted to pass a pointer via <code class="language-plaintext highlighter-rouge">rcx</code>, we would generate the following code.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="c1">; This is a -Zcallconv=fast-style function.</span>
<span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@load_rcx</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%load</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%load</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span>
<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">()</span> <span class="p">{</span>
  <span class="nv">%1</span> <span class="p">=</span> <span class="k">call</span> <span class="err">ptr</span> <span class="vg">@malloc</span><span class="p">(</span><span class="kt">i64</span> <span class="m">8</span><span class="p">)</span>
  <span class="k">store</span> <span class="kt">i64</span> <span class="m">42</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%1</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@by_rcx</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="err">ptr</span> <span class="nv">%1</span><span class="p">,</span>     <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span> <span class="m">42</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%4</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">by_rcx:</span>
  <span class="n">mov</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span>  <span class="n">rax</span>
  <span class="n">mov</span>   <span class="n">edi</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">call</span>  <span class="n">malloc</span>
  <span class="n">mov</span>   <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="mi">42</span>
  <span class="n">mov</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>  <span class="n">load_rcx</span>
  <span class="n">add</span>   <span class="n">rax</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">pop</span>   <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>It is perfectly legal to pass poison to a function, if it does not interact with the poisoned argument in any proscribed way. And as we see, <code class="language-plaintext highlighter-rouge">load_rcx()</code> receives its pointer argument in <code class="language-plaintext highlighter-rouge">rcx</code>, whereas <code class="language-plaintext highlighter-rouge">make_the_call()</code> takes no penalty in setting up the call: loading poison into the other thirteen registers compiles down to nothing<sup id="fnref:requires-opt" role="doc-noteref"><a href="#fn:requires-opt" class="footnote" rel="footnote">4</a></sup>, so it only needs to load the pointer returned by malloc into <code class="language-plaintext highlighter-rouge">rcx</code>.</p> <p>This gives us almost total control over argument passing; unfortunately, it is not total. In an ideal world, the same registers are used for input and output, to allow easier pipelining of calls without introducing extra register traffic. This is true on ARM and RISC-V, but not x86. However, because register ordering is merely a suggestion for us, we can choose to allocate the return registers in whatever order we want. For example, we can pretend the order registers should be allocated in is <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code> for inputs, and <code class="language-plaintext highlighter-rouge">rdx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rax</code> for outputs.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nv">%sq</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nv">%out</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="nv">%Out</span> <span class="err">poison</span><span class="p">,</span>
                      <span class="kt">i64</span> <span class="nv">%sq</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">ret</span> <span class="nv">%Out</span> <span class="nv">%out</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="nv">%4</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%Out</span> <span class="vg">@square</span><span class="p">(</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%3</span><span class="p">,</span>
    <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span>
    <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="err">poison</span><span class="p">)</span>
  <span class="nv">%5</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%Out</span> <span class="nv">%4</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%5</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">imul</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">push</span> <span class="n">rax</span>
  <span class="n">mov</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">call</span> <span class="n">square</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">pop</span> <span class="n">rcx</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p><code class="language-plaintext highlighter-rouge">square</code> generates extremely simple code: the input and output register is <code class="language-plaintext highlighter-rouge">rdi</code>, so no extra register traffic needs to be generated. Similarly, when we effectively do <code class="language-plaintext highlighter-rouge">@square(@square(%0))</code>, there is no setup between the functions. This is similar to code seen on aarch64, which uses the same register sequence for input and output. We can see that the “naive” version of this IR produces the exact same code on aarch64 for this reason.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="k">define</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">mul</span> <span class="kt">i64</span> <span class="nv">%0</span><span class="p">,</span> <span class="nv">%0</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%2</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">i64</span> <span class="vg">@make_the_call</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%0</span><span class="p">)</span>
  <span class="nv">%3</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">i64</span> <span class="vg">@square</span><span class="p">(</span><span class="kt">i64</span> <span class="nv">%2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">i64</span> <span class="nv">%3</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square:</span>
  <span class="n">mul</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span>
  <span class="n">ret</span>

<span class="n">make_the_call</span><span class="o">:</span>
  <span class="n">str</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
  <span class="n">bl</span> <span class="n">square</span>
  <span class="n">ldr</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>
  <span class="n">b</span> <span class="n">square</span>  <span class="c1">// Tail call.</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">ARM Assembly</div></div></div> </div> <h3 id="rust-structs-and-unions"><a href="#rust-structs-and-unions">Rust Structs and Unions</a></h3> <p>Now that we’ve established total control on how registers are assigned, we can turn towards maximizing use of these registers in Rust.</p> <p>For simplicity, we can assume that rustc has already processed the users’s types into basic aggregates and unions; no enums here! We then have to make some decisions about which portions of the arguments to allocate to registers.</p> <p>First, return values. This is relatively straightforward, since there is only one value to pass. The amount of data we need to return is <em>not</em> the size of the struct. For example, <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code> measures 32 bytes wide. However, eight of those bytes are padding! We do not need to preserve padding when returning by value, so we can flatten the struct into <code class="language-plaintext highlighter-rouge">(u64, u32, u64, u32)</code> and sort by size into <code class="language-plaintext highlighter-rouge">(u64, u64, u32, u32)</code>. This has no padding and is 24 bytes wide, which fits into the three return registers LLVM gives us on x86. We define the <em>effective size</em> of a type to be the number of non-<code class="language-plaintext highlighter-rouge">undef</code> bits it occupies. For <code class="language-plaintext highlighter-rouge">[(u64, u32); 2]</code>, this is 192 bits, since it excludes the padding. For <code class="language-plaintext highlighter-rouge">bool</code>, this is one. For <code class="language-plaintext highlighter-rouge">char</code> this is technically 21, but it’s simpler to treat <code class="language-plaintext highlighter-rouge">char</code> as an alias for <code class="language-plaintext highlighter-rouge">u32</code>.</p> <p>The reason for counting bits this way is that it permits significant compaction. For example, returning a struct full of bools can simply bit-pack the bools into a single register.</p> <p>So, a return value is converted to a by-ref return if its effective size is smaller than the output register space (on x86, this is three integer registers and four SSE registers, so we get 88 bytes total, or 704 bits).</p> <p>Argument registers are much harder, because we hit the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, which is NP-hard. The following relatively naive heuristic is where I would start, but it can be made infinitely smarter over time.</p> <p>First, demote to by-ref any argument whose effective size is larget than the total by-register input space (on x86, 176 bytes or 1408 bits). This means we get a pointer argument instead. This is beneficial to do first, since a single pointer might pack better than the huge struct.</p> <p>Enums should be replaced by the appropriate discriminant-union pair. For example, <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code> is, internally, <code class="language-plaintext highlighter-rouge">(union { i32, () }, i1)</code>, while <code class="language-plaintext highlighter-rouge">Option&lt;Option&lt;i32&gt;&gt;</code> is <code class="language-plaintext highlighter-rouge">(union { i32, (), () }, i2)</code>. Using a small non-power-of-two integer improves our ability to pack things, since enum discriminants are often quite tiny.</p> <p>Next, we need to handle unions. Because mucking about with unions’ uninitialized bits behind our backs is allowed, we need to either pass it as an array of <code class="language-plaintext highlighter-rouge">u8</code>, unless it only has a single non-empty variant, in which case it is replaced with that variant<sup id="fnref:union-optimization" role="doc-noteref"><a href="#fn:union-optimization" class="footnote" rel="footnote">5</a></sup>.</p> <p>Now, we can proceed to flatten everything. All of the converted arguments are flattened into their most primitive components: pointers, integers, floats, and bools. Every field should be no larger than the smallest argument register; this may require splitting large types such as <code class="language-plaintext highlighter-rouge">u128</code> or <code class="language-plaintext highlighter-rouge">f64</code>.</p> <p>This big list of primitives is next sorted by effective size, from smallest to largest. We take the largest prefix of this that will fit in the available register space; everything else goes on the stack.</p> <p>If part of a Rust-level input is sent to the stack in this way, and that part is larger than a small multiple of the pointer size (e.g., 2x), it is demoted to being passed by pointer-on-the-stack, to minimize memory traffic. Everything else is passed directly on the stack in the order those inputs were before the sort. This helps keep regions that need to be copied relatively contiguous, to minimize calls to <code class="language-plaintext highlighter-rouge">memcpy</code>.</p> <p>The things we choose to pass in registers are allocated to registers in reverse size order, so e.g. first 64-bit things, then 32-bit things, etc. This is the same layout algorithm that <code class="language-plaintext highlighter-rouge">repr(Rust)</code> structs use to move all the padding into the tail. Once we get to the <code class="language-plaintext highlighter-rouge">bool</code>s, those are bit-packed, 64 to a register.</p> <p>Here’s a relatively complicated example. My Rust function is as follows:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Options</span> <span class="p">{</span>
  <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">verbose_debug</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">allow_spurious_failure</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">retries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Context</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">colorize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_thing</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op_count</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Context</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="p">[</span><span class="nb">char</span><span class="p">;</span> <span class="mi">6</span><span class="p">],</span>
                <span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">op_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">op_count</span> <span class="p">{</span>
    <span class="n">context</span><span class="nf">.check</span><span class="p">(</span><span class="n">op_count</span><span class="p">,</span> <span class="n">options</span><span class="py">.colorize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">code</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">suf</span><span class="p">))</span> <span class="o">=</span> <span class="n">name</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">suf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="s">"idk"</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The codegen for this function is quite complex, so I’ll only cover the prologue and epilogue. After sorting and flattening, our raw argument LLVM types are something like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nl">gprs:</span> <span class="kt">i64</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm0:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i32</span>
<span class="nl">xmm1:</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Everything fits in registers! So, what does the LLVM function look like on x86?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><span class="nv">%Out</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{[</span><span class="m">3</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="p">x</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;]}</span>
<span class="k">define</span> <span class="nv">%Out</span> <span class="vg">@do_thing</span><span class="p">(</span>
  <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span>
  <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span>
  <span class="c1">; Unused.</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm2</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm3</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm4</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm5</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm6</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="p">x</span> <span class="kt">i64</span><span class="p">&gt;</span> <span class="nv">%xmm7</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">; First, unpack all the primitives.</span>
  <span class="nv">%r9.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%r9.1.i64</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i64</span> <span class="nv">%r9</span><span class="p">,</span> <span class="m">32</span>
  <span class="nv">%r9.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%r9.1.i64</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="nv">%xmm0.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm0.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm0.2</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">2</span>
  <span class="nv">%xmm0.3</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm0</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">3</span>
  <span class="nv">%xmm1.0</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">0</span>
  <span class="nv">%xmm1.1</span> <span class="p">=</span> <span class="k">extractelement</span> <span class="p">&lt;</span><span class="m">4</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">&gt;</span> <span class="nv">%xmm1</span><span class="p">,</span> <span class="kt">i32</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.0</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.1.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%xmm1.1.1</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.1.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.2.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%xmm1.1.2</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.2.i32</span> <span class="k">to</span> <span class="kt">i1</span>
  <span class="nv">%xmm1.1.3.i32</span> <span class="p">=</span> <span class="k">lshr</span> <span class="kt">i32</span> <span class="nv">%xmm1.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%xmm1.1.3</span> <span class="p">=</span> <span class="k">trunc</span> <span class="kt">i32</span> <span class="nv">%xmm1.1.3.i32</span> <span class="k">to</span> <span class="kt">i1</span>

  <span class="c1">; Next, reassemble them into concrete values as needed.</span>
  <span class="nv">%op_count.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%op_count</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i64</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%op_count.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.0</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%context.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%context</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="err">ptr</span> <span class="p">}</span> <span class="nv">%context.0</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%name.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%name</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="err">ptr</span><span class="p">,</span> <span class="kt">i64</span> <span class="p">}</span> <span class="nv">%name.0</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%r8</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%code.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.0</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%r9.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%code.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.1</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.0</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%code.3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.2</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.1</span><span class="p">,</span> <span class="m">3</span>
  <span class="nv">%code.4</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.3</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.2</span><span class="p">,</span> <span class="m">4</span>
  <span class="nv">%code</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">[</span><span class="m">6</span> <span class="p">x</span> <span class="kt">i32</span><span class="p">]</span> <span class="nv">%code.4</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm0.3</span><span class="p">,</span> <span class="m">5</span>
  <span class="nv">%options.0</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="err">poison</span><span class="p">,</span> <span class="kt">i32</span> <span class="nv">%xmm1.0</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%options.1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.0</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.1</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%options.2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.1</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.2</span><span class="p">,</span> <span class="m">2</span>
  <span class="nv">%options</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span> <span class="kt">i32</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span><span class="p">,</span> <span class="kt">i1</span> <span class="p">}</span> <span class="nv">%options.2</span><span class="p">,</span> <span class="kt">i1</span> <span class="nv">%xmm1.1.3</span><span class="p">,</span> <span class="m">3</span>

  <span class="c1">; Codegen as usual.</span>
  <span class="c1">; ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">LLVM IR</div></div></div> <p>Above, <code class="language-plaintext highlighter-rouge">!dbg</code> metadata for the argument values should be attached to the instruction that actually materializes it. This ensures that gdb does something halfway intelligent when you ask it to print argument values.</p> <p>On the other hand, in current rustc, it gives LLVM eight pointer-sized parameters, so it winds up spending all six integer registers, plus two values passed on the stack. Not great!</p> <p>This is not a complete description of what a completely over-engineered calling convention could entail: in some cases we might know that we have additional registers available (such as AVX registers on x86). There are cases where we might want to split a struct across registers and the stack.</p> <p>This also isn’t even getting into what returns <em>could</em> look like. <code class="language-plaintext highlighter-rouge">Result</code>s are often passed through several layers of functions via <code class="language-plaintext highlighter-rouge">?</code>, which can result in a lot of redundant register moves. Often, a <code class="language-plaintext highlighter-rouge">Result</code> is large enough that it doesn’t fit in registers, so each call in the <code class="language-plaintext highlighter-rouge">?</code> stack has to inspect an ok bit by loading it from memory. Instead, a <code class="language-plaintext highlighter-rouge">Result</code> return might be implemented as an out-parameter pointer for the error, with the ok variant’s payload, and the is ok bit, returned as an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>. There are some fussy details with <code class="language-plaintext highlighter-rouge">Into</code> calls via <code class="language-plaintext highlighter-rouge">?</code>, but the idea is implementable.</p> <h3 id="optimization-dependent-abi"><a href="#optimization-dependent-abi">Optimization-Dependent ABI</a></h3> <p>Now, because we’re Rust, we’ve also got a trick up our sleeve that C doesn’t (but Go does)! When we’re generating the ABI that all callers will see (for <code class="language-plaintext highlighter-rouge">-Zcallconv=fast</code>), we can look at the function body. This means that a crate can advertise the <em>precise</em> ABI (in terms of register-passing) of its functions.</p> <p>This opens the door to a more extreme optimization-based ABIs. We can start by simply throwing out unused arguments: if the function never does anything with a parameter, don’t bother spending registers on it.</p> <p>Another example: suppose that we know that an <code class="language-plaintext highlighter-rouge">&amp;T</code> argument is not retained (a question the borrow checker can answer at this point in the compiler) and is never converted to a raw pointer (or written to memory a raw pointer is taken of, etc). We also know that <code class="language-plaintext highlighter-rouge">T</code> is fairly small, and <code class="language-plaintext highlighter-rouge">T: Freeze</code>. Then, we can replace the reference with the pointee directly, passed by value.</p> <p>The most obvious candidates for this is APIs like <code class="language-plaintext highlighter-rouge">HashMap::get()</code>. If the key is something like an <code class="language-plaintext highlighter-rouge">i32</code>, we need to spill that integer to the stack and pass a pointer to it! This results in unnecessary, avoidable memory traffic.</p> <p>Profile-guided ABI is a step further. We might know that some arguments are hotter than others, which might cause them to be prioritized in the register allocation order.</p> <p>You could even imagine a case where a function takes a very large struct by reference, but three <code class="language-plaintext highlighter-rouge">i64</code> fields are very hot, so the caller can <em>preload</em> those fields, passing them both by register <em>and</em> via the pointer to the large struct. The callee does not see additional cost: it had to issue those loads anyway. However, the caller probably has those values in registers already, which avoids some memory traffic.</p> <p>Instrumentation profiles may even indicate that it makes sense to duplicate whole functions, which are identical except for their ABIs. Maybe they take different arguments by register to avoid costly spills.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>This is a bit more advanced (and ranty) than my usual writing, but this is an aspect of Rust that I find really frustrating. We could be doing <em>so much better</em> than C++ ever can (because of their ABI constraints). None of this is new ideas; this is <em>literally</em> how Go does it!</p> <p>So why don’t we? Part of the reason is that ABI codegen is complex, and as I described above, LLVM gives us very few useful knobs. It’s not a friendly part of rustc, and doing things wrong can have nasty consequences for usability. The other part is a lack of expertise. As of writing, only a handful of people contributing to rustc have the necessary grasp of LLVM’s semantics (and mood swings) to emit the Right Code such that we get good codegen and don’t crash LLVM.</p> <p>Another reason is compilation time. The more complicated the function signatures, the more prologue/epilogue code we have to generate that LLVM has to chew on. But <code class="language-plaintext highlighter-rouge">-Zcallconv</code> is intended to only be used with optimizations turned on, so I don’t think this is a meaningful complaint. Nor do I think the project’s Goodhartization of compilation time as a metric is healthy… but I do not think this is ultimately a relevant drawback.</p> <p>I, unfortunately, do not have the spare time to dive into fixing rustc’s ABI code, but I do know LLVM really well, and I know that this is a place where Rust has a low bus factor. For that reason, I am happy to provide the Rust compiler team expert knowledge on getting LLVM to do the right thing in service of making optimized code faster.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:just-use-extern-c" role="doc-endnote"> <p>Or just switch it to the codepath for <code class="language-plaintext highlighter-rouge">extern "C"</code> or <code class="language-plaintext highlighter-rouge">extern "fastcall"</code> since those are clearly better. We will always need to know how to generate code for the non-<code class="language-plaintext highlighter-rouge">extern "Rust"</code> calling conventions. <a href="#fnref:just-use-extern-c" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:doubles-and-vectors" role="doc-endnote"> <p>It’s Complicated. Passing a <code class="language-plaintext highlighter-rouge">double</code> burns a whole <code class="language-plaintext highlighter-rouge">&lt;2 x i64&gt;</code> slot. This seems bad, but it can be beneficial since keeping a <code class="language-plaintext highlighter-rouge">double</code> in vector registers reduces register traffic, since usually, fp instructions use the vector registers (or the fp registers shadow the vector registers, like on ARM). <a href="#fnref:doubles-and-vectors" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:official-support" role="doc-endnote"> <p>On the one hand, you might say this “extended calling convention” isn’t an explicitly supported part of LLVM’s <code class="language-plaintext highlighter-rouge">ccc</code> calling convention. On the other hand, <a href="hyrumslaw.com">Hyrum’s Law</a> cuts both ways: Rust is big enough of an LLVM user that LLVM cannot simply miscompile all Rust programs at this point, and the IR I propose Rust emits is extremely reasonable.</p> <p>If Rust causes LLVM to misbehave, that’s an LLVM bug, and we should fix LLVM bugs, not work around them. <a href="#fnref:official-support" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:requires-opt" role="doc-endnote"> <p>Only on <code class="language-plaintext highlighter-rouge">-O1</code> or higher, bizarrely. At <code class="language-plaintext highlighter-rouge">-O0</code>, LLVM decides that all of the <code class="language-plaintext highlighter-rouge">poison</code>s must have the same value, so it copies a bunch of registers around needlessly. This seems like a bug? <a href="#fnref:requires-opt" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:union-optimization" role="doc-endnote"> <p>There are other cases where we might want to replace a union with one of its variants: for example, there’s a lot of cases where <code class="language-plaintext highlighter-rouge">Result&lt;&amp;T, Error&gt;</code> is secretly a <code class="language-plaintext highlighter-rouge">union { ptr, u32 }</code>, in which case it should be replaced with a single <code class="language-plaintext highlighter-rouge">ptr</code>. <a href="#fnref:union-optimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> <li> <span class="post-meta">2024-12-10</span> / <h6 style="display:inline"><a href="/2024/12/10/json-sucks/">Nobody Gets Fired for Picking JSON, but Maybe They Should?</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2024 Miguel Young de la Sota </div> </div> </body> </html>