<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Nobody Gets Fired for Picking JSON, but Maybe They Should? &middot; mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Nobody Gets Fired for Picking JSON, but Maybe They Should? &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/json-sucks-9f2bb2712911cfef44d520486a5b750afbd0cbea.png"> <meta property="og:title" content="Nobody Gets Fired for Picking JSON, but Maybe They Should? &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/json-sucks-9f2bb2712911cfef44d520486a5b750afbd0cbea.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2024/12/10/json-sucks/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2024-12-10 • 2588 words • 21 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> • <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> </span> <h1><a href="/2024/12/10/json-sucks/"> Nobody Gets Fired for Picking JSON, but Maybe They Should? </a></h1> </div> <div class="post"> <p>JSON is extremely popular but deeply flawed. This article discusses the details of JSON’s design, how it’s used (and misused), and how seemingly helpful “human readability” features cause headaches instead. Crucially, you rarely find JSON-based tools (except dedicated tools like <code class="language-plaintext highlighter-rouge">jq</code>) that can safely handle arbitrary JSON documents without a schema—common corner cases can lead to data corruption!</p> <h2 id="what-is-json"><a href="#what-is-json">What is JSON?</a></h2> <p>JSON is famously simple. In fact, you can <a href="https://www.flickr.com/photos/equanimity/3763158824/in/photostream/">fit the entire grammar on the back of a business card</a>. It’s so omnipresent in REST APIs that you might assume you already know JSON quite well. It has decimal numbers, quoted strings, arrays with square brackets, and key-value maps (called “objects”) with curly braces. A JSON document consists of any of these constructs: <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">42</code>, and <code class="language-plaintext highlighter-rouge">{"foo":"bar"}</code> are all valid JSON documents.</p> <p>However, the formal definition of JSON is quite complicated. JSON is defined by the IETF document <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC8259</a> (if you don’t know what the IETF is, it’s the standards body for Internet protocols). However, it’s <em>also</em> normatively defined by <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a>, which is from ECMA, the standards body that defines JavaScript[^json.org].</p> <p>[^json.org]: Of course, some wise guy will probably want to cite <json.org>. I should underscore: <json.org> is __NOT__ a standard. It is __NOT__ normative. the documents produced by the IETF and by ECMA, which are international standards organizations that represent the industry __ARE__ normative. When a browser implementer wants to implement JSON to the letter, they go to ECMA, not to some dude's 90's ass website.</json.org></json.org></p> <p>JavaScript? Yes, JSON (JavaScript Object Notation) is closely linked with JavaScript and is, in fact, (almost) a subset of it. While JSON’s JavaScript ancestry is the main source of its quirks, several other poor design decisions add additional unforced errors.</p> <p>However, the biggest problem with JSON isn’t any specific design decision but rather the incredible diversity of parser behavior and non-conformance across and within language ecosystems. RFC8259 goes out of its way to call this out:</p> <blockquote> <p>Note, however, that ECMA-404 allows several practices that this specification recommends avoiding in the interests of maximal interoperability.</p> </blockquote> <p>The RFC makes many observations regarding interoperability elsewhere in the document. Probably the most glaring—and terrifying—is how numbers work.</p> <h2 id="everything-is-implementation-defined"><a href="#everything-is-implementation-defined">Everything is Implementation-Defined</a></h2> <p>JSON numbers are encoded in decimal, with an optional minus sign, a fractional part after a decimal point, and a scientific notation exponent. This is similar to how many programming languages define their own numeric literals.</p> <p>Presumably, JSON numbers are meant to be floats, right?</p> <p>Wrong.</p> <p>RFC8259 reveals that the answer is, unfortunately, “whatever you want.”</p> <blockquote> <p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">binary64</code> is the “standards-ese” name for the type usually known as <code class="language-plaintext highlighter-rouge">double</code> or <code class="language-plaintext highlighter-rouge">float64</code>. Floats have great dynamic range but often can’t represent exact values. For example, <code class="language-plaintext highlighter-rouge">1.1</code> isn’t representable as a float because all floats are fractions of the form <code class="language-plaintext highlighter-rouge">n / 2^m</code> for integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code>, but <code class="language-plaintext highlighter-rouge">1.1 = 11/10</code>, which has a factor of 5 in its denominator. The closest <code class="language-plaintext highlighter-rouge">float64</code> value is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">2476979795053773 / 2^51 = 1.100000000000000088817841970012523233890533447265625</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Of course, you might think to declare “all JSON values map to their closest <code class="language-plaintext highlighter-rouge">float64</code> value”. Unfortunately, this value might not be unique. For example, the value <code class="language-plaintext highlighter-rouge">900000000000.00006103515625</code> isn’t representable as a <code class="language-plaintext highlighter-rouge">float64</code>, and it’s precisely between two exact <code class="language-plaintext highlighter-rouge">float64</code> values. Depending on the rounding mode, this rounds to either or <code class="language-plaintext highlighter-rouge">900000000000</code> or <code class="language-plaintext highlighter-rouge">900000000000.0001220703125</code> .</p> <p>IEEE 754 recommends “round ties to even” as the default rounding mode, so for almost all software, the result is <code class="language-plaintext highlighter-rouge">900000000000</code>. But remember, floating-point state is a global variable implemented in hardware, and might just happen to be clobbered by some dependency that calls <code class="language-plaintext highlighter-rouge">fesetround()</code> or a similar system function.</p> <h2 id="data-loss-data-loss"><a href="#data-loss-data-loss">Data Loss! Data Loss!</a></h2> <p>You’re probably thinking, “I don’t care about such fussy precision stuff. None of my numbers have any fractional parts—and there is where you would be wrong. The <code class="language-plaintext highlighter-rouge">n</code> part of <code class="language-plaintext highlighter-rouge">n / 2^m</code> only has 53 bits available, but <code class="language-plaintext highlighter-rouge">int64</code> values fall outside of that range. This means that for very large 64-bit integers, such as randomly generated IDs, a JSON parser that converts integers into floats results in <em>data loss.</em> Go’s <code class="language-plaintext highlighter-rouge">encoding/json</code> package does this, for example.</p> <p>How often does this actually happen for randomly-generated numbers? We can do a little Monte Carlo simulation to find out.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
	<span class="s">"math/big"</span>
	<span class="s">"math/rand"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">trials</span> <span class="o">=</span> <span class="m">5</span><span class="n">_000_000</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">misses</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">err</span> <span class="n">big</span><span class="o">.</span><span class="n">Float</span>
	<span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
		<span class="n">y</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c">// Round-trip through binary64.</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
			<span class="n">misses</span><span class="o">++</span>
			<span class="n">err</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span><span class="o">.</span><span class="n">Quo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">trials</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"misses: %d/%d, avg: %f"</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">trials</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// misses: 4970572/5000000, avg: 170.638499</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>It turns out that almost all randomly distributed <code class="language-plaintext highlighter-rouge">int64</code> values are affected by round-trip data loss. Roughly, the only numbers that are safe are those with at most 16 digits (although not exactly: 9,999,999,999,999,999, for example, gets rounded up to a nice round 10 quadrillion).</p> <p>How does this affect you? Suppose you have a JSON document somewhere that includes a user ID and a transcript of their private messages with another user. Data loss due to rounding would result in the wrong user ID being associated with the private messages, which could result in leaking PII or incorrect management of privacy consent (such as GDPR requirements).</p> <p>This isn’t just about <em>your</em> user IDs, mind you. Plenty of other vendors’ IDs are nice big integers, which the JSON grammar can technically accommodate and which random tools will mangle. Some examples:</p> <ul> <li> <p>License keys: for example, Adobe uses 24 digits for <a href="https://helpx.adobe.com/x-productkb/global/invalid-revoked-serial-numbers.html">their serial numbers</a>, which may be tempting to store as an integer.</p> </li> <li> <p>Barcode IDs like the unique serial numbers of medical devices, <a href="https://www.fda.gov/medical-devices/unique-device-identification-system-udi-system/udi-basics">which are tightly regulated</a>.</p> </li> <li> <p>Visa and Mastercard credit card numbers <em>happen</em> to fit in the “safe” range for <code class="language-plaintext highlighter-rouge">binary64</code> , which may lull you into a false sense of security, since they’re so common. But not all credit cards have 16 digit numbers: <a href="https://en.wikipedia.org/wiki/Payment_card_number#Structure">some now support 19</a>.</p> </li> </ul> <p>These are pretty bad compliance consequences purely due to a data serialization format.</p> <p>This problem is avoidable with care. After all, Go can parse JSON into any arbitrary type using reflection. For example, if we replace the inner loop of the Monte Carlo simulation with something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
	<span class="k">var</span> <span class="n">v</span> <span class="k">struct</span><span class="p">{</span> <span class="n">N</span> <span class="kt">int64</span> <span class="p">}</span>
	<span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">`{"N":%d}`</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
	<span class="n">y</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">N</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
		<span class="c">// ...</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>We suddenly see that <code class="language-plaintext highlighter-rouge">x == y</code> in every trial. This is because with type information, Go’s JSON library knows exactly what the target precision is. If we were parsing to an <code class="language-plaintext highlighter-rouge">any</code> instead of to a <code class="language-plaintext highlighter-rouge">struct { N int64 }</code>, we’d be in deep trouble: the outer object would be parsed into a <code class="language-plaintext highlighter-rouge">map[string]any</code>, and the <code class="language-plaintext highlighter-rouge">N</code> field would become a <code class="language-plaintext highlighter-rouge">float64</code>.</p> <p>This means that your system probably can’t safely handle JSON documents with unknown fields. Tools like <code class="language-plaintext highlighter-rouge">jq</code> must be extremely careful about number handling to avoid data loss. This is an easy mistake for third-party tools to make.</p> <p>But again, <code class="language-plaintext highlighter-rouge">float64</code> isn’t the standard—there is no standard. Some implementations might only have 32-bit floats available, making the problem worse. Some implementations might try to be clever, using a <code class="language-plaintext highlighter-rouge">float64</code> for fractional values and an <code class="language-plaintext highlighter-rouge">int64</code> for integer values; however, this still imposes arbitrary limits on the parsed values, potentially resulting in data loss.</p> <p>Some implementations such as Python use bignums, so they appear not to have this problem. However, this can lead to a false sense of security where issues are not caught until it’s too late: some database now contains ostensibly valid but non-interoperable JSON.</p> <p>Protobuf is forced to deal with this in a pretty non-portable way. To avoid data loss, large 64-bit integers are serialized as quoted strings when serializing to JSON. So, instead of writing <code class="language-plaintext highlighter-rouge">{"foo":6574404881820635023}</code>, it emits <code class="language-plaintext highlighter-rouge">{"foo":"6574404881820635023"}</code>. This solves the data loss issue but does not work with other JSON libraries such as Go’s, producing errors like this one:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">json: cannot unmarshal string into Go struct field .N of type int64</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <h3 id="non-finite-values"><a href="#non-finite-values">Non-Finite Values</a></h3> <p>The special floating point values <code class="language-plaintext highlighter-rouge">Infinity</code>, <code class="language-plaintext highlighter-rouge">-Infinity</code>, and <code class="language-plaintext highlighter-rouge">NaN</code> are not representable: it’s the wild west as to what happens when you try to serialize the equivalent of <code class="language-plaintext highlighter-rouge">{x:1.0/0.0}</code>.</p> <ul> <li>Go refuses to serialize, citing <code class="language-plaintext highlighter-rouge">json: unsupported value: +Inf</code>.</li> <li>Protobuf serializes it as <code class="language-plaintext highlighter-rouge">{"x":"inf"}</code> (or should—it’s unclear which implementations get it right).</li> <li>JavaScript won’t even bother trying: <code class="language-plaintext highlighter-rouge">JSON.stringify({x:Infinity})</code> prints <code class="language-plaintext highlighter-rouge">{"x":null}.</code></li> <li>Python is arguably the worst offender: <code class="language-plaintext highlighter-rouge">json.dumps({"x":float("inf")})</code> prints <code class="language-plaintext highlighter-rouge">{"x":Infinity}</code>, which isn’t even valid JSON per RFC8259.</li> </ul> <p>NaN is arguably an even worse offender, because the NaN payload (yes, <a href="https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns">NaNs have a special payload</a>) is discarded when converting to <code class="language-plaintext highlighter-rouge">"nan"</code> or however your library represents it.</p> <p>Does this affect you? Well, if you’re doing anything with floats, you’re one division-by-zero or overflow away from triggering serialization errors. At best, it’s “benign” data corruption (JavaScript). At worst, when the data is partially user-controlled, it might result in crashes or unparseable output, which is the making of a DoS vector.</p> <p>In comparison, Protobuf serialization can’t fail except due to non-UTF-8 <code class="language-plaintext highlighter-rouge">string</code> fields or cyclic message references, both of which are comparatively unlikely to a NaN popping up in a calculation.</p> <p>The upshot is that all the parsers end up parsing a bunch of crazy things for the special floating-point values over time because of <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s law</a>. RFC8259 makes no effort to provide suggestions for dealing with such real-world situations beyond “tough luck, not interoperable.”</p> <h2 id="text-encodings-and-invalid-unicode"><a href="#text-encodings-and-invalid-unicode">Text Encodings and Invalid Unicode</a></h2> <p>JSON strings are relatively tame, with some marked (but good) divergence from JavaScript. Specifically, JavaScript, being a language of a certain age (along with Java), uses UTF-16 as its Unicode text encoding. Most of the world has realized this is a bad idea (it doubles the size of ASCII text, which makes up almost all of Internet traffic), so JSON uses UTF-8 instead. RFC8259 actually specifies that the whole document MUST be encoded in UTF-8.</p> <p>But when we go to read about Unicode characters in §8.2, we are disappointed: it merely says that it’s <em>really great</em> when all quoted strings consist entirely of Unicode characters, which means that unpaired surrogates are allowed. In effect, the spec merely requires that JSON strings be <a href="https://en.wikipedia.org/wiki/UTF-8#Surrogates">WTF-8</a>: UTF-8 that permits unpaired surrogates.</p> <p>What’s an unpaired surrogate? It’s any encoded Unicode 32-bit value in the range <code class="language-plaintext highlighter-rouge">U+D800</code> to <code class="language-plaintext highlighter-rouge">U+DFFF</code> , which form a gap in the Unicode codepoint range. UTF-8’s variable-length integer encoding can encode them, but their presence in a bytestream makes it invalid UTF-8. WTF-8 is UTF-8 but permitting the appearance of these values.</p> <p>So, who actually supports parsing (or serializing) these? Consider the document <code class="language-plaintext highlighter-rouge">{"x":"\udead"}</code>, which contains an unpaired surrogate, <code class="language-plaintext highlighter-rouge">U+DEAD</code>.</p> <ul> <li> <p>Go gladly deserializes AND serializes it (Go’s strings are arbitrary byte strings, not UTF-8). However, Go serializes a non-UTF-8 string such as <code class="language-plaintext highlighter-rouge">"\xff"</code> as <code class="language-plaintext highlighter-rouge">"\ufffd"</code>, having replaced the invalid byte with a <code class="language-plaintext highlighter-rouge">U+FFFD</code> replacement character (this thing: �).</p> </li> <li> <p>Most Java parsers seem to follow the same behavior as Go, but there are many different parsers available, and we’ve already learned that different JSON parsers may behave differently.</p> </li> <li> <p>JavaScript and Python similarly gladly parse unpaired surrogates, but they also serialize them back without converting them into <code class="language-plaintext highlighter-rouge">U+FFFD</code>.</p> </li> <li> <p>Different Protobuf runtimes may not handle this identically, but the reference C++ implementation (whose JSON codec I wrote!) refuses to parse unpaired surrogates.</p> </li> </ul> <p>There are other surprising pitfalls around strings: are <code class="language-plaintext highlighter-rouge">"x"</code> and <code class="language-plaintext highlighter-rouge">“\x78"</code> the same string? RFC8259 feels the need to call out that they are, for the purposes of checking that object keys are equal. The fact that they feel the need to call it out indicates that this is also a source of potential problems.</p> <h2 id="byte-strings"><a href="#byte-strings">Byte Strings</a></h2> <p>What if I don’t want to send text? A common type of byte blob to send is a cryptographic hash that identifies a document in a content-addressed blobstore, or perhaps a digital signature (an encrypted hash). JSON has no native way of representing byte strings.</p> <p>You could send a quoted string full of ASCII and <code class="language-plaintext highlighter-rouge">\xNN</code> escapes (for bytes which are not in the ASCII range), but this is wasteful in terms of bandwidth, and has serious interoperability problems (as noted above, Go actively destroys data in this case). You could also encode it as an array of JSON numbers, which is much worse for bandwidth and serialization speed.</p> <p>What everyone winds up doing, one way or another, is to rely on base64 encoding. Protobuf, for example, encodes <code class="language-plaintext highlighter-rouge">bytes</code> fields into base64 strings in JSON. This has the unfortunate side-effect of defeating JSON’s human-readable property: if the blob contains mostly ASCII, a human reader can’t tell.</p> <p>Because this isn’t part of JSON, virtually no JSON codec does this decoding for you, particularly because in a schema-less context, there’s nothing to distinguish a byte blob encoded with base64 from an actual textual string that <em>happens</em> to contain valid base64, such as an alphanumeric username.</p> <p>Compared to other problems, this is more like a paper cut, but it’s unnecessary and adds complexity and interop problems. <a href="https://en.wikipedia.org/wiki/Base64#Variants_summary_table">By the way, did you know there are multiple incompatible Base64 alphabets?</a></p> <h1 id="streaming-doesnt-work"><a href="#streaming-doesnt-work">Streaming Doesn’t Work</a></h1> <p>A less obvious problem with JSON is that it can’t be streamed. Almost all JSON documents are objects or arrays and are therefore <em>incomplete</em> until they reach the closing <code class="language-plaintext highlighter-rouge">}</code> or <code class="language-plaintext highlighter-rouge">]</code>, respectively. This means you can’t send a stream of JSON documents that form a part of a larger document without some additional protocol for combining them in post-processing.</p> <p><a href="https://jsonlines.org/">JSONL</a> is the world’s silliest spec that “solves” this problem in the simplest way possible: a JSONL document is a sequence of JSON documents separated by newlines. JSONL <em>is</em> streamable, but because it’s done in the simplest way possible, it only supports streaming a giant array. You can’t, for example, stream an object field-by-field or stream an array within that object.</p> <p>Protobuf doesn’t have this problem: in a nutshell, the Protobuf wire format is as if we removed the braces and brackets from the top-level array or object of a document, and made it so that values with the same key get merged. In the wire format, the equivalent of the JSONL document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>is automatically “merged” into the single document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w"> </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>This forms the basis of the “message merge” operation, which is intimately connected to how the wire format was designed. We’ll dive into this fundamental operation in a future article.</p> <h1 id="canonicalization-leads-to-data-loss"><a href="#canonicalization-leads-to-data-loss">Canonicalization Leads to Data Loss</a></h1> <p>Thanks to <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC7519</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC7515</a>, which define JSON Web Tokens (JWT) and JSON Web Signatures (JWS), digitally signing JSON documents is a very common operation. However, digital signatures can only sign specific byte blobs and are sensitive to things that JSON isn’t, such as whitespace and key ordering.</p> <p>This results in specifications like <a href="https://datatracker.ietf.org/doc/html/rfc8785">RFC8785</a> for <em>canonicalization</em> of JSON documents. This introduces a new avenue by which existing JSON documents, which accidentally happen to contain non-interoperable (or, thanks to non-conforming implementations such as Python’s) invalid JSON that must be manipulated and reformatted by third-party tools. RFC8785 itself references ECMA-262 (the JavaScript standard) for how to serialize numbers, meaning that it’s <em>required</em> to induce data loss for 64-bit numerical values!</p> <h1 id="is-json-fixable"><a href="#is-json-fixable">Is JSON Fixable?</a></h1> <p>Plainly? No. JSON can’t be fixed because of how extremely popular it is. Common mistakes are baked into the format. Are comments allowed? Trailing commas? Number formats? Nobody knows!</p> <p>What tools are touching your JSON? Are they aware of all of the rakes they can step on? Do they emit invalid JSON (like Python does)? How do you even begin to audit that?</p> <p>Thankfully, you don’t have to use JSON. There are alternatives—BSON, UBJSON, MessagePack, and CBOR are just a few binary formats that try to replicate JSON’s data model. Unfortunately, many of them have their own problems.</p> <p>Protobuf, however, has none of these problems, because it was <em>designed</em> to fulfill needs JSON couldn’t meet. Using a strongly-typed schema system, like Protobuf, makes all of these problems go away.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2024-12-10 • 2588 words • 21 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#parsing">#parsing</a> • <a href="https://mcyoung.xyz/tags.html#formats">#formats</a> </span> <h1><a href="/2024/12/10/json-sucks/"> Nobody Gets Fired for Picking JSON, but Maybe They Should? </a></h1> </div> <div class="post"> <p>JSON is extremely popular but deeply flawed. This article discusses the details of JSON’s design, how it’s used (and misused), and how seemingly helpful “human readability” features cause headaches instead. Crucially, you rarely find JSON-based tools (except dedicated tools like <code class="language-plaintext highlighter-rouge">jq</code>) that can safely handle arbitrary JSON documents without a schema—common corner cases can lead to data corruption!</p> <h2 id="what-is-json"><a href="#what-is-json">What is JSON?</a></h2> <p>JSON is famously simple. In fact, you can <a href="https://www.flickr.com/photos/equanimity/3763158824/in/photostream/">fit the entire grammar on the back of a business card</a>. It’s so omnipresent in REST APIs that you might assume you already know JSON quite well. It has decimal numbers, quoted strings, arrays with square brackets, and key-value maps (called “objects”) with curly braces. A JSON document consists of any of these constructs: <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">42</code>, and <code class="language-plaintext highlighter-rouge">{"foo":"bar"}</code> are all valid JSON documents.</p> <p>However, the formal definition of JSON is quite complicated. JSON is defined by the IETF document <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC8259</a> (if you don’t know what the IETF is, it’s the standards body for Internet protocols). However, it’s <em>also</em> normatively defined by <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a>, which is from ECMA, the standards body that defines JavaScript[^json.org].</p> <p>[^json.org]: Of course, some wise guy will probably want to cite <json.org>. I should underscore: <json.org> is __NOT__ a standard. It is __NOT__ normative. the documents produced by the IETF and by ECMA, which are international standards organizations that represent the industry __ARE__ normative. When a browser implementer wants to implement JSON to the letter, they go to ECMA, not to some dude's 90's ass website.</json.org></json.org></p> <p>JavaScript? Yes, JSON (JavaScript Object Notation) is closely linked with JavaScript and is, in fact, (almost) a subset of it. While JSON’s JavaScript ancestry is the main source of its quirks, several other poor design decisions add additional unforced errors.</p> <p>However, the biggest problem with JSON isn’t any specific design decision but rather the incredible diversity of parser behavior and non-conformance across and within language ecosystems. RFC8259 goes out of its way to call this out:</p> <blockquote> <p>Note, however, that ECMA-404 allows several practices that this specification recommends avoiding in the interests of maximal interoperability.</p> </blockquote> <p>The RFC makes many observations regarding interoperability elsewhere in the document. Probably the most glaring—and terrifying—is how numbers work.</p> <h2 id="everything-is-implementation-defined"><a href="#everything-is-implementation-defined">Everything is Implementation-Defined</a></h2> <p>JSON numbers are encoded in decimal, with an optional minus sign, a fractional part after a decimal point, and a scientific notation exponent. This is similar to how many programming languages define their own numeric literals.</p> <p>Presumably, JSON numbers are meant to be floats, right?</p> <p>Wrong.</p> <p>RFC8259 reveals that the answer is, unfortunately, “whatever you want.”</p> <blockquote> <p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">binary64</code> is the “standards-ese” name for the type usually known as <code class="language-plaintext highlighter-rouge">double</code> or <code class="language-plaintext highlighter-rouge">float64</code>. Floats have great dynamic range but often can’t represent exact values. For example, <code class="language-plaintext highlighter-rouge">1.1</code> isn’t representable as a float because all floats are fractions of the form <code class="language-plaintext highlighter-rouge">n / 2^m</code> for integers <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">m</code>, but <code class="language-plaintext highlighter-rouge">1.1 = 11/10</code>, which has a factor of 5 in its denominator. The closest <code class="language-plaintext highlighter-rouge">float64</code> value is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">2476979795053773 / 2^51 = 1.100000000000000088817841970012523233890533447265625</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <p>Of course, you might think to declare “all JSON values map to their closest <code class="language-plaintext highlighter-rouge">float64</code> value”. Unfortunately, this value might not be unique. For example, the value <code class="language-plaintext highlighter-rouge">900000000000.00006103515625</code> isn’t representable as a <code class="language-plaintext highlighter-rouge">float64</code>, and it’s precisely between two exact <code class="language-plaintext highlighter-rouge">float64</code> values. Depending on the rounding mode, this rounds to either or <code class="language-plaintext highlighter-rouge">900000000000</code> or <code class="language-plaintext highlighter-rouge">900000000000.0001220703125</code> .</p> <p>IEEE 754 recommends “round ties to even” as the default rounding mode, so for almost all software, the result is <code class="language-plaintext highlighter-rouge">900000000000</code>. But remember, floating-point state is a global variable implemented in hardware, and might just happen to be clobbered by some dependency that calls <code class="language-plaintext highlighter-rouge">fesetround()</code> or a similar system function.</p> <h2 id="data-loss-data-loss"><a href="#data-loss-data-loss">Data Loss! Data Loss!</a></h2> <p>You’re probably thinking, “I don’t care about such fussy precision stuff. None of my numbers have any fractional parts—and there is where you would be wrong. The <code class="language-plaintext highlighter-rouge">n</code> part of <code class="language-plaintext highlighter-rouge">n / 2^m</code> only has 53 bits available, but <code class="language-plaintext highlighter-rouge">int64</code> values fall outside of that range. This means that for very large 64-bit integers, such as randomly generated IDs, a JSON parser that converts integers into floats results in <em>data loss.</em> Go’s <code class="language-plaintext highlighter-rouge">encoding/json</code> package does this, for example.</p> <p>How often does this actually happen for randomly-generated numbers? We can do a little Monte Carlo simulation to find out.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
	<span class="s">"math/big"</span>
	<span class="s">"math/rand"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">trials</span> <span class="o">=</span> <span class="m">5</span><span class="n">_000_000</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">misses</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">err</span> <span class="n">big</span><span class="o">.</span><span class="n">Float</span>
	<span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
		<span class="n">y</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c">// Round-trip through binary64.</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
			<span class="n">misses</span><span class="o">++</span>
			<span class="n">err</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span><span class="o">.</span><span class="n">Quo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">big</span><span class="o">.</span><span class="n">NewFloat</span><span class="p">(</span><span class="n">trials</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"misses: %d/%d, avg: %f"</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">trials</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// misses: 4970572/5000000, avg: 170.638499</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>It turns out that almost all randomly distributed <code class="language-plaintext highlighter-rouge">int64</code> values are affected by round-trip data loss. Roughly, the only numbers that are safe are those with at most 16 digits (although not exactly: 9,999,999,999,999,999, for example, gets rounded up to a nice round 10 quadrillion).</p> <p>How does this affect you? Suppose you have a JSON document somewhere that includes a user ID and a transcript of their private messages with another user. Data loss due to rounding would result in the wrong user ID being associated with the private messages, which could result in leaking PII or incorrect management of privacy consent (such as GDPR requirements).</p> <p>This isn’t just about <em>your</em> user IDs, mind you. Plenty of other vendors’ IDs are nice big integers, which the JSON grammar can technically accommodate and which random tools will mangle. Some examples:</p> <ul> <li> <p>License keys: for example, Adobe uses 24 digits for <a href="https://helpx.adobe.com/x-productkb/global/invalid-revoked-serial-numbers.html">their serial numbers</a>, which may be tempting to store as an integer.</p> </li> <li> <p>Barcode IDs like the unique serial numbers of medical devices, <a href="https://www.fda.gov/medical-devices/unique-device-identification-system-udi-system/udi-basics">which are tightly regulated</a>.</p> </li> <li> <p>Visa and Mastercard credit card numbers <em>happen</em> to fit in the “safe” range for <code class="language-plaintext highlighter-rouge">binary64</code> , which may lull you into a false sense of security, since they’re so common. But not all credit cards have 16 digit numbers: <a href="https://en.wikipedia.org/wiki/Payment_card_number#Structure">some now support 19</a>.</p> </li> </ul> <p>These are pretty bad compliance consequences purely due to a data serialization format.</p> <p>This problem is avoidable with care. After all, Go can parse JSON into any arbitrary type using reflection. For example, if we replace the inner loop of the Monte Carlo simulation with something like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="k">range</span> <span class="n">trials</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Uint64</span><span class="p">())</span>
	<span class="k">var</span> <span class="n">v</span> <span class="k">struct</span><span class="p">{</span> <span class="n">N</span> <span class="kt">int64</span> <span class="p">}</span>
	<span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">`{"N":%d}`</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
	<span class="n">y</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">N</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
		<span class="c">// ...</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>We suddenly see that <code class="language-plaintext highlighter-rouge">x == y</code> in every trial. This is because with type information, Go’s JSON library knows exactly what the target precision is. If we were parsing to an <code class="language-plaintext highlighter-rouge">any</code> instead of to a <code class="language-plaintext highlighter-rouge">struct { N int64 }</code>, we’d be in deep trouble: the outer object would be parsed into a <code class="language-plaintext highlighter-rouge">map[string]any</code>, and the <code class="language-plaintext highlighter-rouge">N</code> field would become a <code class="language-plaintext highlighter-rouge">float64</code>.</p> <p>This means that your system probably can’t safely handle JSON documents with unknown fields. Tools like <code class="language-plaintext highlighter-rouge">jq</code> must be extremely careful about number handling to avoid data loss. This is an easy mistake for third-party tools to make.</p> <p>But again, <code class="language-plaintext highlighter-rouge">float64</code> isn’t the standard—there is no standard. Some implementations might only have 32-bit floats available, making the problem worse. Some implementations might try to be clever, using a <code class="language-plaintext highlighter-rouge">float64</code> for fractional values and an <code class="language-plaintext highlighter-rouge">int64</code> for integer values; however, this still imposes arbitrary limits on the parsed values, potentially resulting in data loss.</p> <p>Some implementations such as Python use bignums, so they appear not to have this problem. However, this can lead to a false sense of security where issues are not caught until it’s too late: some database now contains ostensibly valid but non-interoperable JSON.</p> <p>Protobuf is forced to deal with this in a pretty non-portable way. To avoid data loss, large 64-bit integers are serialized as quoted strings when serializing to JSON. So, instead of writing <code class="language-plaintext highlighter-rouge">{"foo":6574404881820635023}</code>, it emits <code class="language-plaintext highlighter-rouge">{"foo":"6574404881820635023"}</code>. This solves the data loss issue but does not work with other JSON libraries such as Go’s, producing errors like this one:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-text" data-lang="text">json: cannot unmarshal string into Go struct field .N of type int64</code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Plaintext</div></div></div> <h3 id="non-finite-values"><a href="#non-finite-values">Non-Finite Values</a></h3> <p>The special floating point values <code class="language-plaintext highlighter-rouge">Infinity</code>, <code class="language-plaintext highlighter-rouge">-Infinity</code>, and <code class="language-plaintext highlighter-rouge">NaN</code> are not representable: it’s the wild west as to what happens when you try to serialize the equivalent of <code class="language-plaintext highlighter-rouge">{x:1.0/0.0}</code>.</p> <ul> <li>Go refuses to serialize, citing <code class="language-plaintext highlighter-rouge">json: unsupported value: +Inf</code>.</li> <li>Protobuf serializes it as <code class="language-plaintext highlighter-rouge">{"x":"inf"}</code> (or should—it’s unclear which implementations get it right).</li> <li>JavaScript won’t even bother trying: <code class="language-plaintext highlighter-rouge">JSON.stringify({x:Infinity})</code> prints <code class="language-plaintext highlighter-rouge">{"x":null}.</code></li> <li>Python is arguably the worst offender: <code class="language-plaintext highlighter-rouge">json.dumps({"x":float("inf")})</code> prints <code class="language-plaintext highlighter-rouge">{"x":Infinity}</code>, which isn’t even valid JSON per RFC8259.</li> </ul> <p>NaN is arguably an even worse offender, because the NaN payload (yes, <a href="https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns">NaNs have a special payload</a>) is discarded when converting to <code class="language-plaintext highlighter-rouge">"nan"</code> or however your library represents it.</p> <p>Does this affect you? Well, if you’re doing anything with floats, you’re one division-by-zero or overflow away from triggering serialization errors. At best, it’s “benign” data corruption (JavaScript). At worst, when the data is partially user-controlled, it might result in crashes or unparseable output, which is the making of a DoS vector.</p> <p>In comparison, Protobuf serialization can’t fail except due to non-UTF-8 <code class="language-plaintext highlighter-rouge">string</code> fields or cyclic message references, both of which are comparatively unlikely to a NaN popping up in a calculation.</p> <p>The upshot is that all the parsers end up parsing a bunch of crazy things for the special floating-point values over time because of <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s law</a>. RFC8259 makes no effort to provide suggestions for dealing with such real-world situations beyond “tough luck, not interoperable.”</p> <h2 id="text-encodings-and-invalid-unicode"><a href="#text-encodings-and-invalid-unicode">Text Encodings and Invalid Unicode</a></h2> <p>JSON strings are relatively tame, with some marked (but good) divergence from JavaScript. Specifically, JavaScript, being a language of a certain age (along with Java), uses UTF-16 as its Unicode text encoding. Most of the world has realized this is a bad idea (it doubles the size of ASCII text, which makes up almost all of Internet traffic), so JSON uses UTF-8 instead. RFC8259 actually specifies that the whole document MUST be encoded in UTF-8.</p> <p>But when we go to read about Unicode characters in §8.2, we are disappointed: it merely says that it’s <em>really great</em> when all quoted strings consist entirely of Unicode characters, which means that unpaired surrogates are allowed. In effect, the spec merely requires that JSON strings be <a href="https://en.wikipedia.org/wiki/UTF-8#Surrogates">WTF-8</a>: UTF-8 that permits unpaired surrogates.</p> <p>What’s an unpaired surrogate? It’s any encoded Unicode 32-bit value in the range <code class="language-plaintext highlighter-rouge">U+D800</code> to <code class="language-plaintext highlighter-rouge">U+DFFF</code> , which form a gap in the Unicode codepoint range. UTF-8’s variable-length integer encoding can encode them, but their presence in a bytestream makes it invalid UTF-8. WTF-8 is UTF-8 but permitting the appearance of these values.</p> <p>So, who actually supports parsing (or serializing) these? Consider the document <code class="language-plaintext highlighter-rouge">{"x":"\udead"}</code>, which contains an unpaired surrogate, <code class="language-plaintext highlighter-rouge">U+DEAD</code>.</p> <ul> <li> <p>Go gladly deserializes AND serializes it (Go’s strings are arbitrary byte strings, not UTF-8). However, Go serializes a non-UTF-8 string such as <code class="language-plaintext highlighter-rouge">"\xff"</code> as <code class="language-plaintext highlighter-rouge">"\ufffd"</code>, having replaced the invalid byte with a <code class="language-plaintext highlighter-rouge">U+FFFD</code> replacement character (this thing: �).</p> </li> <li> <p>Most Java parsers seem to follow the same behavior as Go, but there are many different parsers available, and we’ve already learned that different JSON parsers may behave differently.</p> </li> <li> <p>JavaScript and Python similarly gladly parse unpaired surrogates, but they also serialize them back without converting them into <code class="language-plaintext highlighter-rouge">U+FFFD</code>.</p> </li> <li> <p>Different Protobuf runtimes may not handle this identically, but the reference C++ implementation (whose JSON codec I wrote!) refuses to parse unpaired surrogates.</p> </li> </ul> <p>There are other surprising pitfalls around strings: are <code class="language-plaintext highlighter-rouge">"x"</code> and <code class="language-plaintext highlighter-rouge">“\x78"</code> the same string? RFC8259 feels the need to call out that they are, for the purposes of checking that object keys are equal. The fact that they feel the need to call it out indicates that this is also a source of potential problems.</p> <h2 id="byte-strings"><a href="#byte-strings">Byte Strings</a></h2> <p>What if I don’t want to send text? A common type of byte blob to send is a cryptographic hash that identifies a document in a content-addressed blobstore, or perhaps a digital signature (an encrypted hash). JSON has no native way of representing byte strings.</p> <p>You could send a quoted string full of ASCII and <code class="language-plaintext highlighter-rouge">\xNN</code> escapes (for bytes which are not in the ASCII range), but this is wasteful in terms of bandwidth, and has serious interoperability problems (as noted above, Go actively destroys data in this case). You could also encode it as an array of JSON numbers, which is much worse for bandwidth and serialization speed.</p> <p>What everyone winds up doing, one way or another, is to rely on base64 encoding. Protobuf, for example, encodes <code class="language-plaintext highlighter-rouge">bytes</code> fields into base64 strings in JSON. This has the unfortunate side-effect of defeating JSON’s human-readable property: if the blob contains mostly ASCII, a human reader can’t tell.</p> <p>Because this isn’t part of JSON, virtually no JSON codec does this decoding for you, particularly because in a schema-less context, there’s nothing to distinguish a byte blob encoded with base64 from an actual textual string that <em>happens</em> to contain valid base64, such as an alphanumeric username.</p> <p>Compared to other problems, this is more like a paper cut, but it’s unnecessary and adds complexity and interop problems. <a href="https://en.wikipedia.org/wiki/Base64#Variants_summary_table">By the way, did you know there are multiple incompatible Base64 alphabets?</a></p> <h1 id="streaming-doesnt-work"><a href="#streaming-doesnt-work">Streaming Doesn’t Work</a></h1> <p>A less obvious problem with JSON is that it can’t be streamed. Almost all JSON documents are objects or arrays and are therefore <em>incomplete</em> until they reach the closing <code class="language-plaintext highlighter-rouge">}</code> or <code class="language-plaintext highlighter-rouge">]</code>, respectively. This means you can’t send a stream of JSON documents that form a part of a larger document without some additional protocol for combining them in post-processing.</p> <p><a href="https://jsonlines.org/">JSONL</a> is the world’s silliest spec that “solves” this problem in the simplest way possible: a JSONL document is a sequence of JSON documents separated by newlines. JSONL <em>is</em> streamable, but because it’s done in the simplest way possible, it only supports streaming a giant array. You can’t, for example, stream an object field-by-field or stream an array within that object.</p> <p>Protobuf doesn’t have this problem: in a nutshell, the Protobuf wire format is as if we removed the braces and brackets from the top-level array or object of a document, and made it so that values with the same key get merged. In the wire format, the equivalent of the JSONL document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>is automatically “merged” into the single document</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w"> </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">JSON</div></div></div> <p>This forms the basis of the “message merge” operation, which is intimately connected to how the wire format was designed. We’ll dive into this fundamental operation in a future article.</p> <h1 id="canonicalization-leads-to-data-loss"><a href="#canonicalization-leads-to-data-loss">Canonicalization Leads to Data Loss</a></h1> <p>Thanks to <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC7519</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC7515</a>, which define JSON Web Tokens (JWT) and JSON Web Signatures (JWS), digitally signing JSON documents is a very common operation. However, digital signatures can only sign specific byte blobs and are sensitive to things that JSON isn’t, such as whitespace and key ordering.</p> <p>This results in specifications like <a href="https://datatracker.ietf.org/doc/html/rfc8785">RFC8785</a> for <em>canonicalization</em> of JSON documents. This introduces a new avenue by which existing JSON documents, which accidentally happen to contain non-interoperable (or, thanks to non-conforming implementations such as Python’s) invalid JSON that must be manipulated and reformatted by third-party tools. RFC8785 itself references ECMA-262 (the JavaScript standard) for how to serialize numbers, meaning that it’s <em>required</em> to induce data loss for 64-bit numerical values!</p> <h1 id="is-json-fixable"><a href="#is-json-fixable">Is JSON Fixable?</a></h1> <p>Plainly? No. JSON can’t be fixed because of how extremely popular it is. Common mistakes are baked into the format. Are comments allowed? Trailing commas? Number formats? Nobody knows!</p> <p>What tools are touching your JSON? Are they aware of all of the rakes they can step on? Do they emit invalid JSON (like Python does)? How do you even begin to audit that?</p> <p>Thankfully, you don’t have to use JSON. There are alternatives—BSON, UBJSON, MessagePack, and CBOR are just a few binary formats that try to replicate JSON’s data model. Unfortunately, many of them have their own problems.</p> <p>Protobuf, however, has none of these problems, because it was <em>designed</em> to fulfill needs JSON couldn’t meet. Using a strongly-typed schema system, like Protobuf, makes all of these problems go away.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> <li> <span class="post-meta">2024-12-12</span> / <h6 style="display:inline"><a href="/2024/12/12/go-abi/">Things You Never Wanted To Know About Go Interfaces</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>