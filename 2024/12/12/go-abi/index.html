<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Things You Never Wanted To Know About Go Interfaces &middot; mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Things You Never Wanted To Know About Go Interfaces &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/go-abi-331aeaa90d24287e6bd06cb2df3c37a9ce2865bf.png"> <meta property="og:title" content="Things You Never Wanted To Know About Go Interfaces &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/go-abi-331aeaa90d24287e6bd06cb2df3c37a9ce2865bf.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2024/12/12/go-abi/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2024-12-12 • 2804 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/12/go-abi/"> Things You Never Wanted To Know About Go Interfaces </a></h1> </div> <div class="post"> <p>Lately I’ve been finding myself writing a bit of Go, and I’ve picked up various fun “layout secrets” that help inform how I write code to minimize hidden allocations, and generally be kind to the optimizer. This article is a series of notes on the topic.</p> <p>This post is about Go implementation details, so they can probably break you at any time if you rely on it. On the other hand, Hyrum’s law is a bitch, so taking your chances may not be that bad. After all, they’re probably never going to be able to properly clean up the mess people made with <code class="language-plaintext highlighter-rouge">//go:linkname</code> with runtime symbols…</p> <p>As with many of my other posts, I’ll assume a basic familiarity with being able to read assembly. I’m using x86 for this post, but it’s worth looking at my <a href="https://mcyoung.xyz//2021/11/09/assembly-1">RISC-V post</a> for a refresher.</p> <h2 id="gc-shapes"><a href="#gc-shapes">GC Shapes</a></h2> <p>The most basic Go-specific concept when it comes to type layouts is the <em>shape</em> of a type. This is an implementation detail of Go’s garbage collector that leaks through the <code class="language-plaintext highlighter-rouge">unsafe</code> package.</p> <p>Like in most native programming languages, every Go type has a size (the number of bytes that type takes up in memory) and an alignment (a power of two that every pointer to that type must be divisible by). Go, like most other languages, requires that size be divisible by the alignment: that is, the size is equal to the stride of an array of that type.</p> <p>The size an alignment of a type can be queried by the intrinsics <a href="https://pkg.go.dev/unsafe#Sizeof"><code class="language-plaintext highlighter-rouge">unsafe.Sizeof</code></a> and <a href="https://pkg.go.dev/unsafe#Alignof"><code class="language-plaintext highlighter-rouge">unsafe.Alignof</code></a>. These are very unwieldy in generic code, so I like to define a couple of helpers<sup id="fnref:constants" role="doc-noteref"><a href="#fn:constants" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Size</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Align</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Together, these two quantities are called the <em>layout</em> of a type (a term common to many native languages). However, the <em>shape</em> of a type also records what pieces thereof contain <em>pointers</em>. This is because memory visible to the GC (such as globals, heap memory, or stack roots) is typed, and the GC needs to know which parts of those types are pointers that it needs to trace through.</p> <p>Because all pointers have the same size and alignment (4 or 8 bytes depending on the system) the pointer words of a type can be represented as a bitset, one bit for every 4 or 8 bytes in the type. This, in fact, is the representation used by the GC<sup id="fnref:gc-programs" role="doc-noteref"><a href="#fn:gc-programs" class="footnote" rel="footnote">2</a></sup>.</p> <p>In particular, this means that whether a field is to be interpreted as an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code> or as a <code class="language-plaintext highlighter-rouge">uintptr</code> is a static property of the type. As we will see when we discuss interfaces, this restriction prevents a few layout optimizations.</p> <h2 id="slices-and-strings"><a href="#slices-and-strings">Slices and Strings</a></h2> <p>Go is very public about the layout of slices and strings. A slice is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">slice</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span>     <span class="o">*</span><span class="n">T</span>
  <span class="nb">len</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">len</code> and <code class="language-plaintext highlighter-rouge">cap</code> are extracted by their eponymous builtins, and <code class="language-plaintext highlighter-rouge">data</code> can be obtained using <code class="language-plaintext highlighter-rouge">unsafe.SliceData</code> (or <code class="language-plaintext highlighter-rouge">&amp;s[0]</code> if the slice is nonempty, but that costs a bounds-check).</p> <p>A string has the same layout as a <code class="language-plaintext highlighter-rouge">[]byte</code>, except for a capacity:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="kt">string</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
  <span class="nb">len</span>  <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Despite essentially being slices, Go treats strings subtly differently. Strings are <code class="language-plaintext highlighter-rouge">comparable</code>, so they can be used as map keys. They are also immutable, which enables a handful of optimizations. Immutability is also why they are <code class="language-plaintext highlighter-rouge">comparable</code>: Go made the mistake of not keeping <code class="language-plaintext highlighter-rouge">const</code> from C, but they really want map keys to be <code class="language-plaintext highlighter-rouge">const</code>.</p> <p>There is nothing stopping us from aliasing strings to data pointed to by a slice: after all, <code class="language-plaintext highlighter-rouge">strings.Builder</code> does it to avoid a copy in <code class="language-plaintext highlighter-rouge">String()</code>. We can implement this easily enough with some <code class="language-plaintext highlighter-rouge">unsafe</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">StringAlias</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Doing this is perfectly safe, so long as data is not mutated while the returned string is accessible. This allows virtually any slice type to be used as a key in a map, with some caveats.</p> <ol> <li> <p>Types which contain alignment padding cannot be used, because Go does not promise that it zeros memory returned by <code class="language-plaintext highlighter-rouge">new</code>.</p> </li> <li> <p>Types which contain pointers will cause those pointers to become unreachable if the only reference is the aliased string; this is because the pointed to data’s shape contains no pointer words.</p> </li> <li> <p>Incomparable types and interfaces will be compared by address (that is, maps, channels and funcs).</p> </li> </ol> <h3 id="dynamic-arrays-with-reflection"><a href="#dynamic-arrays-with-reflection">Dynamic Arrays with Reflection</a></h3> <p>Now, this isn’t the only to accomplish this: you can create dynamically-sized array types using reflection, like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Slice2Array</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span>

  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="n">elem</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">elem</span><span class="p">)</span>

  <span class="c">// NOTE: NewAt will return a reflect.Value containing a</span>
  <span class="c">// pointer, not an array!</span>
  <span class="n">refl</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">NewAt</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
  <span class="n">refl</span> <span class="o">=</span> <span class="n">refl</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span> <span class="c">// Dereference to get a pointer-to-array.</span>
  <span class="k">return</span> <span class="n">refl</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This will return an <code class="language-plaintext highlighter-rouge">any</code> whose type is <code class="language-plaintext highlighter-rouge">[len(s)]T</code>. You can even type assert it for static array sizes. This any is suitable for placing into a <code class="language-plaintext highlighter-rouge">map[any]T</code>, just as if we had built it with e.g. <code class="language-plaintext highlighter-rouge">any([...]byte("foo"))</code></p> <p>However, and this is not at all obvious from the code here, calling <code class="language-plaintext highlighter-rouge">refl.Interface()</code> will perform a copy of the whole array. <code class="language-plaintext highlighter-rouge">Interface()</code> delegates through a few functions until it calls <code class="language-plaintext highlighter-rouge">reflect.packEface()</code>.</p> <p>The code this function (<a href="https://cs.opensource.google/go/go/+/master:src/reflect/value.go;l=119?q=packEface&amp;ss=go%2Fgo">found here</a>) is reproduced below:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">reflect</span>

<span class="c">// packEface converts v to the empty interface.</span>
<span class="k">func</span> <span class="n">packEface</span><span class="p">(</span><span class="n">v</span> <span class="n">Value</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">typ</span><span class="p">()</span>
	<span class="k">var</span> <span class="n">i</span> <span class="n">any</span>
	<span class="n">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">abi</span><span class="o">.</span><span class="n">EmptyInterface</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span>
	<span class="c">// First, fill in the data portion of the interface.</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">t</span><span class="o">.</span><span class="n">IfaceIndir</span><span class="p">()</span><span class="o">:</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">"bad indir"</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c">// Value is indirect, and so is the interface we're making.</span>
		<span class="n">ptr</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagAddr</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">:=</span> <span class="n">unsafe_New</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
			<span class="n">typedmemmove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">c</span>
		<span class="p">}</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">ptr</span>
	<span class="k">case</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">!=</span> <span class="m">0</span><span class="o">:</span>
		<span class="c">// Value is indirect, but interface is direct. We need</span>
		<span class="c">// to load the data at v.ptr into the interface data word.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="c">// Value is direct, and so is the interface.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
	<span class="p">}</span>
	<span class="c">// Now, fill in the type portion. We're very careful here not</span>
	<span class="c">// to have any operation between the e.word and e.typ assignments</span>
	<span class="c">// that would let the garbage collector observe the partially-built</span>
	<span class="c">// interface value.</span>
	<span class="n">e</span><span class="o">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">t</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The switch determines precisely how the interface data pointer is computed. It turns out that (almost all) array types return true for <code class="language-plaintext highlighter-rouge">t.IfaceIndr()</code>, so the first case is selected, which triggers a copy (that being the call to <code class="language-plaintext highlighter-rouge">unsafe_New()</code> followed by a <code class="language-plaintext highlighter-rouge">typedmemmove</code>). This copy is to ensure that the value of the resulting interface cannot be mutated.</p> <p>Now, if only we knew the layout of Go’s interfaces, we might be able to get somewhere here…</p> <h2 id="the-layout-of-gos-interfaces"><a href="#the-layout-of-gos-interfaces">The Layout of Go’s Interfaces</a></h2> <p>Oh, yes, that’s what this article is about. So, if we look at the <code class="language-plaintext highlighter-rouge">runtime2.go</code> file in the runtime (yes, that’s what it’s called), nestled among the giant scheduler types for Gs, Ps, and Ms, we’ll find a couple of structs that really elucidate what’s going on:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">iface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">tab</span>  <span class="o">*</span><span class="n">itab</span>
	<span class="n">data</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">eface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">_type</span> <span class="o">*</span><span class="n">_type</span>
	<span class="n">data</span>  <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">funcval</code> is the layout of a <code class="language-plaintext highlighter-rouge">func()</code>, more on that later. <code class="language-plaintext highlighter-rouge">iface</code> is the layout of your “usual” interface, consisting of an <code class="language-plaintext highlighter-rouge">itab</code> (an interface table, or what Go calls a vtable) and a pointer to some data. <code class="language-plaintext highlighter-rouge">eface</code> is the layout of <code class="language-plaintext highlighter-rouge">any</code> (the artist formerly known as <code class="language-plaintext highlighter-rouge">interface{}</code>, hence the name: <em>e</em>mpty inter<em>face</em>).</p> <p><code class="language-plaintext highlighter-rouge">eface</code> having its own layout is an optimization. Because <code class="language-plaintext highlighter-rouge">any</code> exists to be downcast from dynamically, storing the type directly cuts out a pointer load when doing a type switch on an <code class="language-plaintext highlighter-rouge">any</code> specifically. If we look at what an <code class="language-plaintext highlighter-rouge">itab</code> is (which is “just” an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/iface.go;l=14"><code class="language-plaintext highlighter-rouge">abi.ITab</code></a>):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="c">// The first word of every non-empty interface type contains an *ITab.</span>
<span class="c">// It records the underlying concrete type (Type), the interface type</span>
<span class="c">// it is implementing (Inter), and some ancillary information.</span>
<span class="c">//</span>
<span class="c">// allocated in non-garbage-collected memory</span>
<span class="k">type</span> <span class="n">ITab</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Inter</span> <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">Type</span>  <span class="o">*</span><span class="n">Type</span>
	<span class="n">Hash</span>  <span class="kt">uint32</span>     <span class="c">// copy of Type.Hash. Used for type switches.</span>
	<span class="n">Fun</span>   <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c">// fun[0]==0 means Type does not implement Inter.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <h3 id="codegen-for-interface-operations"><a href="#codegen-for-interface-operations">Codegen for Interface Operations</a></h3> <p>An <code class="language-plaintext highlighter-rouge">ITab</code> contains the same type it would have as an <code class="language-plaintext highlighter-rouge">any</code>, which makes the generated code for a function that upcasts an interface to <code class="language-plaintext highlighter-rouge">any</code> very simple<sup id="fnref:asm" role="doc-noteref"><a href="#fn:asm" class="footnote" rel="footnote">3</a></sup>:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Upcast</span><span class="p">(</span><span class="n">i</span> <span class="n">MyIface</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">F</span><span class="o">:</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>In the register ABI, the x86 argument (and return) registers are <code class="language-plaintext highlighter-rouge">rax</code>, <code class="language-plaintext highlighter-rouge">rbx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, <code class="language-plaintext highlighter-rouge">r10</code> and <code class="language-plaintext highlighter-rouge">r11</code> (with <code class="language-plaintext highlighter-rouge">rdx</code> reserved for passing a closure capture, more on that later; <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the currently running G).</p> <p>The <code class="language-plaintext highlighter-rouge">*ITab</code> comes in on <code class="language-plaintext highlighter-rouge">rax</code> and the data pointer on <code class="language-plaintext highlighter-rouge">rbx</code>. First, we need to check if this is the nil interface, identified by having a nil itab (or type, in the case of <code class="language-plaintext highlighter-rouge">any</code>). If it is nil, we just return: <code class="language-plaintext highlighter-rouge">rax:rbx</code> already contain the data of a nil <code class="language-plaintext highlighter-rouge">any</code>. Otherwise, we load <code class="language-plaintext highlighter-rouge">ITab.Type</code>, at offset 8, into <code class="language-plaintext highlighter-rouge">rax</code>, and return.</p> <p>How do interface function calls work?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span><span class="n">m</span> <span class="n">MyIface</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">Method</span><span class="p">(</span><span class="m">42</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rsp</span><span class="p">,</span> <span class="n">rbp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="mi">42</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="n">nop</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">morestack_noctxt</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>This function seems to be doing a lot more than it actually is. Part of it is that its prologue has to do a call to <code class="language-plaintext highlighter-rouge">runtime.morestack_noctxt()</code>, which is simply a call to <code class="language-plaintext highlighter-rouge">runtime.morestack</code> that clobbers <code class="language-plaintext highlighter-rouge">rdx</code>, the closure capture parameter. The meat of it comes when it loads <code class="language-plaintext highlighter-rouge">[rax + 24]</code>, the first element of <code class="language-plaintext highlighter-rouge">ITab.Fun</code>. It then moves the data pointer in <code class="language-plaintext highlighter-rouge">rbx</code> to <code class="language-plaintext highlighter-rouge">rax</code>, the argument into <code class="language-plaintext highlighter-rouge">rbx</code>, and issues the call.</p> <p>What about upcasts? An upcast to a concrete type is quite simple: simply compare the type in the interface (either directly or in the <code class="language-plaintext highlighter-rouge">*ITab</code>) to a particular statically-known one. Downcasting to an interface (sometimes called a <em>sidecast</em>) is much more complicated, because it essentially requires a little bit of reflection.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Downcast</span><span class="p">(</span><span class="n">m</span> <span class="n">any</span><span class="p">)</span> <span class="n">MyIface</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="p">(</span><span class="n">MyIface</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">hashProbe</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rsi</span>
    <span class="n">and</span>     <span class="n">rsi</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">shl</span>     <span class="n">rsi</span><span class="p">,</span> <span class="mi">4</span>
    <span class="n">mov</span>     <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jeq</span>     <span class="n">found</span>
    <span class="n">lea</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">test</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jnz</span>     <span class="n">hashProbe</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">leq</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">typeAssert</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">done</span>
<span class="n">found</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">done</span><span class="o">:</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="n">foo</span><span class="p">.</span><span class="n">MyIface</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicnildottype</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as it was in foo.Call above.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>When we request an interface downcast, the Go compiler synthesizes a symbol of type <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code>. Its definition is reproduced below.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="k">type</span> <span class="n">TypeAssert</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Cache</span>   <span class="o">*</span><span class="n">TypeAssertCache</span>
	<span class="n">Inter</span>   <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">CanFail</span> <span class="kt">bool</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCache</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Mask</span>    <span class="kt">uintptr</span>
	<span class="n">Entries</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="n">TypeAssertCacheEntry</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCacheEntry</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// type of source value (a *runtime._type)</span>
	<span class="n">Typ</span> <span class="kt">uintptr</span>
	<span class="c">// itab to use for result (a *runtime.itab)</span>
	<span class="c">// nil if CanFail is set and conversion would fail.</span>
	<span class="n">Itab</span> <span class="kt">uintptr</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The first thing this function does is check if <code class="language-plaintext highlighter-rouge">rax</code> contains 0, i.e., if this is a nil <code class="language-plaintext highlighter-rouge">any</code>, and panics if that’s the case (that’s a call to <code class="language-plaintext highlighter-rouge">runtime.panicnildottype</code>). It then loads <code class="language-plaintext highlighter-rouge">foo..typeAssert0</code>, a synthetic global variable containing an <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code> value. It loads the <code class="language-plaintext highlighter-rouge">Cache</code> field, as well as the <code class="language-plaintext highlighter-rouge">Hash</code> field of the <code class="language-plaintext highlighter-rouge">abi.Type</code> attached to the <code class="language-plaintext highlighter-rouge">any</code>. It masks off the low bits using <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Mask</code>, and uses that to start probing the very simple open-addressed hash table located in <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Entries</code>.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with the type we’re looking for (compared by address), we’ve found it. We load that entry’s <code class="language-plaintext highlighter-rouge">Itab</code> value into <code class="language-plaintext highlighter-rouge">rax</code> to change the value from being an <code class="language-plaintext highlighter-rouge">any</code> to being a <code class="language-plaintext highlighter-rouge">MyIface</code>, and we’re done.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with a nil <code class="language-plaintext highlighter-rouge">Typ</code> pointer, we’re forced to hit the slow path, implemented at <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code>. This dynamically builds an itab by searching the method set of the type inside the <code class="language-plaintext highlighter-rouge">any</code>.</p> <p>This then calls the reflection code in <code class="language-plaintext highlighter-rouge">runtime.getitab()</code>, which is what actually performs the messy search through the method set, comparing the names and signatures of methods with those in the interface, to produce an itab at runtime.</p> <p>Then, it shoves this the resulting itab into the global itab cache, which is protected by a global lock! There are lots of scary atomics in this code. There are many places where this can potentially panic, bubbling up a type assertion failure to the user.</p> <p>When <code class="language-plaintext highlighter-rouge">runtime.getitab()</code> returns, <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code> will <em>maybe</em><sup id="fnref:maybe-update" role="doc-noteref"><a href="#fn:maybe-update" class="footnote" rel="footnote">4</a></sup> update the type assertion cache, and return the new itab. This allows the code in our function to return directly, without needing to take another trip into the <code class="language-plaintext highlighter-rouge">hashProbe</code> loop.</p> <p>In theory, PGO could be used to pre-fill the cache, but I couldn’t find any code in the compiler that indicates that this is something they do. In the meantime, you can optimize a hot type assert ahead of time by asserting to a known common type:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">rs</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span>
  <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Check for a known implementation first. This only costs</span>
    <span class="c">// a pointer comparison with the *abi.Type in the itab.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Do an interface type assertion. This would eventually</span>
    <span class="c">// learn os.File, but the branch above skips that "warmup"</span>
    <span class="c">// time. It also lets the hardware branch predictor allocate</span>
    <span class="c">// a prediction slot just for os.File.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// ...</span>
  <span class="p">}</span>
<span class="p">}</span> </code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Type switches, incidentally, use a very similar caching mechanism for switches that include interface types among the cases.</p> <h3 id="what-was-that-about-indirect-interfaces"><a href="#what-was-that-about-indirect-interfaces">What Was That About Indirect Interfaces?</a></h3> <p>Back when we were hacking arrays into existence with reflection, there was some trouble in <code class="language-plaintext highlighter-rouge">reflect.Value.Interface()</code>, where it would do a seemingly unnecessary copy.</p> <p>This is because an interface’s data pointer must be a pointer. If you cram, say, an <code class="language-plaintext highlighter-rouge">int</code> into an <code class="language-plaintext highlighter-rouge">any</code>, Go will spill it to the heap. This is often called <em>boxing</em>, but the Go runtime refers to it as an “indirect interface”.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">push</span>     <span class="n">rbp</span>
  <span class="n">mov</span>      <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
  <span class="n">call</span>     <span class="n">runtime</span><span class="p">.</span><span class="n">convT64</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">pop</span>      <span class="n">rbp</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Like many other managed languages, Go will skip boxing very small values by instead returning pointers into some global array.</p> <p>Now, this boxing could be avoided: after all, an <code class="language-plaintext highlighter-rouge">int</code> is no larger than a pointer, so we could cram it into the data pointer field directly. However, the GC <em>really</em> doesn’t like that: the GC assumes it can trace through any pointer. Now, the GC <em>could</em> treat interfaces differently, and look at the type/itab pointer to determine if the data value pointer or a scalar. However, this would add significant complexity to both the representation of shapes, and to the tracing code in the GC, resulting in more branches and slower tracing.</p> <p>However, if the type being wrapped in an interface happens to be a pointer, it can just use that pointer value directly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Any type that has the same shape as a pointer will be indirect. This includes maps, channels, and funcs. It also includes one element arrays of such types, such as <code class="language-plaintext highlighter-rouge">[1]*int</code> and <code class="language-plaintext highlighter-rouge">[1]chan error</code>, and single-field structs of such types. Curiously, this does not include structs which contain a zero-sized field before the pointer-sized field, even though those have the same shape as a pointer.</p> <p>This means it’s generally not safe to play games with forging an interface out of a pointer to some type: whether that type is indirect in an interface is a subtle implementation detail of the compiler.</p> <p>And of course, it’s important to remember that if you want to return a value by interface, you had best hope it can get inlined, so the compiler can promote the heap allocation to the stack.</p> <h2 id="function-pointers"><a href="#function-pointers">Function Pointers</a></h2> <p>The last thing to look at are Go’s function pointers. For the longest time, I assumed they had the same layout as an interface: a pointer to closure data, and a hardware function pointer.</p> <p>It turns out the layout is weirder: let’s revisit the <code class="language-plaintext highlighter-rouge">runtime.funcval</code> we found in <code class="language-plaintext highlighter-rouge">runtime2.go</code> earlier.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This unusual layout is best understood by looking at the generated assembly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span>
  <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span>
  <span class="n">x</span> <span class="kt">int</span><span class="p">,</span>
<span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>To call <code class="language-plaintext highlighter-rouge">f</code>, first we interpret it as a <code class="language-plaintext highlighter-rouge">*funcval</code> and load <code class="language-plaintext highlighter-rouge">f.fn</code> into a temporary. That is, the first word pointed to by <code class="language-plaintext highlighter-rouge">rax</code> (which holds <code class="language-plaintext highlighter-rouge">f</code> on function entry). Then, we place <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">rdx</code>, the closure context register. The reason for using this extra magic register will become clear shorter. Then, we arrange the rest of the arguments in their usual registers, and we jump to the address stored in <code class="language-plaintext highlighter-rouge">f.fn</code>.</p> <p>Inside of <code class="language-plaintext highlighter-rouge">f</code>, captures are accessed by offsetting from <code class="language-plaintext highlighter-rouge">rdx</code>. What does one of those closures look like?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">imul</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rcx</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>All <code class="language-plaintext highlighter-rouge">Capture</code> is doing is allocating a <code class="language-plaintext highlighter-rouge">funcval</code> with a single <code class="language-plaintext highlighter-rouge">int</code> capture; that’s the <code class="language-plaintext highlighter-rouge">{ F uintptr; X0 int }</code> in the code above. It then places the address of <code class="language-plaintext highlighter-rouge">Capture.func1</code>, which implements the callback, into <code class="language-plaintext highlighter-rouge">F</code>, and the argument of <code class="language-plaintext highlighter-rouge">Capture</code> into <code class="language-plaintext highlighter-rouge">X0</code>.</p> <p>What about when returning a reference to a function? In that case, all that happens is it returns a reference to a global containing the address of the function.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Id</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Id</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="p">]</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="o">:</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="o">:</span>
    <span class="p">.</span><span class="n">quad</span> <span class="n">foo</span><span class="p">.</span><span class="n">Id</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Because we pass the closure arguments in an extra register not used by regular functions, we don’t need to create a thunk for this case.</p> <p>Unfortunately, we do need to create a thunk for methods, even methods with a pointer receiver. This is because of the following incompatible constraints:</p> <ol> <li> <p>The receiver pointer for a method must point exactly to the value the method is called on. It can’t be a fixed offset before, because that would create an out-of-bounds pointer, which the GC does not tolerate.</p> </li> <li> <p>The closure pointer must point to the start of the funcval, <em>not</em> its captures, because adjusting the pointer to point to the captures would cause it to point one-past-the-end of a value, which the GC <em>also</em> does not tolerate!</p> </li> </ol> <p>Thus, <em>even</em> if methods accepted a pointer receiver via <code class="language-plaintext highlighter-rouge">rdx</code>, closures and methods disagree about where that pointer should be passed.</p> <p>Of course, there are adjustments we can make to fix this problem. For example, we could require that all <code class="language-plaintext highlighter-rouge">funcval</code> values have at least one capture. No-capture <code class="language-plaintext highlighter-rouge">funcvals</code> would have a synthetic <code class="language-plaintext highlighter-rouge">_ byte</code> field. This is not unlike how a non-empty struct whose final field is empty will be padded with an extra <code class="language-plaintext highlighter-rouge">_ byte</code> field: this is specifically to avoid a pointer to that field being a past-the-end pointer. The cost is that every non-capturing closure costs twice as much binary size.</p> <p>Another fix is to make the GC blind to the pointer in <code class="language-plaintext highlighter-rouge">rdx</code>. This will never be the only pointer by which a value is reachable, so it would be safe to replace <code class="language-plaintext highlighter-rouge">mov rdx, rax</code> with a <code class="language-plaintext highlighter-rouge">lea rdx, [rax + 8]</code>. The GC would never know!</p> <p>Until then, beware that writing <code class="language-plaintext highlighter-rouge">return foo.Method</code> secretly allocates 16 bytes or so. (Aside: I used to sit next to the Go team at Google, and I remember having a conversation with Austin Clements about this. Apparently I misremembered, because until recently I thought Go already implemented this optimization!)</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>If you made it this far this is probably you right now:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/stickers/dizzy.png" alt="Miguel as a Whimsicott, dizzy with register names."/></p> </figure> <p>This isn’t intended to be as polished as most of my articles, but there’s been enough things I’ve come across that I wanted to write this all up for my own reference.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:constants" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Sizeof</code> and <code class="language-plaintext highlighter-rouge">Alignof</code> are intrinsics, so the compiler will turn them into constants. However, they are only constants if the type being measured is not generic, so wrapping them in a function like this doesn’t actually hurt in generic code. <a href="#fnref:constants" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:gc-programs" role="doc-endnote"> <p>Except for very large types that would have more words than can be recorded by an array of size <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/type.go;l=803;bpv=0"><code class="language-plaintext highlighter-rouge">abi.MaxPtrmaskBytes</code></a>. For larger types, we use GC programs! A GC program is an LZ-compressed bitset serving the same purpose as the pointer bitset most smaller types use. See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/cmd/internal/gcprog/gcprog.go">gcprog.go</a>.</p> <p>In fact, <code class="language-plaintext highlighter-rouge">reflection</code> knows how to create programs on the fly for most types! See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/reflect/type.go;l=2658">reflect/type.go</a>. <a href="#fnref:gc-programs" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:asm" role="doc-endnote"> <p>I will be writing assembly examples in Intel-syntax x86. Go’s assembly syntax is horrible and an impediment to the point I’m making. <a href="#fnref:asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:maybe-update" role="doc-endnote"> <p>Maybe? Well, the cache will only get updated about 0.1% of the time. This is to amortize the costs of growing the cache. I assume they benchmarked this, and found that the cost of growing the cache makes it only worthwhile when that assertion is getting hammered. <a href="#fnref:maybe-update" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-04-08</span> / <h6 style="display:inline"><a href="/2025/04/08/protobuf-tip-1/">Protobuf Tip #1: Field Names Are Forever</a></h6> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2024-12-12 • 2804 words • 23 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/12/go-abi/"> Things You Never Wanted To Know About Go Interfaces </a></h1> </div> <div class="post"> <p>Lately I’ve been finding myself writing a bit of Go, and I’ve picked up various fun “layout secrets” that help inform how I write code to minimize hidden allocations, and generally be kind to the optimizer. This article is a series of notes on the topic.</p> <p>This post is about Go implementation details, so they can probably break you at any time if you rely on it. On the other hand, Hyrum’s law is a bitch, so taking your chances may not be that bad. After all, they’re probably never going to be able to properly clean up the mess people made with <code class="language-plaintext highlighter-rouge">//go:linkname</code> with runtime symbols…</p> <p>As with many of my other posts, I’ll assume a basic familiarity with being able to read assembly. I’m using x86 for this post, but it’s worth looking at my <a href="https://mcyoung.xyz//2021/11/09/assembly-1">RISC-V post</a> for a refresher.</p> <h2 id="gc-shapes"><a href="#gc-shapes">GC Shapes</a></h2> <p>The most basic Go-specific concept when it comes to type layouts is the <em>shape</em> of a type. This is an implementation detail of Go’s garbage collector that leaks through the <code class="language-plaintext highlighter-rouge">unsafe</code> package.</p> <p>Like in most native programming languages, every Go type has a size (the number of bytes that type takes up in memory) and an alignment (a power of two that every pointer to that type must be divisible by). Go, like most other languages, requires that size be divisible by the alignment: that is, the size is equal to the stride of an array of that type.</p> <p>The size an alignment of a type can be queried by the intrinsics <a href="https://pkg.go.dev/unsafe#Sizeof"><code class="language-plaintext highlighter-rouge">unsafe.Sizeof</code></a> and <a href="https://pkg.go.dev/unsafe#Alignof"><code class="language-plaintext highlighter-rouge">unsafe.Alignof</code></a>. These are very unwieldy in generic code, so I like to define a couple of helpers<sup id="fnref:constants" role="doc-noteref"><a href="#fn:constants" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Size</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Align</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Together, these two quantities are called the <em>layout</em> of a type (a term common to many native languages). However, the <em>shape</em> of a type also records what pieces thereof contain <em>pointers</em>. This is because memory visible to the GC (such as globals, heap memory, or stack roots) is typed, and the GC needs to know which parts of those types are pointers that it needs to trace through.</p> <p>Because all pointers have the same size and alignment (4 or 8 bytes depending on the system) the pointer words of a type can be represented as a bitset, one bit for every 4 or 8 bytes in the type. This, in fact, is the representation used by the GC<sup id="fnref:gc-programs" role="doc-noteref"><a href="#fn:gc-programs" class="footnote" rel="footnote">2</a></sup>.</p> <p>In particular, this means that whether a field is to be interpreted as an <code class="language-plaintext highlighter-rouge">unsafe.Pointer</code> or as a <code class="language-plaintext highlighter-rouge">uintptr</code> is a static property of the type. As we will see when we discuss interfaces, this restriction prevents a few layout optimizations.</p> <h2 id="slices-and-strings"><a href="#slices-and-strings">Slices and Strings</a></h2> <p>Go is very public about the layout of slices and strings. A slice is</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">slice</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span>     <span class="o">*</span><span class="n">T</span>
  <span class="nb">len</span><span class="p">,</span> <span class="nb">cap</span> <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">len</code> and <code class="language-plaintext highlighter-rouge">cap</code> are extracted by their eponymous builtins, and <code class="language-plaintext highlighter-rouge">data</code> can be obtained using <code class="language-plaintext highlighter-rouge">unsafe.SliceData</code> (or <code class="language-plaintext highlighter-rouge">&amp;s[0]</code> if the slice is nonempty, but that costs a bounds-check).</p> <p>A string has the same layout as a <code class="language-plaintext highlighter-rouge">[]byte</code>, except for a capacity:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="kt">string</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
  <span class="nb">len</span>  <span class="kt">int</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Despite essentially being slices, Go treats strings subtly differently. Strings are <code class="language-plaintext highlighter-rouge">comparable</code>, so they can be used as map keys. They are also immutable, which enables a handful of optimizations. Immutability is also why they are <code class="language-plaintext highlighter-rouge">comparable</code>: Go made the mistake of not keeping <code class="language-plaintext highlighter-rouge">const</code> from C, but they really want map keys to be <code class="language-plaintext highlighter-rouge">const</code>.</p> <p>There is nothing stopping us from aliasing strings to data pointed to by a slice: after all, <code class="language-plaintext highlighter-rouge">strings.Builder</code> does it to avoid a copy in <code class="language-plaintext highlighter-rouge">String()</code>. We can implement this easily enough with some <code class="language-plaintext highlighter-rouge">unsafe</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">StringAlias</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Doing this is perfectly safe, so long as data is not mutated while the returned string is accessible. This allows virtually any slice type to be used as a key in a map, with some caveats.</p> <ol> <li> <p>Types which contain alignment padding cannot be used, because Go does not promise that it zeros memory returned by <code class="language-plaintext highlighter-rouge">new</code>.</p> </li> <li> <p>Types which contain pointers will cause those pointers to become unreachable if the only reference is the aliased string; this is because the pointed to data’s shape contains no pointer words.</p> </li> <li> <p>Incomparable types and interfaces will be compared by address (that is, maps, channels and funcs).</p> </li> </ol> <h3 id="dynamic-arrays-with-reflection"><a href="#dynamic-arrays-with-reflection">Dynamic Arrays with Reflection</a></h3> <p>Now, this isn’t the only to accomplish this: you can create dynamically-sized array types using reflection, like so:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Slice2Array</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="no">nil</span> <span class="p">}</span>

  <span class="k">var</span> <span class="n">v</span> <span class="n">T</span>
  <span class="n">elem</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ArrayOf</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">elem</span><span class="p">)</span>

  <span class="c">// NOTE: NewAt will return a reflect.Value containing a</span>
  <span class="c">// pointer, not an array!</span>
  <span class="n">refl</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">NewAt</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">SliceData</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
  <span class="n">refl</span> <span class="o">=</span> <span class="n">refl</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span> <span class="c">// Dereference to get a pointer-to-array.</span>
  <span class="k">return</span> <span class="n">refl</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This will return an <code class="language-plaintext highlighter-rouge">any</code> whose type is <code class="language-plaintext highlighter-rouge">[len(s)]T</code>. You can even type assert it for static array sizes. This any is suitable for placing into a <code class="language-plaintext highlighter-rouge">map[any]T</code>, just as if we had built it with e.g. <code class="language-plaintext highlighter-rouge">any([...]byte("foo"))</code></p> <p>However, and this is not at all obvious from the code here, calling <code class="language-plaintext highlighter-rouge">refl.Interface()</code> will perform a copy of the whole array. <code class="language-plaintext highlighter-rouge">Interface()</code> delegates through a few functions until it calls <code class="language-plaintext highlighter-rouge">reflect.packEface()</code>.</p> <p>The code this function (<a href="https://cs.opensource.google/go/go/+/master:src/reflect/value.go;l=119?q=packEface&amp;ss=go%2Fgo">found here</a>) is reproduced below:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">reflect</span>

<span class="c">// packEface converts v to the empty interface.</span>
<span class="k">func</span> <span class="n">packEface</span><span class="p">(</span><span class="n">v</span> <span class="n">Value</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">typ</span><span class="p">()</span>
	<span class="k">var</span> <span class="n">i</span> <span class="n">any</span>
	<span class="n">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">abi</span><span class="o">.</span><span class="n">EmptyInterface</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span>
	<span class="c">// First, fill in the data portion of the interface.</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">t</span><span class="o">.</span><span class="n">IfaceIndir</span><span class="p">()</span><span class="o">:</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">"bad indir"</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c">// Value is indirect, and so is the interface we're making.</span>
		<span class="n">ptr</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagAddr</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">:=</span> <span class="n">unsafe_New</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
			<span class="n">typedmemmove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">c</span>
		<span class="p">}</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">ptr</span>
	<span class="k">case</span> <span class="n">v</span><span class="o">.</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">flagIndir</span> <span class="o">!=</span> <span class="m">0</span><span class="o">:</span>
		<span class="c">// Value is indirect, but interface is direct. We need</span>
		<span class="c">// to load the data at v.ptr into the interface data word.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="c">// Value is direct, and so is the interface.</span>
		<span class="n">e</span><span class="o">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ptr</span>
	<span class="p">}</span>
	<span class="c">// Now, fill in the type portion. We're very careful here not</span>
	<span class="c">// to have any operation between the e.word and e.typ assignments</span>
	<span class="c">// that would let the garbage collector observe the partially-built</span>
	<span class="c">// interface value.</span>
	<span class="n">e</span><span class="o">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">t</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The switch determines precisely how the interface data pointer is computed. It turns out that (almost all) array types return true for <code class="language-plaintext highlighter-rouge">t.IfaceIndr()</code>, so the first case is selected, which triggers a copy (that being the call to <code class="language-plaintext highlighter-rouge">unsafe_New()</code> followed by a <code class="language-plaintext highlighter-rouge">typedmemmove</code>). This copy is to ensure that the value of the resulting interface cannot be mutated.</p> <p>Now, if only we knew the layout of Go’s interfaces, we might be able to get somewhere here…</p> <h2 id="the-layout-of-gos-interfaces"><a href="#the-layout-of-gos-interfaces">The Layout of Go’s Interfaces</a></h2> <p>Oh, yes, that’s what this article is about. So, if we look at the <code class="language-plaintext highlighter-rouge">runtime2.go</code> file in the runtime (yes, that’s what it’s called), nestled among the giant scheduler types for Gs, Ps, and Ms, we’ll find a couple of structs that really elucidate what’s going on:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">iface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">tab</span>  <span class="o">*</span><span class="n">itab</span>
	<span class="n">data</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">eface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">_type</span> <span class="o">*</span><span class="n">_type</span>
	<span class="n">data</span>  <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p><code class="language-plaintext highlighter-rouge">funcval</code> is the layout of a <code class="language-plaintext highlighter-rouge">func()</code>, more on that later. <code class="language-plaintext highlighter-rouge">iface</code> is the layout of your “usual” interface, consisting of an <code class="language-plaintext highlighter-rouge">itab</code> (an interface table, or what Go calls a vtable) and a pointer to some data. <code class="language-plaintext highlighter-rouge">eface</code> is the layout of <code class="language-plaintext highlighter-rouge">any</code> (the artist formerly known as <code class="language-plaintext highlighter-rouge">interface{}</code>, hence the name: <em>e</em>mpty inter<em>face</em>).</p> <p><code class="language-plaintext highlighter-rouge">eface</code> having its own layout is an optimization. Because <code class="language-plaintext highlighter-rouge">any</code> exists to be downcast from dynamically, storing the type directly cuts out a pointer load when doing a type switch on an <code class="language-plaintext highlighter-rouge">any</code> specifically. If we look at what an <code class="language-plaintext highlighter-rouge">itab</code> is (which is “just” an <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/iface.go;l=14"><code class="language-plaintext highlighter-rouge">abi.ITab</code></a>):</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="c">// The first word of every non-empty interface type contains an *ITab.</span>
<span class="c">// It records the underlying concrete type (Type), the interface type</span>
<span class="c">// it is implementing (Inter), and some ancillary information.</span>
<span class="c">//</span>
<span class="c">// allocated in non-garbage-collected memory</span>
<span class="k">type</span> <span class="n">ITab</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Inter</span> <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">Type</span>  <span class="o">*</span><span class="n">Type</span>
	<span class="n">Hash</span>  <span class="kt">uint32</span>     <span class="c">// copy of Type.Hash. Used for type switches.</span>
	<span class="n">Fun</span>   <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c">// fun[0]==0 means Type does not implement Inter.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <h3 id="codegen-for-interface-operations"><a href="#codegen-for-interface-operations">Codegen for Interface Operations</a></h3> <p>An <code class="language-plaintext highlighter-rouge">ITab</code> contains the same type it would have as an <code class="language-plaintext highlighter-rouge">any</code>, which makes the generated code for a function that upcasts an interface to <code class="language-plaintext highlighter-rouge">any</code> very simple<sup id="fnref:asm" role="doc-noteref"><a href="#fn:asm" class="footnote" rel="footnote">3</a></sup>:</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Upcast</span><span class="p">(</span><span class="n">i</span> <span class="n">MyIface</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">F</span><span class="o">:</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>In the register ABI, the x86 argument (and return) registers are <code class="language-plaintext highlighter-rouge">rax</code>, <code class="language-plaintext highlighter-rouge">rbx</code>, <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdi</code>, <code class="language-plaintext highlighter-rouge">rsi</code>, <code class="language-plaintext highlighter-rouge">r8</code>, <code class="language-plaintext highlighter-rouge">r9</code>, <code class="language-plaintext highlighter-rouge">r10</code> and <code class="language-plaintext highlighter-rouge">r11</code> (with <code class="language-plaintext highlighter-rouge">rdx</code> reserved for passing a closure capture, more on that later; <code class="language-plaintext highlighter-rouge">r14</code> holds a pointer to the currently running G).</p> <p>The <code class="language-plaintext highlighter-rouge">*ITab</code> comes in on <code class="language-plaintext highlighter-rouge">rax</code> and the data pointer on <code class="language-plaintext highlighter-rouge">rbx</code>. First, we need to check if this is the nil interface, identified by having a nil itab (or type, in the case of <code class="language-plaintext highlighter-rouge">any</code>). If it is nil, we just return: <code class="language-plaintext highlighter-rouge">rax:rbx</code> already contain the data of a nil <code class="language-plaintext highlighter-rouge">any</code>. Otherwise, we load <code class="language-plaintext highlighter-rouge">ITab.Type</code>, at offset 8, into <code class="language-plaintext highlighter-rouge">rax</code>, and return.</p> <p>How do interface function calls work?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span><span class="n">m</span> <span class="n">MyIface</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">Method</span><span class="p">(</span><span class="m">42</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rsp</span><span class="p">,</span> <span class="n">rbp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="mi">42</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="n">nop</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">morestack_noctxt</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>This function seems to be doing a lot more than it actually is. Part of it is that its prologue has to do a call to <code class="language-plaintext highlighter-rouge">runtime.morestack_noctxt()</code>, which is simply a call to <code class="language-plaintext highlighter-rouge">runtime.morestack</code> that clobbers <code class="language-plaintext highlighter-rouge">rdx</code>, the closure capture parameter. The meat of it comes when it loads <code class="language-plaintext highlighter-rouge">[rax + 24]</code>, the first element of <code class="language-plaintext highlighter-rouge">ITab.Fun</code>. It then moves the data pointer in <code class="language-plaintext highlighter-rouge">rbx</code> to <code class="language-plaintext highlighter-rouge">rax</code>, the argument into <code class="language-plaintext highlighter-rouge">rbx</code>, and issues the call.</p> <p>What about upcasts? An upcast to a concrete type is quite simple: simply compare the type in the interface (either directly or in the <code class="language-plaintext highlighter-rouge">*ITab</code>) to a particular statically-known one. Downcasting to an interface (sometimes called a <em>sidecast</em>) is much more complicated, because it essentially requires a little bit of reflection.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">type</span> <span class="n">MyIface</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Downcast</span><span class="p">(</span><span class="n">m</span> <span class="n">any</span><span class="p">)</span> <span class="n">MyIface</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="p">(</span><span class="n">MyIface</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">jeq</span>     <span class="n">nil</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">hashProbe</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rsi</span>
    <span class="n">and</span>     <span class="n">rsi</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">shl</span>     <span class="n">rsi</span><span class="p">,</span> <span class="mi">4</span>
    <span class="n">mov</span>     <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jeq</span>     <span class="n">found</span>
    <span class="n">lea</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">test</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">r8</span>
    <span class="n">jnz</span>     <span class="n">hashProbe</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">leq</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">..</span><span class="n">typeAssert0</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">typeAssert</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">jmp</span>     <span class="n">done</span>
<span class="n">found</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">done</span><span class="o">:</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">nil</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="n">foo</span><span class="p">.</span><span class="n">MyIface</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicnildottype</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as it was in foo.Call above.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Downcast</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>When we request an interface downcast, the Go compiler synthesizes a symbol of type <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code>. Its definition is reproduced below.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">abi</span>

<span class="k">type</span> <span class="n">TypeAssert</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Cache</span>   <span class="o">*</span><span class="n">TypeAssertCache</span>
	<span class="n">Inter</span>   <span class="o">*</span><span class="n">InterfaceType</span>
	<span class="n">CanFail</span> <span class="kt">bool</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCache</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Mask</span>    <span class="kt">uintptr</span>
	<span class="n">Entries</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="n">TypeAssertCacheEntry</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">TypeAssertCacheEntry</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// type of source value (a *runtime._type)</span>
	<span class="n">Typ</span> <span class="kt">uintptr</span>
	<span class="c">// itab to use for result (a *runtime.itab)</span>
	<span class="c">// nil if CanFail is set and conversion would fail.</span>
	<span class="n">Itab</span> <span class="kt">uintptr</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The first thing this function does is check if <code class="language-plaintext highlighter-rouge">rax</code> contains 0, i.e., if this is a nil <code class="language-plaintext highlighter-rouge">any</code>, and panics if that’s the case (that’s a call to <code class="language-plaintext highlighter-rouge">runtime.panicnildottype</code>). It then loads <code class="language-plaintext highlighter-rouge">foo..typeAssert0</code>, a synthetic global variable containing an <code class="language-plaintext highlighter-rouge">abi.TypeAssert</code> value. It loads the <code class="language-plaintext highlighter-rouge">Cache</code> field, as well as the <code class="language-plaintext highlighter-rouge">Hash</code> field of the <code class="language-plaintext highlighter-rouge">abi.Type</code> attached to the <code class="language-plaintext highlighter-rouge">any</code>. It masks off the low bits using <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Mask</code>, and uses that to start probing the very simple open-addressed hash table located in <code class="language-plaintext highlighter-rouge">typeAssert0.Cache.Entries</code>.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with the type we’re looking for (compared by address), we’ve found it. We load that entry’s <code class="language-plaintext highlighter-rouge">Itab</code> value into <code class="language-plaintext highlighter-rouge">rax</code> to change the value from being an <code class="language-plaintext highlighter-rouge">any</code> to being a <code class="language-plaintext highlighter-rouge">MyIface</code>, and we’re done.</p> <p>If it finds a <code class="language-plaintext highlighter-rouge">TypeAssertCacheEntry</code> with a nil <code class="language-plaintext highlighter-rouge">Typ</code> pointer, we’re forced to hit the slow path, implemented at <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code>. This dynamically builds an itab by searching the method set of the type inside the <code class="language-plaintext highlighter-rouge">any</code>.</p> <p>This then calls the reflection code in <code class="language-plaintext highlighter-rouge">runtime.getitab()</code>, which is what actually performs the messy search through the method set, comparing the names and signatures of methods with those in the interface, to produce an itab at runtime.</p> <p>Then, it shoves this the resulting itab into the global itab cache, which is protected by a global lock! There are lots of scary atomics in this code. There are many places where this can potentially panic, bubbling up a type assertion failure to the user.</p> <p>When <code class="language-plaintext highlighter-rouge">runtime.getitab()</code> returns, <code class="language-plaintext highlighter-rouge">runtime.typeAssert()</code> will <em>maybe</em><sup id="fnref:maybe-update" role="doc-noteref"><a href="#fn:maybe-update" class="footnote" rel="footnote">4</a></sup> update the type assertion cache, and return the new itab. This allows the code in our function to return directly, without needing to take another trip into the <code class="language-plaintext highlighter-rouge">hashProbe</code> loop.</p> <p>In theory, PGO could be used to pre-fill the cache, but I couldn’t find any code in the compiler that indicates that this is something they do. In the meantime, you can optimize a hot type assert ahead of time by asserting to a known common type:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">rs</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span>
  <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Check for a known implementation first. This only costs</span>
    <span class="c">// a pointer comparison with the *abi.Type in the itab.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadSeeker</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="c">// Do an interface type assertion. This would eventually</span>
    <span class="c">// learn os.File, but the branch above skips that "warmup"</span>
    <span class="c">// time. It also lets the hardware branch predictor allocate</span>
    <span class="c">// a prediction slot just for os.File.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">f</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// ...</span>
  <span class="p">}</span>
<span class="p">}</span> </code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Type switches, incidentally, use a very similar caching mechanism for switches that include interface types among the cases.</p> <h3 id="what-was-that-about-indirect-interfaces"><a href="#what-was-that-about-indirect-interfaces">What Was That About Indirect Interfaces?</a></h3> <p>Back when we were hacking arrays into existence with reflection, there was some trouble in <code class="language-plaintext highlighter-rouge">reflect.Value.Interface()</code>, where it would do a seemingly unnecessary copy.</p> <p>This is because an interface’s data pointer must be a pointer. If you cram, say, an <code class="language-plaintext highlighter-rouge">int</code> into an <code class="language-plaintext highlighter-rouge">any</code>, Go will spill it to the heap. This is often called <em>boxing</em>, but the Go runtime refers to it as an “indirect interface”.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">push</span>     <span class="n">rbp</span>
  <span class="n">mov</span>      <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
  <span class="n">call</span>     <span class="n">runtime</span><span class="p">.</span><span class="n">convT64</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">add</span>      <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">pop</span>      <span class="n">rbp</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Like many other managed languages, Go will skip boxing very small values by instead returning pointers into some global array.</p> <p>Now, this boxing could be avoided: after all, an <code class="language-plaintext highlighter-rouge">int</code> is no larger than a pointer, so we could cram it into the data pointer field directly. However, the GC <em>really</em> doesn’t like that: the GC assumes it can trace through any pointer. Now, the GC <em>could</em> treat interfaces differently, and look at the type/itab pointer to determine if the data value pointer or a scalar. However, this would add significant complexity to both the representation of shapes, and to the tracing code in the GC, resulting in more branches and slower tracing.</p> <p>However, if the type being wrapped in an interface happens to be a pointer, it can just use that pointer value directly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Int2Any</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Int2Any</span><span class="o">:</span>
  <span class="n">move</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>      <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
  <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Any type that has the same shape as a pointer will be indirect. This includes maps, channels, and funcs. It also includes one element arrays of such types, such as <code class="language-plaintext highlighter-rouge">[1]*int</code> and <code class="language-plaintext highlighter-rouge">[1]chan error</code>, and single-field structs of such types. Curiously, this does not include structs which contain a zero-sized field before the pointer-sized field, even though those have the same shape as a pointer.</p> <p>This means it’s generally not safe to play games with forging an interface out of a pointer to some type: whether that type is indirect in an interface is a subtle implementation detail of the compiler.</p> <p>And of course, it’s important to remember that if you want to return a value by interface, you had best hope it can get inlined, so the compiler can promote the heap allocation to the stack.</p> <h2 id="function-pointers"><a href="#function-pointers">Function Pointers</a></h2> <p>The last thing to look at are Go’s function pointers. For the longest time, I assumed they had the same layout as an interface: a pointer to closure data, and a hardware function pointer.</p> <p>It turns out the layout is weirder: let’s revisit the <code class="language-plaintext highlighter-rouge">runtime.funcval</code> we found in <code class="language-plaintext highlighter-rouge">runtime2.go</code> earlier.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="k">type</span> <span class="n">funcval</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fn</span> <span class="kt">uintptr</span>
	<span class="c">// variable-size, fn-specific data here</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This unusual layout is best understood by looking at the generated assembly.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Call</span><span class="p">(</span>
  <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span>
  <span class="n">x</span> <span class="kt">int</span><span class="p">,</span>
<span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Call</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">8</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Call</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>To call <code class="language-plaintext highlighter-rouge">f</code>, first we interpret it as a <code class="language-plaintext highlighter-rouge">*funcval</code> and load <code class="language-plaintext highlighter-rouge">f.fn</code> into a temporary. That is, the first word pointed to by <code class="language-plaintext highlighter-rouge">rax</code> (which holds <code class="language-plaintext highlighter-rouge">f</code> on function entry). Then, we place <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">rdx</code>, the closure context register. The reason for using this extra magic register will become clear shorter. Then, we arrange the rest of the arguments in their usual registers, and we jump to the address stored in <code class="language-plaintext highlighter-rouge">f.fn</code>.</p> <p>Inside of <code class="language-plaintext highlighter-rouge">f</code>, captures are accessed by offsetting from <code class="language-plaintext highlighter-rouge">rdx</code>. What does one of those closures look like?</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">cmp</span>     <span class="n">rsp</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">jls</span>     <span class="n">grow</span>
    <span class="n">push</span>    <span class="n">rpb</span>
    <span class="n">mov</span>     <span class="n">rpb</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">grow</span><span class="o">:</span>
    <span class="c1">// Same as before.</span>
    <span class="n">jmp</span>     <span class="n">foo</span><span class="p">.</span><span class="n">Capture</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="p">.</span><span class="n">func1</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">imul</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rcx</span>
    <span class="n">ret</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>All <code class="language-plaintext highlighter-rouge">Capture</code> is doing is allocating a <code class="language-plaintext highlighter-rouge">funcval</code> with a single <code class="language-plaintext highlighter-rouge">int</code> capture; that’s the <code class="language-plaintext highlighter-rouge">{ F uintptr; X0 int }</code> in the code above. It then places the address of <code class="language-plaintext highlighter-rouge">Capture.func1</code>, which implements the callback, into <code class="language-plaintext highlighter-rouge">F</code>, and the argument of <code class="language-plaintext highlighter-rouge">Capture</code> into <code class="language-plaintext highlighter-rouge">X0</code>.</p> <p>What about when returning a reference to a function? In that case, all that happens is it returns a reference to a global containing the address of the function.</p> <div class="code-multicol"> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">foo</span>

<span class="k">func</span> <span class="n">Capture</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Id</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Id</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">foo</span><span class="p">.</span><span class="n">Capture</span><span class="o">:</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="p">]</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="o">:</span>
    <span class="n">ret</span>

<span class="n">foo</span><span class="p">.</span><span class="n">Id</span><span class="err">·</span><span class="n">f</span><span class="o">:</span>
    <span class="p">.</span><span class="n">quad</span> <span class="n">foo</span><span class="p">.</span><span class="n">Id</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> </div> <p>Because we pass the closure arguments in an extra register not used by regular functions, we don’t need to create a thunk for this case.</p> <p>Unfortunately, we do need to create a thunk for methods, even methods with a pointer receiver. This is because of the following incompatible constraints:</p> <ol> <li> <p>The receiver pointer for a method must point exactly to the value the method is called on. It can’t be a fixed offset before, because that would create an out-of-bounds pointer, which the GC does not tolerate.</p> </li> <li> <p>The closure pointer must point to the start of the funcval, <em>not</em> its captures, because adjusting the pointer to point to the captures would cause it to point one-past-the-end of a value, which the GC <em>also</em> does not tolerate!</p> </li> </ol> <p>Thus, <em>even</em> if methods accepted a pointer receiver via <code class="language-plaintext highlighter-rouge">rdx</code>, closures and methods disagree about where that pointer should be passed.</p> <p>Of course, there are adjustments we can make to fix this problem. For example, we could require that all <code class="language-plaintext highlighter-rouge">funcval</code> values have at least one capture. No-capture <code class="language-plaintext highlighter-rouge">funcvals</code> would have a synthetic <code class="language-plaintext highlighter-rouge">_ byte</code> field. This is not unlike how a non-empty struct whose final field is empty will be padded with an extra <code class="language-plaintext highlighter-rouge">_ byte</code> field: this is specifically to avoid a pointer to that field being a past-the-end pointer. The cost is that every non-capturing closure costs twice as much binary size.</p> <p>Another fix is to make the GC blind to the pointer in <code class="language-plaintext highlighter-rouge">rdx</code>. This will never be the only pointer by which a value is reachable, so it would be safe to replace <code class="language-plaintext highlighter-rouge">mov rdx, rax</code> with a <code class="language-plaintext highlighter-rouge">lea rdx, [rax + 8]</code>. The GC would never know!</p> <p>Until then, beware that writing <code class="language-plaintext highlighter-rouge">return foo.Method</code> secretly allocates 16 bytes or so. (Aside: I used to sit next to the Go team at Google, and I remember having a conversation with Austin Clements about this. Apparently I misremembered, because until recently I thought Go already implemented this optimization!)</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>If you made it this far this is probably you right now:</p> <figure> <p><img src="https://mcyoung.xyz/public/images/stickers/dizzy.png" alt="Miguel as a Whimsicott, dizzy with register names."/></p> </figure> <p>This isn’t intended to be as polished as most of my articles, but there’s been enough things I’ve come across that I wanted to write this all up for my own reference.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:constants" role="doc-endnote"> <p><code class="language-plaintext highlighter-rouge">Sizeof</code> and <code class="language-plaintext highlighter-rouge">Alignof</code> are intrinsics, so the compiler will turn them into constants. However, they are only constants if the type being measured is not generic, so wrapping them in a function like this doesn’t actually hurt in generic code. <a href="#fnref:constants" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:gc-programs" role="doc-endnote"> <p>Except for very large types that would have more words than can be recorded by an array of size <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/internal/abi/type.go;l=803;bpv=0"><code class="language-plaintext highlighter-rouge">abi.MaxPtrmaskBytes</code></a>. For larger types, we use GC programs! A GC program is an LZ-compressed bitset serving the same purpose as the pointer bitset most smaller types use. See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/cmd/internal/gcprog/gcprog.go">gcprog.go</a>.</p> <p>In fact, <code class="language-plaintext highlighter-rouge">reflection</code> knows how to create programs on the fly for most types! See <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/reflect/type.go;l=2658">reflect/type.go</a>. <a href="#fnref:gc-programs" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:asm" role="doc-endnote"> <p>I will be writing assembly examples in Intel-syntax x86. Go’s assembly syntax is horrible and an impediment to the point I’m making. <a href="#fnref:asm" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:maybe-update" role="doc-endnote"> <p>Maybe? Well, the cache will only get updated about 0.1% of the time. This is to amortize the costs of growing the cache. I assume they benchmarked this, and found that the cost of growing the cache makes it only worthwhile when that assertion is getting hammered. <a href="#fnref:maybe-update" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-04-08</span> / <h6 style="display:inline"><a href="/2025/04/08/protobuf-tip-1/">Protobuf Tip #1: Field Names Are Forever</a></h6> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> <li> <span class="post-meta">2024-12-16</span> / <h6 style="display:inline"><a href="/2024/12/16/rangefuncs/">Go's Weird Little Iterators</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>