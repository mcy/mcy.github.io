<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Go's Weird Little Iterators &middot; mcyoung </title> <script async src="https://mcyoung.xyz/public/js/redirect.js"></script> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax-overrides.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <link rel="preload" href="https://mcyoung.xyz/public/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/rokkitt-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono.woff2" as="font" type="font/woff2" crossorigin> <link rel="preload" href="https://mcyoung.xyz/public/fonts/spline-mono-italic.woff2" as="font" type="font/woff2" crossorigin> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> <script data-goatcounter="https://mcy.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="Go's Weird Little Iterators &middot; mcyoung"> <meta name="twitter:image" content="https://mcyoung.xyz/og/rangefuncs-a9a49604965667e1a9511a1e9a4d2e0206028a1e.png"> <meta property="og:title" content="Go's Weird Little Iterators &middot; mcyoung"> <meta property="og:type" content="object"> <meta property="og:image" content="https://mcyoung.xyz/og/rangefuncs-a9a49604965667e1a9511a1e9a4d2e0206028a1e.png"> <meta property="og:height" content="630"> <meta property="og:width" content="1200"> <meta property="og:url" content="https://mcyoung.xyz/2024/12/16/rangefuncs/"> </head> <body> <div class="sidebar"> <div class="sidebar-avatar hide-if-mobile"> <a href="https://mcyoung.xyz"> <img class="sidebar-avatar" src="https://mcyoung.xyz/public/images/avatar.png" alt="Yeah, I drew this. Check out my art blog."></a> </div> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz"> mcyoung </a></h1> <div class="lead hide-if-mobile">I'm Miguel. I write about compilers, performance, and silly computer things. I also draw Pokémon. </div> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz">Home</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/about">About</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/posts">Posts</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/tags">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item " href="https://art.mcyoung.xyz">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GitHub</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/resume">Resumé</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/syllabus">Syllabus</a> </nav> <br class="hide-if-mobile"/> <span class="hide-if-mobile"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota</span> </div> </div> <div class="content container"><div class="post-title"> <span class="post-meta"> 2024-12-16 • 3570 words • 29 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/16/rangefuncs/"> Go's Weird Little Iterators </a></h1> </div> <div class="post"> <p>A second post on Go silliness (Miguel, aren’t you a C++ programmer?): in 1.23, Go <em>finally</em> added custom iterators. Now, back when I was at Google and involved in the Go compiler as “the annoying Rust guy who gets lunch with us”, there were proposals suggesting adding something like this, implemented as either an interface or a func:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Iter</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is not what Go did. No, Go did something really weird. And the implementation is <em>incredible</em>.</p> <h2 id="whats-an-iterator"><a href="#whats-an-iterator">What’s an Iterator?</a></h2> <p>An <em>iterator</em>, in the context of programming language design, is a special type of value that can be used to walk through a sequence of values, without necessarily materializing the sequence as whatever the language’s array type is.</p> <p>But, a proper iterator must fit with the language’s looping construct. An <em>iterable type</em> is one which can be used in a for-each loop, such as C++’s <code class="language-plaintext highlighter-rouge">for (T x : y)</code> or Python’s <code class="language-plaintext highlighter-rouge">for x in y</code> (modern languages usually only have a for-each loop as their only <code class="language-plaintext highlighter-rouge">for</code> loop, because C-style for loops are not in anymore).</p> <h3 id="c-iterator-pairs"><a href="#c-iterator-pairs">C++ Iterator Pairs</a></h3> <p>Every language defines a <em>desugaring</em> that defines how custom iteration works in term of the more primitive loops. For example, in C++, when we write <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> (called a <a href="https://en.cppreference.com/w/cpp/language/range-for"><em>range-based for loop</em></a>, added in C++11), desugars as follows<sup id="fnref:cc-range" role="doc-noteref"><a href="#fn:cc-range" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">__range</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">__begin</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span> <span class="c1">// ADL</span>
<span class="k">auto</span> <span class="n">__end</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span>     <span class="c1">// ADL</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">__begin</span> <span class="o">!=</span> <span class="n">__end</span><span class="p">;</span> <span class="o">++</span><span class="n">__begin</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">__begin</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> inside of the loop body require no special handling: they Just Work, because this is just a plain ol for loop.</p> <p>This begin and end weirdness is because, if the iterator backs an actual array, begin and end can just be pointers to the first element and one-past-the-end and this will Just Work. Before C++11, the convention for C++ iterators was to construct types that imitated pointers; you would usually write loops over non-array types like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">things</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">things</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">whatever</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>C++ simply codified common (if gross) practice. It is very tedious to implement C++ iterators, though. You need to provide a dummy end iterator, you need to provide some kind of comparison operator, and iterators that don’t return a reference out of <code class="language-plaintext highlighter-rouge">operator*()</code> are… weird.</p> <p>Begin and end can be different types (which is how C++20 ranges pretend to be iterable), but being able to query done-ness separately from the next value makes implementation annoying: it means that an iterator that has not begun iteration (i.e., <code class="language-plaintext highlighter-rouge">++</code> has not been executed yet, because it occurs in the loop’s latch, not its header<sup id="fnref:loop-jargon" role="doc-noteref"><a href="#fn:loop-jargon" class="footnote" rel="footnote">2</a></sup>) needs to do extra work to answer <code class="language-plaintext highlighter-rouge">!= end</code>, which usually means an extra bool to keep track of whether iteration has started or not.</p> <p>Here’s what writing an iterator (that is also an iterable usable in a range for-loop) over the non-zero elements of a <code class="language-plaintext highlighter-rouge">std::span&lt;const int&gt;</code> might look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">NonZero</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>In this case, <code class="language-plaintext highlighter-rouge">operator==</code> is <em>not</em> <code class="language-plaintext highlighter-rouge">const</code>, which is a bit naughty. Purists might argue that this type should have a constructor, which adjusts <code class="language-plaintext highlighter-rouge">ints</code> to point to the first non-zero element on construction, and <code class="language-plaintext highlighter-rouge">operator++</code> to perform the mutation. That would look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">NonZero</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">NonZero</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">)</span> <span class="o">:</span> <span class="n">ints_</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
  <span class="kt">void</span> <span class="n">skip_zeros</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">std::sentinel_for</code> (C++’s iterator concepts are terribly named) really wants <code class="language-plaintext highlighter-rouge">operator==</code> to be <code class="language-plaintext highlighter-rouge">const</code>, but I could have also just marked <code class="language-plaintext highlighter-rouge">ints</code> as <code class="language-plaintext highlighter-rouge">mutable</code> to avoid that. It it’s not already clear, I really dislike this pattern. See <a href="https://github.com/mcy/best/blob/main/best/iter/iter.h">here</a> for some faffing about with C++ iterators on my part.</p> <h3 id="java-also-got-this-wrong"><a href="#java-also-got-this-wrong">Java Also Got This Wrong</a></h3> <p>At least Java provides a standard iterable interface, thankfully.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">java.util</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
  <span class="no">E</span> <span class="nf">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The desugaring of <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> is then:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">$iter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">$iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span> <span class="o">{</span>
  <span class="no">T</span> <span class="n">x</span> <span class="o">=</span> <span class="n">$iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>Do you see the problem here? Although Java now provides a standard interface, doesn’t require annoying equality comparisons, and doesn’t require an end value, these things are <em>still</em> a pain to implement! You still need to be able to query if you’re done before you’ve had a chance to step through the iterator.</p> <p>Like before, suppose we have an <code class="language-plaintext highlighter-rouge">int[]</code>, and we want to yield every non-zero value in it. How do we construct an iterator for that?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span><span class="o">[]</span> <span class="n">xs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">var</span> <span class="n">it</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">xs</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;</span> <span class="o">!</span><span class="n">done</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{}</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">done</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">hasNext</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">++];</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">done</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">array</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>What a pain. Java’s anonymous classes being wordy aside, it’s annoying and error-prone to do this: it’s tempting to accidentally implement <code class="language-plaintext highlighter-rouge">hasNext</code> by simply checking if the array is empty. (Aside, I hate that <code class="language-plaintext highlighter-rouge">xs.length</code> throws on null arrays. Just return zero like in Go, c’mon).</p> <p>Also, it’s no a single-abstract-method interface, so I can’t use a lambda to create an iterator.</p> <p>At least <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> Just Work, because the underlying operation is a for loop like before.</p> <h3 id="rust-does-it-better"><a href="#rust-does-it-better">Rust Does It Better</a></h3> <p>Rust <em>also</em> has a standard iterable interface.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// mod core::iter</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">IntoIterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">Iter</span><span class="p">:</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">next</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The desugaring for <code class="language-plaintext highlighter-rouge">for x in y { ... }</code> is reasonably straightforward, like in Java:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">__it</span> <span class="o">=</span> <span class="nn">IntoIterator</span><span class="p">::</span><span class="nf">into_iter</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">__it</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is so straightforward that it’s not <em>so</em> unusual to write it yourself, when you don’t plan on consuming the entire iterator. Alternatively, you can partially iterate over an iterator by taking a mutable reference to it. This is useful for iterators that can yield their remainder.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="n">my_slice</span><span class="nf">.chunks_exact</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span> <span class="p">{</span>
  <span class="nf">do_thing</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">do_thing</span><span class="p">(</span><span class="n">it</span><span class="nf">.remainder</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> work in the obvious way.</p> <p>The interface solves the problems C++ and Java had very cleanly: <code class="language-plaintext highlighter-rouge">next</code> both computes the next item and whether the iterator has more elements. Rust even allows iterators to resume yielding <code class="language-plaintext highlighter-rouge">Some</code> after yielding <code class="language-plaintext highlighter-rouge">None</code>, although few algorithms will make use of this.</p> <p>Implementing the non-zero iterator we’ve been writing so far is quite simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">ints</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
  <span class="k">while</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="n">item</span>
<span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this can be written far more simply<sup id="fnref:size_hint" role="doc-noteref"><a href="#fn:size_hint" class="footnote" rel="footnote">3</a></sup> using iterator combinators:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>It requires a little bit of effort to implement some iterators, but most of the common cases are easy to put together with composition.</p> <p>Python iterators are basically the same thing, but there’s no interface to implement (because Python doesn’t believe in type safety). Lua iterators are similar. The Rust pattern of a function that returns the next item (or a special end-of-sequence value) is relatively popular because of this simplicity and composability, and because they can model a lot of iteration strategies.</p> <h2 id="so-what-did-go-do"><a href="#so-what-did-go-do">So, What Did Go Do?</a></h2> <p>Well. Go has a range for syntax like many other languages. The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">y</span> <span class="p">{</span>
  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">x</code> can be a list of places, and the <code class="language-plaintext highlighter-rouge">:=</code> can be plain assignment, <code class="language-plaintext highlighter-rouge">=</code>. You can also write <code class="language-plaintext highlighter-rouge">for range y { ... }</code> if the iteration values aren’t needed.</p> <p>The behavior of this construct, like many others in Go, depends explicitly on the type after <code class="language-plaintext highlighter-rouge">range</code>. Each range iteration can yield zero or more values; the</p> <p>These are:</p> <ol> <li>For <code class="language-plaintext highlighter-rouge">[]T</code>, <code class="language-plaintext highlighter-rouge">[n]T</code>, and <code class="language-plaintext highlighter-rouge">*[n]T</code>, each step yields an index of the slice and the value at that offset, in order.</li> <li>For <code class="language-plaintext highlighter-rouge">map[K]V</code>, each step yields a key and a value, in a random order.</li> <li> <p>For <code class="language-plaintext highlighter-rouge">&lt;- chan T</code>, it desugars into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
 <span class="n">x</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">y</span>
 <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> </li> <li> <p>Starting in Go 1.22, ranging on an integer type would desugar into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> </li> </ol> <p>All of these desugars are essentially still just loops, so <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work as expected.</p> <p>But, how do custom types, like weird map types, implement iteration? The usual<sup id="fnref:chan-iter" role="doc-noteref"><a href="#fn:chan-iter" class="footnote" rel="footnote">4</a></sup> implementation is <a href="https://pkg.go.dev/sync#Map.Range"><code class="language-plaintext highlighter-rouge">sync.Map.Range</code></a>, which looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">Map</span><span class="p">)</span> <span class="n">Range</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="n">any</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This function will call <code class="language-plaintext highlighter-rouge">yield</code> for each element in the map. If the function returns <code class="language-plaintext highlighter-rouge">false</code>, iteration will stop. This pattern is not uncommon, but sometimes libraries omit the <code class="language-plaintext highlighter-rouge">bool</code> return (like <a href="https://pkg.go.dev/container/ring@go1.23.4#Ring.Do"><code class="language-plaintext highlighter-rouge">container/ring.Ring.Do</code></a>). Some, like <a href="https://pkg.go.dev/path/filepath#WalkFunc"><code class="language-plaintext highlighter-rouge">filepath.WalkDir</code></a>, have a more complex interface involving errors.</p> <p>This is the template for what became <em>rangefuncs</em>, a mechanism for using the for-range syntax with certain function values.</p> <h2 id="rangefuncs"><a href="#rangefuncs">Rangefuncs</a></h2> <p>The word “rangefunc” does not appear in Go’s specification. It is a term used to refer to them in some documentation, within the compiler, and in the runtime.</p> <p>A rangefunc is any function with one of the following signatures:</p> <ul> <li><code class="language-plaintext highlighter-rouge">func(yield func() bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(V) bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(K, V) bool)</code></li> </ul> <p>They work like <code class="language-plaintext highlighter-rouge">sync.Map.Range</code> does: the function calls <code class="language-plaintext highlighter-rouge">yield</code> (hereafter simply called “the yield”) for each element, and stops early if yield returns false. The <code class="language-plaintext highlighter-rouge">iter</code> package contains types for the second and third of these:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="k">type</span> <span class="n">Seq2</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>For example, the <code class="language-plaintext highlighter-rouge">slices</code> package provides an adaptor for converting a slice into an iterator that ranges over it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="c">// All returns an iterator over index-value pairs in the slice</span>
<span class="c">// in the usual order.</span>
<span class="k">func</span> <span class="n">All</span><span class="p">[</span><span class="n">Slice</span> <span class="err">~</span><span class="p">[]</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="n">Slice</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
			<span class="k">if</span> <span class="o">!</span><span class="n">yield</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>So. These things are actually pretty nuts. They break my brain somewhat, because this is the opposite of how iterators usually work. Go calls what I’ve described all the other languages do a “pull iterator”, whereas rangefuncs are “push iterators”.</p> <p>They have a few obvious limitations. For one, you can’t do smart sizing like with Rust or C++ iterators<sup id="fnref:size-hint2" role="doc-noteref"><a href="#fn:size-hint2" class="footnote" rel="footnote">5</a></sup>. Another is that you can’t easily “pause” iteration.</p> <p>But they do have one advantage, which I think is the real reason Go went to so much trouble to implement them (and yes, I will dig into how insane that part is). Using push iterators by default means that users “only” need to write an ordinary for loop packaged into a function. Given that Go makes major performance sacrifices in order to be easy to learn<sup id="fnref:tooling" role="doc-noteref"><a href="#fn:tooling" class="footnote" rel="footnote">6</a></sup>, trying to make it so that an iterator packages the actual looping construct it represents makes quite a bit of sense.</p> <p>Rangefuncs are actually really cool in some respects, because they enable unusual patterns. For example, you can use a rangefunc to provide RAII blocks.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Open</span><span class="p">(</span><span class="n">fs</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">,</span> <span class="n">path</span> <span class="kt">string</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fs</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="p">{</span>
      <span class="n">yield</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="n">yield</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">DirFS</span><span class="p">(</span><span class="s">"/"</span><span class="p">),</span> <span class="s">"etc/passwd"</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Being a block that you can put an epilog onto after yielding a single element is quite powerful! You can also use a nilary rangefunc to simply create a block that you can break out of, instead of having to use <code class="language-plaintext highlighter-rouge">goto</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Once</span><span class="p">()</span> <span class="k">func</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="k">range</span> <span class="n">Once</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">canDo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">break</span>
  <span class="p">}</span>

  <span class="n">do</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>So wait. You can return out of rangefunc loops. That means that… Go has non-local returns?!</p> <h2 id="go-now-has-non-local-returns"><a href="#go-now-has-non-local-returns">Go Now Has Non-Local Returns</a></h2> <p>The desugaring for rangefuncs is very complicated. This is because <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work in a rangefunc! How does this work? Let’s Godbolt it.</p> <p>Let’s start with something really basic: a loop body that just calls a function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This produces the following assembly output (which I’ve reformatted into Intel syntax, and removed some extraneous ABI things, including a writer barrier where <code class="language-plaintext highlighter-rouge">(*)</code> is below).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>  <span class="c1">// (*)</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">api</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic2</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>This is a lot to take in, but if we look carefully, we decompile this function into a Go function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c">// Loop body</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Go will actually enforce invariants on the yield it synthesizes in a range for, in order to catch buggy code. In particular, <code class="language-plaintext highlighter-rouge">__state</code> escapes because <code class="language-plaintext highlighter-rouge">s</code> is an arbitrary function, so it gets spilled to the heap.</p> <p>So, what happens when the loop body contains a break? Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>I’ll spare you the assembly listing, since it’s very similar, so I’ll just reverse-engineer the output directly:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Non-local returns are much more complicated. Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The resulting assembly is something like this, with some irrelevant code, such as write barriers, removed:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int; X1 *int; X2 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rdi</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">jne</span>     <span class="n">resume</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">resume</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">test</span>    <span class="n">al</span><span class="p">,</span> <span class="n">al</span>
    <span class="n">jeq</span>     <span class="n">cont</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_DONE</span>
    <span class="n">xor</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">cont</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>Try to reverse engineer this yourself, if you like! If you write this out as Go, here’s what you get:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">(</span><span class="n">__ret</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">__next</span> <span class="kt">int</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="n">__next</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
      <span class="n">__ret</span> <span class="o">=</span> <span class="n">v</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
  <span class="k">if</span> <span class="n">__next</span> <span class="o">==</span> <span class="o">-</span><span class="m">1</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The reason <code class="language-plaintext highlighter-rouge">__next</code> is an int is because it is also used when exiting the loop via <code class="language-plaintext highlighter-rouge">goto</code> or a <code class="language-plaintext highlighter-rouge">break</code>/<code class="language-plaintext highlighter-rouge">continue</code> with label. It specifies where to jump to after the call into the rangefunc returns. Each potential control flow out of the loop is assigned some negative number.</p> <p>The precise details of the lowering have been <a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/rangefunc/rewrite.go">exquisitely documented</a> by Russ Cox and David Chase, the primary implementers of the feature.</p> <p>You might be curious what <code class="language-plaintext highlighter-rouge">runtime.panicrangestate</code> does. It’s pretty simple, and it lives in <code class="language-plaintext highlighter-rouge">runtime/panic.go</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="c">//go:noinline</span>
<span class="k">func</span> <span class="n">panicrangestate</span><span class="p">(</span><span class="n">state</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_State</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeDoneError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangePanicError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeExhaustedError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_MISSING_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeMissingPanicError</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">throw</span><span class="p">(</span><span class="s">"unexpected state passed to panicrangestate"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If you visit this function in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/panic.go;l=306?q=panicrangestate&amp;ss=go%2Fgo">runtime/panic.go</a>, you will be greeted by this extremely terrifying comment from Russ Cox immediately after it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// deferrangefunc is called by functions that are about to</span>
<span class="c">// execute a range-over-function loop in which the loop body</span>
<span class="c">// may execute a defer statement. That defer needs to add to</span>
<span class="c">// the chain for the current function, not the func literal synthesized</span>
<span class="c">// to represent the loop body. To do that, the original function</span>
<span class="c">// calls deferrangefunc to obtain an opaque token representing</span>
<span class="c">// the current frame, and then the loop body uses deferprocat</span>
<span class="c">// instead of deferproc to add to that frame's defer lists.</span>
<span class="c">//</span>
<span class="c">// The token is an 'any' with underlying type *atomic.Pointer[_defer].</span>
<span class="c">// It is the atomically-updated head of a linked list of _defer structs</span>
<span class="c">// representing deferred calls. At the same time, we create a _defer</span>
<span class="c">// struct on the main g._defer list with d.head set to this head pointer.</span>
<span class="c">//</span>
<span class="c">// The g._defer list is now a linked list of deferred calls,</span>
<span class="c">// but an atomic list hanging off:</span>
<span class="c">//</span>
<span class="c">// (increasingly terrifying discussion of concurrent data structures)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This raises one more thing that works in range funcs, seamlessly: <code class="language-plaintext highlighter-rouge">defer</code>. Yes, despite the yield executing multiple call stacks away, possibly on a different goroutine… <code class="language-plaintext highlighter-rouge">defer</code> still gets attached to the calling function.</p> <h2 id="go-now-has-non-local-defer"><a href="#go-now-has-non-local-defer">Go Now Has Non-Local Defer</a></h2> <p>The way defer works is that each G (the goroutine struct, <code class="language-plaintext highlighter-rouge">runtime.g</code>) holds a linked list of defer records, of type <code class="language-plaintext highlighter-rouge">_defer</code>. Each call to <code class="language-plaintext highlighter-rouge">defer</code> sticks one of these onto this list. On function return, Go calls <code class="language-plaintext highlighter-rouge">runtime.deferreturn()</code>, which essentially executes and pops defers off of the list until it finds one whose stack pointer is not the current function’s stack pointer (so, it must belong to another function).</p> <p>Rangefuncs throw a wrench in that mix: if <code class="language-plaintext highlighter-rouge">myFunc.range-n</code> defers, that defer has to be attached to <code class="language-plaintext highlighter-rouge">myFunc</code>’s defer records somehow. So the list must have a way of inserting in the middle.</p> <p>This is what this comment is about: when <code class="language-plaintext highlighter-rouge">defer</code> occurs in the loop body, that defer gets attached to a defer record for that function, using a token that the yield captures; this is later canonicalized when walking the defer list on the way out of <code class="language-plaintext highlighter-rouge">myFunc</code>. Because the yield can escape onto another goroutine, this part of the <code class="language-plaintext highlighter-rouge">defer</code> chain has to be atomic.</p> <p>Incredibly, this approach is extremely robust. For example, if we spawn the yield as a goroutine, and carefully synchronize between that and the outer function, we can force the runtime to hard-crash when <code class="language-plaintext highlighter-rouge">defer</code>ing to a function that has returned.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">bad</span><span class="p">()</span> <span class="p">(</span><span class="n">out</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="n">w1</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="n">w2</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>

	<span class="n">out</span> <span class="o">=</span> <span class="n">w2</span><span class="o">.</span><span class="n">Done</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">recover</span><span class="p">()</span> <span class="p">}()</span>
	<span class="n">iter</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">yield</span><span class="p">()</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait to enter yield().</span>
    <span class="c">// This panics once w1.Done() executes, because</span>
    <span class="c">// we exit the rangefunc while yield() is still</span>
    <span class="c">// running. The runtime incorrectly attributes</span>
    <span class="c">// this to recovering in the rangefunc.</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="k">range</span> <span class="n">iter</span> <span class="p">{</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="c">// Allow the outer function to exit the loop.</span>
		<span class="n">w2</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait for bad() to return.</span>
		<span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"bang"</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="k">return</span> <span class="no">nil</span> <span class="c">// Unreachable</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">resume</span> <span class="o">:=</span> <span class="n">bad</span><span class="p">()</span>
  <span class="n">resume</span><span class="p">()</span>
  <span class="k">select</span> <span class="p">{}</span>  <span class="c">// Block til crash.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This gets us <code class="language-plaintext highlighter-rouge">fatal error: defer after range func returned</code>. Pretty sick! It accomplishes this by poisoning the token the yield func uses to defer.</p> <p>I have tried various other attempts at causing memory unsafety with rangefuncs, but Go actually does a really good job of avoiding this. The only thing I’ve managed to do that’s especially interesting is to tear the return slot on a function without named returns, but that’s no worse than tearing any other value (which is still really bad, because you can tear interface values, but it’s not <em>worse</em>).</p> <h2 id="pull-iterators-and-coroutines"><a href="#pull-iterators-and-coroutines">Pull Iterators and Coroutines</a></h2> <p>Of course we’re not done. Go provides a mechanism for converting push iterators into pull iterators. Essentially, there is a function that looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">yield</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">})</span>
  <span class="n">pull</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}{})</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">seq</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">pull</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">yield</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">}{</span><span class="n">v</span><span class="p">,</span> <span class="no">true</span><span class="p">}</span>
    <span class="p">})</span>

    <span class="nb">close</span><span class="p">(</span><span class="n">yield</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pull</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="n">yield</span>
  <span class="p">}</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">close</span><span class="p">(</span><span class="n">pull</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Essentially, you can request values with <code class="language-plaintext highlighter-rouge">next()</code>, and <code class="language-plaintext highlighter-rouge">stop()</code> can be used if you finish early. But also, this spawns a whole goroutine and uses channels to communicate and synchronize, which feels very unnecessary.</p> <p>The implementation doesn’t use goroutines. It uses coroutines.</p> <h3 id="giving-up-on-goroutines"><a href="#giving-up-on-goroutines">Giving Up on Goroutines</a></h3> <p>Spawning a goroutine is expensive. Doing so expends scheduler and memory resources. It’s overkill for a helper like this (ironic, because the original premise of Go was that goroutines would be cheap enough to allocate willy-nilly).</p> <p>Go instead implements this using “coroutines”, a mechanism for concurrency without parallelism. This is intended to make context switching very cheap, because it does not need to go through the scheduler: instead, it uses cooperative multitasking.</p> <p>The coroutine interface is something like the following. My “userland” implementation will not be very efficient, because it relies on the scheduler to transfer control. The goroutines may run on different CPUs, so synchronization is necessary for communication, even if they are not running concurrently.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">coro</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"runtime"</span>
  <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Coro</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">m</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="o">*</span><span class="n">Coro</span> <span class="p">{</span>
  <span class="n">c</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Coro</span><span class="p">)</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">f</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Coro</span><span class="p">)</span> <span class="n">Resume</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>When we create a coroutine with <code class="language-plaintext highlighter-rouge">coro.New()</code>, it spawns a goroutine that waits on a mutex. Another goroutine can “take its place” as the mutex holder by calling <code class="language-plaintext highlighter-rouge">c.Resume()</code>, which allows the coroutine spawned by <code class="language-plaintext highlighter-rouge">coro.New</code> to resume and enter <code class="language-plaintext highlighter-rouge">f()</code>.</p> <p>Using the coroutine as a rendezvous point, two goroutines can perform concurrent work: in the case of <code class="language-plaintext highlighter-rouge">iter.Pull</code>, one can be deep inside of whatever loops the iterator wants to do, and the other can request values.</p> <p>Here’s what using my <code class="language-plaintext highlighter-rouge">coro.Coro</code> to implement <code class="language-plaintext highlighter-rouge">iter.Pull</code> might look like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">var</span> <span class="p">(</span>
    <span class="n">done</span> <span class="kt">bool</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">z</span> <span class="n">V</span>
  <span class="p">)</span>

  <span class="n">c</span> <span class="o">:=</span> <span class="n">coro</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v1</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Wait for a request for a value.</span>
      <span class="k">if</span> <span class="n">done</span> <span class="p">{</span>
        <span class="c">// This means we resumed from stop(). Break out of the</span>
        <span class="c">// loop.</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">v1</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
      <span class="c">// Yield the last value.</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">z</span>
    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
  <span class="p">})</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="no">false</span> <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>      <span class="c">// Request a value.</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="no">true</span>  <span class="c">// Return it.</span>
  <span class="p">}</span>

  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span> <span class="c">// Mark iteration as complete.</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Resume the iteration goroutine to it can exit.</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">next</span><span class="p">,</span> <span class="n">stop</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If you look at the implementation in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/iter/iter.go"><code class="language-plaintext highlighter-rouge">iter.go</code></a>, it’s basically this, but with a lot of error checking and race detection, to prevent misuse, such as if <code class="language-plaintext highlighter-rouge">next</code> or <code class="language-plaintext highlighter-rouge">stop</code> escape to other goroutines.</p> <p>Now, the main thing that runtime support brings here is that <code class="language-plaintext highlighter-rouge">Resume()</code> is immediate: it does not go to the scheduler, which might not decide to immediately run the goroutine that last called <code class="language-plaintext highlighter-rouge">Resume()</code> for a variety of reasons (for example, to ensure wakeup fairness). Coroutines sidestep fairness, by making <code class="language-plaintext highlighter-rouge">Resume()</code> little more than a jump to the last <code class="language-plaintext highlighter-rouge">Resume()</code> (with registers fixed up accordingly).</p> <p>This is not going to be <em>that</em> cheap: a goroutine still needs to be allocated, and switching needs to poke and prod the underlying Gs a little bit. But it’s a cool optimization, and I hope coroutines eventually make their way into more things in Go, hopefully as a language or <code class="language-plaintext highlighter-rouge">sync</code> primitive.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Congratulations, you have survived over 3000 words of me going on about iterators. Go’s push iterators are a unique approach to a common language design problem (even if it took a decade for them to materialize).</p> <p>I encountered rangefuncs for the first time earlier this year and have found them absolutely fascinating, both from a “oh my god they actually did that” perspective and from a “how do we express iteration” perspective. I don’t think the result was perfect by any means, and it is unsuitable for languages that need the performance you can only get from pull iterators. I think they would be a great match for a language like Python or Java, though.</p> <p>I’d like to thank David Chase, an old colleague, for tolerating my excited contrived questions about the guts of this feature.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:cc-range" role="doc-endnote"> <p>Ugh, ok. This is the C++20 desugaring, and there are cases where we do not just call <code class="language-plaintext highlighter-rouge">std::begin()</code>. In particular, array references and class type references with <code class="language-plaintext highlighter-rouge">.begin()</code> and <code class="language-plaintext highlighter-rouge">.end()</code> do not call <code class="language-plaintext highlighter-rouge">std::begin()</code> and are open-coded. This means that you can’t use ADL to override these types’ iterator. <a href="#fnref:cc-range" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:loop-jargon" role="doc-endnote"> <p>In compiler jargon, a loop is broken up into three parts: the <em>header</em>, which is where the loop is entered, the <em>body</em>, which is one step of iteration, and the <em>latch</em>, which is the part that jumps back to the start of the body. This is where incrementation in a C-style for loop happens. <a href="#fnref:loop-jargon" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size_hint" role="doc-endnote"> <p>And with better performance. Rust’s iterators can provide a size hint to help size containers before a call to <code class="language-plaintext highlighter-rouge">collect()</code>, via the <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code class="language-plaintext highlighter-rouge">FromIterator</code></a> trait. <a href="#fnref:size_hint" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:chan-iter" role="doc-endnote"> <p>Some people observed that you can use a channel as a custom iterator, by having a parallel goroutine run a for loop to feed the channel. <em>Do not do this.</em> It is slow: it has to transit each element through the heap, forcing anything it points to escape. It takes up an extra M and a P in the scheduler, and requires potentially allocating a stack for a G. It’s probably faster to just build a slice and return that, especially for small iterations. <a href="#fnref:chan-iter" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size-hint2" role="doc-endnote"> <p>For this reason, I wish that Go had instead defined something along these lines.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Iterate</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is functionally identical to what they did, but it would have permitted future extensions such as the following interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">SizedSeq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">]</span>

  <span class="n">SizeHint</span><span class="p">()</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="kt">int64</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This would mean that <code class="language-plaintext highlighter-rouge">slices.Collect</code> could be enhanced into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="k">func</span> <span class="n">Collect</span><span class="p">[</span><span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="n">E</span><span class="p">])</span> <span class="p">[]</span><span class="n">E</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">out</span> <span class="p">[]</span><span class="n">E</span>
  <span class="k">if</span> <span class="n">sized</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">seq</span><span class="o">.</span><span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">SizedSeq</span><span class="p">[</span><span class="n">E</span><span class="p">]);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">sized</span><span class="o">.</span><span class="n">SizeHint</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">E</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">seq</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">out</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>I don’t think there’s an easy way to patch this up, at this point. <a href="#fnref:size-hint2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:tooling" role="doc-endnote"> <p>Disclaimer: I am not going to dig into Go’s rationale for rangefuncs. Knowing how the sausage is made, most big Go proposals are a mix of understandable reasoning and less reasonable veiled post-hoc justification to compensate for either Google planning/approvals weirdness or because the design was some principal engineer’s pony. This isn’t even a Go thing, it’s a Google culture problem. I say this as the architect of <a href="https://protobuf.dev/editions/overview">Protobuf Editions</a>, the biggest change to Protobuf since Rob’s misguided proto3<sup id="fnref:proto2" role="doc-noteref"><a href="#fn:proto2" class="footnote" rel="footnote">7</a></sup> experiment. <em>I</em> have written this kind of language proposal, on purpose, because bad culture mandated it.</p> <p><em>The purpose of a system is what it does.</em> It is easier to understand a system by observing its response to stimuli, rather than what it says on the tin. So let’s use that lens.</p> <p>Go wants to be easy to learn. It intended to replace C++ at Google (lol, lmao), which, of course, failed disastrously, because performance of the things already written in C++ is tied to revenue. They have successfully pivoted to being an easy-to-learn language that makes it easy to onboard programmers regardless of what they already use, as opposed to onboarding them to C++.</p> <p>This does not mean that Go is user-friendly. In fact, user-friendliness is clearly not a core value. Rob and his greybeard crowd didn’t seem to care about the human aspect of interacting with a toolchain, so Go tooling rarely provides good diagnostics, nor did the language, until the last few years, try to reduce toil. After all, if it is tedious to use but simple, that does make it easy to onboard new programmers.</p> <p>Rust is the opposite: it is very difficult to learn with a famously steep learning curve; however, it is very accessible, because the implementors have sanded down every corner and sharp edge using diagnostics, error messages, and tooling. C++ is neither of these things. It is very difficult to learn, and most compilers are pretty unhelpful (if they diagnose anything at all).</p> <p>I think that Go has at least realized the language can be a pain to use in some situations, which is fueled in part by legitimate UX research. This is why Go has generics and other recent advanced language features, like being able to use the <code class="language-plaintext highlighter-rouge">for</code> syntax with integers or with custom iterators.</p> <p>I think that rangefuncs are easy to learn in the way Go needs them to be. If you expect more users to want to write rangefuncs than users want to write complicated <em>uses</em> of rangefuncs, I think push iterators are the easiest to learn how to use.</p> <p>I think this is a much more important reason for all the trouble that rangefuncs generate for the compiler and runtime than, say, compatibility with existing code; I have not seen many cases in the wild or in the standard library that conform to the rangefunc signatures. <a href="#fnref:tooling" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:proto2" role="doc-endnote"> <p>But please don’t use proto3. I’m telling you that as the guy who maintained the compiler. Just don’t. <a href="#fnref:proto2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-04-14</span> / <h6 style="display:inline"><a href="/2025/04/14/target-triples/">What the Hell Is a Target Triple?</a></h6> <li> <span class="post-meta">2025-04-08</span> / <h6 style="display:inline"><a href="/2025/04/08/protobuf-tip-1/">Protobuf Tip #1: Field Names Are Forever</a></h6> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post-title"> <span class="post-meta"> 2024-12-16 • 3570 words • 29 minutes <br class="show-if-mobile"/> <span class="hide-if-mobile">•</span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> • <a href="https://mcyoung.xyz/tags.html#go">#go</a> </span> <h1><a href="/2024/12/16/rangefuncs/"> Go's Weird Little Iterators </a></h1> </div> <div class="post"> <p>A second post on Go silliness (Miguel, aren’t you a C++ programmer?): in 1.23, Go <em>finally</em> added custom iterators. Now, back when I was at Google and involved in the Go compiler as “the annoying Rust guy who gets lunch with us”, there were proposals suggesting adding something like this, implemented as either an interface or a func:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Iter</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is not what Go did. No, Go did something really weird. And the implementation is <em>incredible</em>.</p> <h2 id="whats-an-iterator"><a href="#whats-an-iterator">What’s an Iterator?</a></h2> <p>An <em>iterator</em>, in the context of programming language design, is a special type of value that can be used to walk through a sequence of values, without necessarily materializing the sequence as whatever the language’s array type is.</p> <p>But, a proper iterator must fit with the language’s looping construct. An <em>iterable type</em> is one which can be used in a for-each loop, such as C++’s <code class="language-plaintext highlighter-rouge">for (T x : y)</code> or Python’s <code class="language-plaintext highlighter-rouge">for x in y</code> (modern languages usually only have a for-each loop as their only <code class="language-plaintext highlighter-rouge">for</code> loop, because C-style for loops are not in anymore).</p> <h3 id="c-iterator-pairs"><a href="#c-iterator-pairs">C++ Iterator Pairs</a></h3> <p>Every language defines a <em>desugaring</em> that defines how custom iteration works in term of the more primitive loops. For example, in C++, when we write <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> (called a <a href="https://en.cppreference.com/w/cpp/language/range-for"><em>range-based for loop</em></a>, added in C++11), desugars as follows<sup id="fnref:cc-range" role="doc-noteref"><a href="#fn:cc-range" class="footnote" rel="footnote">1</a></sup>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">__range</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">__begin</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span> <span class="c1">// ADL</span>
<span class="k">auto</span> <span class="n">__end</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">__range</span><span class="p">);</span>     <span class="c1">// ADL</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">__begin</span> <span class="o">!=</span> <span class="n">__end</span><span class="p">;</span> <span class="o">++</span><span class="n">__begin</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">__begin</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> inside of the loop body require no special handling: they Just Work, because this is just a plain ol for loop.</p> <p>This begin and end weirdness is because, if the iterator backs an actual array, begin and end can just be pointers to the first element and one-past-the-end and this will Just Work. Before C++11, the convention for C++ iterators was to construct types that imitated pointers; you would usually write loops over non-array types like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">things</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">things</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">whatever</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>C++ simply codified common (if gross) practice. It is very tedious to implement C++ iterators, though. You need to provide a dummy end iterator, you need to provide some kind of comparison operator, and iterators that don’t return a reference out of <code class="language-plaintext highlighter-rouge">operator*()</code> are… weird.</p> <p>Begin and end can be different types (which is how C++20 ranges pretend to be iterable), but being able to query done-ness separately from the next value makes implementation annoying: it means that an iterator that has not begun iteration (i.e., <code class="language-plaintext highlighter-rouge">++</code> has not been executed yet, because it occurs in the loop’s latch, not its header<sup id="fnref:loop-jargon" role="doc-noteref"><a href="#fn:loop-jargon" class="footnote" rel="footnote">2</a></sup>) needs to do extra work to answer <code class="language-plaintext highlighter-rouge">!= end</code>, which usually means an extra bool to keep track of whether iteration has started or not.</p> <p>Here’s what writing an iterator (that is also an iterable usable in a range for-loop) over the non-zero elements of a <code class="language-plaintext highlighter-rouge">std::span&lt;const int&gt;</code> might look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">NonZero</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>In this case, <code class="language-plaintext highlighter-rouge">operator==</code> is <em>not</em> <code class="language-plaintext highlighter-rouge">const</code>, which is a bit naughty. Purists might argue that this type should have a constructor, which adjusts <code class="language-plaintext highlighter-rouge">ints</code> to point to the first non-zero element on construction, and <code class="language-plaintext highlighter-rouge">operator++</code> to perform the mutation. That would look like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">NonZero</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">NonZero</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">)</span> <span class="o">:</span> <span class="n">ints_</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">auto</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sentinel</span><span class="p">{};</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">sentinel</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">sentinel</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">NonZero</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">skip_zeros</span><span class="p">();</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">NonZero</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">struct</span> <span class="nc">sentinel</span><span class="p">{};</span>
  <span class="kt">void</span> <span class="n">skip_zeros</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ints</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">subspan</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p><code class="language-plaintext highlighter-rouge">std::sentinel_for</code> (C++’s iterator concepts are terribly named) really wants <code class="language-plaintext highlighter-rouge">operator==</code> to be <code class="language-plaintext highlighter-rouge">const</code>, but I could have also just marked <code class="language-plaintext highlighter-rouge">ints</code> as <code class="language-plaintext highlighter-rouge">mutable</code> to avoid that. It it’s not already clear, I really dislike this pattern. See <a href="https://github.com/mcy/best/blob/main/best/iter/iter.h">here</a> for some faffing about with C++ iterators on my part.</p> <h3 id="java-also-got-this-wrong"><a href="#java-also-got-this-wrong">Java Also Got This Wrong</a></h3> <p>At least Java provides a standard iterable interface, thankfully.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">java.util</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
  <span class="no">E</span> <span class="nf">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The desugaring of <code class="language-plaintext highlighter-rouge">for (T x : y) { ... }</code> is then:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">$iter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">$iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span> <span class="o">{</span>
  <span class="no">T</span> <span class="n">x</span> <span class="o">=</span> <span class="n">$iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>Do you see the problem here? Although Java now provides a standard interface, doesn’t require annoying equality comparisons, and doesn’t require an end value, these things are <em>still</em> a pain to implement! You still need to be able to query if you’re done before you’ve had a chance to step through the iterator.</p> <p>Like before, suppose we have an <code class="language-plaintext highlighter-rouge">int[]</code>, and we want to yield every non-zero value in it. How do we construct an iterator for that?</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">int</span><span class="o">[]</span> <span class="n">xs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">var</span> <span class="n">it</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">xs</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;</span> <span class="o">!</span><span class="n">done</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{}</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">done</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">hasNext</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">++];</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">done</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">array</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">};</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>What a pain. Java’s anonymous classes being wordy aside, it’s annoying and error-prone to do this: it’s tempting to accidentally implement <code class="language-plaintext highlighter-rouge">hasNext</code> by simply checking if the array is empty. (Aside, I hate that <code class="language-plaintext highlighter-rouge">xs.length</code> throws on null arrays. Just return zero like in Go, c’mon).</p> <p>Also, it’s no a single-abstract-method interface, so I can’t use a lambda to create an iterator.</p> <p>At least <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> Just Work, because the underlying operation is a for loop like before.</p> <h3 id="rust-does-it-better"><a href="#rust-does-it-better">Rust Does It Better</a></h3> <p>Rust <em>also</em> has a standard iterable interface.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// mod core::iter</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">IntoIterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">type</span> <span class="n">Iter</span><span class="p">:</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">next</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The desugaring for <code class="language-plaintext highlighter-rouge">for x in y { ... }</code> is reasonably straightforward, like in Java:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">__it</span> <span class="o">=</span> <span class="nn">IntoIterator</span><span class="p">::</span><span class="nf">into_iter</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">__it</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is so straightforward that it’s not <em>so</em> unusual to write it yourself, when you don’t plan on consuming the entire iterator. Alternatively, you can partially iterate over an iterator by taking a mutable reference to it. This is useful for iterators that can yield their remainder.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="n">my_slice</span><span class="nf">.chunks_exact</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span> <span class="p">{</span>
  <span class="nf">do_thing</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">do_thing</span><span class="p">(</span><span class="n">it</span><span class="nf">.remainder</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, and <code class="language-plaintext highlighter-rouge">return</code> work in the obvious way.</p> <p>The interface solves the problems C++ and Java had very cleanly: <code class="language-plaintext highlighter-rouge">next</code> both computes the next item and whether the iterator has more elements. Rust even allows iterators to resume yielding <code class="language-plaintext highlighter-rouge">Some</code> after yielding <code class="language-plaintext highlighter-rouge">None</code>, although few algorithms will make use of this.</p> <p>Implementing the non-zero iterator we’ve been writing so far is quite simple:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">ints</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
  <span class="k">while</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
  <span class="n">item</span>
<span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>However, this can be written far more simply<sup id="fnref:size_hint" role="doc-noteref"><a href="#fn:size_hint" class="footnote" rel="footnote">3</a></sup> using iterator combinators:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">ints</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>It requires a little bit of effort to implement some iterators, but most of the common cases are easy to put together with composition.</p> <p>Python iterators are basically the same thing, but there’s no interface to implement (because Python doesn’t believe in type safety). Lua iterators are similar. The Rust pattern of a function that returns the next item (or a special end-of-sequence value) is relatively popular because of this simplicity and composability, and because they can model a lot of iteration strategies.</p> <h2 id="so-what-did-go-do"><a href="#so-what-did-go-do">So, What Did Go Do?</a></h2> <p>Well. Go has a range for syntax like many other languages. The syntax looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">y</span> <span class="p">{</span>
  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">x</code> can be a list of places, and the <code class="language-plaintext highlighter-rouge">:=</code> can be plain assignment, <code class="language-plaintext highlighter-rouge">=</code>. You can also write <code class="language-plaintext highlighter-rouge">for range y { ... }</code> if the iteration values aren’t needed.</p> <p>The behavior of this construct, like many others in Go, depends explicitly on the type after <code class="language-plaintext highlighter-rouge">range</code>. Each range iteration can yield zero or more values; the</p> <p>These are:</p> <ol> <li>For <code class="language-plaintext highlighter-rouge">[]T</code>, <code class="language-plaintext highlighter-rouge">[n]T</code>, and <code class="language-plaintext highlighter-rouge">*[n]T</code>, each step yields an index of the slice and the value at that offset, in order.</li> <li>For <code class="language-plaintext highlighter-rouge">map[K]V</code>, each step yields a key and a value, in a random order.</li> <li> <p>For <code class="language-plaintext highlighter-rouge">&lt;- chan T</code>, it desugars into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
 <span class="n">x</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">y</span>
 <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> </li> <li> <p>Starting in Go 1.22, ranging on an integer type would desugar into</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
 <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> </li> </ol> <p>All of these desugars are essentially still just loops, so <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work as expected.</p> <p>But, how do custom types, like weird map types, implement iteration? The usual<sup id="fnref:chan-iter" role="doc-noteref"><a href="#fn:chan-iter" class="footnote" rel="footnote">4</a></sup> implementation is <a href="https://pkg.go.dev/sync#Map.Range"><code class="language-plaintext highlighter-rouge">sync.Map.Range</code></a>, which looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">Map</span><span class="p">)</span> <span class="n">Range</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="n">any</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This function will call <code class="language-plaintext highlighter-rouge">yield</code> for each element in the map. If the function returns <code class="language-plaintext highlighter-rouge">false</code>, iteration will stop. This pattern is not uncommon, but sometimes libraries omit the <code class="language-plaintext highlighter-rouge">bool</code> return (like <a href="https://pkg.go.dev/container/ring@go1.23.4#Ring.Do"><code class="language-plaintext highlighter-rouge">container/ring.Ring.Do</code></a>). Some, like <a href="https://pkg.go.dev/path/filepath#WalkFunc"><code class="language-plaintext highlighter-rouge">filepath.WalkDir</code></a>, have a more complex interface involving errors.</p> <p>This is the template for what became <em>rangefuncs</em>, a mechanism for using the for-range syntax with certain function values.</p> <h2 id="rangefuncs"><a href="#rangefuncs">Rangefuncs</a></h2> <p>The word “rangefunc” does not appear in Go’s specification. It is a term used to refer to them in some documentation, within the compiler, and in the runtime.</p> <p>A rangefunc is any function with one of the following signatures:</p> <ul> <li><code class="language-plaintext highlighter-rouge">func(yield func() bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(V) bool)</code></li> <li><code class="language-plaintext highlighter-rouge">func(yield func(K, V) bool)</code></li> </ul> <p>They work like <code class="language-plaintext highlighter-rouge">sync.Map.Range</code> does: the function calls <code class="language-plaintext highlighter-rouge">yield</code> (hereafter simply called “the yield”) for each element, and stops early if yield returns false. The <code class="language-plaintext highlighter-rouge">iter</code> package contains types for the second and third of these:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="k">type</span> <span class="n">Seq2</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>For example, the <code class="language-plaintext highlighter-rouge">slices</code> package provides an adaptor for converting a slice into an iterator that ranges over it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="c">// All returns an iterator over index-value pairs in the slice</span>
<span class="c">// in the usual order.</span>
<span class="k">func</span> <span class="n">All</span><span class="p">[</span><span class="n">Slice</span> <span class="err">~</span><span class="p">[]</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">s</span> <span class="n">Slice</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
			<span class="k">if</span> <span class="o">!</span><span class="n">yield</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>So. These things are actually pretty nuts. They break my brain somewhat, because this is the opposite of how iterators usually work. Go calls what I’ve described all the other languages do a “pull iterator”, whereas rangefuncs are “push iterators”.</p> <p>They have a few obvious limitations. For one, you can’t do smart sizing like with Rust or C++ iterators<sup id="fnref:size-hint2" role="doc-noteref"><a href="#fn:size-hint2" class="footnote" rel="footnote">5</a></sup>. Another is that you can’t easily “pause” iteration.</p> <p>But they do have one advantage, which I think is the real reason Go went to so much trouble to implement them (and yes, I will dig into how insane that part is). Using push iterators by default means that users “only” need to write an ordinary for loop packaged into a function. Given that Go makes major performance sacrifices in order to be easy to learn<sup id="fnref:tooling" role="doc-noteref"><a href="#fn:tooling" class="footnote" rel="footnote">6</a></sup>, trying to make it so that an iterator packages the actual looping construct it represents makes quite a bit of sense.</p> <p>Rangefuncs are actually really cool in some respects, because they enable unusual patterns. For example, you can use a rangefunc to provide RAII blocks.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Open</span><span class="p">(</span><span class="n">fs</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">,</span> <span class="n">path</span> <span class="kt">string</span><span class="p">)</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq2</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fs</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="p">{</span>
      <span class="n">yield</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="n">yield</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">DirFS</span><span class="p">(</span><span class="s">"/"</span><span class="p">),</span> <span class="s">"etc/passwd"</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">nil</span>
  <span class="p">}</span>

  <span class="c">// ...</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Being a block that you can put an epilog onto after yielding a single element is quite powerful! You can also use a nilary rangefunc to simply create a block that you can break out of, instead of having to use <code class="language-plaintext highlighter-rouge">goto</code>.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">Once</span><span class="p">()</span> <span class="k">func</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">y</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="k">range</span> <span class="n">Once</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">canDo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">break</span>
  <span class="p">}</span>

  <span class="n">do</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>So wait. You can return out of rangefunc loops. That means that… Go has non-local returns?!</p> <h2 id="go-now-has-non-local-returns"><a href="#go-now-has-non-local-returns">Go Now Has Non-Local Returns</a></h2> <p>The desugaring for rangefuncs is very complicated. This is because <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>, <code class="language-plaintext highlighter-rouge">goto</code>, and <code class="language-plaintext highlighter-rouge">return</code> all work in a rangefunc! How does this work? Let’s Godbolt it.</p> <p>Let’s start with something really basic: a loop body that just calls a function.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This produces the following assembly output (which I’ve reformatted into Intel syntax, and removed some extraneous ABI things, including a writer barrier where <code class="language-plaintext highlighter-rouge">(*)</code> is below).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>  <span class="c1">// (*)</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">40</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">api</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">24</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic2</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>This is a lot to take in, but if we look carefully, we decompile this function into a Go function:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c">// Loop body</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Go will actually enforce invariants on the yield it synthesizes in a range for, in order to catch buggy code. In particular, <code class="language-plaintext highlighter-rouge">__state</code> escapes because <code class="language-plaintext highlighter-rouge">s</code> is an arbitrary function, so it gets spilled to the heap.</p> <p>So, what happens when the loop body contains a break? Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>I’ll spare you the assembly listing, since it’s very similar, so I’ll just reverse-engineer the output directly:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Non-local returns are much more complicated. Consider:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">x</span>

<span class="k">import</span> <span class="s">"iter"</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The resulting assembly is something like this, with some irrelevant code, such as write barriers, removed:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">:</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">type</span><span class="o">:</span><span class="kt">int</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="s">"type:noalg.struct { F uintptr; X0 *int; X1 *int; X2 *int }"</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">newobject</span>
    <span class="n">lea</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rbx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>
    <span class="n">call</span>    <span class="n">rdi</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">jeq</span>     <span class="n">panic</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_EXHAUSTED</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">jne</span>     <span class="n">resume</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">resume</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_MISSING_PANIC</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span>

<span class="n">x</span><span class="p">.</span><span class="n">run</span><span class="o">-</span><span class="n">range1</span>
    <span class="n">push</span>    <span class="n">rbp</span>
    <span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rbx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">cmp</span>     <span class="n">rbx</span><span class="p">,</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">jne</span>     <span class="n">panic2</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">],</span> <span class="n">rax</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">],</span> <span class="n">rsi</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">rdx</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_PANIC</span>
    <span class="n">call</span>    <span class="n">x</span><span class="p">.</span><span class="n">sink</span>
    <span class="n">test</span>    <span class="n">al</span><span class="p">,</span> <span class="n">al</span>
    <span class="n">jeq</span>     <span class="n">cont</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">56</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">rcx</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_DONE</span>
    <span class="n">xor</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
    <span class="n">add</span>     <span class="n">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="n">pop</span>     <span class="n">rbp</span>
    <span class="n">ret</span>
<span class="n">cont</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
    <span class="n">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">],</span> <span class="n">internal</span><span class="o">/</span><span class="n">abi</span><span class="p">.</span><span class="n">RF_READY</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">pop</span>     <span class="n">rpb</span>
    <span class="n">ret</span>
<span class="n">panic</span><span class="o">:</span>
    <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rbx</span>
    <span class="n">call</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">panicrangestate</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">x86 Assembly</div></div></div> <p>Try to reverse engineer this yourself, if you like! If you write this out as Go, here’s what you get:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="p">(</span>
  <span class="s">"internal/abi"</span>
  <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">run</span><span class="p">(</span><span class="n">s</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">])</span> <span class="p">(</span><span class="n">__ret</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">__next</span> <span class="kt">int</span>
  <span class="n">__state</span> <span class="o">:=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
  <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">__state</span> <span class="o">!=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span> <span class="p">{</span>
      <span class="n">runtime</span><span class="o">.</span><span class="n">panicrangestate</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span>
    <span class="k">if</span> <span class="n">sink</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span>
      <span class="n">__next</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
      <span class="n">__ret</span> <span class="o">=</span> <span class="n">v</span>
      <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_READY</span>
    <span class="k">return</span> <span class="no">true</span>
  <span class="p">})</span>
  <span class="n">__state</span> <span class="o">=</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span>
  <span class="k">if</span> <span class="n">__next</span> <span class="o">==</span> <span class="o">-</span><span class="m">1</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>The reason <code class="language-plaintext highlighter-rouge">__next</code> is an int is because it is also used when exiting the loop via <code class="language-plaintext highlighter-rouge">goto</code> or a <code class="language-plaintext highlighter-rouge">break</code>/<code class="language-plaintext highlighter-rouge">continue</code> with label. It specifies where to jump to after the call into the rangefunc returns. Each potential control flow out of the loop is assigned some negative number.</p> <p>The precise details of the lowering have been <a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/rangefunc/rewrite.go">exquisitely documented</a> by Russ Cox and David Chase, the primary implementers of the feature.</p> <p>You might be curious what <code class="language-plaintext highlighter-rouge">runtime.panicrangestate</code> does. It’s pretty simple, and it lives in <code class="language-plaintext highlighter-rouge">runtime/panic.go</code>:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">runtime</span>

<span class="c">//go:noinline</span>
<span class="k">func</span> <span class="n">panicrangestate</span><span class="p">(</span><span class="n">state</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_State</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_DONE</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeDoneError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangePanicError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_EXHAUSTED</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeExhaustedError</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">abi</span><span class="o">.</span><span class="n">RF_MISSING_PANIC</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">rangeMissingPanicError</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">throw</span><span class="p">(</span><span class="s">"unexpected state passed to panicrangestate"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If you visit this function in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/panic.go;l=306?q=panicrangestate&amp;ss=go%2Fgo">runtime/panic.go</a>, you will be greeted by this extremely terrifying comment from Russ Cox immediately after it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// deferrangefunc is called by functions that are about to</span>
<span class="c">// execute a range-over-function loop in which the loop body</span>
<span class="c">// may execute a defer statement. That defer needs to add to</span>
<span class="c">// the chain for the current function, not the func literal synthesized</span>
<span class="c">// to represent the loop body. To do that, the original function</span>
<span class="c">// calls deferrangefunc to obtain an opaque token representing</span>
<span class="c">// the current frame, and then the loop body uses deferprocat</span>
<span class="c">// instead of deferproc to add to that frame's defer lists.</span>
<span class="c">//</span>
<span class="c">// The token is an 'any' with underlying type *atomic.Pointer[_defer].</span>
<span class="c">// It is the atomically-updated head of a linked list of _defer structs</span>
<span class="c">// representing deferred calls. At the same time, we create a _defer</span>
<span class="c">// struct on the main g._defer list with d.head set to this head pointer.</span>
<span class="c">//</span>
<span class="c">// The g._defer list is now a linked list of deferred calls,</span>
<span class="c">// but an atomic list hanging off:</span>
<span class="c">//</span>
<span class="c">// (increasingly terrifying discussion of concurrent data structures)</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This raises one more thing that works in range funcs, seamlessly: <code class="language-plaintext highlighter-rouge">defer</code>. Yes, despite the yield executing multiple call stacks away, possibly on a different goroutine… <code class="language-plaintext highlighter-rouge">defer</code> still gets attached to the calling function.</p> <h2 id="go-now-has-non-local-defer"><a href="#go-now-has-non-local-defer">Go Now Has Non-Local Defer</a></h2> <p>The way defer works is that each G (the goroutine struct, <code class="language-plaintext highlighter-rouge">runtime.g</code>) holds a linked list of defer records, of type <code class="language-plaintext highlighter-rouge">_defer</code>. Each call to <code class="language-plaintext highlighter-rouge">defer</code> sticks one of these onto this list. On function return, Go calls <code class="language-plaintext highlighter-rouge">runtime.deferreturn()</code>, which essentially executes and pops defers off of the list until it finds one whose stack pointer is not the current function’s stack pointer (so, it must belong to another function).</p> <p>Rangefuncs throw a wrench in that mix: if <code class="language-plaintext highlighter-rouge">myFunc.range-n</code> defers, that defer has to be attached to <code class="language-plaintext highlighter-rouge">myFunc</code>’s defer records somehow. So the list must have a way of inserting in the middle.</p> <p>This is what this comment is about: when <code class="language-plaintext highlighter-rouge">defer</code> occurs in the loop body, that defer gets attached to a defer record for that function, using a token that the yield captures; this is later canonicalized when walking the defer list on the way out of <code class="language-plaintext highlighter-rouge">myFunc</code>. Because the yield can escape onto another goroutine, this part of the <code class="language-plaintext highlighter-rouge">defer</code> chain has to be atomic.</p> <p>Incredibly, this approach is extremely robust. For example, if we spawn the yield as a goroutine, and carefully synchronize between that and the outer function, we can force the runtime to hard-crash when <code class="language-plaintext highlighter-rouge">defer</code>ing to a function that has returned.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">bad</span><span class="p">()</span> <span class="p">(</span><span class="n">out</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="n">w1</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="n">w2</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>

	<span class="n">out</span> <span class="o">=</span> <span class="n">w2</span><span class="o">.</span><span class="n">Done</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">recover</span><span class="p">()</span> <span class="p">}()</span>
	<span class="n">iter</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">yield</span><span class="p">()</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait to enter yield().</span>
    <span class="c">// This panics once w1.Done() executes, because</span>
    <span class="c">// we exit the rangefunc while yield() is still</span>
    <span class="c">// running. The runtime incorrectly attributes</span>
    <span class="c">// this to recovering in the rangefunc.</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="k">range</span> <span class="n">iter</span> <span class="p">{</span>
		<span class="n">w1</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="c">// Allow the outer function to exit the loop.</span>
		<span class="n">w2</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait for bad() to return.</span>
		<span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"bang"</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="k">return</span> <span class="no">nil</span> <span class="c">// Unreachable</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">resume</span> <span class="o">:=</span> <span class="n">bad</span><span class="p">()</span>
  <span class="n">resume</span><span class="p">()</span>
  <span class="k">select</span> <span class="p">{}</span>  <span class="c">// Block til crash.</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This gets us <code class="language-plaintext highlighter-rouge">fatal error: defer after range func returned</code>. Pretty sick! It accomplishes this by poisoning the token the yield func uses to defer.</p> <p>I have tried various other attempts at causing memory unsafety with rangefuncs, but Go actually does a really good job of avoiding this. The only thing I’ve managed to do that’s especially interesting is to tear the return slot on a function without named returns, but that’s no worse than tearing any other value (which is still really bad, because you can tear interface values, but it’s not <em>worse</em>).</p> <h2 id="pull-iterators-and-coroutines"><a href="#pull-iterators-and-coroutines">Pull Iterators and Coroutines</a></h2> <p>Of course we’re not done. Go provides a mechanism for converting push iterators into pull iterators. Essentially, there is a function that looks like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">yield</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">})</span>
  <span class="n">pull</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}{})</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">seq</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">pull</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">yield</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{</span><span class="n">value</span> <span class="n">V</span><span class="p">;</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">}{</span><span class="n">v</span><span class="p">,</span> <span class="no">true</span><span class="p">}</span>
    <span class="p">})</span>

    <span class="nb">close</span><span class="p">(</span><span class="n">yield</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pull</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="n">yield</span>
  <span class="p">}</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="nb">close</span><span class="p">(</span><span class="n">pull</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>Essentially, you can request values with <code class="language-plaintext highlighter-rouge">next()</code>, and <code class="language-plaintext highlighter-rouge">stop()</code> can be used if you finish early. But also, this spawns a whole goroutine and uses channels to communicate and synchronize, which feels very unnecessary.</p> <p>The implementation doesn’t use goroutines. It uses coroutines.</p> <h3 id="giving-up-on-goroutines"><a href="#giving-up-on-goroutines">Giving Up on Goroutines</a></h3> <p>Spawning a goroutine is expensive. Doing so expends scheduler and memory resources. It’s overkill for a helper like this (ironic, because the original premise of Go was that goroutines would be cheap enough to allocate willy-nilly).</p> <p>Go instead implements this using “coroutines”, a mechanism for concurrency without parallelism. This is intended to make context switching very cheap, because it does not need to go through the scheduler: instead, it uses cooperative multitasking.</p> <p>The coroutine interface is something like the following. My “userland” implementation will not be very efficient, because it relies on the scheduler to transfer control. The goroutines may run on different CPUs, so synchronization is necessary for communication, even if they are not running concurrently.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">coro</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"runtime"</span>
  <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Coro</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">m</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="o">*</span><span class="n">Coro</span> <span class="p">{</span>
  <span class="n">c</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Coro</span><span class="p">)</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">f</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Coro</span><span class="p">)</span> <span class="n">Resume</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
  <span class="n">c</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>When we create a coroutine with <code class="language-plaintext highlighter-rouge">coro.New()</code>, it spawns a goroutine that waits on a mutex. Another goroutine can “take its place” as the mutex holder by calling <code class="language-plaintext highlighter-rouge">c.Resume()</code>, which allows the coroutine spawned by <code class="language-plaintext highlighter-rouge">coro.New</code> to resume and enter <code class="language-plaintext highlighter-rouge">f()</code>.</p> <p>Using the coroutine as a rendezvous point, two goroutines can perform concurrent work: in the case of <code class="language-plaintext highlighter-rouge">iter.Pull</code>, one can be deep inside of whatever loops the iterator wants to do, and the other can request values.</p> <p>Here’s what using my <code class="language-plaintext highlighter-rouge">coro.Coro</code> to implement <code class="language-plaintext highlighter-rouge">iter.Pull</code> might look like:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">func</span> <span class="n">Pull</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">])</span> <span class="p">(</span><span class="n">next</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span> <span class="n">stop</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">var</span> <span class="p">(</span>
    <span class="n">done</span> <span class="kt">bool</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">z</span> <span class="n">V</span>
  <span class="p">)</span>

  <span class="n">c</span> <span class="o">:=</span> <span class="n">coro</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">v1</span> <span class="n">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Wait for a request for a value.</span>
      <span class="k">if</span> <span class="n">done</span> <span class="p">{</span>
        <span class="c">// This means we resumed from stop(). Break out of the</span>
        <span class="c">// loop.</span>
        <span class="k">return</span> <span class="no">false</span>
      <span class="p">}</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">v1</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
      <span class="c">// Yield the last value.</span>
      <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">z</span>
    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
  <span class="p">})</span>

  <span class="n">next</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="no">false</span> <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>      <span class="c">// Request a value.</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="no">true</span>  <span class="c">// Return it.</span>
  <span class="p">}</span>

  <span class="n">stop</span> <span class="o">=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">done</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="n">done</span> <span class="o">=</span> <span class="no">true</span> <span class="c">// Mark iteration as complete.</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Resume</span><span class="p">()</span>  <span class="c">// Resume the iteration goroutine to it can exit.</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">next</span><span class="p">,</span> <span class="n">stop</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>If you look at the implementation in <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/iter/iter.go"><code class="language-plaintext highlighter-rouge">iter.go</code></a>, it’s basically this, but with a lot of error checking and race detection, to prevent misuse, such as if <code class="language-plaintext highlighter-rouge">next</code> or <code class="language-plaintext highlighter-rouge">stop</code> escape to other goroutines.</p> <p>Now, the main thing that runtime support brings here is that <code class="language-plaintext highlighter-rouge">Resume()</code> is immediate: it does not go to the scheduler, which might not decide to immediately run the goroutine that last called <code class="language-plaintext highlighter-rouge">Resume()</code> for a variety of reasons (for example, to ensure wakeup fairness). Coroutines sidestep fairness, by making <code class="language-plaintext highlighter-rouge">Resume()</code> little more than a jump to the last <code class="language-plaintext highlighter-rouge">Resume()</code> (with registers fixed up accordingly).</p> <p>This is not going to be <em>that</em> cheap: a goroutine still needs to be allocated, and switching needs to poke and prod the underlying Gs a little bit. But it’s a cool optimization, and I hope coroutines eventually make their way into more things in Go, hopefully as a language or <code class="language-plaintext highlighter-rouge">sync</code> primitive.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Congratulations, you have survived over 3000 words of me going on about iterators. Go’s push iterators are a unique approach to a common language design problem (even if it took a decade for them to materialize).</p> <p>I encountered rangefuncs for the first time earlier this year and have found them absolutely fascinating, both from a “oh my god they actually did that” perspective and from a “how do we express iteration” perspective. I don’t think the result was perfect by any means, and it is unsuitable for languages that need the performance you can only get from pull iterators. I think they would be a great match for a language like Python or Java, though.</p> <p>I’d like to thank David Chase, an old colleague, for tolerating my excited contrived questions about the guts of this feature.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:cc-range" role="doc-endnote"> <p>Ugh, ok. This is the C++20 desugaring, and there are cases where we do not just call <code class="language-plaintext highlighter-rouge">std::begin()</code>. In particular, array references and class type references with <code class="language-plaintext highlighter-rouge">.begin()</code> and <code class="language-plaintext highlighter-rouge">.end()</code> do not call <code class="language-plaintext highlighter-rouge">std::begin()</code> and are open-coded. This means that you can’t use ADL to override these types’ iterator. <a href="#fnref:cc-range" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:loop-jargon" role="doc-endnote"> <p>In compiler jargon, a loop is broken up into three parts: the <em>header</em>, which is where the loop is entered, the <em>body</em>, which is one step of iteration, and the <em>latch</em>, which is the part that jumps back to the start of the body. This is where incrementation in a C-style for loop happens. <a href="#fnref:loop-jargon" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size_hint" role="doc-endnote"> <p>And with better performance. Rust’s iterators can provide a size hint to help size containers before a call to <code class="language-plaintext highlighter-rouge">collect()</code>, via the <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code class="language-plaintext highlighter-rouge">FromIterator</code></a> trait. <a href="#fnref:size_hint" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:chan-iter" role="doc-endnote"> <p>Some people observed that you can use a channel as a custom iterator, by having a parallel goroutine run a for loop to feed the channel. <em>Do not do this.</em> It is slow: it has to transit each element through the heap, forcing anything it points to escape. It takes up an extra M and a P in the scheduler, and requires potentially allocating a stack for a G. It’s probably faster to just build a slice and return that, especially for small iterations. <a href="#fnref:chan-iter" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:size-hint2" role="doc-endnote"> <p>For this reason, I wish that Go had instead defined something along these lines.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">Seq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Iterate</span><span class="p">(</span><span class="n">yield</span> <span class="k">func</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This is functionally identical to what they did, but it would have permitted future extensions such as the following interface:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">iter</span>

<span class="k">type</span> <span class="n">SizedSeq</span><span class="p">[</span><span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Seq</span><span class="p">[</span><span class="n">V</span><span class="p">]</span>

  <span class="n">SizeHint</span><span class="p">()</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="kt">int64</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>This would mean that <code class="language-plaintext highlighter-rouge">slices.Collect</code> could be enhanced into something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">slices</span>

<span class="k">func</span> <span class="n">Collect</span><span class="p">[</span><span class="n">E</span> <span class="n">any</span><span class="p">](</span><span class="n">seq</span> <span class="n">iter</span><span class="o">.</span><span class="n">Seq</span><span class="p">[</span><span class="n">E</span><span class="p">])</span> <span class="p">[]</span><span class="n">E</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">out</span> <span class="p">[]</span><span class="n">E</span>
  <span class="k">if</span> <span class="n">sized</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">seq</span><span class="o">.</span><span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">SizedSeq</span><span class="p">[</span><span class="n">E</span><span class="p">]);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">sized</span><span class="o">.</span><span class="n">SizeHint</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">E</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">seq</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">out</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Go</div></div></div> <p>I don’t think there’s an easy way to patch this up, at this point. <a href="#fnref:size-hint2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:tooling" role="doc-endnote"> <p>Disclaimer: I am not going to dig into Go’s rationale for rangefuncs. Knowing how the sausage is made, most big Go proposals are a mix of understandable reasoning and less reasonable veiled post-hoc justification to compensate for either Google planning/approvals weirdness or because the design was some principal engineer’s pony. This isn’t even a Go thing, it’s a Google culture problem. I say this as the architect of <a href="https://protobuf.dev/editions/overview">Protobuf Editions</a>, the biggest change to Protobuf since Rob’s misguided proto3<sup id="fnref:proto2" role="doc-noteref"><a href="#fn:proto2" class="footnote" rel="footnote">7</a></sup> experiment. <em>I</em> have written this kind of language proposal, on purpose, because bad culture mandated it.</p> <p><em>The purpose of a system is what it does.</em> It is easier to understand a system by observing its response to stimuli, rather than what it says on the tin. So let’s use that lens.</p> <p>Go wants to be easy to learn. It intended to replace C++ at Google (lol, lmao), which, of course, failed disastrously, because performance of the things already written in C++ is tied to revenue. They have successfully pivoted to being an easy-to-learn language that makes it easy to onboard programmers regardless of what they already use, as opposed to onboarding them to C++.</p> <p>This does not mean that Go is user-friendly. In fact, user-friendliness is clearly not a core value. Rob and his greybeard crowd didn’t seem to care about the human aspect of interacting with a toolchain, so Go tooling rarely provides good diagnostics, nor did the language, until the last few years, try to reduce toil. After all, if it is tedious to use but simple, that does make it easy to onboard new programmers.</p> <p>Rust is the opposite: it is very difficult to learn with a famously steep learning curve; however, it is very accessible, because the implementors have sanded down every corner and sharp edge using diagnostics, error messages, and tooling. C++ is neither of these things. It is very difficult to learn, and most compilers are pretty unhelpful (if they diagnose anything at all).</p> <p>I think that Go has at least realized the language can be a pain to use in some situations, which is fueled in part by legitimate UX research. This is why Go has generics and other recent advanced language features, like being able to use the <code class="language-plaintext highlighter-rouge">for</code> syntax with integers or with custom iterators.</p> <p>I think that rangefuncs are easy to learn in the way Go needs them to be. If you expect more users to want to write rangefuncs than users want to write complicated <em>uses</em> of rangefuncs, I think push iterators are the easiest to learn how to use.</p> <p>I think this is a much more important reason for all the trouble that rangefuncs generate for the compiler and runtime than, say, compatibility with existing code; I have not seen many cases in the wild or in the standard library that conform to the rangefunc signatures. <a href="#fnref:tooling" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:proto2" role="doc-endnote"> <p>But please don’t use proto3. I’m telling you that as the guy who maintained the compiler. Just don’t. <a href="#fnref:proto2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <span class="post-meta">2025-04-14</span> / <h6 style="display:inline"><a href="/2025/04/14/target-triples/">What the Hell Is a Target Triple?</a></h6> <li> <span class="post-meta">2025-04-08</span> / <h6 style="display:inline"><a href="/2025/04/08/protobuf-tip-1/">Protobuf Tip #1: Field Names Are Forever</a></h6> <li> <span class="post-meta">2025-03-11</span> / <h6 style="display:inline"><a href="/2025/03/11/formatters/">The Art of Formatting Code</a></h6> </ul> </div> </div> </div> </div></div> <div class="sidebar show-if-mobile footer"> <div class="container sidebar-sticky"> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> • <a href="https://varz.mcyoung.xyz/">Site Analytics</a> <br> &copy; 2025 Miguel Young de la Sota </div> </div> </body> </html>